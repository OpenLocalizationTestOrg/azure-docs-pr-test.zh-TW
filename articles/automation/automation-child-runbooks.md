---
title: "Azure 自動化中的子 Runbook | Microsoft Docs"
description: "說明在 Azure 自動化中從另一個 Runbook 啟動 Runbook，以及在它們之間共用資訊的不同方法。"
services: automation
documentationcenter: 
author: mgoedtel
manager: jwhit
editor: tysonn
ms.assetid: 919887b9-43e2-4c16-883c-f81807fe37db
ms.service: automation
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: infrastructure-services
ms.date: 02/02/2017
ms.author: magoedte;bwren
ms.openlocfilehash: a605d278dbbda9613b91007ea6a7042403a7a6ff
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="child-runbooks-in-azure-automation"></a><span data-ttu-id="0ece3-103">Azure 自動化中的子 Runbook</span><span class="sxs-lookup"><span data-stu-id="0ece3-103">Child runbooks in Azure Automation</span></span>
<span data-ttu-id="0ece3-104">Azure 自動化中的最佳作法是撰寫可重複使用、模組化的 Runbook，並包含可供其他 Runbook 使用的不同功能。</span><span class="sxs-lookup"><span data-stu-id="0ece3-104">It is a best practice in Azure Automation to write reusable, modular runbooks with a discrete function that can be used by other runbooks.</span></span> <span data-ttu-id="0ece3-105">父 Runbook 通常會呼叫一或多個子 Runbook 來執行必要的功能。</span><span class="sxs-lookup"><span data-stu-id="0ece3-105">A parent runbook will often call one or more child runbooks to perform required functionality.</span></span> <span data-ttu-id="0ece3-106">有兩種方式可以呼叫子 Runbook，而且各有您應該了解的明顯差異，如此您才能判斷在不同的情況下哪一種最適用。</span><span class="sxs-lookup"><span data-stu-id="0ece3-106">There are two ways to call a child runbook, and each has distinct differences that you should understand so that you can determine which will be best for your different scenarios.</span></span>

## <a name="invoking-a-child-runbook-using-inline-execution"></a><span data-ttu-id="0ece3-107">使用內嵌執行叫用子 Runbook</span><span class="sxs-lookup"><span data-stu-id="0ece3-107">Invoking a child runbook using inline execution</span></span>
<span data-ttu-id="0ece3-108">若要從其他 Runbook 叫用 Runbook 內嵌，請使用 Runbook 的名稱並為其提供參數值，如同您使用活動或 Cmdlet 時一樣。</span><span class="sxs-lookup"><span data-stu-id="0ece3-108">To invoke a runbook inline from another runbook, you use the name of the runbook and provide values for its parameters exactly like you would use an activity or cmdlet.</span></span>  <span data-ttu-id="0ece3-109">在相同自動化帳戶中的所有 Runbook 均可以此方式提供所有其他 Runbook 使用。</span><span class="sxs-lookup"><span data-stu-id="0ece3-109">All runbooks in the same Automation account are available to all others to be used in this manner.</span></span> <span data-ttu-id="0ece3-110">父 Runbook 會等候子 Runbook 完成，才會移動到下一行，而且任何輸出都會直接回傳到父代。</span><span class="sxs-lookup"><span data-stu-id="0ece3-110">The parent runbook will wait for the child runbook to complete before moving to the next line, and any output is returned directly to the parent.</span></span>

<span data-ttu-id="0ece3-111">當您叫用 Runbook 內嵌時，它會在父 Runbook 所在的相同工作中執行。</span><span class="sxs-lookup"><span data-stu-id="0ece3-111">When you invoke a runbook inline, it runs in the same job as the parent runbook.</span></span> <span data-ttu-id="0ece3-112">其執行之子 Runbook 的工作歷程記錄中不會指示。</span><span class="sxs-lookup"><span data-stu-id="0ece3-112">There will be no indication in the job history of the child runbook that it ran.</span></span> <span data-ttu-id="0ece3-113">來自子 Runbook 的任何例外狀況及任何資料流輸出都會與父代相關聯。</span><span class="sxs-lookup"><span data-stu-id="0ece3-113">Any exceptions and any stream output from the child runbook will be associated with the parent.</span></span> <span data-ttu-id="0ece3-114">這會導致較少的工作，並使工作更容易追蹤和疑難排解，因為子 Runbook 擲回的任何例外狀況及其任何資料流輸出，都與父 Runbook 的工作相關聯。</span><span class="sxs-lookup"><span data-stu-id="0ece3-114">This results in fewer jobs and makes them easier to track and to troubleshoot since any exceptions thrown by the child runbook and any of its stream output are associated with the parent job.</span></span>

<span data-ttu-id="0ece3-115">發佈 Runbook 時，其呼叫的所有子 Runbook 都必須是已發佈的。</span><span class="sxs-lookup"><span data-stu-id="0ece3-115">When a runbook is published, any child runbooks that it calls must already be published.</span></span> <span data-ttu-id="0ece3-116">這是因為在編譯 Runbook 時，Azure 自動化會建置與任何子 Runbook 的關聯。</span><span class="sxs-lookup"><span data-stu-id="0ece3-116">This is because Azure Automation builds an association with any child runbooks when a runbook is compiled.</span></span> <span data-ttu-id="0ece3-117">如果沒有，父 Runbook 會顯示正常發佈，但在啟動時會產生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ece3-117">If they aren’t, the parent runbook will appear to publish properly, but will generate an exception when it’s started.</span></span> <span data-ttu-id="0ece3-118">如果發生這種情況，您可以重新發佈父 Runbook 以正確參照子 Runbook。</span><span class="sxs-lookup"><span data-stu-id="0ece3-118">If this happens, you can republish the parent runbook in order to properly reference the child runbooks.</span></span> <span data-ttu-id="0ece3-119">因為已經建立關聯，所以如果任何子 Runbook 有變更，您都不需要重新發佈父 Runbook。</span><span class="sxs-lookup"><span data-stu-id="0ece3-119">You do not need to republish the parent runbook if any of the child runbooks are changed because the association will have already been created.</span></span>

<span data-ttu-id="0ece3-120">以內嵌方式呼叫之子 Runbook 的參數可以是任何資料類型 (包括複雜物件)，而且沒有您使用 Azure 管理入口網站或使用 Start-AzureRmAutomationRunbook Cmdlet 啟動 Runbook 時的 [JSON 序列化](automation-starting-a-runbook.md#runbook-parameters) 。</span><span class="sxs-lookup"><span data-stu-id="0ece3-120">The parameters of a child runbook called inline can be any data type including complex objects, and there is no [JSON serialization](automation-starting-a-runbook.md#runbook-parameters) as there is when you start the runbook using the Azure Management Portal or with the Start-AzureRmAutomationRunbook cmdlet.</span></span>

### <a name="runbook-types"></a><span data-ttu-id="0ece3-121">Runbook 類型</span><span class="sxs-lookup"><span data-stu-id="0ece3-121">Runbook types</span></span>
<span data-ttu-id="0ece3-122">哪些類型可以彼此呼叫：</span><span class="sxs-lookup"><span data-stu-id="0ece3-122">Which types can call each other:</span></span>

* <span data-ttu-id="0ece3-123">[PowerShell Runbook](automation-runbook-types.md#powershell-runbooks) 和[圖形化 Runbook](automation-runbook-types.md#graphical-runbooks) 可以內嵌方式呼叫彼此 (這兩者都是 PowerShell)。</span><span class="sxs-lookup"><span data-stu-id="0ece3-123">A [PowerShell runbook](automation-runbook-types.md#powershell-runbooks) and [Graphical runbooks](automation-runbook-types.md#graphical-runbooks) can call each other inline (both are PowerShell based).</span></span>
* <span data-ttu-id="0ece3-124">[PowerShell 工作流程 Runbook](automation-runbook-types.md#powershell-workflow-runbooks) 和圖形化 PowerShell 工作流程 Runbook 可以內嵌方式呼叫彼此 (這兩者都是 PowerShell 工作流程)。</span><span class="sxs-lookup"><span data-stu-id="0ece3-124">A [PowerShell Workflow runbook](automation-runbook-types.md#powershell-workflow-runbooks) and Graphical PowerShell Workflow runbooks can call each other inline (both are PowerShell Workflow based)</span></span>
* <span data-ttu-id="0ece3-125">PowerShell 類型與 PowerShell 工作流程類型無法以內嵌方式彼此呼叫，而且必須使用 Start-AzureRmAutomationRunbook。</span><span class="sxs-lookup"><span data-stu-id="0ece3-125">The PowerShell types and the PowerShell Workflow types can’t call each other inline, and must use Start-AzureRmAutomationRunbook.</span></span>

<span data-ttu-id="0ece3-126">何時會與發行順序有關：</span><span class="sxs-lookup"><span data-stu-id="0ece3-126">When does publish order matter:</span></span>

* <span data-ttu-id="0ece3-127">Runbook 的發行順序只對 PowerShell 工作流程和圖形化 PowerShell 工作流程 Runbook 有關係。</span><span class="sxs-lookup"><span data-stu-id="0ece3-127">The publish order of runbooks only matters for PowerShell Workflow and Graphical PowerShell Workflow runbooks.</span></span>

<span data-ttu-id="0ece3-128">叫用使用內嵌執行的圖形化或 PowerShell 工作流程子 Runbook 時，只要使用 Runbook 名稱即可。</span><span class="sxs-lookup"><span data-stu-id="0ece3-128">When you call a Graphical or PowerShell Workflow child runbook using inline execution, you just use the name of the runbook.</span></span>  <span data-ttu-id="0ece3-129">當您呼叫 PowerShell 子系 runbook 時，您必須前面有其名稱與*。\\*來指定指令碼位於本機目錄。</span><span class="sxs-lookup"><span data-stu-id="0ece3-129">When you call a PowerShell child runbook, you must preceded its name with *.\\* to specify that the script is located in the local directory.</span></span> 

### <a name="example"></a><span data-ttu-id="0ece3-130">範例</span><span class="sxs-lookup"><span data-stu-id="0ece3-130">Example</span></span>
<span data-ttu-id="0ece3-131">下列範例會叫用一個測試子 Runbook，它會接受三個參數、一個複雜物件、一個整數和一個布林值。</span><span class="sxs-lookup"><span data-stu-id="0ece3-131">The following example invokes a test child runbook that accepts three parameters, a complex object, an integer, and a boolean.</span></span> <span data-ttu-id="0ece3-132">子 Runbook 的輸出會指派給一個變數。</span><span class="sxs-lookup"><span data-stu-id="0ece3-132">The output of the child runbook is assigned to a variable.</span></span>  <span data-ttu-id="0ece3-133">此案例的子 Runbook 是 PowerShell 工作流程 Runbook</span><span class="sxs-lookup"><span data-stu-id="0ece3-133">In this case, the child runbook is a PowerShell Workflow runbook</span></span>

    $vm = Get-AzureRmVM –ResourceGroupName "LabRG" –Name "MyVM"
    $output = PSWF-ChildRunbook –VM $vm –RepeatCount 2 –Restart $true

<span data-ttu-id="0ece3-134">以下是使用 PowerShell Runbook 做為子 Runbook 的相同範例。</span><span class="sxs-lookup"><span data-stu-id="0ece3-134">Following is the same example using a PowerShell runbook as the child.</span></span>

    $vm = Get-AzureRmVM –ResourceGroupName "LabRG" –Name "MyVM"
    $output = .\PS-ChildRunbook.ps1 –VM $vm –RepeatCount 2 –Restart $true


## <a name="starting-a-child-runbook-using-cmdlet"></a><span data-ttu-id="0ece3-135">使用 Cmdlet 啟動子 Runbook</span><span class="sxs-lookup"><span data-stu-id="0ece3-135">Starting a child runbook using cmdlet</span></span>
<span data-ttu-id="0ece3-136">您可以依照[使用 Windows PowerShell 啟動 Runbook](automation-starting-a-runbook.md#starting-a-runbook-with-windows-powershell) 中的說明，使用 [Start-AzureRmAutomationRunbook](https://msdn.microsoft.com/library/mt603661.aspx) Cmdlet 啟動 Runbook。</span><span class="sxs-lookup"><span data-stu-id="0ece3-136">You can use the [Start-AzureRmAutomationRunbook](https://msdn.microsoft.com/library/mt603661.aspx) cmdlet to start a runbook as described in [To start a runbook with Windows PowerShell](automation-starting-a-runbook.md#starting-a-runbook-with-windows-powershell).</span></span> <span data-ttu-id="0ece3-137">使用這個 Cmdlet 的模式有兩種。</span><span class="sxs-lookup"><span data-stu-id="0ece3-137">There are two modes of use for this cmdlet.</span></span>  <span data-ttu-id="0ece3-138">在第一個模式中，Cmdlet 會在子 Runbook 的子作業建立時立即傳回作業識別碼。</span><span class="sxs-lookup"><span data-stu-id="0ece3-138">In one mode, the cmdlet returns the job id as soon as the child job is created for the child runbook.</span></span>  <span data-ttu-id="0ece3-139">在第二個模式 (藉由指定 **-wait** 參數啟用) 中，Cmdlet 會等候子作業完成，並且會傳回子 Runbook 的輸出。</span><span class="sxs-lookup"><span data-stu-id="0ece3-139">In the other mode, which you enable by specifying the **-wait** parameter, the cmdlet will wait until the child job finishes and will return the output from the child runbook.</span></span>

<span data-ttu-id="0ece3-140">使用 Cmdlet 啟動之子 Runbook 的工作，將會與父 Runbook 的工作分開執行。</span><span class="sxs-lookup"><span data-stu-id="0ece3-140">The job from a child runbook started with a cmdlet will run in a separate job from the parent runbook.</span></span> <span data-ttu-id="0ece3-141">這會使產生的作業比叫用指令碼內嵌更多，並使它們更難以困難。</span><span class="sxs-lookup"><span data-stu-id="0ece3-141">This results in more jobs than invoking the runbook inline and makes them more difficult to track.</span></span> <span data-ttu-id="0ece3-142">父 Runbook 可以利用非同步方式啟動多個子 Runbook，不需要等候每個子 Runbook 完成。</span><span class="sxs-lookup"><span data-stu-id="0ece3-142">The parent can start multiple child runbooks asynchronously without waiting for each to complete.</span></span> <span data-ttu-id="0ece3-143">對於呼叫子 Runbook 內嵌的同類型平行執行作業，父 Runbook 將需要使用 [平行關鍵字](automation-powershell-workflow.md#parallel-processing)。</span><span class="sxs-lookup"><span data-stu-id="0ece3-143">For that same kind of parallel execution calling the child runbooks inline, the parent runbook would need to use the [parallel keyword](automation-powershell-workflow.md#parallel-processing).</span></span>

<span data-ttu-id="0ece3-144">使用 Cmdlet 啟動之子 Runbook 的參數是以雜湊表方式提供，如 [Runbook 參數](automation-starting-a-runbook.md#runbook-parameters)中所述。</span><span class="sxs-lookup"><span data-stu-id="0ece3-144">Parameters for a child runbook started with a cmdlet are provided as a hashtable as described in [Runbook Parameters](automation-starting-a-runbook.md#runbook-parameters).</span></span> <span data-ttu-id="0ece3-145">只能使用簡單資料類型。</span><span class="sxs-lookup"><span data-stu-id="0ece3-145">Only simple data types can be used.</span></span> <span data-ttu-id="0ece3-146">若 Runbook 有複雜資料類型的參數，必須以內嵌方式呼叫。</span><span class="sxs-lookup"><span data-stu-id="0ece3-146">If the runbook has a parameter with a complex data type, then it must be called inline.</span></span>

### <a name="example"></a><span data-ttu-id="0ece3-147">範例</span><span class="sxs-lookup"><span data-stu-id="0ece3-147">Example</span></span>
<span data-ttu-id="0ece3-148">下列範例使用參數啟動子 Runbook，然後使用 Start-AzureRmAutomationRunbook -wait 參數等待其完成。</span><span class="sxs-lookup"><span data-stu-id="0ece3-148">The following example starts a child runbook with parameters and then waits for it to complete using the Start-AzureRmAutomationRunbook -wait parameter.</span></span> <span data-ttu-id="0ece3-149">完成後，系統會從子 Runbook 收集其輸出。</span><span class="sxs-lookup"><span data-stu-id="0ece3-149">Once completed, its output is collected from the child runbook.</span></span>

    $params = @{"VMName"="MyVM";"RepeatCount"=2;"Restart"=$true} 
    $joboutput = Start-AzureRmAutomationRunbook –AutomationAccountName "MyAutomationAccount" –Name "Test-ChildRunbook" -ResourceGroupName "LabRG" –Parameters $params –wait


## <a name="comparison-of-methods-for-calling-a-child-runbook"></a><span data-ttu-id="0ece3-150">子 Runbook 的呼叫方法比較</span><span class="sxs-lookup"><span data-stu-id="0ece3-150">Comparison of methods for calling a child runbook</span></span>
<span data-ttu-id="0ece3-151">下表摘要說明從另一個 Runbook 呼叫 Runbook 之兩種方法之間的差異。</span><span class="sxs-lookup"><span data-stu-id="0ece3-151">The following table summarizes the differences between the two methods for calling a runbook from another runbook.</span></span>

|  | <span data-ttu-id="0ece3-152">內嵌</span><span class="sxs-lookup"><span data-stu-id="0ece3-152">Inline</span></span> | <span data-ttu-id="0ece3-153">Cmdlet</span><span class="sxs-lookup"><span data-stu-id="0ece3-153">Cmdlet</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="0ece3-154">工作 (Job)</span><span class="sxs-lookup"><span data-stu-id="0ece3-154">Job</span></span> |<span data-ttu-id="0ece3-155">與父代在相同的工作中執行的子 Runbook。</span><span class="sxs-lookup"><span data-stu-id="0ece3-155">Child runbooks run in the same job as the parent.</span></span> |<span data-ttu-id="0ece3-156">會為子 Runbook 建立個別的工作。</span><span class="sxs-lookup"><span data-stu-id="0ece3-156">A separate job is created for the child runbook.</span></span> |
| <span data-ttu-id="0ece3-157">執行</span><span class="sxs-lookup"><span data-stu-id="0ece3-157">Execution</span></span> |<span data-ttu-id="0ece3-158">父 Runbook 會等待子 Runbook 完成後再繼續執行。</span><span class="sxs-lookup"><span data-stu-id="0ece3-158">Parent runbook waits for the child runbook to complete before continuing.</span></span> |<span data-ttu-id="0ece3-159">父 Runbook 會在子 Runbook 啟動後立刻繼續執行，或  父 Runbook 會等候子作業完成。</span><span class="sxs-lookup"><span data-stu-id="0ece3-159">Parent runbook continues immediately after child runbook is started *or* parent runbook waits for the child job to finish.</span></span> |
| <span data-ttu-id="0ece3-160">輸出</span><span class="sxs-lookup"><span data-stu-id="0ece3-160">Output</span></span> |<span data-ttu-id="0ece3-161">父 Runbook 可以直接從子 Runbook 取得輸出。</span><span class="sxs-lookup"><span data-stu-id="0ece3-161">Parent runbook can directly get output from child runbook.</span></span> |<span data-ttu-id="0ece3-162">父 Runbook 必須擷取子 Runbook 作業的輸出，或  父 Runbook 可以直接從子 Runbook 取得輸出。</span><span class="sxs-lookup"><span data-stu-id="0ece3-162">Parent runbook must retrieve output from child runbook job *or* parent runbook can directly get output from child runbook.</span></span> |
| <span data-ttu-id="0ece3-163">參數</span><span class="sxs-lookup"><span data-stu-id="0ece3-163">Parameters</span></span> |<span data-ttu-id="0ece3-164">子 Runbook 參數的值是個別指定，而且可以使用任何資料類型。</span><span class="sxs-lookup"><span data-stu-id="0ece3-164">Values for the child runbook parameters are specified separately and can use any data type.</span></span> |<span data-ttu-id="0ece3-165">子 Runbook 參數的值必須結合成單一雜湊表，且只能包含簡單、陣列，以及運用 JSON 序列化的物件資料類型。</span><span class="sxs-lookup"><span data-stu-id="0ece3-165">Values for the child runbook parameters must be combined into a single hashtable and can only include simple, array, and object data types that leverage JSON serialization.</span></span> |
| <span data-ttu-id="0ece3-166">自動化帳戶</span><span class="sxs-lookup"><span data-stu-id="0ece3-166">Automation Account</span></span> |<span data-ttu-id="0ece3-167">父 Runbook 只能使用相同自動化帳戶中的子 Runbook。</span><span class="sxs-lookup"><span data-stu-id="0ece3-167">Parent runbook can only use child runbook in the same automation account.</span></span> |<span data-ttu-id="0ece3-168">父 Runbook 可以使用來自相同 Azure 訂用帳戶，甚至是不同訂用帳戶 (如果您已連接) 之任何自動化帳戶的子 Runbook。</span><span class="sxs-lookup"><span data-stu-id="0ece3-168">Parent runbook can use child runbook from any automation account from the same Azure subscription and even a different subscription if you have a connection to it.</span></span> |
| <span data-ttu-id="0ece3-169">發佈</span><span class="sxs-lookup"><span data-stu-id="0ece3-169">Publishing</span></span> |<span data-ttu-id="0ece3-170">發佈父 Runbook 之前必須先發佈子 Runbook。</span><span class="sxs-lookup"><span data-stu-id="0ece3-170">Child runbook must be published before parent runbook is published.</span></span> |<span data-ttu-id="0ece3-171">啟動父 Runbook 之前必須先發佈子 Runbook。</span><span class="sxs-lookup"><span data-stu-id="0ece3-171">Child runbook must be published any time before parent runbook is started.</span></span> |

## <a name="next-steps"></a><span data-ttu-id="0ece3-172">後續步驟</span><span class="sxs-lookup"><span data-stu-id="0ece3-172">Next steps</span></span>
* [<span data-ttu-id="0ece3-173">在 Azure 自動化中啟動 Runbook</span><span class="sxs-lookup"><span data-stu-id="0ece3-173">Starting a runbook in Azure Automation</span></span>](automation-starting-a-runbook.md)
* [<span data-ttu-id="0ece3-174">Azure 自動化中的 Runbook 輸出與訊息</span><span class="sxs-lookup"><span data-stu-id="0ece3-174">Runbook output and messages in Azure Automation</span></span>](automation-runbook-output-and-messages.md)

