---
title: "Azure 自動化中的 aaaChild runbook |Microsoft 文件"
description: "描述 hello 不同方法在 Azure 自動化中啟動 runbook，從另一個 runbook 並分享兩者之間的資訊。"
services: automation
documentationcenter: 
author: mgoedtel
manager: jwhit
editor: tysonn
ms.assetid: 919887b9-43e2-4c16-883c-f81807fe37db
ms.service: automation
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: infrastructure-services
ms.date: 02/02/2017
ms.author: magoedte;bwren
ms.openlocfilehash: d3d06818d344b565d53cc4f4705b41dcfcf9a376
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="child-runbooks-in-azure-automation"></a><span data-ttu-id="198e6-103">Azure 自動化中的子 Runbook</span><span class="sxs-lookup"><span data-stu-id="198e6-103">Child runbooks in Azure Automation</span></span>
<span data-ttu-id="198e6-104">它是在 Azure 自動化 toowrite 可重複使用、 模組化 runbook 具備可供其他 runbook 的不同功能的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="198e6-104">It is a best practice in Azure Automation toowrite reusable, modular runbooks with a discrete function that can be used by other runbooks.</span></span> <span data-ttu-id="198e6-105">父 runbook 通常會呼叫一或多個子 runbook tooperform 所需的功能。</span><span class="sxs-lookup"><span data-stu-id="198e6-105">A parent runbook will often call one or more child runbooks tooperform required functionality.</span></span> <span data-ttu-id="198e6-106">有兩種方式 toocall 子系 runbook，而且每個具有不同差異，您應該了解，以便決定，將會最適合您不同的案例。</span><span class="sxs-lookup"><span data-stu-id="198e6-106">There are two ways toocall a child runbook, and each has distinct differences that you should understand so that you can determine which will be best for your different scenarios.</span></span>

## <a name="invoking-a-child-runbook-using-inline-execution"></a><span data-ttu-id="198e6-107">使用內嵌執行叫用子 Runbook</span><span class="sxs-lookup"><span data-stu-id="198e6-107">Invoking a child runbook using inline execution</span></span>
<span data-ttu-id="198e6-108">tooinvoke runbook 內嵌從另一個 runbook，方法，您可以使用 hello hello runbook 名稱，並提供其參數的值，如同您使用活動或 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="198e6-108">tooinvoke a runbook inline from another runbook, you use hello name of hello runbook and provide values for its parameters exactly like you would use an activity or cmdlet.</span></span>  <span data-ttu-id="198e6-109">中的所有 runbook 都 hello 相同自動化帳戶都可用 tooall toobe 用於這種方式的其他項目。</span><span class="sxs-lookup"><span data-stu-id="198e6-109">All runbooks in hello same Automation account are available tooall others toobe used in this manner.</span></span> <span data-ttu-id="198e6-110">hello 父 runbook 將會等到 hello 子 runbook toocomplete 日前 toohello 下一行，並將任何輸出傳回直接 toohello 父代。</span><span class="sxs-lookup"><span data-stu-id="198e6-110">hello parent runbook will wait for hello child runbook toocomplete before moving toohello next line, and any output is returned directly toohello parent.</span></span>

<span data-ttu-id="198e6-111">當您叫用 runbook 內嵌時，它會在 hello hello 父 runbook 相同作業中執行。</span><span class="sxs-lookup"><span data-stu-id="198e6-111">When you invoke a runbook inline, it runs in hello same job as hello parent runbook.</span></span> <span data-ttu-id="198e6-112">有不會指示 hello 作業記錄中的 hello 已執行的子系 runbook。</span><span class="sxs-lookup"><span data-stu-id="198e6-112">There will be no indication in hello job history of hello child runbook that it ran.</span></span> <span data-ttu-id="198e6-113">任何例外狀況及任何資料流從 hello 子 runbook 的輸出會與 hello 父系相關聯。</span><span class="sxs-lookup"><span data-stu-id="198e6-113">Any exceptions and any stream output from hello child runbook will be associated with hello parent.</span></span> <span data-ttu-id="198e6-114">這導致較少的工作，並讓它們更容易 tootrack 且 tootroubleshoot 自 hello 子 runbook 擲回任何例外狀況，及其任何資料流輸出都與 hello 父工作相關聯。</span><span class="sxs-lookup"><span data-stu-id="198e6-114">This results in fewer jobs and makes them easier tootrack and tootroubleshoot since any exceptions thrown by hello child runbook and any of its stream output are associated with hello parent job.</span></span>

<span data-ttu-id="198e6-115">發佈 Runbook 時，其呼叫的所有子 Runbook 都必須是已發佈的。</span><span class="sxs-lookup"><span data-stu-id="198e6-115">When a runbook is published, any child runbooks that it calls must already be published.</span></span> <span data-ttu-id="198e6-116">這是因為在編譯 Runbook 時，Azure 自動化會建置與任何子 Runbook 的關聯。</span><span class="sxs-lookup"><span data-stu-id="198e6-116">This is because Azure Automation builds an association with any child runbooks when a runbook is compiled.</span></span> <span data-ttu-id="198e6-117">不是，如果 hello 父 runbook 會出現 toopublish 正常運作，但啟動時，會產生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="198e6-117">If they aren’t, hello parent runbook will appear toopublish properly, but will generate an exception when it’s started.</span></span> <span data-ttu-id="198e6-118">如果發生這種情況，您可以重新發佈順序 tooproperly 參考 hello 子 runbook 中的 hello 父 runbook。</span><span class="sxs-lookup"><span data-stu-id="198e6-118">If this happens, you can republish hello parent runbook in order tooproperly reference hello child runbooks.</span></span> <span data-ttu-id="198e6-119">如果任何 hello 子 runbook 變更 hello 關聯將已經建立，因為不需要 toorepublish hello 父 runbook。</span><span class="sxs-lookup"><span data-stu-id="198e6-119">You do not need toorepublish hello parent runbook if any of hello child runbooks are changed because hello association will have already been created.</span></span>

<span data-ttu-id="198e6-120">hello 內嵌方式呼叫子 runbook 參數可以是任何資料類型，包括複雜的物件，而且沒有任何[JSON 序列化](automation-starting-a-runbook.md#runbook-parameters)因為，所以當您開始使用 Azure 管理入口網站 hello hello runbook，或以 hello開始 AzureRmAutomationRunbook cmdlet。</span><span class="sxs-lookup"><span data-stu-id="198e6-120">hello parameters of a child runbook called inline can be any data type including complex objects, and there is no [JSON serialization](automation-starting-a-runbook.md#runbook-parameters) as there is when you start hello runbook using hello Azure Management Portal or with hello Start-AzureRmAutomationRunbook cmdlet.</span></span>

### <a name="runbook-types"></a><span data-ttu-id="198e6-121">Runbook 類型</span><span class="sxs-lookup"><span data-stu-id="198e6-121">Runbook types</span></span>
<span data-ttu-id="198e6-122">哪些類型可以彼此呼叫：</span><span class="sxs-lookup"><span data-stu-id="198e6-122">Which types can call each other:</span></span>

* <span data-ttu-id="198e6-123">[PowerShell Runbook](automation-runbook-types.md#powershell-runbooks) 和[圖形化 Runbook](automation-runbook-types.md#graphical-runbooks) 可以內嵌方式呼叫彼此 (這兩者都是 PowerShell)。</span><span class="sxs-lookup"><span data-stu-id="198e6-123">A [PowerShell runbook](automation-runbook-types.md#powershell-runbooks) and [Graphical runbooks](automation-runbook-types.md#graphical-runbooks) can call each other inline (both are PowerShell based).</span></span>
* <span data-ttu-id="198e6-124">[PowerShell 工作流程 Runbook](automation-runbook-types.md#powershell-workflow-runbooks) 和圖形化 PowerShell 工作流程 Runbook 可以內嵌方式呼叫彼此 (這兩者都是 PowerShell 工作流程)。</span><span class="sxs-lookup"><span data-stu-id="198e6-124">A [PowerShell Workflow runbook](automation-runbook-types.md#powershell-workflow-runbooks) and Graphical PowerShell Workflow runbooks can call each other inline (both are PowerShell Workflow based)</span></span>
* <span data-ttu-id="198e6-125">hello PowerShell 類型並 hello PowerShell 工作流程類型不能彼此內嵌方式呼叫，必須使用開始 AzureRmAutomationRunbook。</span><span class="sxs-lookup"><span data-stu-id="198e6-125">hello PowerShell types and hello PowerShell Workflow types can’t call each other inline, and must use Start-AzureRmAutomationRunbook.</span></span>

<span data-ttu-id="198e6-126">何時會與發行順序有關：</span><span class="sxs-lookup"><span data-stu-id="198e6-126">When does publish order matter:</span></span>

* <span data-ttu-id="198e6-127">hello 發行的 runbook 只會有影響的 PowerShell 工作流程和圖形化 PowerShell 工作流程 runbook 中的順序。</span><span class="sxs-lookup"><span data-stu-id="198e6-127">hello publish order of runbooks only matters for PowerShell Workflow and Graphical PowerShell Workflow runbooks.</span></span>

<span data-ttu-id="198e6-128">當您呼叫使用內嵌執行圖形或 PowerShell 工作流程子系 runbook 時，只會使用 hello hello runbook 名稱。</span><span class="sxs-lookup"><span data-stu-id="198e6-128">When you call a Graphical or PowerShell Workflow child runbook using inline execution, you just use hello name of hello runbook.</span></span>  <span data-ttu-id="198e6-129">當您呼叫 PowerShell 子系 runbook 時，您必須前面有其名稱與*。\\* hello 指令碼的 toospecify 位於 hello 本機目錄中。</span><span class="sxs-lookup"><span data-stu-id="198e6-129">When you call a PowerShell child runbook, you must preceded its name with *.\\* toospecify that hello script is located in hello local directory.</span></span> 

### <a name="example"></a><span data-ttu-id="198e6-130">範例</span><span class="sxs-lookup"><span data-stu-id="198e6-130">Example</span></span>
<span data-ttu-id="198e6-131">hello 下列範例會叫用接受三個參數、 複雜物件、 整數和布林值的測試子 runbook。</span><span class="sxs-lookup"><span data-stu-id="198e6-131">hello following example invokes a test child runbook that accepts three parameters, a complex object, an integer, and a boolean.</span></span> <span data-ttu-id="198e6-132">hello hello 子 runbook 的輸出會指派 tooa 變數。</span><span class="sxs-lookup"><span data-stu-id="198e6-132">hello output of hello child runbook is assigned tooa variable.</span></span>  <span data-ttu-id="198e6-133">在此情況下，hello 子系 runbook 是 PowerShell 工作流程 runbook</span><span class="sxs-lookup"><span data-stu-id="198e6-133">In this case, hello child runbook is a PowerShell Workflow runbook</span></span>

    $vm = Get-AzureRmVM –ResourceGroupName "LabRG" –Name "MyVM"
    $output = PSWF-ChildRunbook –VM $vm –RepeatCount 2 –Restart $true

<span data-ttu-id="198e6-134">以下是 hello 做 hello 子系使用 PowerShell runbook 的相同範例。</span><span class="sxs-lookup"><span data-stu-id="198e6-134">Following is hello same example using a PowerShell runbook as hello child.</span></span>

    $vm = Get-AzureRmVM –ResourceGroupName "LabRG" –Name "MyVM"
    $output = .\PS-ChildRunbook.ps1 –VM $vm –RepeatCount 2 –Restart $true


## <a name="starting-a-child-runbook-using-cmdlet"></a><span data-ttu-id="198e6-135">使用 Cmdlet 啟動子 Runbook</span><span class="sxs-lookup"><span data-stu-id="198e6-135">Starting a child runbook using cmdlet</span></span>
<span data-ttu-id="198e6-136">您可以使用 hello[開始 AzureRmAutomationRunbook](https://msdn.microsoft.com/library/mt603661.aspx) cmdlet toostart runbook 中所述[toostart 使用 Windows PowerShell runbook](automation-starting-a-runbook.md#starting-a-runbook-with-windows-powershell)。</span><span class="sxs-lookup"><span data-stu-id="198e6-136">You can use hello [Start-AzureRmAutomationRunbook](https://msdn.microsoft.com/library/mt603661.aspx) cmdlet toostart a runbook as described in [toostart a runbook with Windows PowerShell](automation-starting-a-runbook.md#starting-a-runbook-with-windows-powershell).</span></span> <span data-ttu-id="198e6-137">使用這個 Cmdlet 的模式有兩種。</span><span class="sxs-lookup"><span data-stu-id="198e6-137">There are two modes of use for this cmdlet.</span></span>  <span data-ttu-id="198e6-138">一種模式，在 hello cmdlet 就會傳回 hello 作業識別碼 hello 子 runbook 建立 hello 子工作。</span><span class="sxs-lookup"><span data-stu-id="198e6-138">In one mode, hello cmdlet returns hello job id as soon as hello child job is created for hello child runbook.</span></span>  <span data-ttu-id="198e6-139">在 hello 其他模式，您可以指定 hello 啟用**-等候**hello cmdlet 會等待直到 hello 子參數，作業結束，而且會傳回從 hello 子 runbook 的 hello 輸出。</span><span class="sxs-lookup"><span data-stu-id="198e6-139">In hello other mode, which you enable by specifying hello **-wait** parameter, hello cmdlet will wait until hello child job finishes and will return hello output from hello child runbook.</span></span>

<span data-ttu-id="198e6-140">從 cmdlet 啟動子 runbook 的 hello 作業會從 hello 父 runbook 執行的個別工作中。</span><span class="sxs-lookup"><span data-stu-id="198e6-140">hello job from a child runbook started with a cmdlet will run in a separate job from hello parent runbook.</span></span> <span data-ttu-id="198e6-141">這會產生比叫用 hello runbook 內嵌更多工作，並使其更加困難 tootrack。</span><span class="sxs-lookup"><span data-stu-id="198e6-141">This results in more jobs than invoking hello runbook inline and makes them more difficult tootrack.</span></span> <span data-ttu-id="198e6-142">hello 父代可以以非同步方式啟動多個子系 runbook，而不等候每個 toocomplete。</span><span class="sxs-lookup"><span data-stu-id="198e6-142">hello parent can start multiple child runbooks asynchronously without waiting for each toocomplete.</span></span> <span data-ttu-id="198e6-143">以相同類型的平行呼叫 hello 子 runbook 內嵌，hello 父 runbook 將需要 toouse hello[平行關鍵字](automation-powershell-workflow.md#parallel-processing)。</span><span class="sxs-lookup"><span data-stu-id="198e6-143">For that same kind of parallel execution calling hello child runbooks inline, hello parent runbook would need toouse hello [parallel keyword](automation-powershell-workflow.md#parallel-processing).</span></span>

<span data-ttu-id="198e6-144">使用 Cmdlet 啟動之子 Runbook 的參數是以雜湊表方式提供，如 [Runbook 參數](automation-starting-a-runbook.md#runbook-parameters)中所述。</span><span class="sxs-lookup"><span data-stu-id="198e6-144">Parameters for a child runbook started with a cmdlet are provided as a hashtable as described in [Runbook Parameters](automation-starting-a-runbook.md#runbook-parameters).</span></span> <span data-ttu-id="198e6-145">只能使用簡單資料類型。</span><span class="sxs-lookup"><span data-stu-id="198e6-145">Only simple data types can be used.</span></span> <span data-ttu-id="198e6-146">如果 hello runbook 有複雜資料型別參數，然後必須內嵌呼叫它。</span><span class="sxs-lookup"><span data-stu-id="198e6-146">If hello runbook has a parameter with a complex data type, then it must be called inline.</span></span>

### <a name="example"></a><span data-ttu-id="198e6-147">範例</span><span class="sxs-lookup"><span data-stu-id="198e6-147">Example</span></span>
<span data-ttu-id="198e6-148">hello 下列範例會啟動子 runbook 的參數，然後等候 toocomplete 使用 hello 開始 AzureRmAutomationRunbook-等候參數。</span><span class="sxs-lookup"><span data-stu-id="198e6-148">hello following example starts a child runbook with parameters and then waits for it toocomplete using hello Start-AzureRmAutomationRunbook -wait parameter.</span></span> <span data-ttu-id="198e6-149">完成後，從 hello 子 runbook 會收集其輸出。</span><span class="sxs-lookup"><span data-stu-id="198e6-149">Once completed, its output is collected from hello child runbook.</span></span>

    $params = @{"VMName"="MyVM";"RepeatCount"=2;"Restart"=$true} 
    $joboutput = Start-AzureRmAutomationRunbook –AutomationAccountName "MyAutomationAccount" –Name "Test-ChildRunbook" -ResourceGroupName "LabRG" –Parameters $params –wait


## <a name="comparison-of-methods-for-calling-a-child-runbook"></a><span data-ttu-id="198e6-150">子 Runbook 的呼叫方法比較</span><span class="sxs-lookup"><span data-stu-id="198e6-150">Comparison of methods for calling a child runbook</span></span>
<span data-ttu-id="198e6-151">hello 下表摘要說明 hello 差異 hello 兩種方法，從另一個 runbook 呼叫某個 runbook。</span><span class="sxs-lookup"><span data-stu-id="198e6-151">hello following table summarizes hello differences between hello two methods for calling a runbook from another runbook.</span></span>

|  | <span data-ttu-id="198e6-152">內嵌</span><span class="sxs-lookup"><span data-stu-id="198e6-152">Inline</span></span> | <span data-ttu-id="198e6-153">Cmdlet</span><span class="sxs-lookup"><span data-stu-id="198e6-153">Cmdlet</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="198e6-154">作業</span><span class="sxs-lookup"><span data-stu-id="198e6-154">Job</span></span> |<span data-ttu-id="198e6-155">子 runbook hello 與 hello 父系相同作業中執行。</span><span class="sxs-lookup"><span data-stu-id="198e6-155">Child runbooks run in hello same job as hello parent.</span></span> |<span data-ttu-id="198e6-156">Hello 子 runbook 建立不同的工作。</span><span class="sxs-lookup"><span data-stu-id="198e6-156">A separate job is created for hello child runbook.</span></span> |
| <span data-ttu-id="198e6-157">執行</span><span class="sxs-lookup"><span data-stu-id="198e6-157">Execution</span></span> |<span data-ttu-id="198e6-158">父 runbook 會等到 hello 子 runbook toocomplete 才能繼續。</span><span class="sxs-lookup"><span data-stu-id="198e6-158">Parent runbook waits for hello child runbook toocomplete before continuing.</span></span> |<span data-ttu-id="198e6-159">父 runbook 會繼續執行，啟動子 runbook 之後，立即*或*父 runbook 會等到 hello 子工作 toofinish。</span><span class="sxs-lookup"><span data-stu-id="198e6-159">Parent runbook continues immediately after child runbook is started *or* parent runbook waits for hello child job toofinish.</span></span> |
| <span data-ttu-id="198e6-160">輸出</span><span class="sxs-lookup"><span data-stu-id="198e6-160">Output</span></span> |<span data-ttu-id="198e6-161">父 Runbook 可以直接從子 Runbook 取得輸出。</span><span class="sxs-lookup"><span data-stu-id="198e6-161">Parent runbook can directly get output from child runbook.</span></span> |<span data-ttu-id="198e6-162">父 Runbook 必須擷取子 Runbook 作業的輸出，或  父 Runbook 可以直接從子 Runbook 取得輸出。</span><span class="sxs-lookup"><span data-stu-id="198e6-162">Parent runbook must retrieve output from child runbook job *or* parent runbook can directly get output from child runbook.</span></span> |
| <span data-ttu-id="198e6-163">參數</span><span class="sxs-lookup"><span data-stu-id="198e6-163">Parameters</span></span> |<span data-ttu-id="198e6-164">Hello 子 runbook 參數的值會個別指定，而且可以使用任何資料類型。</span><span class="sxs-lookup"><span data-stu-id="198e6-164">Values for hello child runbook parameters are specified separately and can use any data type.</span></span> |<span data-ttu-id="198e6-165">值為 hello 子 runbook 參數必須結合成單一雜湊表，而且只可包含簡單、 陣列，及運用 JSON 序列化的資料類型的物件。</span><span class="sxs-lookup"><span data-stu-id="198e6-165">Values for hello child runbook parameters must be combined into a single hashtable and can only include simple, array, and object data types that leverage JSON serialization.</span></span> |
| <span data-ttu-id="198e6-166">自動化帳戶</span><span class="sxs-lookup"><span data-stu-id="198e6-166">Automation Account</span></span> |<span data-ttu-id="198e6-167">父系 runbook 只能使用 hello 中的子系 runbook 相同自動化帳戶。</span><span class="sxs-lookup"><span data-stu-id="198e6-167">Parent runbook can only use child runbook in hello same automation account.</span></span> |<span data-ttu-id="198e6-168">父 runbook 可以使用任何自動化帳戶 hello 的子系 runbook 相同的 Azure 訂用帳戶和甚至不同訂用帳戶有連線 tooit。</span><span class="sxs-lookup"><span data-stu-id="198e6-168">Parent runbook can use child runbook from any automation account from hello same Azure subscription and even a different subscription if you have a connection tooit.</span></span> |
| <span data-ttu-id="198e6-169">發佈</span><span class="sxs-lookup"><span data-stu-id="198e6-169">Publishing</span></span> |<span data-ttu-id="198e6-170">發佈父 Runbook 之前必須先發佈子 Runbook。</span><span class="sxs-lookup"><span data-stu-id="198e6-170">Child runbook must be published before parent runbook is published.</span></span> |<span data-ttu-id="198e6-171">啟動父 Runbook 之前必須先發佈子 Runbook。</span><span class="sxs-lookup"><span data-stu-id="198e6-171">Child runbook must be published any time before parent runbook is started.</span></span> |

## <a name="next-steps"></a><span data-ttu-id="198e6-172">後續步驟</span><span class="sxs-lookup"><span data-stu-id="198e6-172">Next steps</span></span>
* [<span data-ttu-id="198e6-173">在 Azure 自動化中啟動 Runbook</span><span class="sxs-lookup"><span data-stu-id="198e6-173">Starting a runbook in Azure Automation</span></span>](automation-starting-a-runbook.md)
* [<span data-ttu-id="198e6-174">Azure 自動化中的 Runbook 輸出與訊息</span><span class="sxs-lookup"><span data-stu-id="198e6-174">Runbook output and messages in Azure Automation</span></span>](automation-runbook-output-and-messages.md)

