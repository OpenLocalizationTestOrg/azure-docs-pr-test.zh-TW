---
title: "aaaAzure Media Services 分散的 MP4 即時內嵌規格 |Microsoft 文件"
description: "此規格說明 hello 通訊協定和格式分散 MP4 基礎即時資料流擷取 Azure 媒體服務。 您可以使用 Azure Media Services toostream 即時事件，並使用 Azure 做為 hello 雲端平台廣播即時內容。 本文件也討論建置高度備援且強固之即時內嵌機制的最佳做法。"
services: media-services
documentationcenter: 
author: cenkdin
manager: cfowler
editor: 
ms.assetid: 43fac263-a5ea-44af-8dd5-cc88e423b4de
ms.service: media-services
ms.workload: media
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 06/29/2017
ms.author: cenkd;juliako
ms.openlocfilehash: 0c191f8d6c5a595621feaba0e571fb984b666f34
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="azure-media-services-fragmented-mp4-live-ingest-specification"></a><span data-ttu-id="a3a4d-105">Azure 媒體服務的分散 MP4 即時內嵌規格</span><span class="sxs-lookup"><span data-stu-id="a3a4d-105">Azure Media Services fragmented MP4 live ingest specification</span></span>
<span data-ttu-id="a3a4d-106">此規格說明 hello 通訊協定和格式分散 MP4 基礎即時資料流擷取 Azure 媒體服務。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-106">This specification describes hello protocol and format for fragmented MP4-based live streaming ingestion for Azure Media Services.</span></span> <span data-ttu-id="a3a4d-107">Media Services 提供即時串流服務的客戶可以使用 toostream 即時事件，並使用 Azure 做為 hello 雲端平台廣播即時內容。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-107">Media Services provides a live streaming service that customers can use toostream live events and broadcast content in real time by using Azure as hello cloud platform.</span></span> <span data-ttu-id="a3a4d-108">本文件也討論建置高度備援且強固之即時內嵌機制的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-108">This document also discusses best practices for building highly redundant and robust live ingest mechanisms.</span></span>

## <a name="1-conformance-notation"></a><span data-ttu-id="a3a4d-109">1.一致性標記法</span><span class="sxs-lookup"><span data-stu-id="a3a4d-109">1. Conformance notation</span></span>
<span data-ttu-id="a3a4d-110">hello 關鍵字 「 必須 」 「 必須不是，」 「 要求 」 的 「"SHALL，"應該 NOT，"「 應該 」，「 應該 NOT，"「 建議 」、 「 可能 」 和此文件中的 [選擇性] 是 toobe 解譯，因為它們是在 RFC 2119 中所述。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-110">hello key words "MUST," "MUST NOT," "REQUIRED," "SHALL," "SHALL NOT," "SHOULD," "SHOULD NOT," "RECOMMENDED," "MAY," and "OPTIONAL" in this document are toobe interpreted as they are described in RFC 2119.</span></span>

## <a name="2-service-diagram"></a><span data-ttu-id="a3a4d-111">2.服務圖表</span><span class="sxs-lookup"><span data-stu-id="a3a4d-111">2. Service diagram</span></span>
<span data-ttu-id="a3a4d-112">hello 下列圖表顯示 hello 高層級架構 hello 即時串流處理媒體服務中的服務：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-112">hello following diagram shows hello high-level architecture of hello live streaming service in Media Services:</span></span>

1. <span data-ttu-id="a3a4d-113">即時編碼器將會建立及佈建的即時摘要 toochannels 推送透過 hello Azure Media Services SDK。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-113">A live encoder pushes live feeds toochannels that are created and provisioned via hello Azure Media Services SDK.</span></span>
2. <span data-ttu-id="a3a4d-114">通道、 程式及所有 hello 都即時串流功能，包括內嵌、 格式化、 媒體服務控制代碼的串流端點雲端 DVR、 安全性、 延展性和備援。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-114">Channels, programs, and streaming endpoints in Media Services handle all hello live streaming functionalities, including ingest, formatting, cloud DVR, security, scalability, and redundancy.</span></span>
3. <span data-ttu-id="a3a4d-115">客戶可以選擇 toodeploy Azure 內容傳遞網路之間的層 hello 串流端點和 hello 用戶端端點。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-115">Optionally, customers can choose toodeploy an Azure Content Delivery Network layer between hello streaming endpoint and hello client endpoints.</span></span>
4. <span data-ttu-id="a3a4d-116">用戶端端點的資料流從 hello 串流端點使用 HTTP 彈性資料流通訊協定。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-116">Client endpoints stream from hello streaming endpoint by using HTTP Adaptive Streaming protocols.</span></span> <span data-ttu-id="a3a4d-117">範例包括 Microsoft Smooth Streaming、透過 HTTP 執行的動態彈性資料流 (DASH 或 MPEG-DASH)，以及 Apple HTTP 即時串流 (HLS)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-117">Examples include Microsoft Smooth Streaming, Dynamic Adaptive Streaming over HTTP (DASH, or MPEG-DASH), and Apple HTTP Live Streaming (HLS).</span></span>

![內嵌流程][image1]

## <a name="3-bitstream-format--iso-14496-12-fragmented-mp4"></a><span data-ttu-id="a3a4d-119">3.位元資料流格式 – ISO 14496-12 分散 MP4</span><span class="sxs-lookup"><span data-stu-id="a3a4d-119">3. Bitstream format – ISO 14496-12 fragmented MP4</span></span>
<span data-ttu-id="a3a4d-120">hello 電傳格式的即時資料流擷取中討論這份文件根據 [14496-12]。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-120">hello wire format for live streaming ingest discussed in this document is based on [ISO-14496-12].</span></span> <span data-ttu-id="a3a4d-121">如需分散 MP4 格式、點播視訊檔案及即時串流內嵌的詳細說明，請參閱 [[MS-SSTR]](http://msdn.microsoft.com/library/ff469518.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-121">For a detailed explanation of fragmented MP4 format and extensions both for video-on-demand files and live streaming ingestion, see [[MS-SSTR]](http://msdn.microsoft.com/library/ff469518.aspx).</span></span>

### <a name="live-ingest-format-definitions"></a><span data-ttu-id="a3a4d-122">即時內嵌格式定義</span><span class="sxs-lookup"><span data-stu-id="a3a4d-122">Live ingest format definitions</span></span>
<span data-ttu-id="a3a4d-123">hello 下列清單說明適用於 toolive 定義內嵌到 Azure Media Services 的特殊格式：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-123">hello following list describes special format definitions that apply toolive ingest into Azure Media Services:</span></span>

1. <span data-ttu-id="a3a4d-124">hello **ftyp**，**即時伺服器資訊清單方塊**，和**moov**方塊必須傳送每個要求 (HTTP POST)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-124">hello **ftyp**, **Live Server Manifest Box**, and **moov** boxes MUST be sent with each request (HTTP POST).</span></span> <span data-ttu-id="a3a4d-125">兩個方塊必須傳送 hello 資料流的 hello 開頭，並的隨時 hello 編碼器必須重新連接 tooresume 資料流擷取。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-125">These boxes MUST be sent at hello beginning of hello stream and any time hello encoder must reconnect tooresume stream ingest.</span></span> <span data-ttu-id="a3a4d-126">如需詳細資訊，請參閱 [1] 的第 6 節。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-126">For more information, see Section 6 in [1].</span></span>
2. <span data-ttu-id="a3a4d-127">[1] 的第 3.3.2 節為即時內嵌定義名為 **StreamManifestBox** 的選用方塊。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-127">Section 3.3.2 in [1] defines an optional box called **StreamManifestBox** for live ingest.</span></span> <span data-ttu-id="a3a4d-128">Toohello hello Azure 負載平衡器的路由邏輯，因為使用此方塊已被取代。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-128">Due toohello routing logic of hello Azure load balancer, using this box is deprecated.</span></span> <span data-ttu-id="a3a4d-129">hello 方塊不能有時擷取到 Media Services。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-129">hello box SHOULD NOT be present when ingesting into Media Services.</span></span> <span data-ttu-id="a3a4d-130">如果有此方塊，則媒體服務會以無訊息方式將其忽略。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-130">If this box is present, Media Services silently ignores it.</span></span>
3. <span data-ttu-id="a3a4d-131">hello **TrackFragmentExtendedHeaderBox**必須存在的每個片段中 3.2.3.2 [1] 中定義的方塊。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-131">hello **TrackFragmentExtendedHeaderBox** box defined in 3.2.3.2 in [1] MUST be present for each fragment.</span></span>
4. <span data-ttu-id="a3a4d-132">第 2 版的 hello **TrackFragmentExtendedHeaderBox**方塊應使用的 toogenerate 媒體區段在多個資料中心中具有相同的 Url。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-132">Version 2 of hello **TrackFragmentExtendedHeaderBox** box SHOULD be used toogenerate media segments that have identical URLs in multiple datacenters.</span></span> <span data-ttu-id="a3a4d-133">hello 片段索引欄位為 REQUIRED 跨資料中心容錯移轉的索引式例如 Apple HLS 的串流格式，以索引為基礎的 MPEG DASH。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-133">hello fragment index field is REQUIRED for cross-datacenter failover of index-based streaming formats such as Apple HLS and index-based MPEG-DASH.</span></span> <span data-ttu-id="a3a4d-134">tooenable 跨資料中心容錯移轉，hello 片段索引必須跨多個編碼器會進行同步處理，並會加 1 的每個後續媒體片段，甚至可跨編碼器重新啟動或失敗。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-134">tooenable cross-datacenter failover, hello fragment index MUST be synced across multiple encoders and be increased by 1 for each successive media fragment, even across encoder restarts or failures.</span></span>
5. <span data-ttu-id="a3a4d-135">在 [1] 的區段 3.3.6 會定義方塊稱為**MovieFragmentRandomAccessBox** (**mfra**)，可能會傳送 hello 即時擷取 tooindicate 結束資料流 (EOS) toohello 通道一端。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-135">Section 3.3.6 in [1] defines a box called **MovieFragmentRandomAccessBox** (**mfra**) that MAY be sent at hello end of live ingestion tooindicate end-of-stream (EOS) toohello channel.</span></span> <span data-ttu-id="a3a4d-136">到期 toohello 內嵌 Media Services 的邏輯，使用 EOS 已經過時，而且 hello **mfra**方塊不會傳送即時擷取的。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-136">Due toohello ingest logic of Media Services, using EOS is deprecated, and hello **mfra** box for live ingestion SHOULD NOT be sent.</span></span> <span data-ttu-id="a3a4d-137">如果已傳送，媒體服務會以無訊息方式將其忽略。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-137">If sent, Media Services silently ignores it.</span></span> <span data-ttu-id="a3a4d-138">hello tooreset hello 狀態擷取點，我們建議您改用[重設通道](https://docs.microsoft.com/rest/api/media/operations/channel#reset_channels)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-138">tooreset hello state of hello ingest point, we recommend that you use [Channel Reset](https://docs.microsoft.com/rest/api/media/operations/channel#reset_channels).</span></span> <span data-ttu-id="a3a4d-139">我們也建議您改用[程式停止](https://msdn.microsoft.com/library/azure/dn783463.aspx#stop_programs)tooend 簡報和資料流。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-139">We also recommend that you use [Program Stop](https://msdn.microsoft.com/library/azure/dn783463.aspx#stop_programs) tooend a presentation and stream.</span></span>
6. <span data-ttu-id="a3a4d-140">hello MP4 片段持續時間應為常數，tooreduce hello 大小 hello 用戶端資訊清單。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-140">hello MP4 fragment duration SHOULD be constant, tooreduce hello size of hello client manifests.</span></span> <span data-ttu-id="a3a4d-141">常數的 MP4 片段持續時間也會改善用戶端下載啟發學習法透過 hello 使用重複的標記。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-141">A constant MP4 fragment duration also improves client download heuristics through hello use of repeat tags.</span></span> <span data-ttu-id="a3a4d-142">hello 持續時間可能會變動 toocompensate 的非整數的畫面播放速率。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-142">hello duration MAY fluctuate toocompensate for non-integer frame rates.</span></span>
7. <span data-ttu-id="a3a4d-143">hello MP4 片段期間應該大約 2 和 6 秒之間。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-143">hello MP4 fragment duration SHOULD be between approximately 2 and 6 seconds.</span></span>
8. <span data-ttu-id="a3a4d-144">「應該」以遞增順序送達 MP4 片段時間戳記和索引 (**TrackFragmentExtendedHeaderBox** `fragment_ absolute_ time` 和 `fragment_index`)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-144">MP4 fragment timestamps and indexes (**TrackFragmentExtendedHeaderBox** `fragment_ absolute_ time` and `fragment_index`) SHOULD arrive in increasing order.</span></span> <span data-ttu-id="a3a4d-145">雖然媒體服務具有恢復功能 tooduplicate 片段，但是它具有有限能力 tooreorder 片段根據 toohello 媒體時間軸。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-145">Although Media Services is resilient tooduplicate fragments, it has limited ability tooreorder fragments according toohello media timeline.</span></span>

## <a name="4-protocol-format--http"></a><span data-ttu-id="a3a4d-146">4.通訊協定格式 – HTTP</span><span class="sxs-lookup"><span data-stu-id="a3a4d-146">4. Protocol format – HTTP</span></span>
<span data-ttu-id="a3a4d-147">ISO 分散 MP4 基礎即時內嵌的 Media Services 會使用標準長時間執行 HTTP POST 要求 tootransmit 編碼媒體資料封裝在分散 MP4 格式 toohello 服務。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-147">ISO fragmented MP4-based live ingest for Media Services uses a standard long-running HTTP POST request tootransmit encoded media data that is packaged in fragmented MP4 format toohello service.</span></span> <span data-ttu-id="a3a4d-148">每個 HTTP POST 傳送完整的分散 MP4 bitstream （「 資料流 」），從標頭方塊的 hello 開頭開始 (**ftyp**，**即時伺服器資訊清單方塊**，和**moov**方塊），並繼續進行一連串的片段 (**moof**和**mdat**方塊)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-148">Each HTTP POST sends a complete fragmented MP4 bitstream ("stream"), starting from hello beginning with header boxes (**ftyp**, **Live Server Manifest Box**, and **moov** boxes), and continuing with a sequence of fragments (**moof** and **mdat** boxes).</span></span> <span data-ttu-id="a3a4d-149">如需 hello HTTP POST 要求的 URL 語法，請參閱節 9.2 [1]。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-149">For URL syntax for hello HTTP POST request, see section 9.2 in [1].</span></span> <span data-ttu-id="a3a4d-150">舉例來說，hello POST URL 是：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-150">An example of hello POST URL is:</span></span> 

    http://customer.channel.mediaservices.windows.net/ingest.isml/streams(720p)

### <a name="requirements"></a><span data-ttu-id="a3a4d-151">需求</span><span class="sxs-lookup"><span data-stu-id="a3a4d-151">Requirements</span></span>
<span data-ttu-id="a3a4d-152">以下是 hello 詳細的需求：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-152">Here are hello detailed requirements:</span></span>

1. <span data-ttu-id="a3a4d-153">hello 編碼器應該啟動廣播傳送 HTTP POST 要求為空白的 hello"body"（內容長度為零） 使用 hello 擷取相同的 URL。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-153">hello encoder SHOULD start hello broadcast by sending an HTTP POST request with an empty “body” (zero content length) by using hello same ingestion URL.</span></span> <span data-ttu-id="a3a4d-154">這可協助 hello 編碼器快速偵測 hello 即時擷取端點是否有效，並且如果有任何驗證或其他所需的條件。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-154">This can help hello encoder quickly detect whether hello live ingestion endpoint is valid, and if there are any authentication or other conditions required.</span></span> <span data-ttu-id="a3a4d-155">每個 HTTP 通訊協定，hello 伺服器無法傳送回 HTTP 回應 hello 整個收到要求之前，包括 hello 張貼的內容。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-155">Per HTTP protocol, hello server can't send back an HTTP response until hello entire request, including hello POST body, is received.</span></span> <span data-ttu-id="a3a4d-156">即時事件，而此步驟中，hello 編碼器不 hello 長時間執行，因此可能不是能 toodetect 任何錯誤直到完成傳送嗨的所有資料為止。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-156">Given hello long-running nature of a live event, without this step, hello encoder might not be able toodetect any error until it finishes sending all hello data.</span></span>
2. <span data-ttu-id="a3a4d-157">hello 編碼器必須處理的任何錯誤或驗證挑戰，因為 (1)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-157">hello encoder MUST handle any errors or authentication challenges because of (1).</span></span> <span data-ttu-id="a3a4d-158">如果 (1) 後續的回應為 200，則繼續進行。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-158">If (1) succeeds with a 200 response, continue.</span></span>
3. <span data-ttu-id="a3a4d-159">hello 編碼器必須啟動新的 HTTP POST 要求與 hello 分散 MP4 資料流。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-159">hello encoder MUST start a new HTTP POST request with hello fragmented MP4 stream.</span></span> <span data-ttu-id="a3a4d-160">hello 承載必須以 hello [標題] 方塊中，後面接著片段開頭。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-160">hello payload MUST start with hello header boxes, followed by fragments.</span></span> <span data-ttu-id="a3a4d-161">請注意該 hello **ftyp**，**即時伺服器資訊清單方塊**，和**moov**必須與每個要求，傳送 （依此順序） 的方塊，即使因為必須重新連接 hello 編碼器 hello前一個要求已終止前一個 toohello hello 資料流結尾。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-161">Note that hello **ftyp**, **Live Server Manifest Box**, and **moov** boxes (in this order) MUST be sent with each request, even if hello encoder must reconnect because hello previous request was terminated prior toohello end of hello stream.</span></span> 
4. <span data-ttu-id="a3a4d-162">hello 編碼器必須使用區塊的傳輸編碼用於上傳，因為它是不可能 toopredict hello 整個內容長度 hello 即時事件。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-162">hello encoder MUST use chunked transfer encoding for uploading, because it’s impossible toopredict hello entire content length of hello live event.</span></span>
5. <span data-ttu-id="a3a4d-163">Hello 事件時，透過傳送嗨最後一個片段之後, hello 編碼器必須依正常程序會結束 hello 區塊傳輸編碼方式 （大部分的 HTTP 用戶端堆疊就會自動處理） 的訊息序列。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-163">When hello event is over, after sending hello last fragment, hello encoder MUST gracefully end hello chunked transfer encoding message sequence (most HTTP client stacks handle it automatically).</span></span> <span data-ttu-id="a3a4d-164">hello 編碼器必須等候 hello 服務 tooreturn hello 最終回應程式碼，並再結束 hello 的連接。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-164">hello encoder MUST wait for hello service tooreturn hello final response code, and then terminate hello connection.</span></span> 
6. <span data-ttu-id="a3a4d-165">hello 編碼器不得使用 hello`Events()`名詞中所述 9.2 中 [1] 到 Media Services 即時擷取的。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-165">hello encoder MUST NOT use hello `Events()` noun as described in 9.2 in [1] for live ingestion into Media Services.</span></span>
7. <span data-ttu-id="a3a4d-166">如果 hello HTTP POST 要求終止或時間出 TCP 錯誤先前 toohello hello 資料流的結尾，與 hello 編碼器必須發出新的 POST 要求使用新的連接，並遵循 hello 上述需求。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-166">If hello HTTP POST request terminates or times out with a TCP error prior toohello end of hello stream, hello encoder MUST issue a new POST request by using a new connection, and follow hello preceding requirements.</span></span> <span data-ttu-id="a3a4d-167">此外，hello 編碼器必須重新傳送嗨先前的兩個 MP4 片段，針對每個追蹤中 hello 資料流，並繼續而不會引進 hello 媒體時間軸中的不一致。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-167">Additionally, hello encoder MUST resend hello previous two MP4 fragments for each track in hello stream, and resume without introducing a discontinuity in hello media timeline.</span></span> <span data-ttu-id="a3a4d-168">重新傳送嗨最後兩個 MP4 片段，針對每個追蹤，可確保不會遺失任何資料。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-168">Resending hello last two MP4 fragments for each track ensures that there is no data loss.</span></span> <span data-ttu-id="a3a4d-169">換句話說，如果資料流包含音訊和視訊播放軌，hello 目前 POST 要求失敗，hello 編碼器必須重新連接並重新傳送 hello hello 音訊播放軌，如先前傳送成功時，最後兩個片段和 hello 最後兩個片段的hello 視訊音軌，先前已成功傳送，不會遺失任何資料的 tooensure。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-169">In other words, if a stream contains both an audio and a video track, and hello current POST request fails, hello encoder must reconnect and resend hello last two fragments for hello audio track, which were previously successfully sent, and hello last two fragments for hello video track, which were previously successfully sent, tooensure that there is no data loss.</span></span> <span data-ttu-id="a3a4d-170">hello 編碼器必須維護它重新連線時重新傳送的媒體片段的 「 轉送 」 緩衝區。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-170">hello encoder MUST maintain a “forward” buffer of media fragments, which it resends when it reconnects.</span></span>

## <a name="5-timescale"></a><span data-ttu-id="a3a4d-171">5.時幅</span><span class="sxs-lookup"><span data-stu-id="a3a4d-171">5. Timescale</span></span>
<span data-ttu-id="a3a4d-172">[[MS SSTR]](https://msdn.microsoft.com/library/ff469518.aspx)說明 hello 用法的時幅**SmoothStreamingMedia** （區段 2.2.2.1）、 **StreamElement** （區段 2.2.2.3）、 **StreamFragmentElement**（區段 2.2.2.6） 和**LiveSMIL** （區段 2.2.7.3.1）。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-172">[[MS-SSTR]](https://msdn.microsoft.com/library/ff469518.aspx) describes hello usage of timescale for **SmoothStreamingMedia** (Section 2.2.2.1), **StreamElement** (Section 2.2.2.3), **StreamFragmentElement** (Section 2.2.2.6), and **LiveSMIL** (Section 2.2.7.3.1).</span></span> <span data-ttu-id="a3a4d-173">如果 hello 的時幅值不存在，hello 所使用的預設值為 10,000,000 (10 MHz)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-173">If hello timescale value is not present, hello default value used is 10,000,000 (10 MHz).</span></span> <span data-ttu-id="a3a4d-174">Hello Smooth Streaming 格式規格不會封鎖其他時間單位值的使用方式，雖然大部分的編碼器實作都會使用此預設值的值 (10 MHz) toogenerate Smooth Streaming 內嵌資料。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-174">Although hello Smooth Streaming format specification doesn’t block usage of other timescale values, most encoder implementations use this default value (10 MHz) toogenerate Smooth Streaming ingest data.</span></span> <span data-ttu-id="a3a4d-175">到期 toohello [Azure 媒體動態封裝](media-services-dynamic-packaging-overview.md)功能，我們建議您使用 90 KHz 時幅視訊資料流和 44.1 KHz 或 48.1 KHz 音訊資料流。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-175">Due toohello [Azure Media Dynamic Packaging](media-services-dynamic-packaging-overview.md) feature, we recommend that you use a 90-KHz timescale for video streams and 44.1 KHz or 48.1 KHz for audio streams.</span></span> <span data-ttu-id="a3a4d-176">如果不同的資料流使用不同的時間單位值時，必須先傳送 hello 資料流層級時幅。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-176">If different timescale values are used for different streams, hello stream-level timescale MUST be sent.</span></span> <span data-ttu-id="a3a4d-177">如需詳細資訊，請參閱 [[MS-SSTR]](https://msdn.microsoft.com/library/ff469518.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-177">For more information, see [[MS-SSTR]](https://msdn.microsoft.com/library/ff469518.aspx).</span></span>     

## <a name="6-definition-of-stream"></a><span data-ttu-id="a3a4d-178">6.「資料流」的定義</span><span class="sxs-lookup"><span data-stu-id="a3a4d-178">6. Definition of “stream”</span></span>
<span data-ttu-id="a3a4d-179">資料流是 hello 的基本單位中組合實況簡報，即時擷取作業處理資料流的容錯移轉與備援性案例。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-179">Stream is hello basic unit of operation in live ingestion for composing live presentations, handling streaming failover, and redundancy scenarios.</span></span> <span data-ttu-id="a3a4d-180">「資料流」定義為一個唯一的分散 MP4 位元資料流，其中可能包含單一資料軌或多個資料軌。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-180">Stream is defined as one unique, fragmented MP4 bitstream that might contain a single track or multiple tracks.</span></span> <span data-ttu-id="a3a4d-181">完整即時展示檔可能包含一或多個資料流，依據 hello hello 即時編碼器設定。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-181">A full live presentation might contain one or more streams, depending on hello configuration of hello live encoders.</span></span> <span data-ttu-id="a3a4d-182">hello 遵循範例說明使用資料流 toocompose 的各種選項完整實況簡報。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-182">hello following examples illustrate various options of using streams toocompose a full live presentation.</span></span>

<span data-ttu-id="a3a4d-183">**範例：**</span><span class="sxs-lookup"><span data-stu-id="a3a4d-183">**Example:**</span></span> 

<span data-ttu-id="a3a4d-184">客戶想 toocreate 即時資料流展示檔包含下列音訊/視訊位元的 hello:</span><span class="sxs-lookup"><span data-stu-id="a3a4d-184">A customer wants toocreate a live streaming presentation that includes hello following audio/video bitrates:</span></span>

<span data-ttu-id="a3a4d-185">視訊 - 3000 kbps、1500 kbps、750 kbps</span><span class="sxs-lookup"><span data-stu-id="a3a4d-185">Video – 3000 kbps, 1500 kbps, 750 kbps</span></span>

<span data-ttu-id="a3a4d-186">音訊 - 128 kbps</span><span class="sxs-lookup"><span data-stu-id="a3a4d-186">Audio – 128 kbps</span></span>

### <a name="option-1-all-tracks-in-one-stream"></a><span data-ttu-id="a3a4d-187">選項 1：一個資料流中所有的資料軌</span><span class="sxs-lookup"><span data-stu-id="a3a4d-187">Option 1: All tracks in one stream</span></span>
<span data-ttu-id="a3a4d-188">在此選項中，單一編碼器會產生所有音訊/視訊資料軌，然後將其組合成一個分散的 MP4 位元資料流。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-188">In this option, a single encoder generates all audio/video tracks, and then bundles them into one fragmented MP4 bitstream.</span></span> <span data-ttu-id="a3a4d-189">hello 分散的 MP4 bitstream 會透過單一的 HTTP POST 連線傳送。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-189">hello fragmented MP4 bitstream is then sent via a single HTTP POST connection.</span></span> <span data-ttu-id="a3a4d-190">此範例中有此即時簡報的唯一資料流。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-190">In this example, there is only one stream for this live presentation.</span></span>

![資料流 - 一個資料軌][image2]

### <a name="option-2-each-track-in-a-separate-stream"></a><span data-ttu-id="a3a4d-192">選項 2：每個資料軌分在不同的資料流中</span><span class="sxs-lookup"><span data-stu-id="a3a4d-192">Option 2: Each track in a separate stream</span></span>
<span data-ttu-id="a3a4d-193">在此選項，hello 編碼器一首曲目放入每個 MP4 片段 bitstream，，然後再將所有 hello 資料流透過個別 HTTP 連線。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-193">In this option, hello encoder puts one track into each fragment MP4 bitstream, and then posts all of hello streams over separate HTTP connections.</span></span> <span data-ttu-id="a3a4d-194">這可透過一或多個編碼器完成。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-194">This can be done with one encoder or with multiple encoders.</span></span> <span data-ttu-id="a3a4d-195">hello 即時擷取可看到此實況簡報四個資料流所組成。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-195">hello live ingestion sees this live presentation as composed of four streams.</span></span>

![資料流 - 分開的資料軌][image3]

### <a name="option-3-bundle-audio-track-with-hello-lowest-bitrate-video-track-into-one-stream"></a><span data-ttu-id="a3a4d-197">選項 3： 組合成一個資料流與 hello 最低位元速率視訊音軌的音訊播放軌</span><span class="sxs-lookup"><span data-stu-id="a3a4d-197">Option 3: Bundle audio track with hello lowest bitrate video track into one stream</span></span>
<span data-ttu-id="a3a4d-198">此選項，在 hello 客戶會選擇 toobundle hello 音訊播放軌與 hello 最低位元速率視訊播放軌中一個片段 MP4 bitstream 和保持 hello 其他兩個視訊音軌，為不同資料流。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-198">In this option, hello customer chooses toobundle hello audio track with hello lowest-bitrate video track in one fragment MP4 bitstream, and leave hello other two video tracks as separate streams.</span></span> 

![資料流 - 音訊與視訊資料軌][image4]

### <a name="summary"></a><span data-ttu-id="a3a4d-200">摘要</span><span class="sxs-lookup"><span data-stu-id="a3a4d-200">Summary</span></span>
<span data-ttu-id="a3a4d-201">此並非詳盡清單，僅列出此範例中部分可用的內嵌選項。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-201">This is not an exhaustive list of all possible ingestion options for this example.</span></span> <span data-ttu-id="a3a4d-202">事實上，即時內嵌支援將資料軌以任何組合分組到資料流。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-202">As a matter of fact, any grouping of tracks into streams is supported by live ingestion.</span></span> <span data-ttu-id="a3a4d-203">客戶和編碼器廠商可以根據工程的複雜性、編碼器的能力，以及備援與容錯移轉考量，來選擇自己的實作。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-203">Customers and encoder vendors can choose their own implementations based on engineering complexity, encoder capacity, and redundancy and failover considerations.</span></span> <span data-ttu-id="a3a4d-204">不過，在大部分情況下，沒有 hello 整個即時展示檔只有一個音訊播放軌。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-204">However, in most cases, there is only one audio track for hello entire live presentation.</span></span> <span data-ttu-id="a3a4d-205">因此，它的重要 tooensure hello healthiness hello 的內嵌資料流，包含 hello 音訊播放軌。這項考量通常會導致將 hello 音訊播放軌放在它自己的資料流 （如同選項 2) 或組合與 hello 最低位元速率視訊音軌 （如同選項 3)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-205">So, it’s important tooensure hello healthiness of hello ingest stream that contains hello audio track. This consideration often results in putting hello audio track in its own stream (as in Option 2) or bundling it with hello lowest-bitrate video track (as in Option 3).</span></span> <span data-ttu-id="a3a4d-206">此外，較佳的備援和容錯功能，如傳送 hello 相同的音訊播放軌中兩個不同的資料流 (選項 2 與備援的音訊播放軌) 或使用至少兩部 hello 最低位元速率視訊音軌的音訊在組合在一起 (選項 3 將 hello 音訊播放軌至少兩個視訊資料流） 強烈建議在即時內嵌到 Media Services。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-206">Also, for better redundancy and fault tolerance, sending hello same audio track in two different streams (Option 2 with redundant audio tracks) or bundling hello audio track with at least two of hello lowest-bitrate video tracks (Option 3 with audio bundled in at least two video streams) is highly recommended for live ingest into Media Services.</span></span>

## <a name="7-service-failover"></a><span data-ttu-id="a3a4d-207">7.服務容錯移轉</span><span class="sxs-lookup"><span data-stu-id="a3a4d-207">7. Service failover</span></span>
<span data-ttu-id="a3a4d-208">指定的即時資料流的 hello 本質，很好的容錯移轉支援是關鍵確保 hello hello 服務可用性。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-208">Given hello nature of live streaming, good failover support is critical for ensuring hello availability of hello service.</span></span> <span data-ttu-id="a3a4d-209">Media Services 是設計的 toohandle 各種類型的失敗，包括網路錯誤，伺服器錯誤，以及儲存體問題。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-209">Media Services is designed toohandle various types of failures, including network errors, server errors, and storage issues.</span></span> <span data-ttu-id="a3a4d-210">中適當的容錯移轉邏輯從 hello 即時編碼器端搭配使用時，客戶就可以達到從 hello 雲端可靠的即時串流服務。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-210">When used in conjunction with proper failover logic from hello live encoder side, customers can achieve a highly reliable live streaming service from hello cloud.</span></span>

<span data-ttu-id="a3a4d-211">在本節中，我們將討論服務容錯移轉的案例。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-211">In this section, we discuss service failover scenarios.</span></span> <span data-ttu-id="a3a4d-212">在此情況下，hello 失敗發生 hello 服務內的某處，它就會出現網路錯誤。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-212">In this case, hello failure happens somewhere within hello service, and it manifests itself as a network error.</span></span> <span data-ttu-id="a3a4d-213">以下是一些 hello 編碼器的實作來處理服務容錯移轉的建議：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-213">Here are some recommendations for hello encoder implementation for handling service failover:</span></span>

1. <span data-ttu-id="a3a4d-214">建立 hello TCP 連接使用 10 秒逾時。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-214">Use a 10-second timeout for establishing hello TCP connection.</span></span> <span data-ttu-id="a3a4d-215">如果嘗試 tooestablish hello 連接費時超過 10 秒，中止 hello 作業，並再試一次。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-215">If an attempt tooestablish hello connection takes longer than 10 seconds, abort hello operation and try again.</span></span> 
2. <span data-ttu-id="a3a4d-216">使用簡短的逾時，傳送嗨 HTTP 要求訊息區塊 （chunk）。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-216">Use a short timeout for sending hello HTTP request message chunks.</span></span> <span data-ttu-id="a3a4d-217">如果 hello 目標 MP4 片段持續時間 N 秒，請使用 N 之間 2 N 秒; 傳送逾時例如，如果 hello MP4 片段持續時間是 6 秒，使用 6 too12 秒的逾時。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-217">If hello target MP4 fragment duration is N seconds, use a send timeout between N and 2 N seconds; for example, if hello MP4 fragment duration is 6 seconds, use a timeout of 6 too12 seconds.</span></span> <span data-ttu-id="a3a4d-218">如果發生逾時，重設 hello 連線、 開啟新的連接，以及繼續資料流將內嵌 hello 新的連接。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-218">If a timeout occurs, reset hello connection, open a new connection, and resume stream ingest on hello new connection.</span></span> 
3. <span data-ttu-id="a3a4d-219">維護具有 hello 最後兩個片段的每個追蹤記錄已成功且完全地傳送 toohello 服務的循環緩衝區。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-219">Maintain a rolling buffer that has hello last two fragments for each track that were successfully and completely sent toohello service.</span></span>  <span data-ttu-id="a3a4d-220">如果 hello 資料流的 HTTP POST 要求已終止，或逾時之前的 toohello hello 資料流結尾，開啟新的連接和開始另一個 HTTP POST 要求，重新傳送嗨資料流標頭、 重新傳送嗨最後兩個片段，針對每個追蹤，並繼續 hello 資料流，而不導入 hello 媒體時間軸中的不一致。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-220">If hello HTTP POST request for a stream is terminated or times out prior toohello end of hello stream, open a new connection and begin another HTTP POST request, resend hello stream headers, resend hello last two fragments for each track, and resume hello stream without introducing a discontinuity in hello media timeline.</span></span> <span data-ttu-id="a3a4d-221">這會減少 hello 可能發生資料遺失。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-221">This reduces hello chance of data loss.</span></span>
4. <span data-ttu-id="a3a4d-222">我們建議的 hello 編碼器不會限制 hello 重試 tooestablish 連線的數目或繼續之後就會發生 TCP 錯誤資料流。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-222">We recommend that hello encoder does NOT limit hello number of retries tooestablish a connection or resume streaming after a TCP error occurs.</span></span>
5. <span data-ttu-id="a3a4d-223">發生 TCP 錯誤後：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-223">After a TCP error:</span></span>
  
    <span data-ttu-id="a3a4d-224">a.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-224">a.</span></span> <span data-ttu-id="a3a4d-225">必須先關閉 hello 目前的連接，並為新的 HTTP POST 要求，必須建立新的連接。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-225">hello current connection MUST be closed, and a new connection MUST be created for a new HTTP POST request.</span></span>

    <span data-ttu-id="a3a4d-226">b.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-226">b.</span></span> <span data-ttu-id="a3a4d-227">新 HTTP POST URL 必須是的 hello hello 與 hello 初始 POST URL 相同。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-227">hello new HTTP POST URL MUST be hello same as hello initial POST URL.</span></span>
  
    <span data-ttu-id="a3a4d-228">c.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-228">c.</span></span> <span data-ttu-id="a3a4d-229">hello 新 HTTP POST 必須包含資料流標頭 (**ftyp**，**即時伺服器資訊清單方塊**，和**moov**方塊)，會在 hello 相同 toohello 資料流標頭初始 POST。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-229">hello new HTTP POST MUST include stream headers (**ftyp**, **Live Server Manifest Box**, and **moov** boxes) that are identical toohello stream headers in hello initial POST.</span></span>
  
    <span data-ttu-id="a3a4d-230">d.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-230">d.</span></span> <span data-ttu-id="a3a4d-231">必須重新傳送 hello 傳送每個追蹤記錄的最後兩個片段，以及資料流必須繼續而不會引進 hello 媒體時間軸中的不一致。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-231">hello last two fragments sent for each track must be resent, and streaming must resume without introducing a discontinuity in hello media timeline.</span></span> <span data-ttu-id="a3a4d-232">hello MP4 片段時間戳記必須持續增加，甚至可跨 HTTP POST 要求。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-232">hello MP4 fragment timestamps must increase continuously, even across HTTP POST requests.</span></span>
6. <span data-ttu-id="a3a4d-233">如果資料不會傳送 hello MP4 片段持續時間與 parallel 速率 hello 編碼器應該結束 hello HTTP POST 要求。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-233">hello encoder SHOULD terminate hello HTTP POST request if data is not being sent at a rate commensurate with hello MP4 fragment duration.</span></span>  <span data-ttu-id="a3a4d-234">不會傳送資料的 HTTP POST 要求可以防止媒體服務快速地中斷連線的服務更新的 hello 事件中的 hello 編碼器。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-234">An HTTP POST request that does not send data can prevent Media Services from quickly disconnecting from hello encoder in hello event of a service update.</span></span> <span data-ttu-id="a3a4d-235">基於這個理由，hello 的 HTTP POST 疏鬆 （在廣告訊號） 追蹤記錄應存留較短，傳送嗨疏鬆片段時，立即終止。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-235">For this reason, hello HTTP POST for sparse (ad signal) tracks SHOULD be short-lived, terminating as soon as hello sparse fragment is sent.</span></span>

## <a name="8-encoder-failover"></a><span data-ttu-id="a3a4d-236">8.編碼器容錯移轉</span><span class="sxs-lookup"><span data-stu-id="a3a4d-236">8. Encoder failover</span></span>
<span data-ttu-id="a3a4d-237">編碼器的容錯移轉是 hello toobe 定址所需要的端對端的即時資料流傳送的容錯移轉案例的第二個型別。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-237">Encoder failover is hello second type of failover scenario that needs toobe addressed for end-to-end live streaming delivery.</span></span> <span data-ttu-id="a3a4d-238">在此案例中，在 hello 編碼器端發生 hello 錯誤狀況。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-238">In this scenario, hello error condition occurs on hello encoder side.</span></span> 

![編碼器容錯移轉][image5]

<span data-ttu-id="a3a4d-240">當編碼器的容錯移轉發生時從 hello 即時擷取端點適用於下列期望的 hello:</span><span class="sxs-lookup"><span data-stu-id="a3a4d-240">hello following expectations apply from hello live ingestion endpoint when encoder failover happens:</span></span>

1. <span data-ttu-id="a3a4d-241">新的編碼程式執行個體應該建立 toocontinue 串流，hello 圖表 （資料流 3000 k 視訊虛線） 中所示。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-241">A new encoder instance SHOULD be created toocontinue streaming, as illustrated in hello diagram (Stream for 3000k video, with dashed line).</span></span>
2. <span data-ttu-id="a3a4d-242">hello hello 的形式使用必須 hello 相同 URL 為 HTTP POST 要求新的編碼器失敗執行個體。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-242">hello new encoder MUST use hello same URL for HTTP POST requests as hello failed instance.</span></span>
3. <span data-ttu-id="a3a4d-243">hello 新的編碼器 POST 要求都必須包含 hello 相同分散 MP4 標題方塊為 hello 失敗的執行個體。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-243">hello new encoder’s POST request MUST include hello same fragmented MP4 header boxes as hello failed instance.</span></span>
4. <span data-ttu-id="a3a4d-244">hello 相同實況簡報 toogenerate 同步處理音訊/視訊樣本對齊的片段界限，hello 新的編碼器，必須正確地同步與所有其他執行的編碼器。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-244">hello new encoder MUST be properly synced with all other running encoders for hello same live presentation toogenerate synced audio/video samples with aligned fragment boundaries.</span></span>
5. <span data-ttu-id="a3a4d-245">hello 新的資料流必須在語意上與使用 hello 先前的資料流，並且可交換 hello 標頭或片段層級。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-245">hello new stream MUST be semantically equivalent with hello previous stream, and interchangeable at hello header and fragment levels.</span></span>
6. <span data-ttu-id="a3a4d-246">hello 新的編碼器應該嘗試 toominimize 資料遺失。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-246">hello new encoder SHOULD try toominimize data loss.</span></span> <span data-ttu-id="a3a4d-247">hello`fragment_absolute_time`和`fragment_index`的媒體片段應增加從上次停止 hello 編碼器 hello 點。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-247">hello `fragment_absolute_time` and `fragment_index` of media fragments SHOULD increase from hello point where hello encoder last stopped.</span></span> <span data-ttu-id="a3a4d-248">hello`fragment_absolute_time`和`fragment_index`應增加持續的方式，但它是允許 toointroduce 不一致，如有必要。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-248">hello `fragment_absolute_time` and `fragment_index` SHOULD increase in a continuous manner, but it is permissible toointroduce a discontinuity, if necessary.</span></span> <span data-ttu-id="a3a4d-249">Media Services 會忽略它已收到並處理片段，因此它是較佳 tooerr 重送片段比 toointroduce 中斷點 hello 媒體時間軸中的 hello 端。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-249">Media Services ignores fragments that it has already received and processed, so it's better tooerr on hello side of resending fragments than toointroduce discontinuities in hello media timeline.</span></span> 

## <a name="9-encoder-redundancy"></a><span data-ttu-id="a3a4d-250">9.編碼器備援</span><span class="sxs-lookup"><span data-stu-id="a3a4d-250">9. Encoder redundancy</span></span>
<span data-ttu-id="a3a4d-251">針對特定重大即時事件，視需要更高可用性和品質使用經驗，我們建議您使用主動-主動備援編碼程式 tooachieve 無縫式容錯移轉，且不遺失資料。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-251">For certain critical live events that demand even higher availability and quality of experience, we recommended that you use active-active redundant encoders tooachieve seamless failover with no data loss.</span></span>

![編碼器備援][image6]

<span data-ttu-id="a3a4d-253">此圖所示，兩個群組的編碼器推送每個資料流的兩個的複本同時 hello 即時服務。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-253">As illustrated in this diagram, two groups of encoders push two copies of each stream simultaneously into hello live service.</span></span> <span data-ttu-id="a3a4d-254">此設定之所以受到支援，是因為媒體服務能夠根據資料流 ID 與片段時間戳記篩選出重複的片段。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-254">This setup is supported because Media Services can filter out duplicate fragments based on stream ID and fragment timestamp.</span></span> <span data-ttu-id="a3a4d-255">hello 產生即時資料流，並封存不是 hello 最佳可能彙總來自 hello 兩個來源的單一複本 hello 的所有資料流。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-255">hello resulting live stream and archive is a single copy of all hello streams that is hello best possible aggregation from hello two sources.</span></span> <span data-ttu-id="a3a4d-256">比方說，假設極端案例中，只要一個編碼器 （不需要 toobe hello 同一個） 執行在任何給定時間點的時間，每個資料流 hello 產生 hello 服務即時資料流是連續不會遺失資料。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-256">For example, in a hypothetical extreme case, as long as there is one encoder (it doesn’t have toobe hello same one) running at any given point in time for each stream, hello resulting live stream from hello service is continuous without data loss.</span></span> 

<span data-ttu-id="a3a4d-257">此案例中的 hello 需求幾乎相同 hello 當做 hello 需求 hello 「 編碼器的容錯移轉 」 案例中，與 hello 例外狀況在 hello 執行編碼器的 hello 第二個集合的相同的時間 hello 主要編碼器。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-257">hello requirements for this scenario are almost hello same as hello requirements in hello "Encoder failover" case, with hello exception that hello second set of encoders are running at hello same time as hello primary encoders.</span></span>

## <a name="10-service-redundancy"></a><span data-ttu-id="a3a4d-258">10.服務備援</span><span class="sxs-lookup"><span data-stu-id="a3a4d-258">10. Service redundancy</span></span>
<span data-ttu-id="a3a4d-259">備援性高的通用散發，有時候您必須要能夠跨地區備份 toohandle 地區災害。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-259">For highly redundant global distribution, sometimes you must have cross-region backup toohandle regional disasters.</span></span> <span data-ttu-id="a3a4d-260">展開 hello 「 編碼器備援 」 拓樸，客戶可以選擇 toohave 備援服務部署的編碼器 hello 第二個集合會連接到不同區域中。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-260">Expanding on hello “Encoder redundancy” topology, customers can choose toohave a redundant service deployment in a different region that's connected with hello second set of encoders.</span></span> <span data-ttu-id="a3a4d-261">客戶也可以使用內容傳遞網路提供者 toodeploy 前面 hello 兩個服務部署 tooseamlessly 路由用戶端流量全域流量管理員使用。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-261">Customers also can work with a Content Delivery Network provider toodeploy a Global Traffic Manager in front of hello two service deployments tooseamlessly route client traffic.</span></span> <span data-ttu-id="a3a4d-262">hello 編碼器的 hello 需求是 hello 與 hello 「 編碼器備援 」 案例相同。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-262">hello requirements for hello encoders are hello same as hello “Encoder redundancy” case.</span></span> <span data-ttu-id="a3a4d-263">hello 只例外狀況是編碼器需求 toobe hello 第二組指向不同 tooa 即時內嵌端點。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-263">hello only exception is that hello second set of encoders needs toobe pointed tooa different live ingest endpoint.</span></span> <span data-ttu-id="a3a4d-264">hello 下圖顯示此安裝程式：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-264">hello following diagram shows this setup:</span></span>

![服務備援][image7]

## <a name="11-special-types-of-ingestion-formats"></a><span data-ttu-id="a3a4d-266">11.特殊類型的內嵌格式</span><span class="sxs-lookup"><span data-stu-id="a3a4d-266">11. Special types of ingestion formats</span></span>
<span data-ttu-id="a3a4d-267">本章節將討論設計的 toohandle 特定案例的即時擷取格式的特殊類型。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-267">This section discusses special types of live ingestion formats that are designed toohandle specific scenarios.</span></span>

### <a name="sparse-track"></a><span data-ttu-id="a3a4d-268">疏鬆資料軌</span><span class="sxs-lookup"><span data-stu-id="a3a4d-268">Sparse track</span></span>
<span data-ttu-id="a3a4d-269">忘即時資料流與豐富型用戶端體驗，通常是必要 tootransmit 時間同步處理的事件或訊號頻外 hello 主要媒體資料。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-269">When delivering a live streaming presentation with a rich client experience, often it's necessary tootransmit time-synced events or signals in-band with hello main media data.</span></span> <span data-ttu-id="a3a4d-270">動態即時廣告插入是其中一個例子。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-270">An example of this is dynamic live ad insertion.</span></span> <span data-ttu-id="a3a4d-271">此類型的事件訊號不同於一般音訊/視訊資料流，因為其疏鬆的本質之故。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-271">This type of event signaling is different from regular audio/video streaming because of its sparse nature.</span></span> <span data-ttu-id="a3a4d-272">換句話說，hello 資料通常不會持續，而且 hello 間隔可以是永久 toopredict 信號。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-272">In other words, hello signaling data usually does not happen continuously, and hello interval can be hard toopredict.</span></span> <span data-ttu-id="a3a4d-273">疏鬆播放軌的 hello 概念是設計的 tooingest 信號廣播頻外的資料。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-273">hello concept of sparse track was designed tooingest and broadcast in-band signaling data.</span></span>

<span data-ttu-id="a3a4d-274">hello 下列步驟會擷取疏鬆播放軌的建議的實作：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-274">hello following steps are a recommended implementation for ingesting sparse track:</span></span>

1. <span data-ttu-id="a3a4d-275">建立個別的分散 MP4 位元資料流，其只包含疏鬆資料軌，但不包含音訊/視訊資料軌。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-275">Create a separate fragmented MP4 bitstream that contains only sparse tracks, without audio/video tracks.</span></span>
2. <span data-ttu-id="a3a4d-276">在 hello**即時伺服器資訊清單中**如第 6 節定義 [1] 中，使用 hello *parentTrackName* hello 父曲目參數 toospecify hello 名稱。如需詳細資訊，請參閱 [1] 的第 4.2.1.2.1.2 節。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-276">In hello **Live Server Manifest Box** as defined in Section 6 in [1], use hello *parentTrackName* parameter toospecify hello name of hello parent track. For more information, see section 4.2.1.2.1.2 in [1].</span></span>
3. <span data-ttu-id="a3a4d-277">在 hello**即時伺服器資訊清單方塊**， **manifestOutput**必須設定得**true**。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-277">In hello **Live Server Manifest Box**, **manifestOutput** MUST be set too**true**.</span></span>
4. <span data-ttu-id="a3a4d-278">指定 hello 疏鬆性質 hello 信號事件，我們建議使用 hello 下列：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-278">Given hello sparse nature of hello signaling event, we recommended hello following:</span></span>
   
    <span data-ttu-id="a3a4d-279">a.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-279">a.</span></span> <span data-ttu-id="a3a4d-280">在 hello 即時事件 hello 開頭，hello 編碼器會傳送 hello 初始的標題方塊 toohello 服務，可讓 hello 用戶端資訊清單中的 hello 服務 tooregister hello 疏鬆播放軌。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-280">At hello beginning of hello live event, hello encoder sends hello initial header boxes toohello service, which allows hello service tooregister hello sparse track in hello client manifest.</span></span>
   
    <span data-ttu-id="a3a4d-281">b.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-281">b.</span></span> <span data-ttu-id="a3a4d-282">未傳送資料時，hello 編碼器應該結束 hello HTTP POST 要求。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-282">hello encoder SHOULD terminate hello HTTP POST request when data is not being sent.</span></span> <span data-ttu-id="a3a4d-283">不會傳送資料的長時間執行 HTTP POST 可以防止媒體服務快速地中斷連線的服務更新或伺服器重新開機的 hello 事件中的 hello 編碼器。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-283">A long-running HTTP POST that does not send data can prevent Media Services from quickly disconnecting from hello encoder in hello event of a service update or server reboot.</span></span> <span data-ttu-id="a3a4d-284">在這些情況下，已暫時封鎖 hello 媒體伺服器 hello 通訊端上接收作業中。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-284">In these cases, hello media server is temporarily blocked in a receive operation on hello socket.</span></span>
   
    <span data-ttu-id="a3a4d-285">c.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-285">c.</span></span> <span data-ttu-id="a3a4d-286">在當信號資料不是可用的 hello 期間，hello 編碼器應該關閉 hello HTTP POST 要求。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-286">During hello time when signaling data is not available, hello encoder SHOULD close hello HTTP POST request.</span></span> <span data-ttu-id="a3a4d-287">Hello POST 要求使用中時，應該將資料傳送 hello 編碼器。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-287">While hello POST request is active, hello encoder SHOULD send data.</span></span>

    <span data-ttu-id="a3a4d-288">d.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-288">d.</span></span> <span data-ttu-id="a3a4d-289">當傳送疏鬆的片段，hello 編碼器可以設定明確的內容長度標頭，如果有的話。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-289">When sending sparse fragments, hello encoder can set an explicit content-length header, if it’s available.</span></span>

    <span data-ttu-id="a3a4d-290">e.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-290">e.</span></span> <span data-ttu-id="a3a4d-291">傳送時具有新的連接疏鬆片段，hello 編碼器應該開始傳送 hello [標題] 方塊中，後面接著 hello 新片段。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-291">When sending sparse fragments with a new connection, hello encoder SHOULD start sending from hello header boxes, followed by hello new fragments.</span></span> <span data-ttu-id="a3a4d-292">這是在容錯移轉會發生介於，案例和 hello 新疏鬆連線正在建立的 tooa 見過 hello 之前疏鬆播放軌的新伺服器。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-292">This is for cases in which failover happens in-between, and hello new sparse connection is being established tooa new server that has not seen hello sparse track before.</span></span>

    <span data-ttu-id="a3a4d-293">f.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-293">f.</span></span> <span data-ttu-id="a3a4d-294">hello 疏鬆播放軌片段 hello 對應父曲目片段具有相等或更大的時間戳記值進行可用 toohello 用戶端時，會變成可用 toohello 用戶端。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-294">hello sparse track fragment becomes available toohello client when hello corresponding parent track fragment that has an equal or larger timestamp value is made available toohello client.</span></span> <span data-ttu-id="a3a4d-295">例如，如果 hello 疏鬆片段都有 t 的時間戳記 = 1000，預期的 hello 用戶端觀察 「 視訊 」 （假設 hello 追蹤懷疑 「 視訊 」） 片段時間戳記 1000年或更新版本，才能下載之後 hello 疏鬆片段 t = 1000年。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-295">For example, if hello sparse fragment has a timestamp of t=1000, it is expected that after hello client sees "video" (assuming hello parent track name is "video") fragment timestamp 1000 or beyond, it can download hello sparse fragment t=1000.</span></span> <span data-ttu-id="a3a4d-296">請注意，hello 實際訊號無法用於 hello 簡報時間軸中的不同位置，為其指定的目的。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-296">Note that hello actual signal could be used for a different position in hello presentation timeline for its designated purpose.</span></span> <span data-ttu-id="a3a4d-297">在此範例中，它的可能在 hello 疏鬆片段 t = 1000年具有 XML 裝載，也就是將廣告插入的位置時，在幾秒鐘內更新版本。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-297">In this example, it’s possible that hello sparse fragment of t=1000 has an XML payload, which is for inserting an ad in a position that’s a few seconds later.</span></span>

    <span data-ttu-id="a3a4d-298">g.</span><span class="sxs-lookup"><span data-stu-id="a3a4d-298">g.</span></span> <span data-ttu-id="a3a4d-299">hello 裝載的疏鬆播放軌片段可以是以不同格式 （例如 XML、 文字或二進位），視 hello 案例而定。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-299">hello payload of sparse track fragments can be in different formats (such as XML, text, or binary), depending on hello scenario.</span></span>

### <a name="redundant-audio-track"></a><span data-ttu-id="a3a4d-300">備援音訊資料軌</span><span class="sxs-lookup"><span data-stu-id="a3a4d-300">Redundant audio track</span></span>
<span data-ttu-id="a3a4d-301">在一般 HTTP 彈性串流處理案例 （例如，Smooth Streaming 或虛線），通常會在 hello 整個簡報中的只有一個音訊播放軌。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-301">In a typical HTTP adaptive streaming scenario (for example, Smooth Streaming or DASH), often, there's only one audio track in hello entire presentation.</span></span> <span data-ttu-id="a3a4d-302">不同視訊音軌，有多個的品質等級的 hello 用戶端 toochoose 從錯誤狀況中，如果 hello 擷取包含 hello 音訊播放軌的 hello 資料流已損毀 hello 音訊播放軌時，可以有單一失敗點。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-302">Unlike video tracks, which have multiple quality levels for hello client toochoose from in error conditions, hello audio track can be a single point of failure if hello ingestion of hello stream that contains hello audio track is broken.</span></span> 

<span data-ttu-id="a3a4d-303">這個問題，Media Services 支援的 toosolve 即時備援音訊音軌的擷取。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-303">toosolve this problem, Media Services supports live ingestion of redundant audio tracks.</span></span> <span data-ttu-id="a3a4d-304">hello 概念是相同的音訊播放軌可以多次傳送不同的資料流中的 hello。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-304">hello idea is that hello same audio track can be sent multiple times in different streams.</span></span> <span data-ttu-id="a3a4d-305">雖然 hello 服務只會註冊 hello 音訊播放軌一次 hello 用戶端資訊清單中，它可作為備援音訊音軌備份擷取音訊的片段，如果 hello 主要音訊音軌有問題。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-305">Although hello service only registers hello audio track once in hello client manifest, it can use redundant audio tracks as backups for retrieving audio fragments if hello primary audio track has issues.</span></span> <span data-ttu-id="a3a4d-306">tooingest 多餘的音訊播放軌 hello 編碼器必須：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-306">tooingest redundant audio tracks, hello encoder needs to:</span></span>

1. <span data-ttu-id="a3a4d-307">建立多個片段 MP4 bitstreams hello 相同的音訊播放軌。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-307">Create hello same audio track in multiple fragment MP4 bitstreams.</span></span> <span data-ttu-id="a3a4d-308">hello 備援音訊音軌必須在語意上與、 以 hello 相同片段時間戳記，並可以互換 hello 標頭和片段層級。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-308">hello redundant audio tracks MUST be semantically equivalent, with hello same fragment timestamps, and be interchangeable at hello header and fragment levels.</span></span>
2. <span data-ttu-id="a3a4d-309">請確定該 hello 「 聲音 」 項目在 hello 即時伺服器資訊清單 (第 6 節中 [1]) 是 hello 相同所有多餘的音訊音軌。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-309">Ensure that hello “audio” entry in hello Live Server Manifest (Section 6 in [1]) is hello same for all redundant audio tracks.</span></span>

<span data-ttu-id="a3a4d-310">hello 下列實作是多餘的音訊音軌的建議：</span><span class="sxs-lookup"><span data-stu-id="a3a4d-310">hello following implementation is recommended for redundant audio tracks:</span></span>

1. <span data-ttu-id="a3a4d-311">讓資料流獨自傳送每個唯一的音訊資料軌。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-311">Send each unique audio track in a stream by itself.</span></span> <span data-ttu-id="a3a4d-312">此外，每個音訊播放軌資料流，其中第二個資料流 hello 只有不同於 hello 先 hello HTTP POST URL 中的 hello 識別碼傳送重複的資料流: {通訊協定}:// {伺服器位址} / {發佈點 path}/Streams({identifier})。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-312">Also, send a redundant stream for each of these audio track streams, where hello second stream differs from hello first only by hello identifier in hello HTTP POST URL: {protocol}://{server address}/{publishing point path}/Streams({identifier}).</span></span>
2. <span data-ttu-id="a3a4d-313">使用個別的資料流 toosend hello 兩個最低視訊位元。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-313">Use separate streams toosend hello two lowest video bitrates.</span></span> <span data-ttu-id="a3a4d-314">這些資料流皆「應該」包含每個唯一音訊資料軌的複本。例如，當支援多國語言時，這些資料流「應該」包含每種語言的音訊資料軌。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-314">Each of these streams SHOULD also contain a copy of each unique audio track. For example, when multiple languages are supported, these streams SHOULD contain audio tracks for each language.</span></span>
3. <span data-ttu-id="a3a4d-315">使用不同的伺服器 （編碼器） 執行個體 tooencode 以及傳送 hello 多餘資料流中所述 （1） 和 (2)。</span><span class="sxs-lookup"><span data-stu-id="a3a4d-315">Use separate server (encoder) instances tooencode and send hello redundant streams mentioned in (1) and (2).</span></span> 

## <a name="media-services-learning-paths"></a><span data-ttu-id="a3a4d-316">媒體服務學習路徑</span><span class="sxs-lookup"><span data-stu-id="a3a4d-316">Media Services learning paths</span></span>
[!INCLUDE [media-services-learning-paths-include](../../includes/media-services-learning-paths-include.md)]

## <a name="provide-feedback"></a><span data-ttu-id="a3a4d-317">提供意見反應</span><span class="sxs-lookup"><span data-stu-id="a3a4d-317">Provide feedback</span></span>
[!INCLUDE [media-services-user-voice-include](../../includes/media-services-user-voice-include.md)]

[image1]: ./media/media-services-fmp4-live-ingest-overview/media-services-image1.png
[image2]: ./media/media-services-fmp4-live-ingest-overview/media-services-image2.png
[image3]: ./media/media-services-fmp4-live-ingest-overview/media-services-image3.png
[image4]: ./media/media-services-fmp4-live-ingest-overview/media-services-image4.png
[image5]: ./media/media-services-fmp4-live-ingest-overview/media-services-image5.png
[image6]: ./media/media-services-fmp4-live-ingest-overview/media-services-image6.png
[image7]: ./media/media-services-fmp4-live-ingest-overview/media-services-image7.png
