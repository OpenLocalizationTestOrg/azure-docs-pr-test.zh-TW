---
title: "建立 web API 與 REST API 作為連接器 - Azure Logic Apps | Microsoft Docs"
description: "建立 web API 與 REST API 來呼叫您工作流程中的 API、服務或系統，以便與 Azure Logic Apps 進行系統整合"
keywords: "web API, REST API, 連接器, 工作流程, 系統整合"
services: logic-apps
author: jeffhollan
manager: anneta
editor: 
documentationcenter: 
ms.assetid: bd229179-7199-4aab-bae0-1baf072c7659
ms.service: logic-apps
ms.workload: integration
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 5/26/2017
ms.author: LADocs; jehollan
ms.openlocfilehash: 4ae98804aced23c0261c1d58721cb18d8152c6f1
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="create-custom-apis-as-connectors-for-logic-apps"></a><span data-ttu-id="8b317-104">建立自訂 API 作為 Logic Apps 的連接器</span><span class="sxs-lookup"><span data-stu-id="8b317-104">Create custom APIs as connectors for logic apps</span></span>

<span data-ttu-id="8b317-105">雖然 Azure Logic Apps 提供了 [100 多個內建連接器](../connectors/apis-list.md)，可供您在邏輯應用程式工作流程中使用，但建議您呼叫無法用來作為連接器的 API、系統與服務。</span><span class="sxs-lookup"><span data-stu-id="8b317-105">Although Azure Logic Apps offers [100+ built-in connectors](../connectors/apis-list.md) that you can use in logic app workflows, you might want to call APIs, systems, and services that aren't available as connectors.</span></span> <span data-ttu-id="8b317-106">您可以建立自己的自訂 API，能提供可在 Logic Apps 中使用的動作和觸發程序。</span><span class="sxs-lookup"><span data-stu-id="8b317-106">You can create your own custom APIs that provide actions and triggers to use in logic apps.</span></span> <span data-ttu-id="8b317-107">以下是您將需要建立自己的 API 用來作為 Logic Apps 中之連接器的其他原因：</span><span class="sxs-lookup"><span data-stu-id="8b317-107">Here are other reasons why you might want to create your own APIs to use as connectors in logic apps:</span></span>

* <span data-ttu-id="8b317-108">延伸您目前的系統整合及資料整合工作流程。</span><span class="sxs-lookup"><span data-stu-id="8b317-108">Extend your current system integration and data integration workflows.</span></span>
* <span data-ttu-id="8b317-109">協助客戶使用您的服務來管理專業或個人工作。</span><span class="sxs-lookup"><span data-stu-id="8b317-109">Help customers use your service to manage professional or personal tasks.</span></span>
* <span data-ttu-id="8b317-110">展開您服務的觸達、搜尋功能以及用途。</span><span class="sxs-lookup"><span data-stu-id="8b317-110">Expand the reach, discoverability, and use for your service.</span></span>

<span data-ttu-id="8b317-111">基本上，連接器是使用 REST 作為隨插即用介面、[Swagger 中繼資料格式](http://swagger.io/specification/)作為文件，以及 JSON 作為其資料交換格式的 web API。</span><span class="sxs-lookup"><span data-stu-id="8b317-111">Basically, connectors are web APIs that use REST for pluggable interfaces, [Swagger metadata format](http://swagger.io/specification/) for documentation, and JSON as their data exchange format.</span></span> <span data-ttu-id="8b317-112">因為連接器是透過 HTTP 端點進行通訊的 REST API，您可以使用諸如 .NET、Java 或 Node.js 等任何語言來建置連接器。</span><span class="sxs-lookup"><span data-stu-id="8b317-112">Because connectors are REST APIs that communicate through HTTP endpoints, you can use any language, like .NET, Java, or Node.js, for building connectors.</span></span> <span data-ttu-id="8b317-113">您也可以在 [Azure App Service](../app-service/app-service-value-prop-what-is.md) 上裝載您的 API，Azure App Service 是平台即服務 (PaaS) 供應項目，能為 API 裝載提供最佳、最簡單且擴充性最高的方法。</span><span class="sxs-lookup"><span data-stu-id="8b317-113">You can also host your APIs on [Azure App Service](../app-service/app-service-value-prop-what-is.md), a platform-as-a-service (PaaS) offering that provides one of the best, easiest, and most scalable ways for API hosting.</span></span> 

<span data-ttu-id="8b317-114">若要讓自訂 API 與 Logic Apps 搭配使用，您的 API 可以提供[*動作*](./logic-apps-what-are-logic-apps.md#logic-app-concepts)，能在邏輯應用程式工作流程中執行特定的工作。</span><span class="sxs-lookup"><span data-stu-id="8b317-114">For custom APIs to work with logic apps, your API can provide [*actions*](./logic-apps-what-are-logic-apps.md#logic-app-concepts) that perform specific tasks in logic app workflows.</span></span> <span data-ttu-id="8b317-115">您的 API 也可作為[*觸發程序*](./logic-apps-what-are-logic-apps.md#logic-app-concepts)，當新資料或事件符合指定的條件時，能啟動邏輯應用程式工作流程。</span><span class="sxs-lookup"><span data-stu-id="8b317-115">Your API can also act as a [*trigger*](./logic-apps-what-are-logic-apps.md#logic-app-concepts) that starts a logic app workflow when new data or an event meets a specified condition.</span></span> <span data-ttu-id="8b317-116">本主題描述常見的模式，以您想要 API 提供的行為作為基礎，加以遵循即可在您的 API 中建置動作和觸發程序。</span><span class="sxs-lookup"><span data-stu-id="8b317-116">This topic describes common patterns that you can follow for building actions and triggers in your API, based on the behavior that you want your API to provide.</span></span>

> [!TIP] 
> <span data-ttu-id="8b317-117">雖然您可以將 API 部署為 [web 應用程式](../app-service-web/app-service-web-overview.md)，但請考慮將您的 API 部署為 [API 應用程式](../app-service-api/app-service-api-apps-why-best-platform.md)，如此一來，當您在雲端中及內部部署建置、裝載並自訂 API 時，可讓您的作業更容易。</span><span class="sxs-lookup"><span data-stu-id="8b317-117">Although you can deploy your APIs as [web apps](../app-service-web/app-service-web-overview.md), consider deploying your APIs as [API apps](../app-service-api/app-service-api-apps-why-best-platform.md), which can make your job easier when you build, host, and consume APIs in the cloud and on premises.</span></span> <span data-ttu-id="8b317-118">您不需要在 API 中變更任何程式碼 -- 只需將您的程式碼部署至 API 應用程式。</span><span class="sxs-lookup"><span data-stu-id="8b317-118">You don't have to change any code in your APIs -- just deploy your code to an API app.</span></span> <span data-ttu-id="8b317-119">深入了解如何[建置使用 ASP.NET](../app-service-api/app-service-api-dotnet-get-started.md)、[Java](../app-service-api/app-service-api-java-api-app.md) 或 [Node.js](../app-service-api/app-service-api-nodejs-api-app.md) 建立的 API 應用程式。</span><span class="sxs-lookup"><span data-stu-id="8b317-119">Learn how to [build API apps created with ASP.NET](../app-service-api/app-service-api-dotnet-get-started.md), [Java](../app-service-api/app-service-api-java-api-app.md), or [Node.js](../app-service-api/app-service-api-nodejs-api-app.md).</span></span> 
>
> <span data-ttu-id="8b317-120">如需針對 Logic Apps 建置的 API 應用程式範例，請瀏覽 [Azure Logic Apps GitHub 存放庫](http://github.com/logicappsio)或[部落格](http://aka.ms/logicappsblog)。</span><span class="sxs-lookup"><span data-stu-id="8b317-120">For API App samples built for logic apps, visit the [Azure Logic Apps GitHub repository](http://github.com/logicappsio) or [blog](http://aka.ms/logicappsblog).</span></span>

## <a name="helpful-tools"></a><span data-ttu-id="8b317-121">實用工具</span><span class="sxs-lookup"><span data-stu-id="8b317-121">Helpful tools</span></span>

<span data-ttu-id="8b317-122">當 API 也具有描述 API 作業和參數的 [Swagger 文件](http://swagger.io/specification/)時，自訂 API 最適合與 Logic Apps 搭配使用。</span><span class="sxs-lookup"><span data-stu-id="8b317-122">A custom API works best with logic apps when the API also has a [Swagger document](http://swagger.io/specification/) that describes the API's operations and parameters.</span></span>
<span data-ttu-id="8b317-123">許多程式庫 (例如 [Swashbuckle](https://github.com/domaindrivendev/Swashbuckle)) 可為您自動產生 Swagger 檔案。</span><span class="sxs-lookup"><span data-stu-id="8b317-123">Many libraries, like [Swashbuckle](https://github.com/domaindrivendev/Swashbuckle), can automatically generate the Swagger file for you.</span></span> <span data-ttu-id="8b317-124">若要標註 Swagger 檔案的顯示名稱、屬性類型等等，您也可以使用 [TRex](https://github.com/nihaue/TRex) ，讓您的 Swagger 檔案能適用於 Logic Apps。</span><span class="sxs-lookup"><span data-stu-id="8b317-124">To annotate the Swagger file for display names, property types, and so on, you can also use [TRex](https://github.com/nihaue/TRex) so that your Swagger file works well with logic apps.</span></span>

<a name="actions"></a>

## <a name="action-patterns"></a><span data-ttu-id="8b317-125">動作模式</span><span class="sxs-lookup"><span data-stu-id="8b317-125">Action patterns</span></span>

<span data-ttu-id="8b317-126">針對執行工作的 Logic Apps，您的自訂 API 應提供[*動作*](./logic-apps-what-are-logic-apps.md#logic-app-concepts)。</span><span class="sxs-lookup"><span data-stu-id="8b317-126">For logic apps to perform tasks, your custom API should provide [*actions*](./logic-apps-what-are-logic-apps.md#logic-app-concepts).</span></span> <span data-ttu-id="8b317-127">您 API 中的每項作業都會對應至動作。</span><span class="sxs-lookup"><span data-stu-id="8b317-127">Each operation in your API maps to an action.</span></span> <span data-ttu-id="8b317-128">基本的動作是可接受 HTTP 要求並傳回 HTTP 回應的控制器。</span><span class="sxs-lookup"><span data-stu-id="8b317-128">A basic action is a controller that accepts HTTP requests and returns HTTP responses.</span></span> <span data-ttu-id="8b317-129">比方說，邏輯應用程式會將 HTTP 要求傳送至 web 應用程式或 API 應用程式。</span><span class="sxs-lookup"><span data-stu-id="8b317-129">So for example, a logic app sends an HTTP request to your web app or API app.</span></span> <span data-ttu-id="8b317-130">接著，您的應用程式會傳回 HTTP 回應，以及邏輯應用程式可以處理的內容。</span><span class="sxs-lookup"><span data-stu-id="8b317-130">Your app then returns an HTTP response, along with content that the logic app can process.</span></span>

<span data-ttu-id="8b317-131">針對標準動作，您可以在 API 中撰寫 HTTP 要求方法，並在 Swagger 檔案中描述該方法。</span><span class="sxs-lookup"><span data-stu-id="8b317-131">For a standard action, you can write an HTTP request method in your API and describe that method in a Swagger file.</span></span> <span data-ttu-id="8b317-132">接著，您可以使用 [HTTP 動作](../connectors/connectors-native-http.md)或 [HTTP + Swagger](../connectors/connectors-native-http-swagger.md) 動作直接呼叫您的 API。</span><span class="sxs-lookup"><span data-stu-id="8b317-132">You can then call your API directly with an [HTTP action](../connectors/connectors-native-http.md) or an [HTTP + Swagger](../connectors/connectors-native-http-swagger.md) action.</span></span> <span data-ttu-id="8b317-133">根據預設，必須在[要求逾時限制](./logic-apps-limits-and-config.md)內將回應傳回。</span><span class="sxs-lookup"><span data-stu-id="8b317-133">By default, responses must be returned within the [request timeout limit](./logic-apps-limits-and-config.md).</span></span> 

![標準動作模式](./media/logic-apps-create-api-app/standard-action.png)

<span data-ttu-id="8b317-135"><a name="pattern-overview"></a> 若要讓您的 API 在完成執行時間較長的工作時等候邏輯應用程式，您的 API 可以遵循本主題中所述的[非同步輪詢模式](#async-pattern)或[非同步 webhook 模式](#webhook-actions)。</span><span class="sxs-lookup"><span data-stu-id="8b317-135"><a name="pattern-overview"></a> To make a logic app wait while your API finishes longer-running tasks, your API can follow the [asynchronous polling pattern](#async-pattern) or the [asynchronous webhook pattern](#webhook-actions) described in this topic.</span></span> <span data-ttu-id="8b317-136">如需比喻來協助您以視覺化方式檢視這些模式的不同行為，您可想像從麵包店訂購客製化蛋糕的程序。</span><span class="sxs-lookup"><span data-stu-id="8b317-136">For an analogy that helps you visualize these patterns' different behaviors, imagine the process for ordering a custom cake from a bakery.</span></span> <span data-ttu-id="8b317-137">輪詢模式所鏡像的行為，就如同您每隔 20 分鐘打電話給這家麵包店檢查蛋糕是否就緒。</span><span class="sxs-lookup"><span data-stu-id="8b317-137">The polling pattern mirrors the behavior where you call the bakery every 20 minutes to check whether the cake is ready.</span></span> <span data-ttu-id="8b317-138">Webhook 模式所鏡像的行為，就如同這家麵包店向您要求電話號碼，讓它們可以在蛋糕就緒時打電話給您。</span><span class="sxs-lookup"><span data-stu-id="8b317-138">The webhook pattern mirrors the behavior where the bakery asks you for your phone number so they can call you when the cake is ready.</span></span>

<span data-ttu-id="8b317-139">如需範例，請瀏覽 [Logic Apps GitHub 存放庫](https://github.com/logicappsio)。</span><span class="sxs-lookup"><span data-stu-id="8b317-139">For samples, visit the [Logic Apps GitHub repository](https://github.com/logicappsio).</span></span> <span data-ttu-id="8b317-140">此外，深入了解[動作的使用量計量](logic-apps-pricing.md)。</span><span class="sxs-lookup"><span data-stu-id="8b317-140">Also, learn more about [usage metering for actions](logic-apps-pricing.md).</span></span>

<a name="async-pattern"></a>

### <a name="perform-long-running-tasks-with-the-polling-action-pattern"></a><span data-ttu-id="8b317-141">以輪詢動作模式來執行長時間執行的工作</span><span class="sxs-lookup"><span data-stu-id="8b317-141">Perform long-running tasks with the polling action pattern</span></span>

<span data-ttu-id="8b317-142">若要讓您 API 執行的工作可執行超過[要求逾時限制](./logic-apps-limits-and-config.md)的時間，您可以使用非同步輪詢模式。</span><span class="sxs-lookup"><span data-stu-id="8b317-142">To have your API perform tasks that could run longer than the [request timeout limit](./logic-apps-limits-and-config.md), you can use the asynchronous polling pattern.</span></span> <span data-ttu-id="8b317-143">此模式可讓您的 API 在個別的執行緒中執行工作，但保留作用中連線給 Logic Apps 引擎。</span><span class="sxs-lookup"><span data-stu-id="8b317-143">This pattern has your API do work in a separate thread, but keep an active connection to the Logic Apps engine.</span></span> <span data-ttu-id="8b317-144">這樣一來，邏輯應用程式就不會逾時，或是在您的 API 完成工作之前，繼續工作流程中的下一個步驟。</span><span class="sxs-lookup"><span data-stu-id="8b317-144">That way, the logic app does not time out or continue with the next step in the workflow before your API finishes working.</span></span>

<span data-ttu-id="8b317-145">以下是一般模式：</span><span class="sxs-lookup"><span data-stu-id="8b317-145">Here's the general pattern:</span></span>

1. <span data-ttu-id="8b317-146">請確定引擎知道您的 API 已接受要求並啟動工作。</span><span class="sxs-lookup"><span data-stu-id="8b317-146">Make sure that the engine knows that your API accepted the request and started working.</span></span>
2. <span data-ttu-id="8b317-147">當引擎針對作業狀態提出後續要求時，請讓引擎知道您的 API 何時會完成工作。</span><span class="sxs-lookup"><span data-stu-id="8b317-147">When the engine makes subsequent requests for job status, let the engine know when your API finishes the task.</span></span>
3. <span data-ttu-id="8b317-148">將相關資料傳回引擎，如此邏輯應用程式工作流程才能繼續。</span><span class="sxs-lookup"><span data-stu-id="8b317-148">Return relevant data to the engine so that the logic app workflow can continue.</span></span>

<span data-ttu-id="8b317-149"><a name="bakery-polling-action"></a> 現在，將先前的麵包店比喻套用至輪詢模式，再想像您打電話給這家麵包店並訂購客製化蛋糕要求外送。</span><span class="sxs-lookup"><span data-stu-id="8b317-149"><a name="bakery-polling-action"></a> Now apply the previous bakery analogy to the polling pattern, and imagine that you call a bakery and order a custom cake for delivery.</span></span> <span data-ttu-id="8b317-150">製作蛋糕的程序需要時間，而您不想要在麵包店製作蛋糕時等候電話。</span><span class="sxs-lookup"><span data-stu-id="8b317-150">The process for making the cake takes time, and you don't want to wait on the phone while the bakery works on the cake.</span></span> <span data-ttu-id="8b317-151">這家麵包店確認您的訂單，並要求您每隔 20 分鐘打電話詢問蛋糕的狀態。</span><span class="sxs-lookup"><span data-stu-id="8b317-151">The bakery confirms your order and has you call every 20 minutes for the cake's status.</span></span> <span data-ttu-id="8b317-152">過了 20 分鐘之後，您打電話給麵包店，但它們告訴您蛋糕還沒完成，您要等 20 分鐘後再打電話過來。</span><span class="sxs-lookup"><span data-stu-id="8b317-152">After 20 minutes pass, you call the bakery, but they tell you that your cake isn't done and that you should call in another 20 minutes.</span></span> <span data-ttu-id="8b317-153">這個往來的程序會持續直到您打電話，且這家麵包店告訴您訂單備妥且您的蛋糕送出為止。</span><span class="sxs-lookup"><span data-stu-id="8b317-153">This back-and-forth process continues until you call, and the bakery tells you that your order is ready and delivers your cake.</span></span> 

<span data-ttu-id="8b317-154">現在讓我們來對應回此輪詢模式。</span><span class="sxs-lookup"><span data-stu-id="8b317-154">So let's map this polling pattern back.</span></span> <span data-ttu-id="8b317-155">這家麵包店就代表您的自訂 API，而身為蛋糕客戶的您則代表 Logic Apps 引擎。</span><span class="sxs-lookup"><span data-stu-id="8b317-155">The bakery represents your custom API, while you, the cake customer, represent the Logic Apps engine.</span></span> <span data-ttu-id="8b317-156">當引擎呼叫您的 API 並提出要求時，您的 API 會確認要求，並在時間間隔內回應，讓引擎可以檢查作業狀態。</span><span class="sxs-lookup"><span data-stu-id="8b317-156">When the engine calls your API with a request, your API confirms the request and responds with the time interval when the engine can check job status.</span></span> <span data-ttu-id="8b317-157">引擎會繼續檢查作業狀態，直到您的 API 回應作業已完成，並將資料傳回您的邏輯應用程式，然後會繼續進行工作流程。</span><span class="sxs-lookup"><span data-stu-id="8b317-157">The engine continues checking job status until your API responds that the job is done and returns data to your logic app, which then continues workflow.</span></span> 

![輪詢動作模式](./media/logic-apps-create-api-app/custom-api-async-action-pattern.png)

<span data-ttu-id="8b317-159">以下可供您 API 遵循的特定步驟，是從 API 的觀點加以描述：</span><span class="sxs-lookup"><span data-stu-id="8b317-159">Here are the specific steps for your API to follow, described from the API's perspective:</span></span>

1. <span data-ttu-id="8b317-160">當您的 API 開始進行 HTTP 要求時，立即傳回 HTTP `202 ACCEPTED` 回應，並包含 `location` 此步驟中稍後所述的標頭。</span><span class="sxs-lookup"><span data-stu-id="8b317-160">When your API gets an HTTP request to start work, immediately return an HTTP `202 ACCEPTED` response with the `location` header described later in this step.</span></span> <span data-ttu-id="8b317-161">這個回應可讓 Logic Apps 引擎知道您的 API 已取得要求、接受了要求承載 (資料輸入)，並正在處理中。</span><span class="sxs-lookup"><span data-stu-id="8b317-161">This response lets the Logic Apps engine know that your API got the request, accepted the request payload (data input), and is now processing.</span></span> 
   
   <span data-ttu-id="8b317-162">`202 ACCEPTED` 回應應包含這些標頭：</span><span class="sxs-lookup"><span data-stu-id="8b317-162">The `202 ACCEPTED` response should include these headers:</span></span>
   
   * <span data-ttu-id="8b317-163">必要：`location` 標頭所指定的 URL 絕對路徑，可讓 Logic Apps 引擎在其中檢查您的 API 作業狀態</span><span class="sxs-lookup"><span data-stu-id="8b317-163">*Required*: A `location` header that specifies the absolute path to a URL where the Logic Apps engine can check your API's job status</span></span>

   * <span data-ttu-id="8b317-164">選擇性：`retry-after` 標頭所指定的秒數，是引擎在檢查 `location` URL 以了解作業狀態時所需等候的時間。</span><span class="sxs-lookup"><span data-stu-id="8b317-164">*Optional*: A `retry-after` header that specifies the number of seconds that the engine should wait before checking the `location` URL for job status.</span></span> 

     <span data-ttu-id="8b317-165">根據預設，引擎每隔 20 秒會進行檢查。</span><span class="sxs-lookup"><span data-stu-id="8b317-165">By default, the engine checks every 20 seconds.</span></span> <span data-ttu-id="8b317-166">若要指定不同的間隔，請包括 `retry-after` 標頭，以及下一次輪詢之前的秒數。</span><span class="sxs-lookup"><span data-stu-id="8b317-166">To specify a different interval, include the `retry-after` header and the number of seconds until the next poll.</span></span>

2. <span data-ttu-id="8b317-167">過了指定的時間之後，Logic Apps 引擎會輪詢 `location` URL 來檢查作業狀態。</span><span class="sxs-lookup"><span data-stu-id="8b317-167">After the specified time passes, the Logic Apps engine polls the `location` URL to check job status.</span></span> <span data-ttu-id="8b317-168">您的 API 應執行這些檢查，並傳回這些回應：</span><span class="sxs-lookup"><span data-stu-id="8b317-168">Your API should perform these checks and return these responses:</span></span>
   
   * <span data-ttu-id="8b317-169">如果作業已完成，就會傳回 HTTP `200 OK` 回應，以及回應承載 (下一個步驟的輸入)。</span><span class="sxs-lookup"><span data-stu-id="8b317-169">If the job is done, return an HTTP `200 OK` response, along with the response payload (input for the next step).</span></span>

   * <span data-ttu-id="8b317-170">如果作業仍在處理︰傳回另一個 HTTP `202 ACCEPTED` 回應，並以相同的標頭作為原始回應。</span><span class="sxs-lookup"><span data-stu-id="8b317-170">If the job is still processing, return another HTTP `202 ACCEPTED` response, but with the same headers as the original response.</span></span>

<span data-ttu-id="8b317-171">當您的 API 遵循此模式時，您不需要在邏輯應用程式工作流程定義中採取任何動作，即可繼續檢查作業狀態。</span><span class="sxs-lookup"><span data-stu-id="8b317-171">When your API follows this pattern, you don't have to do anything in the logic app workflow definition to continue checking job status.</span></span> <span data-ttu-id="8b317-172">當引擎取得 HTTP `202 ACCEPTED` 回應及有效 `location` 標頭時，引擎會遵循非同步模式，並檢查 `location` 標頭，直到您的 API 傳回非 202 回應為止。</span><span class="sxs-lookup"><span data-stu-id="8b317-172">When the engine gets an HTTP `202 ACCEPTED` response and a valid `location` header, the engine respects the asynchronous pattern and checks the `location` header until your API returns a non-202 response.</span></span>

> [!TIP]
> <span data-ttu-id="8b317-173">如需非同步模式範例，請檢閱此 [GitHub 中的非同步控制器回應範例](https://github.com/logicappsio/LogicAppsAsyncResponseSample)。</span><span class="sxs-lookup"><span data-stu-id="8b317-173">For an example asynchronous pattern, review this [asynchronous controller response sample in GitHub](https://github.com/logicappsio/LogicAppsAsyncResponseSample).</span></span>

<a name="webhook-actions"></a>

### <a name="perform-long-running-tasks-with-the-webhook-action-pattern"></a><span data-ttu-id="8b317-174">以 Webhook 動作模式來執行長時間執行的工作</span><span class="sxs-lookup"><span data-stu-id="8b317-174">Perform long-running tasks with the webhook action pattern</span></span>

<span data-ttu-id="8b317-175">或者，您可以使用 webhook 模式進行長時間執行的工作和非同步處理。</span><span class="sxs-lookup"><span data-stu-id="8b317-175">As an alternative, you can use the webhook pattern for long-running tasks and asynchronous processing.</span></span> <span data-ttu-id="8b317-176">此模式具有邏輯應用程式暫停，並等候來自您 API 的「回呼」完成處理後，才會繼續工作流程。</span><span class="sxs-lookup"><span data-stu-id="8b317-176">This pattern has the logic app pause and wait for a "callback" from your API to finish processing before continuing workflow.</span></span> <span data-ttu-id="8b317-177">此回呼是 HTTP POST，在事件發生時，會將訊息傳送到 URL。</span><span class="sxs-lookup"><span data-stu-id="8b317-177">This callback is an HTTP POST that sends a message to a URL when an event happens.</span></span> 

<span data-ttu-id="8b317-178"><a name="bakery-webhook-action"></a> 現在，將先前的麵包店比喻套用至 Webhook 模式，再想像您打電話給這家麵包店並訂購客製化蛋糕要求外送。</span><span class="sxs-lookup"><span data-stu-id="8b317-178"><a name="bakery-webhook-action"></a> Now apply the previous bakery analogy to the webhook pattern, and imagine that you call a bakery and order a custom cake for delivery.</span></span> <span data-ttu-id="8b317-179">製作蛋糕的程序需要時間，而您不想要在麵包店製作蛋糕時等候電話。</span><span class="sxs-lookup"><span data-stu-id="8b317-179">The process for making the cake takes time, and you don't want to wait on the phone while the bakery works on the cake.</span></span> <span data-ttu-id="8b317-180">這家麵包店確認了您的訂單，但這次，您向它們提供您的電話號碼，讓它們在蛋糕完成時可以打電話給您。</span><span class="sxs-lookup"><span data-stu-id="8b317-180">The bakery confirms your order, but this time, you give them your phone number so they can call you when the cake is done.</span></span> <span data-ttu-id="8b317-181">此時，這家麵包店告訴您訂單已就緒，並送出您的蛋糕。</span><span class="sxs-lookup"><span data-stu-id="8b317-181">This time, the bakery tells you when your order is ready and delivers your cake.</span></span>

<span data-ttu-id="8b317-182">當我們對應回此 webhook 模式時，這家麵包店就代表您的自訂 API，而身為蛋糕客戶的您則代表 Logic Apps 引擎。</span><span class="sxs-lookup"><span data-stu-id="8b317-182">When we map this webhook pattern back, the bakery represents your custom API, while you, the cake customer, represent the Logic Apps engine.</span></span> <span data-ttu-id="8b317-183">引擎會使用要求呼叫您的 API，並包含「回呼」URL。</span><span class="sxs-lookup"><span data-stu-id="8b317-183">The engine calls your API with a request and includes a "callback" URL.</span></span>
<span data-ttu-id="8b317-184">當作業完成時，您的 API 會使用此 URL 來通知引擎，並將資料傳回給您的邏輯應用程式，然後繼續進行工作流程。</span><span class="sxs-lookup"><span data-stu-id="8b317-184">When the job is done, your API uses the URL to notify the engine and return data to your logic app, which then continues workflow.</span></span> 

<span data-ttu-id="8b317-185">對於此模式，設定您控制器上的兩個端點：`subscribe` 和 `unsubscribe`</span><span class="sxs-lookup"><span data-stu-id="8b317-185">For this pattern, set up two endpoints on your controller: `subscribe` and `unsubscribe`</span></span>

*  <span data-ttu-id="8b317-186">`subscribe` 端點：當執行在工作流程中觸達您 API 的動作時，Logic Apps 引擎會呼叫 `subscribe` 端點。</span><span class="sxs-lookup"><span data-stu-id="8b317-186">`subscribe` endpoint: When execution reaches your API's action in the workflow, the Logic Apps engine calls the `subscribe` endpoint.</span></span> <span data-ttu-id="8b317-187">這個步驟會導致邏輯應用程式建立您的 API 所儲存之回呼 URL，然後在工作完成時，等候您 API 所發出的回呼。</span><span class="sxs-lookup"><span data-stu-id="8b317-187">This step causes the logic app to create a callback URL that your API stores and then wait for the callback from your API when work is complete.</span></span> <span data-ttu-id="8b317-188">接著，您的 API 會使用 HTTP POST 回呼 URL，並傳遞任何傳回的內容和標頭來作為邏輯應用程式的輸入。</span><span class="sxs-lookup"><span data-stu-id="8b317-188">Your API then calls back with an HTTP POST to the URL and passes any returned content and headers as input to the logic app.</span></span>

* <span data-ttu-id="8b317-189">`unsubscribe` 端點：如果取消邏輯應用程式執行，Logic Apps 引擎就會呼叫 `unsubscribe` 端點。</span><span class="sxs-lookup"><span data-stu-id="8b317-189">`unsubscribe` endpoint: If the logic app run is canceled, the Logic Apps engine calls the `unsubscribe` endpoint.</span></span> <span data-ttu-id="8b317-190">接著，您的 API 就可以取消註冊回呼 URL，並視需要停止任何處理程序。</span><span class="sxs-lookup"><span data-stu-id="8b317-190">Your API can then unregister the callback URL and stop any processes as necessary.</span></span>

![Webhook 動作模式](./media/logic-apps-create-api-app/custom-api-webhook-action-pattern.png)

> [!NOTE]
> <span data-ttu-id="8b317-192">目前，Logic App Designer 並不支援透過 Swagger 探索 webhook 端點。</span><span class="sxs-lookup"><span data-stu-id="8b317-192">Currently, the Logic App Designer doesn't support discovering webhook endpoints through Swagger.</span></span> <span data-ttu-id="8b317-193">因此對於此模式，您必須新增 [**Webhook** 動作](../connectors/connectors-native-webhook.md)並指定 URL、標頭，以及您的要求主體。</span><span class="sxs-lookup"><span data-stu-id="8b317-193">So for this pattern, you have to add a [**Webhook** action](../connectors/connectors-native-webhook.md) and specify the URL, headers, and body for your request.</span></span> <span data-ttu-id="8b317-194">另請參閱[工作流程動作與觸發程序](logic-apps-workflow-actions-triggers.md#api-connection-webhook-action)。</span><span class="sxs-lookup"><span data-stu-id="8b317-194">See also [Workflow actions and triggers](logic-apps-workflow-actions-triggers.md#api-connection-webhook-action).</span></span> <span data-ttu-id="8b317-195">若要傳入回呼 URL，您可以視需要在任何一個先前的欄位中使用 `@listCallbackUrl()` 工作流程函式。</span><span class="sxs-lookup"><span data-stu-id="8b317-195">To pass in the callback URL, you can use the `@listCallbackUrl()` workflow function in any of the previous fields as necessary.</span></span>

> [!TIP]
> <span data-ttu-id="8b317-196">如需範例 webhook 模式，請檢閱此 [GitHub 中的 webhook 觸發程序範例](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs)。</span><span class="sxs-lookup"><span data-stu-id="8b317-196">For an example webhook pattern, review this [webhook trigger sample in GitHub](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs).</span></span>

<a name="triggers"></a>

## <a name="trigger-patterns"></a><span data-ttu-id="8b317-197">觸發程序模式</span><span class="sxs-lookup"><span data-stu-id="8b317-197">Trigger patterns</span></span>

<span data-ttu-id="8b317-198">您的自訂 API 可作為[*觸發程序*](./logic-apps-what-are-logic-apps.md#logic-app-concepts)，當新資料或事件符合指定的條件時，能啟動邏輯應用程式。</span><span class="sxs-lookup"><span data-stu-id="8b317-198">Your custom API can act as a [*trigger*](./logic-apps-what-are-logic-apps.md#logic-app-concepts) that starts a logic app when new data or an event meets a specified condition.</span></span> <span data-ttu-id="8b317-199">這個觸發程序可以定期檢查，或是等候並接聽您服務端點上的新資料或事件。</span><span class="sxs-lookup"><span data-stu-id="8b317-199">This trigger can either check regularly, or wait and listen, for new data or events at your service endpoint.</span></span> <span data-ttu-id="8b317-200">如果新的資料或事件符合指定的條件，觸發程序就會引發，並啟動邏輯應用程式，用來接聽該觸發程序。</span><span class="sxs-lookup"><span data-stu-id="8b317-200">If new data or an event meets the specified condition, the trigger fires and starts the logic app, which is listening to that trigger.</span></span> <span data-ttu-id="8b317-201">若要用這種方式啟動 Logic Apps，您的 API 可以遵循[*輪詢觸發程序*](#polling-triggers)或 [ *webhook 觸發程序*](#webhook-triggers)模式。</span><span class="sxs-lookup"><span data-stu-id="8b317-201">To start logic apps this way, your API can follow the [*polling trigger*](#polling-triggers) or the [*webhook trigger*](#webhook-triggers) pattern.</span></span> <span data-ttu-id="8b317-202">這些模式會與其[輪詢動作](#async-pattern)和 [webhook 動作](#webhook-actions)的對應類似。</span><span class="sxs-lookup"><span data-stu-id="8b317-202">These patterns are similar to their counterparts for [polling actions](#async-pattern) and [webhook actions](#webhook-actions).</span></span> <span data-ttu-id="8b317-203">此外，深入了解[觸發程序的使用量計量](logic-apps-pricing.md)。</span><span class="sxs-lookup"><span data-stu-id="8b317-203">Also, learn more about [usage metering for triggers](logic-apps-pricing.md).</span></span>

<a name="polling-triggers"></a>

### <a name="check-for-new-data-or-events-regularly-with-the-polling-trigger-pattern"></a><span data-ttu-id="8b317-204">使用輪詢觸發程序模式定期檢查新的資料或事件</span><span class="sxs-lookup"><span data-stu-id="8b317-204">Check for new data or events regularly with the polling trigger pattern</span></span>

<span data-ttu-id="8b317-205">輪詢觸發程序作用很像本主題先前所述的[輪詢動作](#async-pattern)。</span><span class="sxs-lookup"><span data-stu-id="8b317-205">A *polling trigger* acts much like the [polling action](#async-pattern) previously described in this topic.</span></span> <span data-ttu-id="8b317-206">Logic Apps 引擎會定期呼叫並檢查新的資料或事件，以查看觸發程序端點。</span><span class="sxs-lookup"><span data-stu-id="8b317-206">The Logic Apps engine periodically calls and checks the trigger endpoint for new data or events.</span></span> <span data-ttu-id="8b317-207">如果引擎發現符合您指定條件的新資料或事件，就會引發觸發程序。</span><span class="sxs-lookup"><span data-stu-id="8b317-207">If the engine finds new data or an event that meets your specified condition, the trigger fires.</span></span> <span data-ttu-id="8b317-208">然後，引擎會建立處理資料的邏輯應用程式執行個體作為輸入。</span><span class="sxs-lookup"><span data-stu-id="8b317-208">Then, the engine creates a logic app instance that processes the data as input.</span></span> 

![輪詢觸發程序](./media/logic-apps-create-api-app/custom-api-polling-trigger-pattern.png)

> [!NOTE]
> <span data-ttu-id="8b317-210">每個輪詢要求都會計算為動作執行，即使未建立邏輯應用程式執行個體時亦然。</span><span class="sxs-lookup"><span data-stu-id="8b317-210">Each polling request counts as an action execution, even when no logic app instance is created.</span></span> <span data-ttu-id="8b317-211">若要避免多次處理相同的資料，您的觸發程序應該將已讀取並傳遞至邏輯應用程式的資料清除。</span><span class="sxs-lookup"><span data-stu-id="8b317-211">To prevent processing the same data multiple times, your trigger should clean up data that was already read and passed to the logic app.</span></span>

<span data-ttu-id="8b317-212">以下適用於輪詢觸發程序的特定步驟，是從 API 的觀點加以描述：</span><span class="sxs-lookup"><span data-stu-id="8b317-212">Here are specific steps for a polling trigger, described from the API's perspective:</span></span>

| <span data-ttu-id="8b317-213">找到新資料或事件了嗎？</span><span class="sxs-lookup"><span data-stu-id="8b317-213">Found new data or event?</span></span>  | <span data-ttu-id="8b317-214">API 回應</span><span class="sxs-lookup"><span data-stu-id="8b317-214">API response</span></span> | 
| ------------------------- | ------------ |
| <span data-ttu-id="8b317-215">已找到</span><span class="sxs-lookup"><span data-stu-id="8b317-215">Found</span></span> | <span data-ttu-id="8b317-216">傳回包含回應承載的 HTTP `200 OK` 狀態 (下一個步驟的輸入)。</span><span class="sxs-lookup"><span data-stu-id="8b317-216">Return an HTTP `200 OK` status with the response payload (input for next step).</span></span> <br/><span data-ttu-id="8b317-217">此回應會建立邏輯應用程式執行個體，並啟動工作流程。</span><span class="sxs-lookup"><span data-stu-id="8b317-217">This response creates a logic app instance and starts the workflow.</span></span> |
| <span data-ttu-id="8b317-218">找不到</span><span class="sxs-lookup"><span data-stu-id="8b317-218">Not found</span></span> | <span data-ttu-id="8b317-219">傳回包含 `location` 標頭和 `retry-after` 標頭的 HTTP`202 ACCEPTED` 狀態。</span><span class="sxs-lookup"><span data-stu-id="8b317-219">Return an HTTP `202 ACCEPTED` status with a `location` header and a `retry-after` header.</span></span> <br/><span data-ttu-id="8b317-220">針對觸發程序，`location` 標頭也應該包含 `triggerState` 查詢參數，通常是「時間戳記」。</span><span class="sxs-lookup"><span data-stu-id="8b317-220">For triggers, the `location` header should also contain a `triggerState` query parameter, which is usually a "timestamp."</span></span> <span data-ttu-id="8b317-221">您的 API 可以利用這個識別碼，來追蹤邏輯應用程式所觸發的最後時間。</span><span class="sxs-lookup"><span data-stu-id="8b317-221">Your API can use this identifier to track the last time that the logic app was triggered.</span></span> |

<span data-ttu-id="8b317-222">例如，定期檢查您的服務是否有新檔案，您可能會建立具有這些行為的輪詢觸發程序：</span><span class="sxs-lookup"><span data-stu-id="8b317-222">For example, to periodically check your service for new files, you might build a polling trigger that has these behaviors:</span></span>

| <span data-ttu-id="8b317-223">要求是否包含 `triggerState`？</span><span class="sxs-lookup"><span data-stu-id="8b317-223">Request includes `triggerState`?</span></span> | <span data-ttu-id="8b317-224">API 回應</span><span class="sxs-lookup"><span data-stu-id="8b317-224">API response</span></span> |
| -------------------------------- | -------------|
| <span data-ttu-id="8b317-225">否</span><span class="sxs-lookup"><span data-stu-id="8b317-225">No</span></span> | <span data-ttu-id="8b317-226">傳回 HTTP `202 ACCEPTED` 狀態與 `location` 標頭，並將 `triggerState` 設為目前的時間，且 `retry-after` 間隔設為 15 秒。</span><span class="sxs-lookup"><span data-stu-id="8b317-226">Return an HTTP `202 ACCEPTED` status plus a `location` header with `triggerState` set to the current time and the `retry-after` interval to 15 seconds.</span></span> |
| <span data-ttu-id="8b317-227">是</span><span class="sxs-lookup"><span data-stu-id="8b317-227">Yes</span></span> | <span data-ttu-id="8b317-228">請檢查您的服務是否有 `triggerState` 的 `DateTime` 之後新增的檔案。</span><span class="sxs-lookup"><span data-stu-id="8b317-228">Check your service for files added after the `DateTime` for `triggerState`.</span></span> |

| <span data-ttu-id="8b317-229">找到的檔案數</span><span class="sxs-lookup"><span data-stu-id="8b317-229">Number of files found</span></span> | <span data-ttu-id="8b317-230">API 回應</span><span class="sxs-lookup"><span data-stu-id="8b317-230">API response</span></span> |
| --------------------- | -------------|
| <span data-ttu-id="8b317-231">單一檔案</span><span class="sxs-lookup"><span data-stu-id="8b317-231">Single file</span></span> | <span data-ttu-id="8b317-232">傳回 HTTP `200 OK` 狀態和內容承載、將傳回檔案的 `triggerState` 更新為 `DateTime`，並將 `retry-after` 間隔設定為 15 秒。</span><span class="sxs-lookup"><span data-stu-id="8b317-232">Return an HTTP `200 OK` status and the content payload, update `triggerState` to the `DateTime` for the returned file, and set `retry-after` interval to 15 seconds.</span></span> |
| <span data-ttu-id="8b317-233">多個檔案</span><span class="sxs-lookup"><span data-stu-id="8b317-233">Multiple files</span></span> | <span data-ttu-id="8b317-234">一次傳回一個檔案與 HTTP `200 OK` 狀態、更新 `triggerState`，並將 `retry-after` 間隔設定為 0 秒。</span><span class="sxs-lookup"><span data-stu-id="8b317-234">Return one file at a time and an HTTP `200 OK` status, update `triggerState`, and set the `retry-after` interval to 0 seconds.</span></span> </br><span data-ttu-id="8b317-235">這些步驟會讓引擎知道有更多資料可用，以及引擎應立即從 `location` 標頭中的 URL 要求資料。</span><span class="sxs-lookup"><span data-stu-id="8b317-235">These steps let the engine know that more data is available, and that the engine should immediately request the data from the URL in the `location` header.</span></span> |
| <span data-ttu-id="8b317-236">沒有任何檔案</span><span class="sxs-lookup"><span data-stu-id="8b317-236">No files</span></span> | <span data-ttu-id="8b317-237">傳回 HTTP `202 ACCEPTED` 狀態、不要變更 `triggerState`，並將 `retry-after` 間隔設定為 15 秒。</span><span class="sxs-lookup"><span data-stu-id="8b317-237">Return an HTTP `202 ACCEPTED` status, don't change `triggerState`, and set the `retry-after` interval to 15 seconds.</span></span> |

> [!TIP]
> <span data-ttu-id="8b317-238">如需範例輪詢觸發程序模式，請檢閱此 [GitHub 中的輪詢觸發程序控制器範例](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/PollTriggerController.cs)。</span><span class="sxs-lookup"><span data-stu-id="8b317-238">For an example polling trigger pattern, review this [poll trigger controller sample in GitHub](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/PollTriggerController.cs).</span></span>

<a name="webhook-triggers"></a>

### <a name="wait-and-listen-for-new-data-or-events-with-the-webhook-trigger-pattern"></a><span data-ttu-id="8b317-239">等候並接聽使用 webhook 觸發程序模式的新資料或事件</span><span class="sxs-lookup"><span data-stu-id="8b317-239">Wait and listen for new data or events with the webhook trigger pattern</span></span>

<span data-ttu-id="8b317-240">Webhook 觸發程序是推送觸發程序，會等候並接聽您服務端點中的新資料或事件。</span><span class="sxs-lookup"><span data-stu-id="8b317-240">A webhook trigger is a *push trigger* that waits and listens for new data or events at your service endpoint.</span></span> <span data-ttu-id="8b317-241">如果新的資料或事件符合指定的條件，觸發程序就會引發，並建立邏輯應用程式執行個體，然後處理資料作為輸入。</span><span class="sxs-lookup"><span data-stu-id="8b317-241">If new data or an event meets the specified condition, the trigger fires and creates a logic app instance, which then processes the data as input.</span></span>
<span data-ttu-id="8b317-242">Webhook 觸發程序作用很像本主題之前所述的 [webhook 動作](#webhook-actions)，並使用 `subscribe` 和 `unsubscribe` 端點加以設定。</span><span class="sxs-lookup"><span data-stu-id="8b317-242">Webhook triggers act much like the [webhook actions](#webhook-actions) previously described in this topic, and are set up with `subscribe` and `unsubscribe` endpoints.</span></span> 

* <span data-ttu-id="8b317-243">`subscribe` 端點：當您在邏輯應用程式中新增及儲存 webhook 觸發程序時，Logic Apps 引擎會呼叫 `subscribe` 端點。</span><span class="sxs-lookup"><span data-stu-id="8b317-243">`subscribe` endpoint: When you add and save a webhook trigger in your logic app, the Logic Apps engine calls the `subscribe` endpoint.</span></span> <span data-ttu-id="8b317-244">這個步驟會導致邏輯應用程式建立您 API 所儲存的回呼 URL。</span><span class="sxs-lookup"><span data-stu-id="8b317-244">This step causes the logic app to create a callback URL that your API stores.</span></span> <span data-ttu-id="8b317-245">當沒有新的資料或事件符合指定的條件時，您的 API 會使用 HTTP POST 回呼 URL。</span><span class="sxs-lookup"><span data-stu-id="8b317-245">When there's new data or an event that meets the specified condition, your API calls back with an HTTP POST to the URL.</span></span> <span data-ttu-id="8b317-246">內容承載和標頭會作為輸入傳遞至邏輯應用程式。</span><span class="sxs-lookup"><span data-stu-id="8b317-246">The content payload and headers pass as input to the logic app.</span></span>

* <span data-ttu-id="8b317-247">`unsubscribe` 端點：如果將 webhook 觸發程序或整個邏輯應用程式刪除時，Logic Apps 引擎會呼叫 `unsubscribe` 端點。</span><span class="sxs-lookup"><span data-stu-id="8b317-247">`unsubscribe` endpoint: If the webhook trigger or entire logic app is deleted, the Logic Apps engine calls the `unsubscribe` endpoint.</span></span> <span data-ttu-id="8b317-248">接著，您的 API 就可以取消註冊回呼 URL，並視需要停止任何處理程序。</span><span class="sxs-lookup"><span data-stu-id="8b317-248">Your API can then unregister the callback URL and stop any processes as necessary.</span></span>

![Webhook 觸發程序](./media/logic-apps-create-api-app/custom-api-webhook-trigger-pattern.png)

> [!NOTE]
> <span data-ttu-id="8b317-250">目前，Logic App Designer 並不支援透過 Swagger 探索 webhook 端點。</span><span class="sxs-lookup"><span data-stu-id="8b317-250">Currently, the Logic App Designer doesn't support discovering webhook endpoints through Swagger.</span></span> <span data-ttu-id="8b317-251">因此對於此模式，您必須新增 [**Webhook** 觸發程序](../connectors/connectors-native-webhook.md)並指定 URL、標頭，以及您的要求主體。</span><span class="sxs-lookup"><span data-stu-id="8b317-251">So for this pattern, you have to add a [**Webhook** trigger](../connectors/connectors-native-webhook.md) and specify the URL, headers, and body for your request.</span></span> <span data-ttu-id="8b317-252">另請參閱 [HTTPWebhook 觸發程序](logic-apps-workflow-actions-triggers.md#httpwebhook-trigger)。</span><span class="sxs-lookup"><span data-stu-id="8b317-252">See also [HTTPWebhook trigger](logic-apps-workflow-actions-triggers.md#httpwebhook-trigger).</span></span> <span data-ttu-id="8b317-253">若要傳入回呼 URL，您可以視需要在任何一個先前的欄位中使用 `@listCallbackUrl()` 工作流程函式。</span><span class="sxs-lookup"><span data-stu-id="8b317-253">To pass in the callback URL, you can use the `@listCallbackUrl()` workflow function in any of the previous fields as necessary.</span></span>
>
> <span data-ttu-id="8b317-254">若要避免多次處理相同的資料，您的觸發程序應該將已讀取並傳遞至邏輯應用程式的資料清除。</span><span class="sxs-lookup"><span data-stu-id="8b317-254">To prevent processing the same data multiple times, your trigger should clean up data that was already read and passed to the logic app.</span></span>

> [!TIP]
> <span data-ttu-id="8b317-255">如需範例 webhook 模式，請檢閱此 [GitHub 中的 webhook 觸發程序控制器範例](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs)。</span><span class="sxs-lookup"><span data-stu-id="8b317-255">For an example webhook pattern, review this [webhook trigger controller sample in GitHub](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs).</span></span>

## <a name="deploy-call-and-secure-custom-apis"></a><span data-ttu-id="8b317-256">部署、呼叫並保護自訂 API</span><span class="sxs-lookup"><span data-stu-id="8b317-256">Deploy, call, and secure custom APIs</span></span>

<span data-ttu-id="8b317-257">建立您的自訂 API 之後，請設定您的 API 以進行部署，讓您可安全地呼叫它們。</span><span class="sxs-lookup"><span data-stu-id="8b317-257">After creating your custom APIs, set up your APIs for deployment so you can call them securely.</span></span> <span data-ttu-id="8b317-258">深入了解如何[部署、呼叫，保護 Logic Apps 的自訂 API](./logic-apps-custom-hosted-api.md)。</span><span class="sxs-lookup"><span data-stu-id="8b317-258">Learn how to [deploy, call, and secure custom APIs for logic apps](./logic-apps-custom-hosted-api.md).</span></span>

## <a name="publish-custom-apis-to-azure"></a><span data-ttu-id="8b317-259">將自訂 API 發佈至 Azure</span><span class="sxs-lookup"><span data-stu-id="8b317-259">Publish custom APIs to Azure</span></span>

<span data-ttu-id="8b317-260">若要讓您的自訂 API 能夠在 Azure 中公開使用，請將您的提名提交至 [Microsoft Azure 認證計畫](https://azure.microsoft.com/marketplace/programs/certified/logic-apps/)。</span><span class="sxs-lookup"><span data-stu-id="8b317-260">To make your custom APIs available for public use in Azure, submit your nominations to the [Microsoft Azure Certified program](https://azure.microsoft.com/marketplace/programs/certified/logic-apps/).</span></span>

## <a name="get-help"></a><span data-ttu-id="8b317-261">取得說明</span><span class="sxs-lookup"><span data-stu-id="8b317-261">Get help</span></span>

<span data-ttu-id="8b317-262">如需自訂 API 的特定說明，請連絡 [customapishelp@microsoft.com](mailto:customapishelp@microsoft.com)。</span><span class="sxs-lookup"><span data-stu-id="8b317-262">For specific help with custom APIs, contact [customapishelp@microsoft.com](mailto:customapishelp@microsoft.com).</span></span>

<span data-ttu-id="8b317-263">若要提出問題、回答問題以及查看其他 Azure Logic Apps 使用者的做法，請造訪 [Azure Logic Apps 論壇](https://social.msdn.microsoft.com/Forums/en-US/home?forum=azurelogicapps)。</span><span class="sxs-lookup"><span data-stu-id="8b317-263">To ask questions, answer questions, and see what other Azure Logic Apps users are doing, visit the [Azure Logic Apps forum](https://social.msdn.microsoft.com/Forums/en-US/home?forum=azurelogicapps).</span></span>

<span data-ttu-id="8b317-264">若要改善 Logic Apps 和連接器，請在 [Logic Apps 使用者意見反應網站](http://aka.ms/logicapps-wish)上票選或提交想法。</span><span class="sxs-lookup"><span data-stu-id="8b317-264">To help improve Logic Apps and connectors, vote on or submit ideas at the [Logic Apps user feedback site](http://aka.ms/logicapps-wish).</span></span> 

## <a name="next-steps"></a><span data-ttu-id="8b317-265">後續步驟</span><span class="sxs-lookup"><span data-stu-id="8b317-265">Next steps</span></span>

* [<span data-ttu-id="8b317-266">動作和觸發程序的使用量計量</span><span class="sxs-lookup"><span data-stu-id="8b317-266">Usage metering for actions and triggers</span></span>](logic-apps-pricing.md)
* [<span data-ttu-id="8b317-267">處理內容類型</span><span class="sxs-lookup"><span data-stu-id="8b317-267">Handle content types</span></span>](./logic-apps-content-type.md)
* [<span data-ttu-id="8b317-268">處理錯誤和例外狀況</span><span class="sxs-lookup"><span data-stu-id="8b317-268">Handle errors and exceptions</span></span>](./logic-apps-exception-handling.md)
* [<span data-ttu-id="8b317-269">安全存取您的 Logic Apps</span><span class="sxs-lookup"><span data-stu-id="8b317-269">Secure access to your logic apps</span></span>](./logic-apps-securing-a-logic-app.md)
* [<span data-ttu-id="8b317-270">透過 HTTP 端點呼叫、觸發或巢狀處理 Logic Apps</span><span class="sxs-lookup"><span data-stu-id="8b317-270">Call, trigger, or nest logic apps with HTTP endpoints</span></span>](./logic-apps-http-endpoint.md)