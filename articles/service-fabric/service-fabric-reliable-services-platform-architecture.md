---
title: "Reliable Services 架構 | Microsoft Docs"
description: "具狀態與無狀態之 Reliable Services 架構概觀"
services: service-fabric
documentationcenter: .net
author: AlanWarwick
manager: timlt
editor: vturecek
ms.assetid: af002ae6-7f6d-4769-b049-82aa1ba0891b
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 03/30/2016
ms.author: alanwar
redirect_url: /azure/service-fabric/service-fabric-reliable-services-introduction
ms.openlocfilehash: a00a16945356b9731485554e06df46528b5c7bb2
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="architecture-for-stateful-and-stateless-reliable-services"></a><span data-ttu-id="d591a-103">具狀態與無狀態 Reliable Services 的架構</span><span class="sxs-lookup"><span data-stu-id="d591a-103">Architecture for stateful and stateless Reliable Services</span></span>
<span data-ttu-id="d591a-104">Azure Service Fabric 可靠服務可能是具狀態或無狀態。</span><span class="sxs-lookup"><span data-stu-id="d591a-104">An Azure Service Fabric Reliable Service may be stateful or stateless.</span></span> <span data-ttu-id="d591a-105">每一種服務都在特定架構內執行。</span><span class="sxs-lookup"><span data-stu-id="d591a-105">Each type of service runs within a specific architecture.</span></span> <span data-ttu-id="d591a-106">本文將會說明這些架構。</span><span class="sxs-lookup"><span data-stu-id="d591a-106">These architectures are described in this article.</span></span>
<span data-ttu-id="d591a-107">請參閱 [Reliable Services 概觀](service-fabric-reliable-services-introduction.md) ，以取得具狀態與無狀態服務之間差異的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="d591a-107">See the [Reliable Service overview](service-fabric-reliable-services-introduction.md) for more information about the differences between stateful and stateless services.</span></span>

## <a name="stateful-reliable-services"></a><span data-ttu-id="d591a-108">具狀態可靠的服務</span><span class="sxs-lookup"><span data-stu-id="d591a-108">Stateful Reliable Services</span></span>
### <a name="architecture-of-a-stateful-service"></a><span data-ttu-id="d591a-109">具狀態服務的架構</span><span class="sxs-lookup"><span data-stu-id="d591a-109">Architecture of a stateful service</span></span>
![具狀態服務的架構圖](./media/service-fabric-reliable-services-platform-architecture/reliable-stateful-service-architecture.png)

### <a name="stateful-reliable-service"></a><span data-ttu-id="d591a-111">具狀態可靠的服務</span><span class="sxs-lookup"><span data-stu-id="d591a-111">Stateful Reliable Service</span></span>
<span data-ttu-id="d591a-112">具狀態可靠的服務可以從 StatefulService 或 StatefulServiceBase 類別衍生。</span><span class="sxs-lookup"><span data-stu-id="d591a-112">A stateful Reliable Service can derive from either the StatefulService or StatefulServiceBase class.</span></span> <span data-ttu-id="d591a-113">這兩個基底類別都由 Service Fabric 所提供。</span><span class="sxs-lookup"><span data-stu-id="d591a-113">Both of these base classes are provided by Service Fabric.</span></span> <span data-ttu-id="d591a-114">這兩個基底類別可為具狀態服務提供各種支援和抽象層級以便與 Service Fabric 互動，以及做為 Service Fabric 叢集內的服務參與。</span><span class="sxs-lookup"><span data-stu-id="d591a-114">They offer various levels of support and abstraction for the stateful service to interface with Service Fabric--and to participate as a service within the Service Fabric cluster.</span></span>

<span data-ttu-id="d591a-115">StatefulService 衍生自 StatefulServiceBase。</span><span class="sxs-lookup"><span data-stu-id="d591a-115">StatefulService derives from StatefulServiceBase.</span></span> <span data-ttu-id="d591a-116">StatefulServiceBase 提供服務更多的彈性，但需要對 Service Fabric 內部運作有更多了解。</span><span class="sxs-lookup"><span data-stu-id="d591a-116">StatefulServiceBase offers services more flexibility, but requires more understanding of the internals of Service Fabric.</span></span>
<span data-ttu-id="d591a-117">請參閱 [Reliable Services 概觀](service-fabric-reliable-services-introduction.md)和 [Reliable Services 進階用法](service-fabric-reliable-services-advanced-usage.md)，以取得使用 StatefulService 和 StatefulServiceBase 類別撰寫服務細節的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="d591a-117">See the [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on the specifics of writing services by using the StatefulService and StatefulServiceBase classes.</span></span>

<span data-ttu-id="d591a-118">這兩個基底類別會管理服務實作的存留期和角色。</span><span class="sxs-lookup"><span data-stu-id="d591a-118">Both base classes manage the lifetime and role of the service implementation.</span></span> <span data-ttu-id="d591a-119">如果服務實作在服務實作生命週期中的那些點有工作要執行，或是想要建立通訊接聽程式物件，服務實作可能會覆寫任一基底類別的虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="d591a-119">The service implementation may override virtual methods of either base class if the service implementation has work to do at those points in the service implementation lifecycle--or if it wants to create a communication listener object.</span></span> <span data-ttu-id="d591a-120">請注意雖然服務實作可能會實作自己的通訊接聽程式物件並公開 ICommunicationListener，在上圖中，通訊接聽程式由 Service Fabric 實作，因為服務實作使用 Service Fabric 所實作的通訊接聽程式。</span><span class="sxs-lookup"><span data-stu-id="d591a-120">Note that although a service implementation may implement its own communication listener object exposing ICommunicationListener, in the diagram above, the communication listener is implemented by Service Fabric--as the service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="d591a-121">具狀態可靠的服務會使用可靠的狀態管理員來利用可靠的集合。</span><span class="sxs-lookup"><span data-stu-id="d591a-121">A stateful Reliable Service uses the reliable state manager to take advantage of reliable collections.</span></span> <span data-ttu-id="d591a-122">可靠的集合是對服務而言高度可用的本機資料結構，也就是，不論服務容錯移轉，一律可以使用。</span><span class="sxs-lookup"><span data-stu-id="d591a-122">Reliable collections are local data structures that are highly available to the service--that is, they are always available, regardless of service failovers.</span></span> <span data-ttu-id="d591a-123">可靠的集合的每個類型是由可靠的狀態提供者所實作。</span><span class="sxs-lookup"><span data-stu-id="d591a-123">Each type of reliable collection is implemented by a reliable state provider.</span></span>
<span data-ttu-id="d591a-124">如需可靠的集合的詳細資訊，請參閱 [可靠的集合概觀](service-fabric-reliable-services-reliable-collections.md)</span><span class="sxs-lookup"><span data-stu-id="d591a-124">For more information on reliable collections, see the [reliable collections overview](service-fabric-reliable-services-reliable-collections.md).</span></span>

### <a name="reliable-state-manager-and-state-providers"></a><span data-ttu-id="d591a-125">可靠的狀態管理員和狀態提供者</span><span class="sxs-lookup"><span data-stu-id="d591a-125">Reliable state manager and state providers</span></span>
<span data-ttu-id="d591a-126">可靠的狀態管理員是用以管理可靠的狀態提供者的物件。</span><span class="sxs-lookup"><span data-stu-id="d591a-126">The reliable state manager is the object that manages reliable state providers.</span></span> <span data-ttu-id="d591a-127">它具有建立、刪除、列舉和確保可靠的狀態提供者持續保存且高度可用的功能。</span><span class="sxs-lookup"><span data-stu-id="d591a-127">It has the functionality to create, delete, enumerate, and ensure that the reliable state providers are persisted and highly available.</span></span> <span data-ttu-id="d591a-128">可靠的狀態提供者執行個體代表持續保存且高度可用之資料結構的執行個體，例如字典或佇列。</span><span class="sxs-lookup"><span data-stu-id="d591a-128">A reliable state provider instance represents an instance of a persisted and highly available data structure, such as a dictionary or a queue.</span></span>

<span data-ttu-id="d591a-129">每個可靠的狀態提供者會公開具狀態服務所使用的介面，以和可靠的狀態提供者互動。</span><span class="sxs-lookup"><span data-stu-id="d591a-129">Each reliable state provider exposes an interface that is used by a stateful service to interact with the reliable state provider.</span></span> <span data-ttu-id="d591a-130">例如，IReliableDictionary 用來與可靠的字典互動，而 IReliableQueue 用來與可靠的佇列互動。</span><span class="sxs-lookup"><span data-stu-id="d591a-130">For example, IReliableDictionary is used to interface with the reliable dictionary, while IReliableQueue is used to interface with the reliable queue.</span></span> <span data-ttu-id="d591a-131">所有可靠的狀態提供者都實作 IReliableState 介面。</span><span class="sxs-lookup"><span data-stu-id="d591a-131">All reliable state providers implement the IReliableState interface.</span></span>

<span data-ttu-id="d591a-132">可靠的狀態管理員具有名為 IReliableStateManager 的介面，其可讓您從具狀態服務進行存取。</span><span class="sxs-lookup"><span data-stu-id="d591a-132">The reliable state manager has an interface named IReliableStateManager, which allows access to it from a stateful service.</span></span> <span data-ttu-id="d591a-133">與可靠的狀態提供者的介面會透過 IReliableStateManager 傳回。</span><span class="sxs-lookup"><span data-stu-id="d591a-133">Interfaces to reliable state providers are returned through IReliableStateManager.</span></span>

<span data-ttu-id="d591a-134">可靠的狀態管理員使用外掛程式架構，因此新類型的可靠的集合可以動態地插入。</span><span class="sxs-lookup"><span data-stu-id="d591a-134">The reliable state manager uses a plug-in architecture so that new types of reliable collections can be plugged in dynamically.</span></span>

<span data-ttu-id="d591a-135">可靠的字典和可靠的佇列是建立在高效能版本的差異存放區實作上。</span><span class="sxs-lookup"><span data-stu-id="d591a-135">The reliable dictionary and reliable queue are built upon the implementation of a high-performance, versioned differential store.</span></span>

### <a name="transactional-replicator"></a><span data-ttu-id="d591a-136">交易式複寫器</span><span class="sxs-lookup"><span data-stu-id="d591a-136">Transactional replicator</span></span>
<span data-ttu-id="d591a-137">交易式複寫器元件負責確保服務的狀態 (也就是可靠狀態管理員和可靠集合的狀態)，在執行服務的所有複本之間都一致。</span><span class="sxs-lookup"><span data-stu-id="d591a-137">The transactional replicator component is responsible for ensuring that the state of a service (that is, the state within the reliable state manager and the reliable collections) is consistent across all replicas running the service.</span></span> <span data-ttu-id="d591a-138">也可確保狀態保存在記錄檔中。</span><span class="sxs-lookup"><span data-stu-id="d591a-138">It also ensures that the state is persisted in the log.</span></span> <span data-ttu-id="d591a-139">可靠狀態管理員透過私用機制與交易式複寫器互動。</span><span class="sxs-lookup"><span data-stu-id="d591a-139">The reliable state manager interfaces with the transactional replicator via a private mechanism.</span></span>

<span data-ttu-id="d591a-140">交易式複寫器使用網路通訊協定來與服務執行個體的其他複本溝通狀態，如此所有複本都有最新的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="d591a-140">The transactional replicator uses a network protocol to communicate state with other replicas of the service instance so that all replicas have up-to-date state information.</span></span>

<span data-ttu-id="d591a-141">交易式複寫器使用記錄來保存狀態資訊，因此狀態資訊可以保存經歷處理序或節點當機。</span><span class="sxs-lookup"><span data-stu-id="d591a-141">The transactional replicator uses a log to persist state information so that the state information survives process or node crashes.</span></span> <span data-ttu-id="d591a-142">記錄檔的介面是透過私用機制。</span><span class="sxs-lookup"><span data-stu-id="d591a-142">The interface to the log is via a private mechanism.</span></span>

### <a name="log"></a><span data-ttu-id="d591a-143">記錄檔</span><span class="sxs-lookup"><span data-stu-id="d591a-143">Log</span></span>
<span data-ttu-id="d591a-144">記錄元件提供高效能的持續性存放區，它可以針對寫入旋轉或固態磁碟而最佳化。</span><span class="sxs-lookup"><span data-stu-id="d591a-144">The log component provides a high-performance persistent store that can be optimized for writing to spinning or solid-state disks.</span></span>  <span data-ttu-id="d591a-145">記錄檔的設計是讓持續性儲存體 (亦即硬碟) 能在執行具狀態服務的節點本機。</span><span class="sxs-lookup"><span data-stu-id="d591a-145">The design of the log is for the persistent storage (i.e., hard disks) to be local to the nodes that are running the stateful service.</span></span> <span data-ttu-id="d591a-146">如此即可達到低延遲及高輸送量 (相較於非節點本機的遠端持續性儲存體)。</span><span class="sxs-lookup"><span data-stu-id="d591a-146">This allows for low latencies and high throughput, as compared to remote persistent storage, which is not local to the node.</span></span>

<span data-ttu-id="d591a-147">記錄元件會使用多個記錄檔。</span><span class="sxs-lookup"><span data-stu-id="d591a-147">The log component uses multiple log files.</span></span> <span data-ttu-id="d591a-148">有一個所有複本都會使用的全節點共用記錄檔，因為它可在儲存狀態資料時提供最低的延遲與最高的輸送量。</span><span class="sxs-lookup"><span data-stu-id="d591a-148">There is a node-wide shared log file that all replicas use as it can provide the lowest latency and highest throughput for storing state data.</span></span> <span data-ttu-id="d591a-149">依預設，共用記錄檔放在 Service Fabric 節點工作目錄中，但它也可以設定為放在另一個位置上，最好是放在僅保留給共用記錄檔的磁碟上。</span><span class="sxs-lookup"><span data-stu-id="d591a-149">By default the shared log is placed in the Service Fabric node work directory but it may also be configured to be placed at another location, ideally on a disk reserved for only the shared log.</span></span> <span data-ttu-id="d591a-150">服務的每個複本也有專用記錄檔，而且專用記錄檔放在服務的工作目錄內。</span><span class="sxs-lookup"><span data-stu-id="d591a-150">Each replica for the service also has a dedicated log file and the dedicated log is placed within the service's work directory.</span></span> <span data-ttu-id="d591a-151">沒有任何機制，可用來將專用記錄檔設定為放在不同的位置上。</span><span class="sxs-lookup"><span data-stu-id="d591a-151">There is no mechanism to configure the dedicated log to be placed at a different location.</span></span>

<span data-ttu-id="d591a-152">共用記錄檔是複本狀態資訊的過渡區域，而專用記錄檔則是其保存所在位置的最終目的地。</span><span class="sxs-lookup"><span data-stu-id="d591a-152">The shared log is a transitional area for the replica's state information, while the dedicated log file is the final destination where it is persisted.</span></span> <span data-ttu-id="d591a-153">在這種設計中，狀態資訊會先寫入共用記錄檔，然後在背景中延遲地移到專用記錄檔。</span><span class="sxs-lookup"><span data-stu-id="d591a-153">In this design, the state information is first written to the shared log file and then lazily moved to the dedicated log file in the background.</span></span> <span data-ttu-id="d591a-154">如此，對共用記錄檔的寫入延遲會最小且輸送量會最高，因而允許服務進度更快速。</span><span class="sxs-lookup"><span data-stu-id="d591a-154">In this way, the write to the shared log would have the lowest latency and highest throughput which allows the service to make progress faster.</span></span>

<span data-ttu-id="d591a-155">完成讀取和寫入共用記錄檔的方式為直接 IO 至磁碟上預先配置給共用記錄檔的空間。</span><span class="sxs-lookup"><span data-stu-id="d591a-155">Reads and writes to the shared log are done via direct IO to preallocated space on the disk for the shared log file.</span></span> <span data-ttu-id="d591a-156">為了讓專用記錄檔能以最有效方式使用磁碟機上的磁碟空間，專用記錄檔會建立為 NTFS 疏鬆檔案。</span><span class="sxs-lookup"><span data-stu-id="d591a-156">To allow optimal use of disk space on the drive with dedicated logs, the dedicated log file is created as a NTFS sparse file.</span></span> <span data-ttu-id="d591a-157">請注意，這將允許過度佈建磁碟空間，因此 OS 將會使用遠超過實際使用的磁碟空間顯示專用記錄檔。</span><span class="sxs-lookup"><span data-stu-id="d591a-157">Note that this will allow overprovisioning of disk space and the OS will show the dedicated log files using much more disk space than is actually used.</span></span>

<span data-ttu-id="d591a-158">除了對記錄檔的最小使用者模式介面，記錄檔會撰寫為核心模式驅動程式。</span><span class="sxs-lookup"><span data-stu-id="d591a-158">Aside from a minimal user-mode interface to the log, the log is written as a kernel-mode driver.</span></span> <span data-ttu-id="d591a-159">藉由以核心模式驅動程式方式執行，記錄檔可以提供最高的效能給使用它的所有服務。</span><span class="sxs-lookup"><span data-stu-id="d591a-159">By running as a kernel-mode driver, the log can provide the highest performance to all services that use it.</span></span>

<span data-ttu-id="d591a-160">如需設定記錄的詳細資訊，請參閱 [設定具狀態的 Reliable Services](service-fabric-reliable-services-configuration.md)。</span><span class="sxs-lookup"><span data-stu-id="d591a-160">For more information about configuring the log, see [Configuring stateful Reliable Services](service-fabric-reliable-services-configuration.md).</span></span>

## <a name="stateless-reliable-service"></a><span data-ttu-id="d591a-161">無狀態的可靠的服務</span><span class="sxs-lookup"><span data-stu-id="d591a-161">Stateless Reliable Service</span></span>
### <a name="architecture-of-a-stateless-service"></a><span data-ttu-id="d591a-162">無狀態服務的架構</span><span class="sxs-lookup"><span data-stu-id="d591a-162">Architecture of a stateless service</span></span>
![無狀態服務的架構圖](./media/service-fabric-reliable-services-platform-architecture/reliable-stateless-service-architecture.png)

### <a name="stateless-reliable-service"></a><span data-ttu-id="d591a-164">無狀態的可靠的服務</span><span class="sxs-lookup"><span data-stu-id="d591a-164">Stateless Reliable Service</span></span>
<span data-ttu-id="d591a-165">無狀態服務實作衍生自 StatelessService 類別或 StatelessServiceBase 類別。</span><span class="sxs-lookup"><span data-stu-id="d591a-165">Stateless service implementations derive from the StatelessService or StatelessServiceBase class.</span></span> <span data-ttu-id="d591a-166">StatelessServiceBase 類別比 StatelessService 允許更多彈性。</span><span class="sxs-lookup"><span data-stu-id="d591a-166">The StatelessServiceBase class allows more flexibility than the StatelessService class.</span></span>
<span data-ttu-id="d591a-167">這兩個基底類別會管理服務的存留期和角色。</span><span class="sxs-lookup"><span data-stu-id="d591a-167">Both base classes manage the lifetime and role of a service.</span></span>

<span data-ttu-id="d591a-168">如果服務在服務生命週期中的那些點有工作要執行，或是想要建立通訊接聽程式物件，服務實作可能會覆寫任一基底類別的虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="d591a-168">The service implementation may override virtual methods of either base class if the service has work to do at those points in the service lifecycle--or if it wants to create a communication listener object.</span></span> <span data-ttu-id="d591a-169">請注意雖然服務可能會實作自己的通訊接聽程式物件並公開 ICommunicationListener，在上圖中，通訊接聽程式由 Service Fabric 實作，因為服務實作使用 Service Fabric 所實作的通訊接聽程式。</span><span class="sxs-lookup"><span data-stu-id="d591a-169">Note that although the service may implement its own communication listener object exposing ICommunicationListener, in the diagram above, the communication listener is implemented by Service Fabric, as that service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="d591a-170">請參閱 [Reliable Services 概觀](service-fabric-reliable-services-introduction.md)和 [Reliable Services 進階用法](service-fabric-reliable-services-advanced-usage.md)，以取得使用 StatelessService 和 StatelessServiceBase 類別撰寫服務細節的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="d591a-170">See the [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on the specifics of writing services using the StatelessService and StatelessServiceBase classes.</span></span>

<!--Every topic should have next steps and links to the next logical set of content to keep the customer engaged-->
## <a name="next-steps"></a><span data-ttu-id="d591a-171">後續步驟</span><span class="sxs-lookup"><span data-stu-id="d591a-171">Next steps</span></span>
<span data-ttu-id="d591a-172">如需 Service Fabric 的詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="d591a-172">For more information about Service Fabric, see:</span></span>

[<span data-ttu-id="d591a-173">可靠的服務概觀</span><span class="sxs-lookup"><span data-stu-id="d591a-173">Reliable service overview</span></span>](service-fabric-reliable-services-introduction.md)

[<span data-ttu-id="d591a-174">快速入門</span><span class="sxs-lookup"><span data-stu-id="d591a-174">Quick start</span></span>](service-fabric-reliable-services-quick-start.md)

[<span data-ttu-id="d591a-175">可靠的集合概觀</span><span class="sxs-lookup"><span data-stu-id="d591a-175">Reliable collections overview</span></span>](service-fabric-reliable-services-reliable-collections.md)

[<span data-ttu-id="d591a-176">可靠的服務的進階用法</span><span class="sxs-lookup"><span data-stu-id="d591a-176">Reliable service advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)

[<span data-ttu-id="d591a-177">可靠的服務組態</span><span class="sxs-lookup"><span data-stu-id="d591a-177">Reliable service configuration</span></span>](service-fabric-reliable-services-configuration.md)  

