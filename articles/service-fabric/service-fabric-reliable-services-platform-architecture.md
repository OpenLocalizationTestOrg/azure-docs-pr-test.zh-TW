---
title: "aaaReliable 服務架構 |Microsoft 文件"
description: "可設定狀態，而且無狀態服務的 hello 可靠的服務架構的概觀"
services: service-fabric
documentationcenter: .net
author: AlanWarwick
manager: timlt
editor: vturecek
ms.assetid: af002ae6-7f6d-4769-b049-82aa1ba0891b
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 03/30/2016
ms.author: alanwar
redirect_url: /azure/service-fabric/service-fabric-reliable-services-introduction
ms.openlocfilehash: d2d0ec9600275ae248ab7717be269cc7204a1e4d
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="architecture-for-stateful-and-stateless-reliable-services"></a><span data-ttu-id="2abef-103">具狀態與無狀態 Reliable Services 的架構</span><span class="sxs-lookup"><span data-stu-id="2abef-103">Architecture for stateful and stateless Reliable Services</span></span>
<span data-ttu-id="2abef-104">Azure Service Fabric 可靠服務可能是具狀態或無狀態。</span><span class="sxs-lookup"><span data-stu-id="2abef-104">An Azure Service Fabric Reliable Service may be stateful or stateless.</span></span> <span data-ttu-id="2abef-105">每一種服務都在特定架構內執行。</span><span class="sxs-lookup"><span data-stu-id="2abef-105">Each type of service runs within a specific architecture.</span></span> <span data-ttu-id="2abef-106">本文將會說明這些架構。</span><span class="sxs-lookup"><span data-stu-id="2abef-106">These architectures are described in this article.</span></span>
<span data-ttu-id="2abef-107">請參閱 hello[可靠的服務概觀](service-fabric-reliable-services-introduction.md)如需有關 hello 可設定狀態，而且無狀態服務之間的差異。</span><span class="sxs-lookup"><span data-stu-id="2abef-107">See hello [Reliable Service overview](service-fabric-reliable-services-introduction.md) for more information about hello differences between stateful and stateless services.</span></span>

## <a name="stateful-reliable-services"></a><span data-ttu-id="2abef-108">具狀態可靠的服務</span><span class="sxs-lookup"><span data-stu-id="2abef-108">Stateful Reliable Services</span></span>
### <a name="architecture-of-a-stateful-service"></a><span data-ttu-id="2abef-109">具狀態服務的架構</span><span class="sxs-lookup"><span data-stu-id="2abef-109">Architecture of a stateful service</span></span>
![具狀態服務的架構圖](./media/service-fabric-reliable-services-platform-architecture/reliable-stateful-service-architecture.png)

### <a name="stateful-reliable-service"></a><span data-ttu-id="2abef-111">具狀態可靠的服務</span><span class="sxs-lookup"><span data-stu-id="2abef-111">Stateful Reliable Service</span></span>
<span data-ttu-id="2abef-112">可設定狀態 Reliable Service 可以衍生自 hello StatefulService 或 StatefulServiceBase 類別。</span><span class="sxs-lookup"><span data-stu-id="2abef-112">A stateful Reliable Service can derive from either hello StatefulService or StatefulServiceBase class.</span></span> <span data-ttu-id="2abef-113">這兩個基底類別都由 Service Fabric 所提供。</span><span class="sxs-lookup"><span data-stu-id="2abef-113">Both of these base classes are provided by Service Fabric.</span></span> <span data-ttu-id="2abef-114">提供了各種層級支援與 hello 具狀態服務 toointerface Service Fabric-與 tooparticipate hello Service Fabric 叢集內的服務為抽象。</span><span class="sxs-lookup"><span data-stu-id="2abef-114">They offer various levels of support and abstraction for hello stateful service toointerface with Service Fabric--and tooparticipate as a service within hello Service Fabric cluster.</span></span>

<span data-ttu-id="2abef-115">StatefulService 衍生自 StatefulServiceBase。</span><span class="sxs-lookup"><span data-stu-id="2abef-115">StatefulService derives from StatefulServiceBase.</span></span> <span data-ttu-id="2abef-116">StatefulServiceBase 提供服務更多的彈性，但需要更多的了解 hello 內部的 Service Fabric。</span><span class="sxs-lookup"><span data-stu-id="2abef-116">StatefulServiceBase offers services more flexibility, but requires more understanding of hello internals of Service Fabric.</span></span>
<span data-ttu-id="2abef-117">請參閱 hello[可靠的服務概觀](service-fabric-reliable-services-introduction.md)和[可靠的服務的進階用法](service-fabric-reliable-services-advanced-usage.md)如需使用 hello StatefulService 和 StatefulServiceBase 類別撰寫服務的 hello 細節.</span><span class="sxs-lookup"><span data-stu-id="2abef-117">See hello [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on hello specifics of writing services by using hello StatefulService and StatefulServiceBase classes.</span></span>

<span data-ttu-id="2abef-118">這兩個基底類別會管理 hello 存留期和 hello 服務實作的角色。</span><span class="sxs-lookup"><span data-stu-id="2abef-118">Both base classes manage hello lifetime and role of hello service implementation.</span></span> <span data-ttu-id="2abef-119">hello 服務實作可能會覆寫虛擬方法的其中一個基底類別，或如果 hello 服務實作這些要點牢記在 hello 服務實作的生命週期--在有工作 toodo 想 toocreate 通訊接聽程式物件。</span><span class="sxs-lookup"><span data-stu-id="2abef-119">hello service implementation may override virtual methods of either base class if hello service implementation has work toodo at those points in hello service implementation lifecycle--or if it wants toocreate a communication listener object.</span></span> <span data-ttu-id="2abef-120">請注意，雖然服務實作可能會實作公開 ICommunicationListener，hello 圖，在自己的通訊接聽程式物件 hello 通訊接聽程式實作透過 Service Fabric-hello 服務實作會使用由服務網狀架構所實作的通訊接聽程式。</span><span class="sxs-lookup"><span data-stu-id="2abef-120">Note that although a service implementation may implement its own communication listener object exposing ICommunicationListener, in hello diagram above, hello communication listener is implemented by Service Fabric--as hello service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="2abef-121">可設定狀態 Reliable Service 會使用 hello 穩定的狀態，請管理員 tootake 利用可靠的集合。</span><span class="sxs-lookup"><span data-stu-id="2abef-121">A stateful Reliable Service uses hello reliable state manager tootake advantage of reliable collections.</span></span> <span data-ttu-id="2abef-122">可靠的集合是本機資料結構，其中是高可用性 toohello 服務--也就是說，它們永遠都可以使用，不論服務容錯移轉。</span><span class="sxs-lookup"><span data-stu-id="2abef-122">Reliable collections are local data structures that are highly available toohello service--that is, they are always available, regardless of service failovers.</span></span> <span data-ttu-id="2abef-123">可靠的集合的每個類型是由可靠的狀態提供者所實作。</span><span class="sxs-lookup"><span data-stu-id="2abef-123">Each type of reliable collection is implemented by a reliable state provider.</span></span>
<span data-ttu-id="2abef-124">如需有關可靠集合的詳細資訊，請參閱 hello[可靠集合概觀](service-fabric-reliable-services-reliable-collections.md)。</span><span class="sxs-lookup"><span data-stu-id="2abef-124">For more information on reliable collections, see hello [reliable collections overview](service-fabric-reliable-services-reliable-collections.md).</span></span>

### <a name="reliable-state-manager-and-state-providers"></a><span data-ttu-id="2abef-125">可靠的狀態管理員和狀態提供者</span><span class="sxs-lookup"><span data-stu-id="2abef-125">Reliable state manager and state providers</span></span>
<span data-ttu-id="2abef-126">管理可靠狀態提供者的 hello 物件 hello 穩定的狀態管理員。</span><span class="sxs-lookup"><span data-stu-id="2abef-126">hello reliable state manager is hello object that manages reliable state providers.</span></span> <span data-ttu-id="2abef-127">它有 hello 功能 toocreate、 刪除、 列舉，並確定 hello 可靠狀態提供者持續性、 高可用性。</span><span class="sxs-lookup"><span data-stu-id="2abef-127">It has hello functionality toocreate, delete, enumerate, and ensure that hello reliable state providers are persisted and highly available.</span></span> <span data-ttu-id="2abef-128">可靠的狀態提供者執行個體代表持續保存且高度可用之資料結構的執行個體，例如字典或佇列。</span><span class="sxs-lookup"><span data-stu-id="2abef-128">A reliable state provider instance represents an instance of a persisted and highly available data structure, such as a dictionary or a queue.</span></span>

<span data-ttu-id="2abef-129">每一個穩定的狀態提供者會公開可由具狀態服務 toointeract 與 hello 穩定的狀態提供者的介面。</span><span class="sxs-lookup"><span data-stu-id="2abef-129">Each reliable state provider exposes an interface that is used by a stateful service toointeract with hello reliable state provider.</span></span> <span data-ttu-id="2abef-130">比方說，IReliableDictionary 時，使用與 hello 可靠的字典，toointerface IReliableQueue 是使用的 toointerface 與 hello 可靠的佇列。</span><span class="sxs-lookup"><span data-stu-id="2abef-130">For example, IReliableDictionary is used toointerface with hello reliable dictionary, while IReliableQueue is used toointerface with hello reliable queue.</span></span> <span data-ttu-id="2abef-131">所有的穩定的狀態提供者實作 hello IReliableState 介面。</span><span class="sxs-lookup"><span data-stu-id="2abef-131">All reliable state providers implement hello IReliableState interface.</span></span>

<span data-ttu-id="2abef-132">hello 穩定的狀態管理員具有名為 IReliableStateManager，允許存取 tooit 從具狀態服務的介面。</span><span class="sxs-lookup"><span data-stu-id="2abef-132">hello reliable state manager has an interface named IReliableStateManager, which allows access tooit from a stateful service.</span></span> <span data-ttu-id="2abef-133">透過 IReliableStateManager 傳回介面 tooreliable 狀態提供者。</span><span class="sxs-lookup"><span data-stu-id="2abef-133">Interfaces tooreliable state providers are returned through IReliableStateManager.</span></span>

<span data-ttu-id="2abef-134">hello 可靠狀態管理員會使用外掛程式的架構，讓新類型的可靠的集合可以插入動態。</span><span class="sxs-lookup"><span data-stu-id="2abef-134">hello reliable state manager uses a plug-in architecture so that new types of reliable collections can be plugged in dynamically.</span></span>

<span data-ttu-id="2abef-135">hello 可靠字典和可靠的佇列是建置在 hello 實作的高效能、 版本設定的差異存放區中。</span><span class="sxs-lookup"><span data-stu-id="2abef-135">hello reliable dictionary and reliable queue are built upon hello implementation of a high-performance, versioned differential store.</span></span>

### <a name="transactional-replicator"></a><span data-ttu-id="2abef-136">交易式複寫器</span><span class="sxs-lookup"><span data-stu-id="2abef-136">Transactional replicator</span></span>
<span data-ttu-id="2abef-137">hello 異動複寫器元件會負責確保 hello 狀態 （也就是 hello 可靠狀態管理員和 hello 可靠集合中的 hello 狀態） 的服務在執行 hello 服務的所有複本上一致的。</span><span class="sxs-lookup"><span data-stu-id="2abef-137">hello transactional replicator component is responsible for ensuring that hello state of a service (that is, hello state within hello reliable state manager and hello reliable collections) is consistent across all replicas running hello service.</span></span> <span data-ttu-id="2abef-138">它也可確保 hello 狀態會保存在 hello 記錄檔中。</span><span class="sxs-lookup"><span data-stu-id="2abef-138">It also ensures that hello state is persisted in hello log.</span></span> <span data-ttu-id="2abef-139">hello 與 hello 異動複寫器透過私人機制穩定的狀態管理員介面。</span><span class="sxs-lookup"><span data-stu-id="2abef-139">hello reliable state manager interfaces with hello transactional replicator via a private mechanism.</span></span>

<span data-ttu-id="2abef-140">hello 異動複寫器使用網路通訊協定 toocommunicate 狀態與 hello 服務執行個體的其他複本，使所有複本都有最新狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="2abef-140">hello transactional replicator uses a network protocol toocommunicate state with other replicas of hello service instance so that all replicas have up-to-date state information.</span></span>

<span data-ttu-id="2abef-141">hello 異動複寫器使用 toopersist 狀態資訊的記錄檔，讓 hello 狀態資訊便會存在著處理程序，或節點當機。</span><span class="sxs-lookup"><span data-stu-id="2abef-141">hello transactional replicator uses a log toopersist state information so that hello state information survives process or node crashes.</span></span> <span data-ttu-id="2abef-142">hello 介面 toohello 記錄是透過私用的機制。</span><span class="sxs-lookup"><span data-stu-id="2abef-142">hello interface toohello log is via a private mechanism.</span></span>

### <a name="log"></a><span data-ttu-id="2abef-143">記錄檔</span><span class="sxs-lookup"><span data-stu-id="2abef-143">Log</span></span>
<span data-ttu-id="2abef-144">hello 記錄元件提供高效能的持續性存放區，可以針對寫入 toospinning 或固態硬碟進行最佳化。</span><span class="sxs-lookup"><span data-stu-id="2abef-144">hello log component provides a high-performance persistent store that can be optimized for writing toospinning or solid-state disks.</span></span>  <span data-ttu-id="2abef-145">hello hello 記錄檔的設計是 hello 永續性儲存體 （也就是硬碟） toobe 本機 toohello 節點執行 hello 可設定狀態的服務。</span><span class="sxs-lookup"><span data-stu-id="2abef-145">hello design of hello log is for hello persistent storage (i.e., hard disks) toobe local toohello nodes that are running hello stateful service.</span></span> <span data-ttu-id="2abef-146">這樣低的延遲和高輸送量，做為比較的 tooremote 永續性儲存體，這不是本機 toohello 節點。</span><span class="sxs-lookup"><span data-stu-id="2abef-146">This allows for low latencies and high throughput, as compared tooremote persistent storage, which is not local toohello node.</span></span>

<span data-ttu-id="2abef-147">hello 記錄元件會使用多個記錄檔。</span><span class="sxs-lookup"><span data-stu-id="2abef-147">hello log component uses multiple log files.</span></span> <span data-ttu-id="2abef-148">沒有節點全共用的記錄檔，讓它可以提供 hello 最低延遲和最高輸送量的儲存狀態資料做為所有複本。</span><span class="sxs-lookup"><span data-stu-id="2abef-148">There is a node-wide shared log file that all replicas use as it can provide hello lowest latency and highest throughput for storing state data.</span></span> <span data-ttu-id="2abef-149">根據預設，hello 共用記錄檔會置於 hello Service Fabric 節點工作目錄，但也可能是設定的 toobe 放在另一個位置，最好是在 hello 共用記錄的保留磁碟上。</span><span class="sxs-lookup"><span data-stu-id="2abef-149">By default hello shared log is placed in hello Service Fabric node work directory but it may also be configured toobe placed at another location, ideally on a disk reserved for only hello shared log.</span></span> <span data-ttu-id="2abef-150">每個複本 hello 服務也會有專用的記錄檔和 hello 專用的記錄檔會放置在 hello 服務的工作目錄。</span><span class="sxs-lookup"><span data-stu-id="2abef-150">Each replica for hello service also has a dedicated log file and hello dedicated log is placed within hello service's work directory.</span></span> <span data-ttu-id="2abef-151">放在不同的位置沒有機制 tooconfigure hello 專用記錄 toobe。</span><span class="sxs-lookup"><span data-stu-id="2abef-151">There is no mechanism tooconfigure hello dedicated log toobe placed at a different location.</span></span>

<span data-ttu-id="2abef-152">hello 共用的記錄為 hello 複本的狀態資訊的過渡期區域，hello 專用的記錄檔之後再保存 hello 最終目的地。</span><span class="sxs-lookup"><span data-stu-id="2abef-152">hello shared log is a transitional area for hello replica's state information, while hello dedicated log file is hello final destination where it is persisted.</span></span> <span data-ttu-id="2abef-153">在這個設計中，hello 狀態資訊是第一個寫入的 toohello 共用的記錄檔，然後再執行延遲移 hello 背景 toohello 專用的記錄檔。</span><span class="sxs-lookup"><span data-stu-id="2abef-153">In this design, hello state information is first written toohello shared log file and then lazily moved toohello dedicated log file in hello background.</span></span> <span data-ttu-id="2abef-154">如此一來，hello 寫入 toohello 共用記錄檔中會有 hello 最低延遲和高的輸送量更快讓 hello 服務 toomake 進度。</span><span class="sxs-lookup"><span data-stu-id="2abef-154">In this way, hello write toohello shared log would have hello lowest latency and highest throughput which allows hello service toomake progress faster.</span></span>

<span data-ttu-id="2abef-155">讀取和寫入 toohello 共用記錄檔會透過直接 IO toopreallocated 空間 hello hello 共用記錄檔的磁碟上完成。</span><span class="sxs-lookup"><span data-stu-id="2abef-155">Reads and writes toohello shared log are done via direct IO toopreallocated space on hello disk for hello shared log file.</span></span> <span data-ttu-id="2abef-156">tooallow hello 專用的記錄檔的磁碟機上的磁碟空間使用最佳的 hello 專用的記錄檔會建立為 NTFS 的疏鬆檔案。</span><span class="sxs-lookup"><span data-stu-id="2abef-156">tooallow optimal use of disk space on hello drive with dedicated logs, hello dedicated log file is created as a NTFS sparse file.</span></span> <span data-ttu-id="2abef-157">請注意，這可讓過度佈建的磁碟空間 hello OS 將會顯示 hello 專用使用更多磁碟空間超過實際使用的記錄檔。</span><span class="sxs-lookup"><span data-stu-id="2abef-157">Note that this will allow overprovisioning of disk space and hello OS will show hello dedicated log files using much more disk space than is actually used.</span></span>

<span data-ttu-id="2abef-158">除了基本使用者模式的介面 toohello 記錄檔 hello 記錄會寫入成為核心模式驅動程式。</span><span class="sxs-lookup"><span data-stu-id="2abef-158">Aside from a minimal user-mode interface toohello log, hello log is written as a kernel-mode driver.</span></span> <span data-ttu-id="2abef-159">核心模式驅動程式的身分執行，hello 記錄可藉由提供 hello 最高的效能 tooall 服務使用它。</span><span class="sxs-lookup"><span data-stu-id="2abef-159">By running as a kernel-mode driver, hello log can provide hello highest performance tooall services that use it.</span></span>

<span data-ttu-id="2abef-160">如需設定 hello 記錄檔的詳細資訊，請參閱[設定可設定狀態的可靠服務](service-fabric-reliable-services-configuration.md)。</span><span class="sxs-lookup"><span data-stu-id="2abef-160">For more information about configuring hello log, see [Configuring stateful Reliable Services](service-fabric-reliable-services-configuration.md).</span></span>

## <a name="stateless-reliable-service"></a><span data-ttu-id="2abef-161">無狀態的可靠的服務</span><span class="sxs-lookup"><span data-stu-id="2abef-161">Stateless Reliable Service</span></span>
### <a name="architecture-of-a-stateless-service"></a><span data-ttu-id="2abef-162">無狀態服務的架構</span><span class="sxs-lookup"><span data-stu-id="2abef-162">Architecture of a stateless service</span></span>
![無狀態服務的架構圖](./media/service-fabric-reliable-services-platform-architecture/reliable-stateless-service-architecture.png)

### <a name="stateless-reliable-service"></a><span data-ttu-id="2abef-164">無狀態的可靠的服務</span><span class="sxs-lookup"><span data-stu-id="2abef-164">Stateless Reliable Service</span></span>
<span data-ttu-id="2abef-165">無狀態服務實作衍生自 hello StatelessService 或 StatelessServiceBase 類別。</span><span class="sxs-lookup"><span data-stu-id="2abef-165">Stateless service implementations derive from hello StatelessService or StatelessServiceBase class.</span></span> <span data-ttu-id="2abef-166">hello StatelessServiceBase 類別可讓更多的彈性比 hello StatelessService 類別。</span><span class="sxs-lookup"><span data-stu-id="2abef-166">hello StatelessServiceBase class allows more flexibility than hello StatelessService class.</span></span>
<span data-ttu-id="2abef-167">這兩個基底類別會管理 hello 存留期和服務的角色。</span><span class="sxs-lookup"><span data-stu-id="2abef-167">Both base classes manage hello lifetime and role of a service.</span></span>

<span data-ttu-id="2abef-168">如果 hello 服務工作 toodo hello 服務生命週期--在這些時間點，或者它想 toocreate 通訊接聽程式物件，hello 服務實作可能會覆寫虛擬方法的其中一個基底類別。</span><span class="sxs-lookup"><span data-stu-id="2abef-168">hello service implementation may override virtual methods of either base class if hello service has work toodo at those points in hello service lifecycle--or if it wants toocreate a communication listener object.</span></span> <span data-ttu-id="2abef-169">請注意，雖然 hello 服務可能會實作公開 ICommunicationListener，hello 圖，在自己的通訊接聽程式物件 hello 通訊接聽程式會實作由服務網狀架構，因為該服務實作會使用通訊服務網狀架構所實作的接聽程式。</span><span class="sxs-lookup"><span data-stu-id="2abef-169">Note that although hello service may implement its own communication listener object exposing ICommunicationListener, in hello diagram above, hello communication listener is implemented by Service Fabric, as that service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="2abef-170">請參閱 hello[可靠的服務概觀](service-fabric-reliable-services-introduction.md)和[可靠的服務的進階用法](service-fabric-reliable-services-advanced-usage.md)如需撰寫使用 hello StatelessService 和 StatelessServiceBase 類別服務的 hello 細節.</span><span class="sxs-lookup"><span data-stu-id="2abef-170">See hello [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on hello specifics of writing services using hello StatelessService and StatelessServiceBase classes.</span></span>

<!--Every topic should have next steps and links toohello next logical set of content tookeep hello customer engaged-->
## <a name="next-steps"></a><span data-ttu-id="2abef-171">後續步驟</span><span class="sxs-lookup"><span data-stu-id="2abef-171">Next steps</span></span>
<span data-ttu-id="2abef-172">如需 Service Fabric 的詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="2abef-172">For more information about Service Fabric, see:</span></span>

[<span data-ttu-id="2abef-173">可靠的服務概觀</span><span class="sxs-lookup"><span data-stu-id="2abef-173">Reliable service overview</span></span>](service-fabric-reliable-services-introduction.md)

[<span data-ttu-id="2abef-174">快速入門</span><span class="sxs-lookup"><span data-stu-id="2abef-174">Quick start</span></span>](service-fabric-reliable-services-quick-start.md)

[<span data-ttu-id="2abef-175">可靠的集合概觀</span><span class="sxs-lookup"><span data-stu-id="2abef-175">Reliable collections overview</span></span>](service-fabric-reliable-services-reliable-collections.md)

[<span data-ttu-id="2abef-176">可靠的服務的進階用法</span><span class="sxs-lookup"><span data-stu-id="2abef-176">Reliable service advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)

[<span data-ttu-id="2abef-177">可靠的服務組態</span><span class="sxs-lookup"><span data-stu-id="2abef-177">Reliable service configuration</span></span>](service-fabric-reliable-services-configuration.md)  

