---
title: "hello Service Fabric 可靠服務程式設計模型 aaaOverview |Microsoft 文件"
description: "深入了解 Service Fabric 可靠的服務的程式設計模型，並開始撰寫自己的服務。"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek; mani-ramaswamy
ms.assetid: 0c88a533-73f8-4ae1-a939-67d17456ac06
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 8/9/2017
ms.author: masnider;
ms.openlocfilehash: 41d1826df902b1f1845c4702bf2567e6b9ca1f1f
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-overview"></a><span data-ttu-id="6dff2-103">Reliable Services 概觀</span><span class="sxs-lookup"><span data-stu-id="6dff2-103">Reliable Services overview</span></span>
<span data-ttu-id="6dff2-104">Azure Service Fabric 可簡化撰寫和管理無狀態與具狀態的 Reliable Services。</span><span class="sxs-lookup"><span data-stu-id="6dff2-104">Azure Service Fabric simplifies writing and managing stateless and stateful Reliable Services.</span></span> <span data-ttu-id="6dff2-105">本主題涵蓋︰</span><span class="sxs-lookup"><span data-stu-id="6dff2-105">This topic covers:</span></span>

* <span data-ttu-id="6dff2-106">hello 可靠的服務之程式設計模型無狀態與可設定狀態服務。</span><span class="sxs-lookup"><span data-stu-id="6dff2-106">hello Reliable Services programming model for stateless and stateful services.</span></span>
* <span data-ttu-id="6dff2-107">hello 選項時，您有 toomake 撰寫可靠的服務。</span><span class="sxs-lookup"><span data-stu-id="6dff2-107">hello choices you have toomake when writing a Reliable Service.</span></span>
* <span data-ttu-id="6dff2-108">某些情況和時機的範例 toouse Reliable Services 和寫入的方式。</span><span class="sxs-lookup"><span data-stu-id="6dff2-108">Some scenarios and examples of when toouse Reliable Services and how they are written.</span></span>

<span data-ttu-id="6dff2-109">可靠的服務是一個 hello 程式設計模型服務網狀架構上可用。</span><span class="sxs-lookup"><span data-stu-id="6dff2-109">Reliable Services is one of hello programming models available on Service Fabric.</span></span> <span data-ttu-id="6dff2-110">其他 hello 是 hello Reliable Actor 的程式設計模型，提供虛擬執行者程式設計模型 hello 可靠的服務模型之上。</span><span class="sxs-lookup"><span data-stu-id="6dff2-110">hello other is hello Reliable Actor programming model, which provides a virtual Actor programming model on top of hello Reliable Services model.</span></span> <span data-ttu-id="6dff2-111">如需有關 hello Reliable Actors 程式設計模型的詳細資訊，請參閱[簡介 tooService 網狀架構 Reliable Actors](service-fabric-reliable-actors-introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="6dff2-111">For more information on hello Reliable Actors programming model, see [Introduction tooService Fabric Reliable Actors](service-fabric-reliable-actors-introduction.md).</span></span>

<span data-ttu-id="6dff2-112">Service Fabric 管理服務的佈建和部署升級和刪除，透過 hello 存留期間透過[Service Fabric 應用程式管理](service-fabric-deploy-remove-applications.md)。</span><span class="sxs-lookup"><span data-stu-id="6dff2-112">Service Fabric manages hello lifetime of services, from provisioning and deployment through upgrade and deletion, via [Service Fabric application management](service-fabric-deploy-remove-applications.md).</span></span>

## <a name="what-are-reliable-services"></a><span data-ttu-id="6dff2-113">什麼是 Reliable Services？</span><span class="sxs-lookup"><span data-stu-id="6dff2-113">What are Reliable Services?</span></span>
<span data-ttu-id="6dff2-114">可靠的服務會提供簡單、 強大、 最上層的程式設計模型 toohelp 你什麼是重要的 tooyour 應用程式。</span><span class="sxs-lookup"><span data-stu-id="6dff2-114">Reliable Services gives you a simple, powerful, top-level programming model toohelp you express what is important tooyour application.</span></span> <span data-ttu-id="6dff2-115">透過 hello 可靠服務程式設計模型，您可以取得：</span><span class="sxs-lookup"><span data-stu-id="6dff2-115">With hello Reliable Services programming model, you get:</span></span>

* <span data-ttu-id="6dff2-116">存取 toohello 其餘的 hello Service Fabric 程式設計應用程式開發介面。</span><span class="sxs-lookup"><span data-stu-id="6dff2-116">Access toohello rest of hello Service Fabric programming APIs.</span></span> <span data-ttu-id="6dff2-117">不同於 Service Fabric 服務模型化為[客體可執行檔](service-fabric-deploy-existing-app.md)，可靠的服務會直接取得 toouse hello 其餘的 hello Service Fabric 應用程式開發介面。</span><span class="sxs-lookup"><span data-stu-id="6dff2-117">Unlike Service Fabric Services modeled as [Guest Executables](service-fabric-deploy-existing-app.md), Reliable Services get toouse hello rest of hello Service Fabric APIs directly.</span></span> <span data-ttu-id="6dff2-118">如此可讓服務︰</span><span class="sxs-lookup"><span data-stu-id="6dff2-118">This allows services to:</span></span>
  * <span data-ttu-id="6dff2-119">查詢 hello 系統</span><span class="sxs-lookup"><span data-stu-id="6dff2-119">query hello system</span></span>
  * <span data-ttu-id="6dff2-120">回報關於 hello 叢集中的實體的健全狀況</span><span class="sxs-lookup"><span data-stu-id="6dff2-120">report health about entities in hello cluster</span></span>
  * <span data-ttu-id="6dff2-121">接收有關設定和程式碼變更的通知</span><span class="sxs-lookup"><span data-stu-id="6dff2-121">receive notifications about configuration and code changes</span></span>
  * <span data-ttu-id="6dff2-122">尋找其他服務而與之通訊，</span><span class="sxs-lookup"><span data-stu-id="6dff2-122">find and communicate with other services,</span></span>
  * <span data-ttu-id="6dff2-123">（選擇性） 使用 hello[可靠的集合](service-fabric-reliable-services-reliable-collections.md)</span><span class="sxs-lookup"><span data-stu-id="6dff2-123">(optionally) use hello [Reliable Collections](service-fabric-reliable-services-reliable-collections.md)</span></span>
  * <span data-ttu-id="6dff2-124">… 並提供他們存取 toomany 其他功能，全部從第一個類別的程式設計模型，以數種程式設計語言。</span><span class="sxs-lookup"><span data-stu-id="6dff2-124">...and giving them access toomany other capabilities, all from a first class programming model in several programming languages.</span></span>
* <span data-ttu-id="6dff2-125">類似您所習慣使用之程式設計模型的簡單模型，以便執行您自己的程式碼。</span><span class="sxs-lookup"><span data-stu-id="6dff2-125">A simple model for running your own code that looks like programming models you are used to.</span></span> <span data-ttu-id="6dff2-126">您的程式碼會具有定義完善的切入點和容易管理的生命週期。</span><span class="sxs-lookup"><span data-stu-id="6dff2-126">Your code has a well-defined entry point and easily managed lifecycle.</span></span>
* <span data-ttu-id="6dff2-127">隨插即用的通訊模型。</span><span class="sxs-lookup"><span data-stu-id="6dff2-127">A pluggable communication model.</span></span> <span data-ttu-id="6dff2-128">使用您的選擇，例如使用 HTTP 的 hello 傳輸[Web API](service-fabric-reliable-services-communication-webapi.md)，WebSockets，自訂 TCP 通訊協定，或任何其他項目。</span><span class="sxs-lookup"><span data-stu-id="6dff2-128">Use hello transport of your choice, such as HTTP with [Web API](service-fabric-reliable-services-communication-webapi.md), WebSockets, custom TCP protocols, or anything else.</span></span> <span data-ttu-id="6dff2-129">Reliable Services 提供一些很棒的現成選項供您使用，或者您可以提供您自己的選項。</span><span class="sxs-lookup"><span data-stu-id="6dff2-129">Reliable Services provide some great out-of-the-box options you can use, or you can provide your own.</span></span>
* <span data-ttu-id="6dff2-130">可設定狀態服務，hello 可靠服務程式設計模型可讓您 tooconsistently 可靠地使用和儲存您位於您的服務狀態[可靠集合](service-fabric-reliable-services-reliable-collections.md)。</span><span class="sxs-lookup"><span data-stu-id="6dff2-130">For stateful services, hello Reliable Services programming model allows you tooconsistently and reliably store your state right inside your service by using [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="6dff2-131">可靠的集合是一組簡單的高度可用且可靠的集合類別，將會是很熟悉 tooanyone 已使用 C# 集合。</span><span class="sxs-lookup"><span data-stu-id="6dff2-131">Reliable Collections are a simple set of highly available and reliable collection classes that will be familiar tooanyone who has used C# collections.</span></span> <span data-ttu-id="6dff2-132">傳統上，服務需要外部系統來進行可靠狀態管理。</span><span class="sxs-lookup"><span data-stu-id="6dff2-132">Traditionally, services needed external systems for Reliable state management.</span></span> <span data-ttu-id="6dff2-133">與可靠的集合，您可以儲存您的狀態下一步 tooyour 的運算以 hello 相同的高可用性和可靠性您返回 tooexpect 從高可用性的外部存放區。</span><span class="sxs-lookup"><span data-stu-id="6dff2-133">With Reliable Collections, you can store your state next tooyour compute with hello same high availability and reliability you've come tooexpect from highly available external stores.</span></span> <span data-ttu-id="6dff2-134">此模型也可以改善延遲，因為您會共置 hello 運算和它需要 toofunction 的狀態。</span><span class="sxs-lookup"><span data-stu-id="6dff2-134">This model also improves latency because you are co-locating hello compute and state it needs toofunction.</span></span>

<span data-ttu-id="6dff2-135">觀看此 Microsoft Virtual Academy 影片以取得 Reliable Services 概觀︰<center>
<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=HhD9566yC_4106218965">
<img src="./media/service-fabric-reliable-services-introduction/ReliableServicesVid.png" WIDTH="360" HEIGHT="244" />
</a>
</center></span><span class="sxs-lookup"><span data-stu-id="6dff2-135">Watch this Microsoft Virtual Academy video for an overview of Reliable services: <center>
<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=HhD9566yC_4106218965">
<img src="./media/service-fabric-reliable-services-introduction/ReliableServicesVid.png" WIDTH="360" HEIGHT="244" />
</a>
</center></span></span>

## <a name="what-makes-reliable-services-different"></a><span data-ttu-id="6dff2-136">Reliable Services 有什麼不同之處？</span><span class="sxs-lookup"><span data-stu-id="6dff2-136">What makes Reliable Services different?</span></span>
<span data-ttu-id="6dff2-137">Service Fabric 中的可靠的服務與您之前撰寫的服務不同。</span><span class="sxs-lookup"><span data-stu-id="6dff2-137">Reliable Services in Service Fabric are different from services you may have written before.</span></span> <span data-ttu-id="6dff2-138">Service Fabric 提供可靠性、可用性、一致性和延展性。</span><span class="sxs-lookup"><span data-stu-id="6dff2-138">Service Fabric provides reliability, availability, consistency, and scalability.</span></span>

* <span data-ttu-id="6dff2-139">**可靠性**-您註冊服務會保持，甚至是在您的電腦失敗或叫用的網路問題的位置不可靠的環境或在其中 hello 服務本身的情況下會遇到的錯誤和損毀或失敗。</span><span class="sxs-lookup"><span data-stu-id="6dff2-139">**Reliability** - Your service stays up even in unreliable environments where your machines fail or hit network issues, or in cases where hello services themselves encounter errors and crash or fail.</span></span> <span data-ttu-id="6dff2-140">可設定狀態服務，您的狀態會保留即使在 hello 存在網路或其他失敗。</span><span class="sxs-lookup"><span data-stu-id="6dff2-140">For stateful services, your state is preserved even in hello presence of network or other failures.</span></span>
* <span data-ttu-id="6dff2-141">**可用性** - 您的服務可供存取且有回應。</span><span class="sxs-lookup"><span data-stu-id="6dff2-141">**Availability** - Your service is reachable and responsive.</span></span> <span data-ttu-id="6dff2-142">Service Fabric 會維護您所需的執行中複本數目。</span><span class="sxs-lookup"><span data-stu-id="6dff2-142">Service Fabric maintains your desired number of running copies.</span></span>
* <span data-ttu-id="6dff2-143">**延展性**-服務彼此分離時特定的硬體，以及他們可以擴張或縮小，視需要透過 hello 新增或移除硬體或其他資源。</span><span class="sxs-lookup"><span data-stu-id="6dff2-143">**Scalability** - Services are decoupled from specific hardware, and they can grow or shrink as necessary through hello addition or removal of hardware or other resources.</span></span> <span data-ttu-id="6dff2-144">服務已輕鬆地分割 （特別是在 hello 可設定狀態的情況下） tooensure hello 服務可調整且控制代碼部分失敗。</span><span class="sxs-lookup"><span data-stu-id="6dff2-144">Services are easily partitioned (especially in hello stateful case) tooensure that hello service can scale and handle partial failures.</span></span> <span data-ttu-id="6dff2-145">服務可以建立和刪除以動態方式透過程式碼，讓多個執行個體 toobe 調整大小如有必要，說出回應 toocustomer 要求。</span><span class="sxs-lookup"><span data-stu-id="6dff2-145">Services can be created and deleted dynamically via code, enabling more instances toobe spun up as necessary, say in response toocustomer requests.</span></span> <span data-ttu-id="6dff2-146">最後，Service Fabric 鼓勵服務 toobe 輕量型。</span><span class="sxs-lookup"><span data-stu-id="6dff2-146">Finally, Service Fabric encourages services toobe lightweight.</span></span> <span data-ttu-id="6dff2-147">服務網狀架構可讓數以千計的服務 toobe 佈建內單一處理序，而不需要或專用整個作業系統執行個體或處理程序 tooa 單一執行個體的服務。</span><span class="sxs-lookup"><span data-stu-id="6dff2-147">Service Fabric allows thousands of services toobe provisioned within a single process, rather than requiring or dedicating entire OS instances or processes tooa single instance of a service.</span></span>
* <span data-ttu-id="6dff2-148">**一致性**-此服務中儲存的任何資訊才能保證 toobe 一致。</span><span class="sxs-lookup"><span data-stu-id="6dff2-148">**Consistency** - Any information stored in this service can be guaranteed toobe consistent.</span></span> <span data-ttu-id="6dff2-149">即使在服務內跨越多個可靠的集合也一樣。</span><span class="sxs-lookup"><span data-stu-id="6dff2-149">This is true even across multiple reliable collections within a service.</span></span> <span data-ttu-id="6dff2-150">利用交易不可部分完成的方式，即可在服務內跨集合進行變更。</span><span class="sxs-lookup"><span data-stu-id="6dff2-150">Changes across collections within a service can be made in a transactionally atomic manner.</span></span>

## <a name="service-lifecycle"></a><span data-ttu-id="6dff2-151">服務生命週期</span><span class="sxs-lookup"><span data-stu-id="6dff2-151">Service lifecycle</span></span>
<span data-ttu-id="6dff2-152">無論您的服務是具狀態還是無狀態，Reliable Services 會提供簡單的生命週期，可讓您快速插入您的程式碼，並開始著手。</span><span class="sxs-lookup"><span data-stu-id="6dff2-152">Whether your service is stateful or stateless, Reliable Services provide a simple lifecycle that lets you quickly plug in your code and get started.</span></span>  <span data-ttu-id="6dff2-153">有只有一個或兩個方法，您需要 tooimplement tooget 您的服務啟動並執行。</span><span class="sxs-lookup"><span data-stu-id="6dff2-153">There are just one or two methods that you need tooimplement tooget your service up and running.</span></span>

* <span data-ttu-id="6dff2-154">**CreateServiceReplicaListeners/CreateServiceInstanceListeners** -這個方法是 hello 服務而定義，它想 toouse hello 通訊 stack(s)。</span><span class="sxs-lookup"><span data-stu-id="6dff2-154">**CreateServiceReplicaListeners/CreateServiceInstanceListeners** - This method is where hello service defines hello communication stack(s) that it wants toouse.</span></span> <span data-ttu-id="6dff2-155">hello 通訊堆疊，例如[Web API](service-fabric-reliable-services-communication-webapi.md)、 是所定義的 hello 接聽端點或端點 hello （如何用戶端連線 hello 服務） 的服務。</span><span class="sxs-lookup"><span data-stu-id="6dff2-155">hello communication stack, such as [Web API](service-fabric-reliable-services-communication-webapi.md), is what defines hello listening endpoint or endpoints for hello service (how clients reach hello service).</span></span> <span data-ttu-id="6dff2-156">它也會定義所顯示的 hello 訊息與 hello 其餘的 hello 服務程式碼之間的互動方式。</span><span class="sxs-lookup"><span data-stu-id="6dff2-156">It also defines how hello messages that appear interact with hello rest of hello service code.</span></span>
* <span data-ttu-id="6dff2-157">**RunAsync** -此方法，而且您的服務執行其商務邏輯，它會開始進行關閉 hello hello 服務存留期間應該執行的任何背景工作。</span><span class="sxs-lookup"><span data-stu-id="6dff2-157">**RunAsync** - This method is where your service runs its business logic, and where it would kick off any background tasks that should run for hello lifetime of hello service.</span></span> <span data-ttu-id="6dff2-158">hello 取消語彙基元提供是當該工作應該停止的信號。</span><span class="sxs-lookup"><span data-stu-id="6dff2-158">hello cancellation token that is provided is a signal for when that work should stop.</span></span> <span data-ttu-id="6dff2-159">例如，如果 hello 服務需要可靠的佇列 toopull 訊息並進行處理，這是該工作的發生位置。</span><span class="sxs-lookup"><span data-stu-id="6dff2-159">For example, if hello service needs toopull messages out of a Reliable Queue and process them, this is where that work happens.</span></span>

<span data-ttu-id="6dff2-160">如果您所學習的 hello 可靠服務第一次，閱讀 ！</span><span class="sxs-lookup"><span data-stu-id="6dff2-160">If you're learning about reliable services for hello first time, read on!</span></span> <span data-ttu-id="6dff2-161">如果您要尋找的可靠的服務的 hello 生命週期的詳細逐步解說，您可以向透過太[本文](service-fabric-reliable-services-lifecycle.md)。</span><span class="sxs-lookup"><span data-stu-id="6dff2-161">If you're looking for a detailed walkthrough of hello lifecycle of reliable services, you can head over too[this article](service-fabric-reliable-services-lifecycle.md).</span></span>

## <a name="example-services"></a><span data-ttu-id="6dff2-162">範例服務</span><span class="sxs-lookup"><span data-stu-id="6dff2-162">Example services</span></span>
<span data-ttu-id="6dff2-163">了解這個程式設計模型，讓我們快速查看兩個不同的服務 toosee 這些部分配合。</span><span class="sxs-lookup"><span data-stu-id="6dff2-163">Knowing this programming model, let's take a quick look at two different services toosee how these pieces fit together.</span></span>

### <a name="stateless-reliable-services"></a><span data-ttu-id="6dff2-164">無狀態的可靠的服務</span><span class="sxs-lookup"><span data-stu-id="6dff2-164">Stateless Reliable Services</span></span>
<span data-ttu-id="6dff2-165">無狀態服務是一個 where 沒有呼叫之間保留 hello 服務內的狀態。</span><span class="sxs-lookup"><span data-stu-id="6dff2-165">A stateless service is one where there is no state maintained within hello service across calls.</span></span> <span data-ttu-id="6dff2-166">任何已存在的狀態完全可丟棄，不需要同步處理、複寫、持續性或高可用性。</span><span class="sxs-lookup"><span data-stu-id="6dff2-166">Any state that is present is entirely disposable and doesn't require synchronization, replication, persistence, or high availability.</span></span>

<span data-ttu-id="6dff2-167">例如，請考慮沒有記憶體，一次接收所有的詞彙和作業 tooperform 計算機。</span><span class="sxs-lookup"><span data-stu-id="6dff2-167">For example, consider a calculator that has no memory and receives all terms and operations tooperform at once.</span></span>

<span data-ttu-id="6dff2-168">在此情況下，hello `RunAsync()` (C#) 或`runAsync()`(Java) 的 hello 服務可以是空白，因為沒有任何背景工作處理 hello 服務需要 toodo。</span><span class="sxs-lookup"><span data-stu-id="6dff2-168">In this case, hello `RunAsync()` (C#) or `runAsync()` (Java) of hello service can be empty, since there is no background task-processing that hello service needs toodo.</span></span> <span data-ttu-id="6dff2-169">建立 hello 計算機服務時，它會傳回`ICommunicationListener`(C#) 或`CommunicationListener`(Java) (例如[Web API](service-fabric-reliable-services-communication-webapi.md))，會開啟某些連接埠上接聽端點。</span><span class="sxs-lookup"><span data-stu-id="6dff2-169">When hello calculator service is created, it returns an `ICommunicationListener` (C#) or `CommunicationListener` (Java) (for example [Web API](service-fabric-reliable-services-communication-webapi.md)) that opens up a listening endpoint on some port.</span></span> <span data-ttu-id="6dff2-170">這個接聽端點連結 toohello 不同的計算方法 (範例: 「 新增 （n1、 n2） 」)，定義 [小算盤] hello 公用 API。</span><span class="sxs-lookup"><span data-stu-id="6dff2-170">This listening endpoint hooks up toohello different calculation methods (example: "Add(n1, n2)") that define hello calculator's public API.</span></span>

<span data-ttu-id="6dff2-171">從用戶端呼叫時，hello 適當的方法會叫用，並 hello 計算機服務 hello 上執行作業提供資料，並傳回 hello 結果的 hello。</span><span class="sxs-lookup"><span data-stu-id="6dff2-171">When a call is made from a client, hello appropriate method is invoked, and hello calculator service performs hello operations on hello data provided and returns hello result.</span></span> <span data-ttu-id="6dff2-172">它不會儲存任何狀態。</span><span class="sxs-lookup"><span data-stu-id="6dff2-172">It doesn't store any state.</span></span>

<span data-ttu-id="6dff2-173">不儲存任何內部狀態會讓此範例計算機變得較簡單。</span><span class="sxs-lookup"><span data-stu-id="6dff2-173">Not storing any internal state makes this example calculator simple.</span></span> <span data-ttu-id="6dff2-174">不過大多數服務並不是真正無狀態。</span><span class="sxs-lookup"><span data-stu-id="6dff2-174">But most services aren't truly stateless.</span></span> <span data-ttu-id="6dff2-175">相反地，它們外部化其狀態 toosome 其他存放區。</span><span class="sxs-lookup"><span data-stu-id="6dff2-175">Instead, they externalize their state toosome other store.</span></span> <span data-ttu-id="6dff2-176">(例如，任何依賴在備份存放區或快取中保留工作階段狀態的 Web 應用程式便不是無狀態)。</span><span class="sxs-lookup"><span data-stu-id="6dff2-176">(For example, any web app that relies on keeping session state in a backing store or cache is not stateless.)</span></span>

<span data-ttu-id="6dff2-177">如何在無狀態服務的常見範例用於 Service Fabric 是做為前端公開 hello 公開 API 的 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="6dff2-177">A common example of how stateless services are used in Service Fabric is as a front-end that exposes hello public-facing API for a web application.</span></span> <span data-ttu-id="6dff2-178">hello 前端服務然後交談 toostateful 服務 toocomplete 使用者要求。</span><span class="sxs-lookup"><span data-stu-id="6dff2-178">hello front-end service then talks toostateful services toocomplete a user request.</span></span> <span data-ttu-id="6dff2-179">在此情況下，用戶端的呼叫會導向的 tooa 已知連接埠 80，例如 hello 無狀態服務接聽的位置。</span><span class="sxs-lookup"><span data-stu-id="6dff2-179">In this case, calls from clients are directed tooa known port, such as 80, where hello stateless service is listening.</span></span> <span data-ttu-id="6dff2-180">此無狀態服務收到 hello 呼叫，並判斷是否 hello 呼叫是來自受信任的合作對象和它的服務以為目的端。</span><span class="sxs-lookup"><span data-stu-id="6dff2-180">This stateless service receives hello call and determines whether hello call is from a trusted party and which service it's destined for.</span></span>  <span data-ttu-id="6dff2-181">然後，hello 無狀態服務轉送 hello 呼叫 toohello 正確的資料分割的 hello 具狀態服務，並等候回應。</span><span class="sxs-lookup"><span data-stu-id="6dff2-181">Then, hello stateless service forwards hello call toohello correct partition of hello stateful service and waits for a response.</span></span> <span data-ttu-id="6dff2-182">當 hello 無狀態服務收到回應時，它會回覆 toohello 原始用戶端。</span><span class="sxs-lookup"><span data-stu-id="6dff2-182">When hello stateless service receives a response, it replies toohello original client.</span></span> <span data-ttu-id="6dff2-183">我們的 [C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) / [Java](https://github.com/Azure-Samples/service-fabric-java-getting-started/tree/master/Actors/VisualObjectActor/VisualObjectWebService) 範例中有這類服務的例子。</span><span class="sxs-lookup"><span data-stu-id="6dff2-183">An example of such a service is in our samples [C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) / [Java](https://github.com/Azure-Samples/service-fabric-java-getting-started/tree/master/Actors/VisualObjectActor/VisualObjectWebService).</span></span> <span data-ttu-id="6dff2-184">這是只有一個 hello 範例在這個模式的範例，還有其他在以及其他範例。</span><span class="sxs-lookup"><span data-stu-id="6dff2-184">This is only one example of this pattern in hello samples, there are others in other samples as well.</span></span>

### <a name="stateful-reliable-services"></a><span data-ttu-id="6dff2-185">具狀態可靠的服務</span><span class="sxs-lookup"><span data-stu-id="6dff2-185">Stateful Reliable Services</span></span>
<span data-ttu-id="6dff2-186">必須有狀態保持一致且 hello 服務 toofunction 存在的某些部分的其中一個可設定狀態的服務。</span><span class="sxs-lookup"><span data-stu-id="6dff2-186">A stateful service is one that must have some portion of state kept consistent and present in order for hello service toofunction.</span></span> <span data-ttu-id="6dff2-187">假設有一個服務不斷地根據某個值收到的更新，計算它的滾動平均。</span><span class="sxs-lookup"><span data-stu-id="6dff2-187">Consider a service that constantly computes a rolling average of some value based on updates it receives.</span></span> <span data-ttu-id="6dff2-188">toodo，它必須有 hello 的連入要求需要 tooprocess 目前資料集和 hello 目前的平均。</span><span class="sxs-lookup"><span data-stu-id="6dff2-188">toodo this, it must have hello current set of incoming requests it needs tooprocess and hello current average.</span></span> <span data-ttu-id="6dff2-189">擷取、處理並將資訊儲存在外部存放區 (例如現在的 Azure Blob 或資料表存放區) 的任何服務都是具狀態。</span><span class="sxs-lookup"><span data-stu-id="6dff2-189">Any service that retrieves, processes, and stores information in an external store (such as an Azure blob or table store today) is stateful.</span></span> <span data-ttu-id="6dff2-190">它只會 hello 外部狀態存放區中保存其狀態。</span><span class="sxs-lookup"><span data-stu-id="6dff2-190">It just keeps its state in hello external state store.</span></span>

<span data-ttu-id="6dff2-191">大部分服務今天儲存在外部，其狀態，因為 hello 外部存放區是什麼，為該狀態提供可靠性、 可用性、 延展性和一致性。</span><span class="sxs-lookup"><span data-stu-id="6dff2-191">Most services today store their state externally, since hello external store is what provides reliability, availability, scalability, and consistency for that state.</span></span> <span data-ttu-id="6dff2-192">在 Service Fabric 服務不需要的 toostore 其狀態儲存在外部。</span><span class="sxs-lookup"><span data-stu-id="6dff2-192">In Service Fabric, services aren't required toostore their state externally.</span></span> <span data-ttu-id="6dff2-193">Service Fabric 會負責 hello 服務程式碼和 hello 服務狀態的需求。</span><span class="sxs-lookup"><span data-stu-id="6dff2-193">Service Fabric takes care of these requirements for both hello service code and hello service state.</span></span>

> [!NOTE]
> <span data-ttu-id="6dff2-194">Linux 上尚不支援 Stateful Reliable Services (針對 C# 或 Java)。</span><span class="sxs-lookup"><span data-stu-id="6dff2-194">Support for Stateful Reliable Services is not available on Linux yet (for C# or Java).</span></span>
>

<span data-ttu-id="6dff2-195">例如，假設我們想要 toowrite 處理影像的服務。</span><span class="sxs-lookup"><span data-stu-id="6dff2-195">Let's say we want toowrite a service that processes images.</span></span> <span data-ttu-id="6dff2-196">toodo 此映像和 hello 轉換 tooperform 該映像上的數列中的 hello 服務採用。</span><span class="sxs-lookup"><span data-stu-id="6dff2-196">toodo this, hello service takes in an image and hello series of conversions tooperform on that image.</span></span> <span data-ttu-id="6dff2-197">此服務會傳回一個通訊接聽程式 (假設是 WebAPI)，其中公開一個像 `ConvertImage(Image i, IList<Conversion> conversions)` 的 API。</span><span class="sxs-lookup"><span data-stu-id="6dff2-197">This service returns a communication listener (let's suppose it's a WebAPI) that exposes an API like `ConvertImage(Image i, IList<Conversion> conversions)`.</span></span> <span data-ttu-id="6dff2-198">當它收到要求時，hello 服務會儲存在`IReliableQueue`，並傳回某些識別碼 toohello 用戶端，讓它能夠追蹤 hello 要求。</span><span class="sxs-lookup"><span data-stu-id="6dff2-198">When it receives a request, hello service stores it in a `IReliableQueue`, and returns some id toohello client so it can track hello request.</span></span>

<span data-ttu-id="6dff2-199">在這個服務中，`RunAsync()` 可能較為複雜。</span><span class="sxs-lookup"><span data-stu-id="6dff2-199">In this service, `RunAsync()` could be more complex.</span></span> <span data-ttu-id="6dff2-200">hello 服務有迴圈中的其`RunAsync()`的提取要求出`IReliableQueue`並執行要求的 hello 轉換。</span><span class="sxs-lookup"><span data-stu-id="6dff2-200">hello service has a loop inside its `RunAsync()` that pulls requests out of `IReliableQueue` and performs hello conversions requested.</span></span> <span data-ttu-id="6dff2-201">hello 結果取得儲存在`IReliableDictionary`以便當 hello 用戶端重新上線時，就可以取得其已轉換的映像。</span><span class="sxs-lookup"><span data-stu-id="6dff2-201">hello results get stored in an `IReliableDictionary` so that when hello client comes back they can get their converted images.</span></span> <span data-ttu-id="6dff2-202">tooensure，即使發生失敗 hello 映像不會遺失，可靠的服務會從 hello 佇列提取、 執行 hello 轉換和 hello 結果儲存在單一交易中所有。</span><span class="sxs-lookup"><span data-stu-id="6dff2-202">tooensure that even if something fails hello image isn't lost, this Reliable Service would pull out of hello queue, perform hello conversions, and store hello result all in a single transaction.</span></span> <span data-ttu-id="6dff2-203">在此情況下，從 hello 佇列中移除 hello 訊息，並只 hello 轉換完成時，將會儲存在 hello 結果字典的 hello 結果。</span><span class="sxs-lookup"><span data-stu-id="6dff2-203">In this case, hello message is removed from hello queue and hello results are stored in hello result dictionary only when hello conversions are complete.</span></span> <span data-ttu-id="6dff2-204">或者，hello 服務無法提取從 hello 佇列 hello 映像，並立即將它儲存在遠端存放區。</span><span class="sxs-lookup"><span data-stu-id="6dff2-204">Alternatively, hello service could pull hello image out of hello queue and immediately store it in a remote store.</span></span> <span data-ttu-id="6dff2-205">這會減少 hello 狀態 hello 服務數量有 toomanage，但是會增加複雜性，因為 hello 服務有 tookeep hello 必要的中繼資料 toomanage hello 遠端存放區。</span><span class="sxs-lookup"><span data-stu-id="6dff2-205">This reduces hello amount of state hello service has toomanage, but increases complexity since hello service has tookeep hello necessary metadata toomanage hello remote store.</span></span> <span data-ttu-id="6dff2-206">使用其中一個方法時，如果項目無法在 hello 中間 hello 要求會保持 hello 佇列等候 toobe 處理。</span><span class="sxs-lookup"><span data-stu-id="6dff2-206">With either approach, if something failed in hello middle hello request remains in hello queue waiting toobe processed.</span></span>

<span data-ttu-id="6dff2-207">關於這項服務的一件事 toonote 為聽起來正常的.NET 服務 ！</span><span class="sxs-lookup"><span data-stu-id="6dff2-207">One thing toonote about this service is that it sounds like a normal .NET service!</span></span> <span data-ttu-id="6dff2-208">hello 唯一的差別在於 hello 資料結構所使用 (`IReliableQueue`和`IReliableDictionary`) 所提供的服務的網狀架構，而且高度可靠、 可用，且一致。</span><span class="sxs-lookup"><span data-stu-id="6dff2-208">hello only difference is that hello data structures being used (`IReliableQueue` and `IReliableDictionary`) are provided by Service Fabric, and are highly reliable, available, and consistent.</span></span>

## <a name="when-toouse-reliable-services-apis"></a><span data-ttu-id="6dff2-209">當 toouse 可靠的服務應用程式開發介面</span><span class="sxs-lookup"><span data-stu-id="6dff2-209">When toouse Reliable Services APIs</span></span>
<span data-ttu-id="6dff2-210">如果 hello 下列任何一項描述應用程式服務的需求，您應該考慮可靠的服務 Api:</span><span class="sxs-lookup"><span data-stu-id="6dff2-210">If any of hello following characterize your application service needs, then you should consider Reliable Services APIs:</span></span>

* <span data-ttu-id="6dff2-211">您想要您的服務程式碼 （和選擇性狀態） toobe 高度可用且可靠</span><span class="sxs-lookup"><span data-stu-id="6dff2-211">You want your service's code (and optionally state) toobe highly available and reliable</span></span>
* <span data-ttu-id="6dff2-212">您需要跨多個狀態單位 (例如，訂單和訂單明細項目) 的交易式保證。</span><span class="sxs-lookup"><span data-stu-id="6dff2-212">You need transactional guarantees across multiple units of state (for example, orders and order line items).</span></span>
* <span data-ttu-id="6dff2-213">您的應用程式狀態可以自然地模型化，做為可靠的字典和佇列。</span><span class="sxs-lookup"><span data-stu-id="6dff2-213">Your application’s state can be naturally modeled as Reliable Dictionaries and Queues.</span></span>
* <span data-ttu-id="6dff2-214">您的應用程式程式碼或狀態需要 toobe 高可用性與低度延遲讀取和寫入。</span><span class="sxs-lookup"><span data-stu-id="6dff2-214">Your applications code or state needs toobe highly available with low latency reads and writes.</span></span>
* <span data-ttu-id="6dff2-215">您的應用程式需要 toocontrol hello 並行或資料粒度的交易作業，跨一或多個可靠的集合。</span><span class="sxs-lookup"><span data-stu-id="6dff2-215">Your application needs toocontrol hello concurrency or granularity of transacted operations across one or more Reliable Collections.</span></span>
* <span data-ttu-id="6dff2-216">您想 toomanage hello 通訊或資料分割配置為您的服務控制 hello。</span><span class="sxs-lookup"><span data-stu-id="6dff2-216">You want toomanage hello communications or control hello partitioning scheme for your service.</span></span>
* <span data-ttu-id="6dff2-217">您的程式碼需要無限制執行緒的執行階段環境。</span><span class="sxs-lookup"><span data-stu-id="6dff2-217">Your code needs a free-threaded runtime environment.</span></span>
* <span data-ttu-id="6dff2-218">您的應用程式需要 toodynamically 建立或終結可靠字典或佇列或整個服務在執行階段。</span><span class="sxs-lookup"><span data-stu-id="6dff2-218">Your application needs toodynamically create or destroy Reliable Dictionaries or Queues or whole Services at runtime.</span></span>
* <span data-ttu-id="6dff2-219">Tooprogrammatically 控制 Service Fabric 提供備份和還原功能所需的服務的狀態。</span><span class="sxs-lookup"><span data-stu-id="6dff2-219">You need tooprogrammatically control Service Fabric-provided backup and restore features for your service’s state.</span></span>
* <span data-ttu-id="6dff2-220">應用程式就需要其狀態的單位 toomaintain 變更歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="6dff2-220">Your application needs toomaintain change history for its units of state.</span></span>
* <span data-ttu-id="6dff2-221">您想要 toodevelop，或使用協力廠商開發的自訂狀態提供者。</span><span class="sxs-lookup"><span data-stu-id="6dff2-221">You want toodevelop or consume third-party-developed, custom state providers.</span></span>

## <a name="next-steps"></a><span data-ttu-id="6dff2-222">後續步驟</span><span class="sxs-lookup"><span data-stu-id="6dff2-222">Next steps</span></span>
* [<span data-ttu-id="6dff2-223">Reliable Services 快速入門</span><span class="sxs-lookup"><span data-stu-id="6dff2-223">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="6dff2-224">Reliable Services 的進階用法</span><span class="sxs-lookup"><span data-stu-id="6dff2-224">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
* [<span data-ttu-id="6dff2-225">hello Reliable Actors 程式設計模型</span><span class="sxs-lookup"><span data-stu-id="6dff2-225">hello Reliable Actors programming model</span></span>](service-fabric-reliable-actors-introduction.md)
