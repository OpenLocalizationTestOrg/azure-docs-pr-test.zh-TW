---
title: "Service Fabric Reliable Services 程式設計模型概觀 | Microsoft Docs"
description: "深入了解 Service Fabric 可靠的服務的程式設計模型，並開始撰寫自己的服務。"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek; mani-ramaswamy
ms.assetid: 0c88a533-73f8-4ae1-a939-67d17456ac06
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 8/9/2017
ms.author: masnider;
ms.openlocfilehash: 601b1c7713c9785d949c1c72000ec7f3f63dd682
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-overview"></a><span data-ttu-id="1fbc4-103">Reliable Services 概觀</span><span class="sxs-lookup"><span data-stu-id="1fbc4-103">Reliable Services overview</span></span>
<span data-ttu-id="1fbc4-104">Azure Service Fabric 可簡化撰寫和管理無狀態與具狀態的 Reliable Services。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-104">Azure Service Fabric simplifies writing and managing stateless and stateful Reliable Services.</span></span> <span data-ttu-id="1fbc4-105">本主題涵蓋︰</span><span class="sxs-lookup"><span data-stu-id="1fbc4-105">This topic covers:</span></span>

* <span data-ttu-id="1fbc4-106">無狀態和具狀態之服務的 Reliable Services 程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-106">The Reliable Services programming model for stateless and stateful services.</span></span>
* <span data-ttu-id="1fbc4-107">撰寫 Reliable Services 時必須進行的選擇。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-107">The choices you have to make when writing a Reliable Service.</span></span>
* <span data-ttu-id="1fbc4-108">Reliable Services 使用時機及撰寫方式的一些案例和範例。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-108">Some scenarios and examples of when to use Reliable Services and how they are written.</span></span>

<span data-ttu-id="1fbc4-109">可靠的服務是 Service Fabric 上可用的其中一種程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-109">Reliable Services is one of the programming models available on Service Fabric.</span></span> <span data-ttu-id="1fbc4-110">另一個是 Reliable Actor 程式設計模型，提供一個以 Reliable Services 模型為基礎的虛擬「執行者」程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-110">The other is the Reliable Actor programming model, which provides a virtual Actor programming model on top of the Reliable Services model.</span></span> <span data-ttu-id="1fbc4-111">如需 Reliable Actors 程式設計模型的詳細資訊，請參閱 [Service Fabric Reliable Actors 簡介](service-fabric-reliable-actors-introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-111">For more information on the Reliable Actors programming model, see [Introduction to Service Fabric Reliable Actors](service-fabric-reliable-actors-introduction.md).</span></span>

<span data-ttu-id="1fbc4-112">Service Fabric 透過 [Service Fabric 應用程式管理](service-fabric-deploy-remove-applications.md)管理服務的存留期間，從佈建和部署一直到升級和刪除。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-112">Service Fabric manages the lifetime of services, from provisioning and deployment through upgrade and deletion, via [Service Fabric application management](service-fabric-deploy-remove-applications.md).</span></span>

## <a name="what-are-reliable-services"></a><span data-ttu-id="1fbc4-113">什麼是 Reliable Services？</span><span class="sxs-lookup"><span data-stu-id="1fbc4-113">What are Reliable Services?</span></span>
<span data-ttu-id="1fbc4-114">Reliable Service 提供您簡易、功能強大、最高階的程式設計模型，以協助您針對應用程式的重要項目進行表達。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-114">Reliable Services gives you a simple, powerful, top-level programming model to help you express what is important to your application.</span></span> <span data-ttu-id="1fbc4-115">使用 Reliable Services 程式設計模型，您會得到：</span><span class="sxs-lookup"><span data-stu-id="1fbc4-115">With the Reliable Services programming model, you get:</span></span>

* <span data-ttu-id="1fbc4-116">存取其餘的 Service Fabric 程式設計 API。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-116">Access to the rest of the Service Fabric programming APIs.</span></span> <span data-ttu-id="1fbc4-117">不同於模型化為[來賓可執行檔](service-fabric-deploy-existing-app.md)的 Service Fabric 服務，Reliable Services 會直接使用其餘的 Service Fabric API。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-117">Unlike Service Fabric Services modeled as [Guest Executables](service-fabric-deploy-existing-app.md), Reliable Services get to use the rest of the Service Fabric APIs directly.</span></span> <span data-ttu-id="1fbc4-118">如此可讓服務︰</span><span class="sxs-lookup"><span data-stu-id="1fbc4-118">This allows services to:</span></span>
  * <span data-ttu-id="1fbc4-119">查詢系統</span><span class="sxs-lookup"><span data-stu-id="1fbc4-119">query the system</span></span>
  * <span data-ttu-id="1fbc4-120">報告有關叢集中之實體的健全狀況</span><span class="sxs-lookup"><span data-stu-id="1fbc4-120">report health about entities in the cluster</span></span>
  * <span data-ttu-id="1fbc4-121">接收有關設定和程式碼變更的通知</span><span class="sxs-lookup"><span data-stu-id="1fbc4-121">receive notifications about configuration and code changes</span></span>
  * <span data-ttu-id="1fbc4-122">尋找其他服務而與之通訊，</span><span class="sxs-lookup"><span data-stu-id="1fbc4-122">find and communicate with other services,</span></span>
  * <span data-ttu-id="1fbc4-123">(選擇性) 使用[可靠的集合](service-fabric-reliable-services-reliable-collections.md)</span><span class="sxs-lookup"><span data-stu-id="1fbc4-123">(optionally) use the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md)</span></span>
  * <span data-ttu-id="1fbc4-124">...讓它們存取許多其他功能，全都來自一流的程式設計模型，且支援多種程式設計語言。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-124">...and giving them access to many other capabilities, all from a first class programming model in several programming languages.</span></span>
* <span data-ttu-id="1fbc4-125">類似您所習慣使用之程式設計模型的簡單模型，以便執行您自己的程式碼。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-125">A simple model for running your own code that looks like programming models you are used to.</span></span> <span data-ttu-id="1fbc4-126">您的程式碼會具有定義完善的切入點和容易管理的生命週期。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-126">Your code has a well-defined entry point and easily managed lifecycle.</span></span>
* <span data-ttu-id="1fbc4-127">隨插即用的通訊模型。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-127">A pluggable communication model.</span></span> <span data-ttu-id="1fbc4-128">使用您選擇的傳輸方式，例如 HTTP 搭配 [Web API](service-fabric-reliable-services-communication-webapi.md)、WebSockets、自訂 TCP 通訊協定等。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-128">Use the transport of your choice, such as HTTP with [Web API](service-fabric-reliable-services-communication-webapi.md), WebSockets, custom TCP protocols, or anything else.</span></span> <span data-ttu-id="1fbc4-129">Reliable Services 提供一些很棒的現成選項供您使用，或者您可以提供您自己的選項。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-129">Reliable Services provide some great out-of-the-box options you can use, or you can provide your own.</span></span>
* <span data-ttu-id="1fbc4-130">對於具狀態服務，Reliable Services 程式設計模型可讓您使用[可靠的集合](service-fabric-reliable-services-reliable-collections.md)，直接在服務內以一致且可靠地方式儲存狀態。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-130">For stateful services, the Reliable Services programming model allows you to consistently and reliably store your state right inside your service by using [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="1fbc4-131">可靠的集合是一組簡單的高可用性和可靠的集合類別，用過 C# 集合的任何人都會很熟悉。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-131">Reliable Collections are a simple set of highly available and reliable collection classes that will be familiar to anyone who has used C# collections.</span></span> <span data-ttu-id="1fbc4-132">傳統上，服務需要外部系統來進行可靠狀態管理。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-132">Traditionally, services needed external systems for Reliable state management.</span></span> <span data-ttu-id="1fbc4-133">有了可靠的集合，您可以將狀態儲存在您的計算旁邊，並且具有您預期高度可用的外部存放區會具備的相同高可用性和可靠性。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-133">With Reliable Collections, you can store your state next to your compute with the same high availability and reliability you've come to expect from highly available external stores.</span></span> <span data-ttu-id="1fbc4-134">此模型也可以改善延遲，因為計算及其運作所需的狀態都在一起。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-134">This model also improves latency because you are co-locating the compute and state it needs to function.</span></span>

<span data-ttu-id="1fbc4-135">觀看此 Microsoft Virtual Academy 影片以取得 Reliable Services 概觀︰<center>
<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=HhD9566yC_4106218965">
<img src="./media/service-fabric-reliable-services-introduction/ReliableServicesVid.png" WIDTH="360" HEIGHT="244" />
</a>
</center></span><span class="sxs-lookup"><span data-stu-id="1fbc4-135">Watch this Microsoft Virtual Academy video for an overview of Reliable services: <center>
<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=HhD9566yC_4106218965">
<img src="./media/service-fabric-reliable-services-introduction/ReliableServicesVid.png" WIDTH="360" HEIGHT="244" />
</a>
</center></span></span>

## <a name="what-makes-reliable-services-different"></a><span data-ttu-id="1fbc4-136">Reliable Services 有什麼不同之處？</span><span class="sxs-lookup"><span data-stu-id="1fbc4-136">What makes Reliable Services different?</span></span>
<span data-ttu-id="1fbc4-137">Service Fabric 中的可靠的服務與您之前撰寫的服務不同。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-137">Reliable Services in Service Fabric are different from services you may have written before.</span></span> <span data-ttu-id="1fbc4-138">Service Fabric 提供可靠性、可用性、一致性和延展性。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-138">Service Fabric provides reliability, availability, consistency, and scalability.</span></span>

* <span data-ttu-id="1fbc4-139">**可靠性** - 即使在不可靠的環境中，您的電腦故障或發生網路問題，或在服務本身遇到錯誤及損毀或失敗的情況下，您的服務仍然可以運作。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-139">**Reliability** - Your service stays up even in unreliable environments where your machines fail or hit network issues, or in cases where the services themselves encounter errors and crash or fail.</span></span> <span data-ttu-id="1fbc4-140">對於具狀態服務，即使發生網路或其他失敗，也會保留您的狀態。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-140">For stateful services, your state is preserved even in the presence of network or other failures.</span></span>
* <span data-ttu-id="1fbc4-141">**可用性** - 您的服務可供存取且有回應。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-141">**Availability** - Your service is reachable and responsive.</span></span> <span data-ttu-id="1fbc4-142">Service Fabric 會維護您所需的執行中複本數目。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-142">Service Fabric maintains your desired number of running copies.</span></span>
* <span data-ttu-id="1fbc4-143">**延展性** - 服務與特定硬體分離，可以視需要透過加入或移除硬體或其他資源而成長或壓縮。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-143">**Scalability** - Services are decoupled from specific hardware, and they can grow or shrink as necessary through the addition or removal of hardware or other resources.</span></span> <span data-ttu-id="1fbc4-144">服務可以輕鬆分割 (特別是在具狀態的情況下)，以確保服務可以調整和處理局部失敗。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-144">Services are easily partitioned (especially in the stateful case) to ensure that the service can scale and handle partial failures.</span></span> <span data-ttu-id="1fbc4-145">服務可以透過程式碼來動態建立和刪除，以依需要啟動更多執行個體，例如為了回應客戶要求。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-145">Services can be created and deleted dynamically via code, enabling more instances to be spun up as necessary, say in response to customer requests.</span></span> <span data-ttu-id="1fbc4-146">最後，Service Fabric 建議使用輕量型的服務。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-146">Finally, Service Fabric encourages services to be lightweight.</span></span> <span data-ttu-id="1fbc4-147">Service Fabric 允許在單一處理序內佈建數千個服務，而不需要或讓整個作業系統的執行個體或處理序專用於服務的單一執行個體。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-147">Service Fabric allows thousands of services to be provisioned within a single process, rather than requiring or dedicating entire OS instances or processes to a single instance of a service.</span></span>
* <span data-ttu-id="1fbc4-148">**一致性** - 此服務中儲存任何資訊保證一致。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-148">**Consistency** - Any information stored in this service can be guaranteed to be consistent.</span></span> <span data-ttu-id="1fbc4-149">即使在服務內跨越多個可靠的集合也一樣。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-149">This is true even across multiple reliable collections within a service.</span></span> <span data-ttu-id="1fbc4-150">利用交易不可部分完成的方式，即可在服務內跨集合進行變更。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-150">Changes across collections within a service can be made in a transactionally atomic manner.</span></span>

## <a name="service-lifecycle"></a><span data-ttu-id="1fbc4-151">服務生命週期</span><span class="sxs-lookup"><span data-stu-id="1fbc4-151">Service lifecycle</span></span>
<span data-ttu-id="1fbc4-152">無論您的服務是具狀態還是無狀態，Reliable Services 會提供簡單的生命週期，可讓您快速插入您的程式碼，並開始著手。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-152">Whether your service is stateful or stateless, Reliable Services provide a simple lifecycle that lets you quickly plug in your code and get started.</span></span>  <span data-ttu-id="1fbc4-153">您只需要實作一個或兩個方法，即可讓您的服務啟動並執行。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-153">There are just one or two methods that you need to implement to get your service up and running.</span></span>

* <span data-ttu-id="1fbc4-154">**CreateServiceReplicaListeners/CreateServiceInstanceListeners** - 服務在此方法中定義它想要使用的通訊堆疊。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-154">**CreateServiceReplicaListeners/CreateServiceInstanceListeners** - This method is where the service defines the communication stack(s) that it wants to use.</span></span> <span data-ttu-id="1fbc4-155">通訊堆疊 (例如 [Web API](service-fabric-reliable-services-communication-webapi.md)) 定義服務的一或多個接聽端點 (用戶端如何存取服務)。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-155">The communication stack, such as [Web API](service-fabric-reliable-services-communication-webapi.md), is what defines the listening endpoint or endpoints for the service (how clients reach the service).</span></span> <span data-ttu-id="1fbc4-156">它也定義出現的訊息如何與服務程式碼的其餘部分互動。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-156">It also defines how the messages that appear interact with the rest of the service code.</span></span>
* <span data-ttu-id="1fbc4-157">**RunAsync** - 服務在此方法中執行其商務邏輯，也在此處啟動應該在服務存留期執行的任何背景工作。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-157">**RunAsync** - This method is where your service runs its business logic, and where it would kick off any background tasks that should run for the lifetime of the service.</span></span> <span data-ttu-id="1fbc4-158">所提供的取消語彙基元是針對該工作何時應該停止的訊號。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-158">The cancellation token that is provided is a signal for when that work should stop.</span></span> <span data-ttu-id="1fbc4-159">比方說，如果服務需要從可靠的佇列提取訊息並加以處理，這就是執行這項工作的地方。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-159">For example, if the service needs to pull messages out of a Reliable Queue and process them, this is where that work happens.</span></span>

<span data-ttu-id="1fbc4-160">如果您是第一次來了解 Reliable Services，請繼續閱讀！</span><span class="sxs-lookup"><span data-stu-id="1fbc4-160">If you're learning about reliable services for the first time, read on!</span></span> <span data-ttu-id="1fbc4-161">如果想要尋找 Reliable Services 留存期的詳細逐步解說，您可以閱讀[這篇文章](service-fabric-reliable-services-lifecycle.md)。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-161">If you're looking for a detailed walkthrough of the lifecycle of reliable services, you can head over to [this article](service-fabric-reliable-services-lifecycle.md).</span></span>

## <a name="example-services"></a><span data-ttu-id="1fbc4-162">範例服務</span><span class="sxs-lookup"><span data-stu-id="1fbc4-162">Example services</span></span>
<span data-ttu-id="1fbc4-163">了解這個程式設計模型之後，讓我們來快速看看兩個不同的服務，了解這些部分如何彼此搭配運作。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-163">Knowing this programming model, let's take a quick look at two different services to see how these pieces fit together.</span></span>

### <a name="stateless-reliable-services"></a><span data-ttu-id="1fbc4-164">無狀態的可靠的服務</span><span class="sxs-lookup"><span data-stu-id="1fbc4-164">Stateless Reliable Services</span></span>
<span data-ttu-id="1fbc4-165">無狀態服務是指在服務內不維護呼叫之間的狀態。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-165">A stateless service is one where there is no state maintained within the service across calls.</span></span> <span data-ttu-id="1fbc4-166">任何已存在的狀態完全可丟棄，不需要同步處理、複寫、持續性或高可用性。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-166">Any state that is present is entirely disposable and doesn't require synchronization, replication, persistence, or high availability.</span></span>

<span data-ttu-id="1fbc4-167">例如，想想沒有記憶體且會接收要一次執行之所有項和作業的計算機。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-167">For example, consider a calculator that has no memory and receives all terms and operations to perform at once.</span></span>

<span data-ttu-id="1fbc4-168">在此情況下，服務的 `RunAsync()` (C#) 或 `runAsync()` (Java) 可以是空的，因為沒有服務需要進行的背景工作處理。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-168">In this case, the `RunAsync()` (C#) or `runAsync()` (Java) of the service can be empty, since there is no background task-processing that the service needs to do.</span></span> <span data-ttu-id="1fbc4-169">建立計算機服務時，它會傳回 `ICommunicationListener` (C#) 或 `CommunicationListener` (Java) (例如 [Web API](service-fabric-reliable-services-communication-webapi.md))，而這會在某個連接埠上開啟接聽端點。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-169">When the calculator service is created, it returns an `ICommunicationListener` (C#) or `CommunicationListener` (Java) (for example [Web API](service-fabric-reliable-services-communication-webapi.md)) that opens up a listening endpoint on some port.</span></span> <span data-ttu-id="1fbc4-170">此接聽端點會連結到不同的計算方法 (範例："Add(n1, n2)")，這些方法定義計算機的公用 API。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-170">This listening endpoint hooks up to the different calculation methods (example: "Add(n1, n2)") that define the calculator's public API.</span></span>

<span data-ttu-id="1fbc4-171">從用戶端進行呼叫時，會叫用適當的方法，且計算機服務會在所提供的資料上執行作業，並傳回結果。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-171">When a call is made from a client, the appropriate method is invoked, and the calculator service performs the operations on the data provided and returns the result.</span></span> <span data-ttu-id="1fbc4-172">它不會儲存任何狀態。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-172">It doesn't store any state.</span></span>

<span data-ttu-id="1fbc4-173">不儲存任何內部狀態會讓此範例計算機變得較簡單。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-173">Not storing any internal state makes this example calculator simple.</span></span> <span data-ttu-id="1fbc4-174">不過大多數服務並不是真正無狀態。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-174">But most services aren't truly stateless.</span></span> <span data-ttu-id="1fbc4-175">相反地，它們是將狀態外部化到其他某些存放區 </span><span class="sxs-lookup"><span data-stu-id="1fbc4-175">Instead, they externalize their state to some other store.</span></span> <span data-ttu-id="1fbc4-176">(例如，任何依賴在備份存放區或快取中保留工作階段狀態的 Web 應用程式便不是無狀態)。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-176">(For example, any web app that relies on keeping session state in a backing store or cache is not stateless.)</span></span>

<span data-ttu-id="1fbc4-177">Service Fabric 中常見的無狀態服務使用範例是做為前端，其公開 Web 應用程式的公用 API。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-177">A common example of how stateless services are used in Service Fabric is as a front-end that exposes the public-facing API for a web application.</span></span> <span data-ttu-id="1fbc4-178">前端服務接著和具狀態服務交談，以完成使用者的要求。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-178">The front-end service then talks to stateful services to complete a user request.</span></span> <span data-ttu-id="1fbc4-179">在此情況下，用戶端的呼叫會導向至無狀態服務接聽的已知連接埠 (例如 80)。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-179">In this case, calls from clients are directed to a known port, such as 80, where the stateless service is listening.</span></span> <span data-ttu-id="1fbc4-180">這個無狀態服務收到呼叫，並判斷呼叫是否來自受信任的合作對象，以及其預定為哪些服務。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-180">This stateless service receives the call and determines whether the call is from a trusted party and which service it's destined for.</span></span>  <span data-ttu-id="1fbc4-181">然後，無狀態服務將呼叫轉送至正確的具狀態服務分割，並等候回應。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-181">Then, the stateless service forwards the call to the correct partition of the stateful service and waits for a response.</span></span> <span data-ttu-id="1fbc4-182">當無狀態服務收到回應時，它會回覆原始用戶端。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-182">When the stateless service receives a response, it replies to the original client.</span></span> <span data-ttu-id="1fbc4-183">我們的 [C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) / [Java](https://github.com/Azure-Samples/service-fabric-java-getting-started/tree/master/Actors/VisualObjectActor/VisualObjectWebService) 範例中有這類服務的例子。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-183">An example of such a service is in our samples [C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) / [Java](https://github.com/Azure-Samples/service-fabric-java-getting-started/tree/master/Actors/VisualObjectActor/VisualObjectWebService).</span></span> <span data-ttu-id="1fbc4-184">這只是範例中這種模式的其中一個例子，其他範例中還有其他例子。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-184">This is only one example of this pattern in the samples, there are others in other samples as well.</span></span>

### <a name="stateful-reliable-services"></a><span data-ttu-id="1fbc4-185">具狀態可靠的服務</span><span class="sxs-lookup"><span data-stu-id="1fbc4-185">Stateful Reliable Services</span></span>
<span data-ttu-id="1fbc4-186">具狀態服務必須有某部分的狀態保持一致且存在，服務才能運作。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-186">A stateful service is one that must have some portion of state kept consistent and present in order for the service to function.</span></span> <span data-ttu-id="1fbc4-187">假設有一個服務不斷地根據某個值收到的更新，計算它的滾動平均。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-187">Consider a service that constantly computes a rolling average of some value based on updates it receives.</span></span> <span data-ttu-id="1fbc4-188">若要這樣做，它必須擁有目前需要處理的連入要求集，以及目前的平均。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-188">To do this, it must have the current set of incoming requests it needs to process and the current average.</span></span> <span data-ttu-id="1fbc4-189">擷取、處理並將資訊儲存在外部存放區 (例如現在的 Azure Blob 或資料表存放區) 的任何服務都是具狀態。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-189">Any service that retrieves, processes, and stores information in an external store (such as an Azure blob or table store today) is stateful.</span></span> <span data-ttu-id="1fbc4-190">它只將狀態保留在外部狀態存放區中。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-190">It just keeps its state in the external state store.</span></span>

<span data-ttu-id="1fbc4-191">現在的大部分服務會在外部儲存其狀態，因為外部存放區為該狀態提供可靠性、可用性、延展性和一致性。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-191">Most services today store their state externally, since the external store is what provides reliability, availability, scalability, and consistency for that state.</span></span> <span data-ttu-id="1fbc4-192">在 Service Fabric 中，服務不需要將狀態儲存在外部。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-192">In Service Fabric, services aren't required to store their state externally.</span></span> <span data-ttu-id="1fbc4-193">Service Fabric 會為服務程式碼和服務狀態來處理這些需求。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-193">Service Fabric takes care of these requirements for both the service code and the service state.</span></span>

> [!NOTE]
> <span data-ttu-id="1fbc4-194">Linux 上尚不支援 Stateful Reliable Services (針對 C# 或 Java)。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-194">Support for Stateful Reliable Services is not available on Linux yet (for C# or Java).</span></span>
>

<span data-ttu-id="1fbc4-195">假設我們想要撰寫一個處理映像的服務。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-195">Let's say we want to write a service that processes images.</span></span> <span data-ttu-id="1fbc4-196">在做法上，這個服務需要取得映像和要在該映像上執行的一系列轉換。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-196">To do this, the service takes in an image and the series of conversions to perform on that image.</span></span> <span data-ttu-id="1fbc4-197">此服務會傳回一個通訊接聽程式 (假設是 WebAPI)，其中公開一個像 `ConvertImage(Image i, IList<Conversion> conversions)` 的 API。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-197">This service returns a communication listener (let's suppose it's a WebAPI) that exposes an API like `ConvertImage(Image i, IList<Conversion> conversions)`.</span></span> <span data-ttu-id="1fbc4-198">當它收到要求時，服務會將它儲存在 `IReliableQueue` 中，並將某個識別碼傳回給用戶端，讓它能夠追蹤要求。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-198">When it receives a request, the service stores it in a `IReliableQueue`, and returns some id to the client so it can track the request.</span></span>

<span data-ttu-id="1fbc4-199">在這個服務中，`RunAsync()` 可能較為複雜。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-199">In this service, `RunAsync()` could be more complex.</span></span> <span data-ttu-id="1fbc4-200">服務的 `RunAsync()` 內有一個迴圈會從 `IReliableQueue` 提取要求，並執行所要求的轉換。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-200">The service has a loop inside its `RunAsync()` that pulls requests out of `IReliableQueue` and performs the conversions requested.</span></span> <span data-ttu-id="1fbc4-201">結果會儲存在 `IReliableDictionary` 中，當用戶端回來時，便可取得轉換後的映像。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-201">The results get stored in an `IReliableDictionary` so that when the client comes back they can get their converted images.</span></span> <span data-ttu-id="1fbc4-202">為了確保即使發生失敗，也不會遺失映像，這個 Reliable Services 會從佇列提取、執行轉換，並將整個結果儲存在單一交易中。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-202">To ensure that even if something fails the image isn't lost, this Reliable Service would pull out of the queue, perform the conversions, and store the result all in a single transaction.</span></span> <span data-ttu-id="1fbc4-203">在此情況下，只有在轉換完成時，才會從佇列移除訊息並將結果儲存在結果字典中。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-203">In this case, the message is removed from the queue and the results are stored in the result dictionary only when the conversions are complete.</span></span> <span data-ttu-id="1fbc4-204">或者，服務也可能從佇列提取映像，並立即將它儲存在遠端存放區。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-204">Alternatively, the service could pull the image out of the queue and immediately store it in a remote store.</span></span> <span data-ttu-id="1fbc4-205">這樣可以減少服務必須管理的狀態，但會增加複雜性，因為服務必須保留必要的中繼資料，以管理遠端存放區。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-205">This reduces the amount of state the service has to manage, but increases complexity since the service has to keep the necessary metadata to manage the remote store.</span></span> <span data-ttu-id="1fbc4-206">不論採取何種方法，如果中途發生失敗，要求會保留在佇列中等候處理。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-206">With either approach, if something failed in the middle the request remains in the queue waiting to be processed.</span></span>

<span data-ttu-id="1fbc4-207">關於這個服務，請注意一件事，它聽起來像是一般的 .NET 服務！</span><span class="sxs-lookup"><span data-stu-id="1fbc4-207">One thing to note about this service is that it sounds like a normal .NET service!</span></span> <span data-ttu-id="1fbc4-208">唯一的差別在於使用的資料結構 (`IReliableQueue` 和 `IReliableDictionary`) 是由 Service Fabric 提供，可靠性、可用性和一致性都很高。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-208">The only difference is that the data structures being used (`IReliableQueue` and `IReliableDictionary`) are provided by Service Fabric, and are highly reliable, available, and consistent.</span></span>

## <a name="when-to-use-reliable-services-apis"></a><span data-ttu-id="1fbc4-209">使用 Reliable Services API 的時機</span><span class="sxs-lookup"><span data-stu-id="1fbc4-209">When to use Reliable Services APIs</span></span>
<span data-ttu-id="1fbc4-210">如果下列任何一項描述出您的應用程式服務需求，那麼便應該考慮 Reliable Services API：</span><span class="sxs-lookup"><span data-stu-id="1fbc4-210">If any of the following characterize your application service needs, then you should consider Reliable Services APIs:</span></span>

* <span data-ttu-id="1fbc4-211">您希望服務的程式碼 (也許還有狀態) 具有高可用性和可靠性</span><span class="sxs-lookup"><span data-stu-id="1fbc4-211">You want your service's code (and optionally state) to be highly available and reliable</span></span>
* <span data-ttu-id="1fbc4-212">您需要跨多個狀態單位 (例如，訂單和訂單明細項目) 的交易式保證。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-212">You need transactional guarantees across multiple units of state (for example, orders and order line items).</span></span>
* <span data-ttu-id="1fbc4-213">您的應用程式狀態可以自然地模型化，做為可靠的字典和佇列。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-213">Your application’s state can be naturally modeled as Reliable Dictionaries and Queues.</span></span>
* <span data-ttu-id="1fbc4-214">應用程式的程式碼或狀態需要具有高可用性，以及較低的讀取和寫入延遲性。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-214">Your applications code or state needs to be highly available with low latency reads and writes.</span></span>
* <span data-ttu-id="1fbc4-215">您的應用程式必須跨越一個或多個可靠的集合，控制交易作業的並行處理或資料粒度。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-215">Your application needs to control the concurrency or granularity of transacted operations across one or more Reliable Collections.</span></span>
* <span data-ttu-id="1fbc4-216">您想要管理通訊或控制服務的資料分割配置。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-216">You want to manage the communications or control the partitioning scheme for your service.</span></span>
* <span data-ttu-id="1fbc4-217">您的程式碼需要無限制執行緒的執行階段環境。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-217">Your code needs a free-threaded runtime environment.</span></span>
* <span data-ttu-id="1fbc4-218">您的應用程式需要在執行階段動態建立或終結可靠的字典或佇列，或整個服務。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-218">Your application needs to dynamically create or destroy Reliable Dictionaries or Queues or whole Services at runtime.</span></span>
* <span data-ttu-id="1fbc4-219">您需要以程式設計方式為服務的狀態控制 Service Fabric 提供的備份和還原功能。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-219">You need to programmatically control Service Fabric-provided backup and restore features for your service’s state.</span></span>
* <span data-ttu-id="1fbc4-220">您的應用程式需要維護其狀態單位的變更歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-220">Your application needs to maintain change history for its units of state.</span></span>
* <span data-ttu-id="1fbc4-221">您想要開發或使用協力廠商開發的自訂狀態提供器。</span><span class="sxs-lookup"><span data-stu-id="1fbc4-221">You want to develop or consume third-party-developed, custom state providers.</span></span>

## <a name="next-steps"></a><span data-ttu-id="1fbc4-222">後續步驟</span><span class="sxs-lookup"><span data-stu-id="1fbc4-222">Next steps</span></span>
* [<span data-ttu-id="1fbc4-223">Reliable Services 快速入門</span><span class="sxs-lookup"><span data-stu-id="1fbc4-223">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="1fbc4-224">Reliable Services 的進階用法</span><span class="sxs-lookup"><span data-stu-id="1fbc4-224">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
* [<span data-ttu-id="1fbc4-225">Reliable Actors 程式設計模型</span><span class="sxs-lookup"><span data-stu-id="1fbc4-225">The Reliable Actors programming model</span></span>](service-fabric-reliable-actors-introduction.md)
