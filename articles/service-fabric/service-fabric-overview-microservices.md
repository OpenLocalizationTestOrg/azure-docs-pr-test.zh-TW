---
title: "Azure 上的微服務簡介 | Microsoft Docs"
description: "概述在現代應用程式開發中，為何使用微服務方法建置雲端應用程式很重要，以及 Azure Service Fabric 如何提供平台以達成此目標。"
services: service-fabric
documentationcenter: .net
author: msfussell
manager: timlt
editor: 
ms.assetid: fae2be85-0ab4-4cd3-9d1f-e0d95fe1959b
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 07/02/2017
ms.author: msfussell
ms.openlocfilehash: 53c142217c67465d29fa413f4edb4f96fcb4c6cc
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/03/2017
---
# <a name="why-a-microservices-approach-to-building-applications"></a><span data-ttu-id="d469b-103">為何要用微服務方式建置應用程式？</span><span class="sxs-lookup"><span data-stu-id="d469b-103">Why a microservices approach to building applications?</span></span>
<span data-ttu-id="d469b-104">身為軟體開發人員，已熟悉思考如何將應用程式分解成元件部分。</span><span class="sxs-lookup"><span data-stu-id="d469b-104">As software developers, there is nothing new in how we think about factoring an application into component parts.</span></span> <span data-ttu-id="d469b-105">它是物件導向、軟體抽象化和元件化的中心範型。</span><span class="sxs-lookup"><span data-stu-id="d469b-105">It is the central paradigm of object orientation, software abstractions, and componentization.</span></span> <span data-ttu-id="d469b-106">現在，這種分解經常以共用程式庫和技術層之間的類別與介面呈現。</span><span class="sxs-lookup"><span data-stu-id="d469b-106">Today, this factorization tends to take the form of classes and interfaces between shared libraries and technology layers.</span></span> <span data-ttu-id="d469b-107">通常是透過一種分層方法，有後端存放區、中間層商務邏輯和前端使用者介面 (UI)。</span><span class="sxs-lookup"><span data-stu-id="d469b-107">Typically, a tiered approach is taken with a back-end store, middle-tier business logic, and a front-end user interface (UI).</span></span> <span data-ttu-id="d469b-108">過去幾年來的變化  是身為開發人員的我們，開始為商業驅動和雲端建置分散式應用程式。</span><span class="sxs-lookup"><span data-stu-id="d469b-108">What *has* changed over the last few years is that we, as developers, are building distributed applications that are for the cloud and driven by the business.</span></span>

<span data-ttu-id="d469b-109">變更的商務需求包括：</span><span class="sxs-lookup"><span data-stu-id="d469b-109">The changing business needs are:</span></span>

* <span data-ttu-id="d469b-110">大規模建立和運作的服務，以便觸達新地理區域中的客戶 (舉例來說)。</span><span class="sxs-lookup"><span data-stu-id="d469b-110">A service that's built and operates at scale to reach customers in new geographical regions (for example).</span></span>
* <span data-ttu-id="d469b-111">更快速提供特色與功能，靈活地回應客戶的需求。</span><span class="sxs-lookup"><span data-stu-id="d469b-111">Faster delivery of features and capabilities to be able to respond to customer demands in an agile way.</span></span>
* <span data-ttu-id="d469b-112">提高資源使用率來降低成本。</span><span class="sxs-lookup"><span data-stu-id="d469b-112">Improved resource utilization to reduce costs.</span></span>

<span data-ttu-id="d469b-113">這些商務需求會影響我們「如何」  建置應用程式。</span><span class="sxs-lookup"><span data-stu-id="d469b-113">These business needs are affecting *how* we build applications.</span></span>

<span data-ttu-id="d469b-114">如需 Azure 使用微服務之方式的詳細資訊，請參閱 [Microservices: An application revolution powered by the cloud (微服務︰採用雲端技術的應用程式革命)](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)。</span><span class="sxs-lookup"><span data-stu-id="d469b-114">For more information about the approach of Azure to microservices, read [Microservices: An application revolution powered by the cloud](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/).</span></span>

## <a name="monolithic-vs-microservice-design-approach"></a><span data-ttu-id="d469b-115">單體式與微服務設計方法</span><span class="sxs-lookup"><span data-stu-id="d469b-115">Monolithic vs. microservice design approach</span></span>
<span data-ttu-id="d469b-116">所有應用程式會隨著時間而演化。</span><span class="sxs-lookup"><span data-stu-id="d469b-116">All applications evolve over time.</span></span> <span data-ttu-id="d469b-117">成功的應用程式因為有實用性而演化。</span><span class="sxs-lookup"><span data-stu-id="d469b-117">Successful applications evolve by being useful to people.</span></span> <span data-ttu-id="d469b-118">失敗的應用程式不會演化，最後會取代。</span><span class="sxs-lookup"><span data-stu-id="d469b-118">Unsuccessful applications do not evolve and eventually are deprecated.</span></span> <span data-ttu-id="d469b-119">問題在於：您現在對需求了解多少，以及未來有何變化？</span><span class="sxs-lookup"><span data-stu-id="d469b-119">The question becomes: How much do you know about your requirements today, and what will they be in the future?</span></span> <span data-ttu-id="d469b-120">例如，假設您要建置某部門的報告應用程式。</span><span class="sxs-lookup"><span data-stu-id="d469b-120">For example, let's say that you are building a reporting application for a department.</span></span> <span data-ttu-id="d469b-121">您確定該應用程式會在您的公司範圍內，並且報告為短期報告。</span><span class="sxs-lookup"><span data-stu-id="d469b-121">You are sure that the application remains within the scope of your company and that the reports are short-lived.</span></span> <span data-ttu-id="d469b-122">那麼，您選擇的方法就會與要建置將視訊內容傳遞給數千萬客戶的服務不同。</span><span class="sxs-lookup"><span data-stu-id="d469b-122">Your choice of approach is different from, say, building a service that delivers video content to tens of millions of customers.</span></span> 

<span data-ttu-id="d469b-123">在已知後來可以重新設計應用程式的情況下，有時向外尋求概念證明才是驅動因素。</span><span class="sxs-lookup"><span data-stu-id="d469b-123">Sometimes, getting something out the door as proof of concept is the driving factor, while you know that the application can be redesigned later.</span></span> <span data-ttu-id="d469b-124">從來不用卻過度設計並沒有太大意義。</span><span class="sxs-lookup"><span data-stu-id="d469b-124">There is little point in over-engineering something that never gets used.</span></span> <span data-ttu-id="d469b-125">這就是一般所謂的工程取捨。</span><span class="sxs-lookup"><span data-stu-id="d469b-125">It’s the usual engineering trade-off.</span></span> <span data-ttu-id="d469b-126">另一方面，公司談論建置雲端時都會期望成長和使用量。</span><span class="sxs-lookup"><span data-stu-id="d469b-126">On the other hand, when companies talk about building for the cloud, the expectation is growth and usage.</span></span> <span data-ttu-id="d469b-127">問題在於無法預期成長和範圍。</span><span class="sxs-lookup"><span data-stu-id="d469b-127">The issue is that growth and scale are unpredictable.</span></span> <span data-ttu-id="d469b-128">我們想要能夠迅速建立原型，同時還要了解我們正在通往未來成功的路徑上。</span><span class="sxs-lookup"><span data-stu-id="d469b-128">We would like to be able to prototype quickly while also knowing that we are on a path to deal with future success.</span></span> <span data-ttu-id="d469b-129">這是精簡的創業方法：建置、測量、學習及反覆執行。</span><span class="sxs-lookup"><span data-stu-id="d469b-129">This is the lean startup approach: build, measure, learn, and iterate.</span></span>

<span data-ttu-id="d469b-130">在主從架構的時代，我們傾向專注於建立分層式應用程式，每一層都採用特定的技術。</span><span class="sxs-lookup"><span data-stu-id="d469b-130">During the client-server era, we tended to focus on building tiered applications by using specific technologies in each tier.</span></span> <span data-ttu-id="d469b-131">已針對這些方法衍生出「單體式」應用程式一詞。</span><span class="sxs-lookup"><span data-stu-id="d469b-131">The term *monolithic* application has emerged for these approaches.</span></span> <span data-ttu-id="d469b-132">介面通常存在於各層之間，而在各層內的元件之間採用更緊密結合的設計。</span><span class="sxs-lookup"><span data-stu-id="d469b-132">The interfaces tended to be between the tiers, and a more tightly coupled design was used between components within each tier.</span></span> <span data-ttu-id="d469b-133">開發人員設計並分解類別，將類別編譯成程式庫，然後連結起來成為一些可執行檔和 DLL。</span><span class="sxs-lookup"><span data-stu-id="d469b-133">Developers designed and factored classes that were compiled into libraries and linked together into a few executables and DLLs.</span></span> 

<span data-ttu-id="d469b-134">這類單體式設計方法有一些優點。</span><span class="sxs-lookup"><span data-stu-id="d469b-134">There are benefits to such a monolithic design approach.</span></span> <span data-ttu-id="d469b-135">設計通常比較簡單，元件之間通常透過處理序間通訊 (IPC) 而呼叫更快。</span><span class="sxs-lookup"><span data-stu-id="d469b-135">It's often simpler to design, and it has faster calls between components, because these calls are often over interprocess communication (IPC).</span></span> <span data-ttu-id="d469b-136">此外，每個人都只測試單一產品，人力資源運用更有效率。</span><span class="sxs-lookup"><span data-stu-id="d469b-136">Also, everyone tests a single product, which tends to be more people-resource efficient.</span></span> <span data-ttu-id="d469b-137">缺點是分層式層級之間的結合緊密，以致您無法調整個別的元件。</span><span class="sxs-lookup"><span data-stu-id="d469b-137">The downside is that there's a tight coupling between tiered layers, and you cannot scale individual components.</span></span> <span data-ttu-id="d469b-138">如果您需要執行修正或升級，則必須等候其他人完成其測試。</span><span class="sxs-lookup"><span data-stu-id="d469b-138">If you need to perform fixes or upgrades, you have to wait for others to finish their testing.</span></span> <span data-ttu-id="d469b-139">更難以發揮靈活度。</span><span class="sxs-lookup"><span data-stu-id="d469b-139">It is more difficult to be agile.</span></span>

<span data-ttu-id="d469b-140">微服務可解決這些缺點，更密切配合上述的商務需求，但它們本身也都有優缺點。</span><span class="sxs-lookup"><span data-stu-id="d469b-140">Microservices address these downsides and more closely align with the preceding business requirements, but they also have both benefits and liabilities.</span></span> <span data-ttu-id="d469b-141">微服務的優點是通常各自封裝較簡單的商務功能，您可以獨立地相應增加或減少、測試、部署和管理。</span><span class="sxs-lookup"><span data-stu-id="d469b-141">The benefits of microservices are that each one typically encapsulates simpler business functionality, which you scale up or down, test, deploy, and manage independently.</span></span> <span data-ttu-id="d469b-142">微服務方法的一個重要優點是團隊較具商務案例的導向，而不是分層方法所建議的技術導向。</span><span class="sxs-lookup"><span data-stu-id="d469b-142">One important benefit of a microservice approach is that teams are driven more by business scenarios than by technology, which the tiered approach encourages.</span></span> <span data-ttu-id="d469b-143">實際上，較小的團隊會採用他們選擇的任何技術，根據客戶案例來開發微服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-143">In practice, smaller teams develop a microservice based on a customer scenario and use any technologies they choose.</span></span> 

<span data-ttu-id="d469b-144">換句話說，組織不需要為了維護微服務應用程式而將技術標準化。</span><span class="sxs-lookup"><span data-stu-id="d469b-144">In other words, the organization doesn’t need to standardize tech to maintain microservice applications.</span></span> <span data-ttu-id="d469b-145">擁有服務的個別團隊可以根據團隊的專業知識，或什麼是最適合所要解決的問題，各自發揮所長。</span><span class="sxs-lookup"><span data-stu-id="d469b-145">Individual teams that own services can do what makes sense for them based on team expertise or what’s most appropriate to solve the problem.</span></span> <span data-ttu-id="d469b-146">實際上，最好有一組建議的技術，例如特定的 NoSQL 存放區或 Web 應用程式架構。</span><span class="sxs-lookup"><span data-stu-id="d469b-146">In practice, a set of recommended technologies, such as a particular NoSQL store or web application framework, is preferable.</span></span>

<span data-ttu-id="d469b-147">微服務的缺點包括需要管理越來越多的個別實體，以及處理更複雜的部署和版本控制。</span><span class="sxs-lookup"><span data-stu-id="d469b-147">The downside of microservices comes in managing the increased number of separate entities and dealing with more complex deployments and versioning.</span></span> <span data-ttu-id="d469b-148">微服務之間的網路流量會增加，而相對應的網路延遲也會增加。</span><span class="sxs-lookup"><span data-stu-id="d469b-148">Network traffic between the microservices increases as well as the corresponding network latencies.</span></span> <span data-ttu-id="d469b-149">經過大量論述之後，可知細微的服務是效能夢魘的解決良方。</span><span class="sxs-lookup"><span data-stu-id="d469b-149">Lots of chatty, granular services are a recipe for a performance nightmare.</span></span> <span data-ttu-id="d469b-150">如果沒有工具協助檢視這些相依性，很難「看見」整個系統。</span><span class="sxs-lookup"><span data-stu-id="d469b-150">Without tools to help view these dependencies, it is hard to “see” the whole system.</span></span> 

<span data-ttu-id="d469b-151">標準會讓微服務方法奏效、在通訊方式上達成共識，以及只在乎您需要從服務取得什麼，而不是僵固的合約。</span><span class="sxs-lookup"><span data-stu-id="d469b-151">Standards make the microservice approach work by agreeing on how to communicate and being tolerant of only the things you need from a service, rather than rigid contracts.</span></span> <span data-ttu-id="d469b-152">必須在設計的初期定義這些聯繫，因為服務會各自獨立地更新。</span><span class="sxs-lookup"><span data-stu-id="d469b-152">It is important to define these contracts up front in the design, because services update independently of each other.</span></span> <span data-ttu-id="d469b-153">另一個在設計微服務方法時出現的描述是「細緻的服務導向架構 (SOA)」。</span><span class="sxs-lookup"><span data-stu-id="d469b-153">Another description coined for designing with a microservices approach is “fine-grained service-oriented architecture (SOA).”</span></span>

<span data-ttu-id="d469b-154">***簡而言之，微服務設計方法是低耦合的服務同盟，各自獨立變更，並達成一致的通訊標準。***</span><span class="sxs-lookup"><span data-stu-id="d469b-154">***At its simplest, the microservices design approach is about a decoupled federation of services, with independent changes to each, and agreed-upon standards for communication.***</span></span>

<span data-ttu-id="d469b-155">隨著越多的雲端應用程式產生，人們發現這種將整體應用程式分解成獨立、案例焦點式服務的做法，在長期上是較好的方法。</span><span class="sxs-lookup"><span data-stu-id="d469b-155">As more cloud apps are produced, people discover that this decomposition of the overall app into independent, scenario-focused services is a better long-term approach.</span></span>

## <a name="comparison-between-application-development-approaches"></a><span data-ttu-id="d469b-156">應用程式開發方法的比較</span><span class="sxs-lookup"><span data-stu-id="d469b-156">Comparison between application development approaches</span></span>
![Service Fabric 平台應用程式開發][Image1]

1) <span data-ttu-id="d469b-158">單體式應用程式包含領域特定功能，通常會依功能層來劃分，例如 Web、商務和資料。</span><span class="sxs-lookup"><span data-stu-id="d469b-158">A monolithic app contains domain-specific functionality and is normally divided by functional layers, such as web, business, and data.</span></span>

2) <span data-ttu-id="d469b-159">單體式應用程式可藉由複製到多部伺服器/虛擬機器/容器上進行擴充。</span><span class="sxs-lookup"><span data-stu-id="d469b-159">You scale a monolithic app by cloning it on multiple servers/virtual machines/containers.</span></span>

3) <span data-ttu-id="d469b-160">微服務應用程式會將個別功能分隔成個別較小的服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-160">A microservice application separates functionality into separate smaller services.</span></span>

4) <span data-ttu-id="d469b-161">微服務方法可獨立部署每個服務而相應放大，跨伺服器/虛擬機器/容器建立這些服務的執行個體。</span><span class="sxs-lookup"><span data-stu-id="d469b-161">The microservices approach scales out by deploying each service independently, creating instances of these services across servers/virtual machines/containers.</span></span>

<span data-ttu-id="d469b-162">使用微服務方法來設計並非所有專案的萬靈丹，但確實較符合稍早所述的商務目標。</span><span class="sxs-lookup"><span data-stu-id="d469b-162">Designing with a microservice approach is not a panacea for all projects, but it does align more closely with the business objectives described earlier.</span></span> <span data-ttu-id="d469b-163">如果您知道稍後將有機會將程式碼修改成微服務設計，或許可接受從單體方式開始著手。</span><span class="sxs-lookup"><span data-stu-id="d469b-163">Starting with a monolithic approach might be acceptable if you know that you will have the opportunity to rework the code later into a microservices design.</span></span> <span data-ttu-id="d469b-164">較常見的情況是您從單體式應用程式開始著手，然後從需要更高調整性或靈活度的功能領域開始，分階段緩慢地將它拆解。</span><span class="sxs-lookup"><span data-stu-id="d469b-164">More commonly, you begin with a monolithic application and slowly break it up in stages, starting with the functional areas that need to be more scalable or agile.</span></span>

<span data-ttu-id="d469b-165">總而言之，微服務方法是以許多小型服務來組成應用程式。</span><span class="sxs-lookup"><span data-stu-id="d469b-165">To summarize, the microservice approach is to compose your application of many small services.</span></span> <span data-ttu-id="d469b-166">這些服務會在部署於電腦叢集的容器中執行。</span><span class="sxs-lookup"><span data-stu-id="d469b-166">The services run in containers that are deployed across a cluster of machines.</span></span> <span data-ttu-id="d469b-167">較小的團隊會開發著重於某個案例且獨立測試的服務、進行各服務的控制版本、部署和調整規模，所以應用程式可以整體演化。</span><span class="sxs-lookup"><span data-stu-id="d469b-167">Smaller teams develop a service that focuses on a scenario and independently test, version, deploy, and scale each service so that the entire application can evolve.</span></span>

## <a name="what-is-a-microservice"></a><span data-ttu-id="d469b-168">什麼是微服務？</span><span class="sxs-lookup"><span data-stu-id="d469b-168">What is a microservice?</span></span>
<span data-ttu-id="d469b-169">有不同的微服務定義。</span><span class="sxs-lookup"><span data-stu-id="d469b-169">There are different definitions of microservices.</span></span> <span data-ttu-id="d469b-170">如果您搜尋網際網路，會發現許多有用的資源可提供自己的觀點和定義。</span><span class="sxs-lookup"><span data-stu-id="d469b-170">If you search the Internet, you'll find many useful resources that provide their own viewpoints and definitions.</span></span> <span data-ttu-id="d469b-171">但在微服務的下列大部分特性上，已廣泛達成共識：</span><span class="sxs-lookup"><span data-stu-id="d469b-171">However, most of the following characteristics of microservices are widely agreed upon:</span></span>

* <span data-ttu-id="d469b-172">封裝客戶或商務案例。</span><span class="sxs-lookup"><span data-stu-id="d469b-172">Encapsulate a customer or business scenario.</span></span> <span data-ttu-id="d469b-173">您要解決什麼問題？</span><span class="sxs-lookup"><span data-stu-id="d469b-173">What is the problem you are solving?</span></span>
* <span data-ttu-id="d469b-174">由小型工程團隊開發。</span><span class="sxs-lookup"><span data-stu-id="d469b-174">Developed by a small engineering team.</span></span>
* <span data-ttu-id="d469b-175">使用任何程式設計語言撰寫並使用任何架構。</span><span class="sxs-lookup"><span data-stu-id="d469b-175">Written in any programming language and use any framework.</span></span>
* <span data-ttu-id="d469b-176">由獨立控制版本、部署及調整的程式碼和 (選擇性) 狀態所組成。</span><span class="sxs-lookup"><span data-stu-id="d469b-176">Consist of code and (optionally) state, both of which are independently versioned, deployed, and scaled.</span></span>
* <span data-ttu-id="d469b-177">透過定義完善的介面和通訊協定，與其他微服務互動。</span><span class="sxs-lookup"><span data-stu-id="d469b-177">Interact with other microservices over well-defined interfaces and protocols.</span></span>
* <span data-ttu-id="d469b-178">具有可用來解析位置的唯一名稱 (URL)。</span><span class="sxs-lookup"><span data-stu-id="d469b-178">Have unique names (URLs) used to resolve their location.</span></span>
* <span data-ttu-id="d469b-179">在失敗時維持一致且可用的。</span><span class="sxs-lookup"><span data-stu-id="d469b-179">Remain consistent and available in the presence of failures.</span></span>

<span data-ttu-id="d469b-180">您可以彙整這些特性︰</span><span class="sxs-lookup"><span data-stu-id="d469b-180">You can summarize these characteristics into:</span></span>

<span data-ttu-id="d469b-181">***微服務應用程式是由獨立控制版本和可調整的客戶焦點式服務所組成，這些服務透過標準通訊協定和定義完善的介面彼此通訊。***</span><span class="sxs-lookup"><span data-stu-id="d469b-181">***Microservice applications are composed of small, independently versioned, and scalable customer-focused services that communicate with each other over standard protocols with well-defined interfaces.***</span></span>

<span data-ttu-id="d469b-182">我們在上一節已說明前兩點，接下來將闡明並釐清其他各點。</span><span class="sxs-lookup"><span data-stu-id="d469b-182">We covered the first two points in the preceding section, and now we expand on and clarify the others.</span></span>

### <a name="written-in-any-programming-language-and-use-any-framework"></a><span data-ttu-id="d469b-183">使用任何程式設計語言撰寫並使用任何架構。</span><span class="sxs-lookup"><span data-stu-id="d469b-183">Written in any programming language and use any framework</span></span>
<span data-ttu-id="d469b-184">身為開發人員，我們應該根據本身的技術或服務需求，自由選擇我們想要的語言或架構。</span><span class="sxs-lookup"><span data-stu-id="d469b-184">As developers, we should be free to choose a language or framework that we want, depending on our skills or the needs of the service.</span></span> <span data-ttu-id="d469b-185">在某些服務中，您可能認為 C++ 的效能優點勝於一切。</span><span class="sxs-lookup"><span data-stu-id="d469b-185">In some services, you might value the performance benefits of C++ above all else.</span></span> <span data-ttu-id="d469b-186">在其他服務中，C# 或 Java 的簡易管理開發可能才是最重要的。</span><span class="sxs-lookup"><span data-stu-id="d469b-186">In other services, the ease of managed development in C# or Java might be most important.</span></span> <span data-ttu-id="d469b-187">在某些情況下，您可能需要使用特定的合作夥伴程式庫、資料儲存技術，或向用戶端公開服務的方式。</span><span class="sxs-lookup"><span data-stu-id="d469b-187">In some cases, you may need to use a specific partner library, data storage technology, or means of exposing the service to clients.</span></span>

<span data-ttu-id="d469b-188">在選擇技術之後，接下來就是服務的操作或生命週期管理和調整。</span><span class="sxs-lookup"><span data-stu-id="d469b-188">After you have chosen a technology, you come to the operational or lifecycle management and scaling of the service.</span></span>

### <a name="allows-code-and-state-to-be-independently-versioned-deployed-and-scaled"></a><span data-ttu-id="d469b-189">允許獨立控制版本、部署及調整的程式碼和狀態</span><span class="sxs-lookup"><span data-stu-id="d469b-189">Allows code and state to be independently versioned, deployed, and scaled</span></span>
<span data-ttu-id="d469b-190">不論您選擇何種方式來撰寫微服務，程式碼和 (選擇性) 狀態都應該獨立地部署、升級及調整。</span><span class="sxs-lookup"><span data-stu-id="d469b-190">However you choose to write your microservices, the code and optionally the state should independently deploy, upgrade, and scale.</span></span> <span data-ttu-id="d469b-191">這確實是難以解決的問題之一，因為這涉及到您選擇的技術。</span><span class="sxs-lookup"><span data-stu-id="d469b-191">This is actually one of the harder problems to solve, because it comes down to your choice of technologies.</span></span> <span data-ttu-id="d469b-192">在調整方面，很不容易了解如何分割 (或分區化) 程式碼和狀態。</span><span class="sxs-lookup"><span data-stu-id="d469b-192">For scaling, understanding how to partition (or shard) both the code and state is challenging.</span></span> <span data-ttu-id="d469b-193">當程式碼和狀態使用不同的技術時 (目前的普遍情況)，微服務的部署指令碼必須能夠妥善調整兩者。</span><span class="sxs-lookup"><span data-stu-id="d469b-193">When the code and state use separate technologies, which is common today, the deployment scripts for your microservice need to be able to cope with scaling them both.</span></span> <span data-ttu-id="d469b-194">這也關乎靈活度和彈性，如此您就能升級部分微服務，而不需一次全部升級。</span><span class="sxs-lookup"><span data-stu-id="d469b-194">This is also about agility and flexibility, so you can upgrade some of the microservices without having to upgrade all of them at once.</span></span>

<span data-ttu-id="d469b-195">暫時回到單體式和微服務方法的比較，下圖顯示狀態儲存方法的差異。</span><span class="sxs-lookup"><span data-stu-id="d469b-195">Returning to the monolithic versus microservice approach for a moment, the following diagram shows the differences in the approach to storing state.</span></span>

#### <a name="state-storage-between-application-styles"></a><span data-ttu-id="d469b-196">應用程式樣式之間的狀態儲存</span><span class="sxs-lookup"><span data-stu-id="d469b-196">State storage between application styles</span></span>
![Service Fabric 平台狀態儲存體][Image2]

<span data-ttu-id="d469b-198">***左邊的單體式方法有單一資料庫和多層的特定技術。***</span><span class="sxs-lookup"><span data-stu-id="d469b-198">***The monolithic approach on the left has a single database and tiers of specific technologies.***</span></span>

<span data-ttu-id="d469b-199">***右邊的微服務方法有圖形顯示互連的微服務，其中狀態通常以微服務為範圍，並會使用各種技術。***</span><span class="sxs-lookup"><span data-stu-id="d469b-199">***The microservices approach on the right has a graph of interconnected microservices where state is typically scoped to the microservice and various technologies are used.***</span></span>

<span data-ttu-id="d469b-200">在單體式方法中，應用程式通常會使用單一資料庫。</span><span class="sxs-lookup"><span data-stu-id="d469b-200">In a monolithic approach, typically the application uses a single database.</span></span> <span data-ttu-id="d469b-201">優點是這是單一位置，很容易部署。</span><span class="sxs-lookup"><span data-stu-id="d469b-201">The advantage is that it is a single location, which makes it easy to deploy.</span></span> <span data-ttu-id="d469b-202">每個元件可以有單一資料表來儲存其狀態。</span><span class="sxs-lookup"><span data-stu-id="d469b-202">Each component can have a single table to store its state.</span></span> <span data-ttu-id="d469b-203">挑戰之處在於團隊必須嚴格區分狀態。</span><span class="sxs-lookup"><span data-stu-id="d469b-203">Teams need to strictly separate state, which is a challenge.</span></span> <span data-ttu-id="d469b-204">無可避免地就想將新的資料行新增至現有的客戶資料表、在資料表之間執行聯結，以及對儲存層形成相依性。</span><span class="sxs-lookup"><span data-stu-id="d469b-204">Inevitably there are temptations to add a new column to an existing customer table, do a join between tables, and create dependencies at the storage layer.</span></span> <span data-ttu-id="d469b-205">發生這種情況後，您無法調整個別的元件。</span><span class="sxs-lookup"><span data-stu-id="d469b-205">After this happens, you can't scale individual components.</span></span> 

<span data-ttu-id="d469b-206">在微服務方法中，每個服務都會管理並儲存自己的狀態。</span><span class="sxs-lookup"><span data-stu-id="d469b-206">In the microservices approach, each service manages and stores its own state.</span></span> <span data-ttu-id="d469b-207">每個服務負責同時調整程式碼和狀態，以滿足服務的需求。</span><span class="sxs-lookup"><span data-stu-id="d469b-207">Each service is responsible for scaling both code and state together to meet the demands of the service.</span></span> <span data-ttu-id="d469b-208">缺點就是在需要建立應用程式資料的檢視或查詢時，您必須跨不同的狀態存放區進行查詢。</span><span class="sxs-lookup"><span data-stu-id="d469b-208">A downside is that when there is a need to create views, or queries, of your application’s data, you need to query across disparate state stores.</span></span> <span data-ttu-id="d469b-209">為了解決此問題，通常是由一個獨立的微服務建置一個跨許多微服務的檢視。</span><span class="sxs-lookup"><span data-stu-id="d469b-209">Typically, this is solved by having a separate microservice that builds a view across a collection of microservices.</span></span> <span data-ttu-id="d469b-210">如果您需要在資料上執行多個即席查詢，則每個微服務應該考慮將其資料寫入資料倉儲服務，供離線分析。</span><span class="sxs-lookup"><span data-stu-id="d469b-210">If you need to perform multiple impromptu queries on the data, each microservice should consider writing its data to a data warehousing service for offline analytics.</span></span>

<span data-ttu-id="d469b-211">版本控制是已部署的微服務版本所特有，以便部署和並行執行多個不同的版本。</span><span class="sxs-lookup"><span data-stu-id="d469b-211">Versioning is specific to the deployed version of a microservice so that multiple, different versions deploy and run side by side.</span></span> <span data-ttu-id="d469b-212">當較新版的微服務在升級期間失敗，而需要回復至舊版時，版本控制可以解決這種情況。</span><span class="sxs-lookup"><span data-stu-id="d469b-212">Versioning addresses the scenarios where a newer version of a microservice fails during upgrade and needs to roll back to an earlier version.</span></span> <span data-ttu-id="d469b-213">版本控制的另一種情況是執行 A/B 樣式測試，其中不同的使用者會體驗到不同版本的服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-213">The other scenario for versioning is performing A/B-style testing, where different users experience different versions of the service.</span></span> <span data-ttu-id="d469b-214">比方說，在更廣泛推出新功能之前，通常會先針對一組特定的客戶升級微服務以測試新功能。</span><span class="sxs-lookup"><span data-stu-id="d469b-214">For example, it is common to upgrade a microservice for a specific set of customers to test new functionality before rolling it out more widely.</span></span> <span data-ttu-id="d469b-215">在微服務的生命週期管理之後，這現在會將我們帶往它們之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="d469b-215">After lifecycle management of microservices, this now brings us to communication between them.</span></span>

### <a name="interacts-with-other-microservices-over-well-defined-interfaces-and-protocols"></a><span data-ttu-id="d469b-216">透過定義完善的介面和通訊協定，與其他微服務互動</span><span class="sxs-lookup"><span data-stu-id="d469b-216">Interacts with other microservices over well-defined interfaces and protocols</span></span>
<span data-ttu-id="d469b-217">本主題無需太多著墨，因為過去 10 年來發佈的大量服務導向架構文獻都已說明通訊模式。</span><span class="sxs-lookup"><span data-stu-id="d469b-217">This topic needs little attention here, because extensive literature about service-oriented architecture that has been published over the past 10 years describes communication patterns.</span></span> <span data-ttu-id="d469b-218">一般而言，服務通訊使用 REST 方法，並搭配 HTTP 和 TCP 通訊協定及 XML 或 JSON 做為序列化格式。</span><span class="sxs-lookup"><span data-stu-id="d469b-218">Generally, service communication uses a REST approach with HTTP and TCP protocols and XML or JSON as the serialization format.</span></span> <span data-ttu-id="d469b-219">從介面觀點來看，這是有關採用 Web 設計方法。</span><span class="sxs-lookup"><span data-stu-id="d469b-219">From an interface perspective, it is about embracing the web design approach.</span></span> <span data-ttu-id="d469b-220">但並不禁止您使用二進位通訊協定或您自己的資料格式。</span><span class="sxs-lookup"><span data-stu-id="d469b-220">But nothing stops you from using binary protocols or your own data formats.</span></span> <span data-ttu-id="d469b-221">您公開的微服務會較難使用，要有心理準備。</span><span class="sxs-lookup"><span data-stu-id="d469b-221">Be prepared for people to have a harder time using your microservices if these are openly available.</span></span>

### <a name="has-a-unique-name-url-used-to-resolve-its-location"></a><span data-ttu-id="d469b-222">具有可用來解析位置的唯一名稱 (URL)</span><span class="sxs-lookup"><span data-stu-id="d469b-222">Has a unique name (URL) used to resolve its location</span></span>
<span data-ttu-id="d469b-223">別忘了，我們一直表示微服務如何像 Web 一樣？</span><span class="sxs-lookup"><span data-stu-id="d469b-223">Remember how we keep saying that the microservice approach is like the web?</span></span> <span data-ttu-id="d469b-224">就像 Web 一樣，微服務不論在何處執行，都必須可定址。</span><span class="sxs-lookup"><span data-stu-id="d469b-224">Like the web, your microservice needs to be addressable wherever it is running.</span></span> <span data-ttu-id="d469b-225">如果您正在考慮機器及哪一部要執行特定的微服務，很快就會陷入困境。</span><span class="sxs-lookup"><span data-stu-id="d469b-225">If you are thinking about machines and which one is running a particular microservice, things go bad quickly.</span></span> 

<span data-ttu-id="d469b-226">就像 DNS 解析特定電腦的特定 URL 一樣，微服務需要有唯一的名稱，才可探索它目前所在的位置。</span><span class="sxs-lookup"><span data-stu-id="d469b-226">In the same way that DNS resolves a particular URL to a particular machine, your microservice needs to have a unique name so that its current location is discoverable.</span></span> <span data-ttu-id="d469b-227">微服務需要有可定址的名稱，才能獨立於它們執行時所在的基礎結構之外。</span><span class="sxs-lookup"><span data-stu-id="d469b-227">Microservices need addressable names that make them independent from the infrastructure that they are running on.</span></span> <span data-ttu-id="d469b-228">這意味著服務的部署和探索方式之間會互相影響，因為需要有服務登錄。</span><span class="sxs-lookup"><span data-stu-id="d469b-228">This implies that there is an interaction between how your service is deployed and how it is discovered, because there needs to be a service registry.</span></span> <span data-ttu-id="d469b-229">同樣地，當電腦故障時，登錄服務必須告訴您服務現在執行所在的位置。</span><span class="sxs-lookup"><span data-stu-id="d469b-229">Equally, when a machine fails, the registry service must tell you where the service is now running.</span></span> 

<span data-ttu-id="d469b-230">接下來的課題：恢復能力和一致性。</span><span class="sxs-lookup"><span data-stu-id="d469b-230">This brings us to the next topic: resilience and consistency.</span></span>

### <a name="remains-consistent-and-available-in-the-presence-of-failures"></a><span data-ttu-id="d469b-231">失敗時維持一致且可用</span><span class="sxs-lookup"><span data-stu-id="d469b-231">Remains consistent and available in the presence of failures</span></span>
<span data-ttu-id="d469b-232">處理非預期的失敗是最難解決的問題之一，特別是在分散式系統中。</span><span class="sxs-lookup"><span data-stu-id="d469b-232">Dealing with unexpected failures is one of the hardest problems to solve, especially in a distributed system.</span></span> <span data-ttu-id="d469b-233">開發人員撰寫的程式碼大多是在處理例外狀況，這也是測試時花費最多時間的地方。</span><span class="sxs-lookup"><span data-stu-id="d469b-233">Much of the code that we write as developers is handling exceptions, and this is also where the most time is spent in testing.</span></span> <span data-ttu-id="d469b-234">問題比撰寫程式碼來處理失敗更複雜。</span><span class="sxs-lookup"><span data-stu-id="d469b-234">The problem is more involved than writing code to handle failures.</span></span> <span data-ttu-id="d469b-235">當執行微服務的電腦故障時，該怎麼辦？</span><span class="sxs-lookup"><span data-stu-id="d469b-235">What happens when the machine where the microservice is running fails?</span></span> <span data-ttu-id="d469b-236">您不僅需要偵測此微服務失敗 (本身就是棘手的問題)，還需要設法重新啟動微服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-236">Not only do you need to detect this microservice failure (a hard problem on its own), but you also need something to restart your microservice.</span></span> 

<span data-ttu-id="d469b-237">微服務必須能夠從失敗中恢復，基於可用性理由，通常還必須在另一部電腦上重新啟動。</span><span class="sxs-lookup"><span data-stu-id="d469b-237">A microservice needs to be resilient to failures and restart often on another machine for availability reasons.</span></span> <span data-ttu-id="d469b-238">這也涉及到代表微服務儲存了何種狀態、微服務可從何處復原此狀態，以及微服務是否能夠順利重新啟動它。</span><span class="sxs-lookup"><span data-stu-id="d469b-238">This also comes down to the state that was saved on behalf of the microservice, where the microservice can recover this state from, and whether the microservice is able to restart successfully.</span></span> <span data-ttu-id="d469b-239">換句話說，需要能夠恢復計算 (重新啟動處理序)，以及狀態或資料的恢復能力 (不遺失任何資料，資料保持一致)。</span><span class="sxs-lookup"><span data-stu-id="d469b-239">In other words, there needs to be resilience in the compute (the process restarts) as well as resilience in the state or data (no data loss and the data remains consistent).</span></span>

<span data-ttu-id="d469b-240">在其他情況下，恢復能力的問題更難處理，例如應用程式升級期間失敗。</span><span class="sxs-lookup"><span data-stu-id="d469b-240">The problems of resiliency are compounded during other scenarios, such as when failures happen during an application upgrade.</span></span> <span data-ttu-id="d469b-241">在搭配部署系統一起運作時，微服務不需要復原。</span><span class="sxs-lookup"><span data-stu-id="d469b-241">The microservice, working with the deployment system, doesn't need to recover.</span></span> <span data-ttu-id="d469b-242">它也需要判斷是否可以繼續升級到較新版本，還是復原為舊版來維護一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="d469b-242">It also needs to then decide whether it can continue to move forward to the newer version or instead roll back to a previous version to maintain a consistent state.</span></span> <span data-ttu-id="d469b-243">需要考慮一些問題，例如，是否有足夠的電腦可繼續升級，以及如何復原舊版的微服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-243">Questions such as whether enough machines are available to keep moving forward and how to recover previous versions of the microservice need to be considered.</span></span> <span data-ttu-id="d469b-244">這需要微服務發出狀況資訊，才能做出這些決定。</span><span class="sxs-lookup"><span data-stu-id="d469b-244">This requires the microservice to emit health information to be able to make these decisions.</span></span>

### <a name="reports-health-and-diagnostics"></a><span data-ttu-id="d469b-245">報告狀況和診斷</span><span class="sxs-lookup"><span data-stu-id="d469b-245">Reports health and diagnostics</span></span>
<span data-ttu-id="d469b-246">微服務必須報告其健全狀況和診斷，這一點看似明顯，但卻經常被輕忽。</span><span class="sxs-lookup"><span data-stu-id="d469b-246">It may seem obvious, and it is often overlooked, but a microservice must report its health and diagnostics.</span></span> <span data-ttu-id="d469b-247">否則，難以從操作觀點上深入了解。</span><span class="sxs-lookup"><span data-stu-id="d469b-247">Otherwise, there is little insight from an operations perspective.</span></span> <span data-ttu-id="d469b-248">所面臨的挑戰是讓一組獨立服務的診斷事件相互關聯，並修正電腦時間差異以了解事件順序。</span><span class="sxs-lookup"><span data-stu-id="d469b-248">Correlating diagnostic events across a set of independent services and dealing with machine clock skews to make sense of the event order is challenging.</span></span> <span data-ttu-id="d469b-249">同樣地，透過同意的通訊協定和資料格式來與微服務互動時，需要將健全狀況和診斷事件的記錄方式標準化，這些事件最後會放入可供查詢和檢視的事件存放區。</span><span class="sxs-lookup"><span data-stu-id="d469b-249">In the same way that you interact with a microservice over agreed-upon protocols and data formats, there emerges a need for standardization in how to log health and diagnostic events that ultimately end up in an event store for querying and viewing.</span></span> <span data-ttu-id="d469b-250">在微服務方法中，關鍵在於不同團隊同意採用單一記錄格式。</span><span class="sxs-lookup"><span data-stu-id="d469b-250">In a microservices approach, it is key that different teams agree on a single logging format.</span></span> <span data-ttu-id="d469b-251">需要有一致的方法可檢視整個應用程式中的診斷事件。</span><span class="sxs-lookup"><span data-stu-id="d469b-251">There needs to be a consistent approach to viewing diagnostic events in the application as a whole.</span></span>

<span data-ttu-id="d469b-252">狀況與診斷不同。</span><span class="sxs-lookup"><span data-stu-id="d469b-252">Health is different from diagnostics.</span></span> <span data-ttu-id="d469b-253">健全狀況是指微服務報告其目前狀態，以便採取適當的行動。</span><span class="sxs-lookup"><span data-stu-id="d469b-253">Health is about the microservice reporting its current state to take appropriate actions.</span></span> <span data-ttu-id="d469b-254">使用升級和部署機制來維護可用性是一個很好例子。</span><span class="sxs-lookup"><span data-stu-id="d469b-254">A good example is working with upgrade and deployment mechanisms to maintain availability.</span></span> <span data-ttu-id="d469b-255">雖然目前服務可能由於處理序損毀或重新開機而狀況不良，但服務可能仍會運作。</span><span class="sxs-lookup"><span data-stu-id="d469b-255">Although a service may be currently unhealthy due to a process crash or machine reboot, the service might still be operational.</span></span> <span data-ttu-id="d469b-256">您不應該執行升級而讓情況惡化。</span><span class="sxs-lookup"><span data-stu-id="d469b-256">The last thing you need is to make this worse by performing an upgrade.</span></span> <span data-ttu-id="d469b-257">最好是先進行調查，或讓微服務有時間復原。</span><span class="sxs-lookup"><span data-stu-id="d469b-257">The best approach is to do an investigation first or allow time for the microservice to recover.</span></span> <span data-ttu-id="d469b-258">微服務的健全狀況事件可協助我們做出明智的決策，實際上有助於建立自我修復的服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-258">Health events from a microservice help us make informed decisions and, in effect, help create self-healing services.</span></span>

## <a name="service-fabric-as-a-microservices-platform"></a><span data-ttu-id="d469b-259">Service Fabric 做為微服務平台</span><span class="sxs-lookup"><span data-stu-id="d469b-259">Service Fabric as a microservices platform</span></span>
<span data-ttu-id="d469b-260">Azure Service Fabric 源自於 Microsoft 從提供盒裝產品 (通常是單體式) 的轉換到提供服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-260">Azure Service Fabric emerged from a transition by Microsoft from delivering box products, which were typically monolithic in style, to delivering services.</span></span> <span data-ttu-id="d469b-261">建置和操作大型服務 (例如 Azure SQL Database、Azure Cosmos DB、圖形化 Service Fabric) 的經驗。</span><span class="sxs-lookup"><span data-stu-id="d469b-261">The experience of building and operating large services, such as Azure SQL Database and Azure Cosmos DB, shaped Service Fabric.</span></span> <span data-ttu-id="d469b-262">此平台已隨著越來越多的服務採用它而演化。</span><span class="sxs-lookup"><span data-stu-id="d469b-262">The platform evolved over time as more and more services adopted it.</span></span> <span data-ttu-id="d469b-263">重要的是，Service Fabric 必須不僅在 Azure 中執行，還有在獨立式 Windows Server 部署中。</span><span class="sxs-lookup"><span data-stu-id="d469b-263">Importantly, Service Fabric had to run not only in Azure but also in standalone Windows Server deployments.</span></span>

<span data-ttu-id="d469b-264">***Service Fabric 的目標是解決建置和執行服務方面的艱難問題，以及有效率地利用基礎結構資源，讓團隊可以使用微服務方法來解決商務問題。***</span><span class="sxs-lookup"><span data-stu-id="d469b-264">***The aim of Service Fabric is to solve the hard problems of building and running a service and utilize infrastructure resources efficiently, so that teams can solve business problems using a microservices approach.***</span></span>

<span data-ttu-id="d469b-265">Service Fabric 提供三個廣泛的領域，可協助您建置使用微服務方法的應用程式：</span><span class="sxs-lookup"><span data-stu-id="d469b-265">Service Fabric provides three broad areas to help you build applications that use a microservices approach:</span></span>

* <span data-ttu-id="d469b-266">一個提供系統服務的平台 - 這些服務可進行部署、升級、偵測及重新啟動失敗的服務、探索服務、路由傳送訊息、管理狀態，以及監視健康情況。</span><span class="sxs-lookup"><span data-stu-id="d469b-266">A platform that provides system services to deploy, upgrade, detect, and restart failed services, discover services, route messages, manage state, and monitor health.</span></span> <span data-ttu-id="d469b-267">這些系統服務實際上具備上述微服務的許多特性。</span><span class="sxs-lookup"><span data-stu-id="d469b-267">These system services in effect enable many of the characteristics of microservices previously described.</span></span>
* <span data-ttu-id="d469b-268">部署應用程式的能力 - 不論這些應用程式是在容器中執行，還是以處理序形式執行。</span><span class="sxs-lookup"><span data-stu-id="d469b-268">Ability to deploy applications either running in containers or as processes.</span></span> <span data-ttu-id="d469b-269">Service Fabric 是一個容器和處理序協調者。</span><span class="sxs-lookup"><span data-stu-id="d469b-269">Service Fabric is a container and process orchestrator.</span></span>
* <span data-ttu-id="d469b-270">高生產力的程式設計 API - 可協助您將應用程式建置成微服務：[ASP.NET Core、Reliable Actors 及 Reliable Services](service-fabric-choose-framework.md)。</span><span class="sxs-lookup"><span data-stu-id="d469b-270">Productive programming APIs,  to help you build applications as microservices: [ASP.NET Core, Reliable Actors, and Reliable Services](service-fabric-choose-framework.md).</span></span> <span data-ttu-id="d469b-271">您可以選擇任何程式碼來建置微服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-271">You can choose any code to build your microservice.</span></span> <span data-ttu-id="d469b-272">但使用這些 API 不僅可讓工作更簡單，也更深入地與平台整合。</span><span class="sxs-lookup"><span data-stu-id="d469b-272">But these APIs make the job more straightforward, and they integrate with the platform at a deeper level.</span></span> <span data-ttu-id="d469b-273">例如，您可以取得健康狀態和診斷資訊，或利用內建的高可用性。</span><span class="sxs-lookup"><span data-stu-id="d469b-273">This way, for example, you can get health and diagnostics information, or you can take advantage of built-in high availability.</span></span>

<span data-ttu-id="d469b-274">***Service Fabric 不會限制您建置服務的方式，您可以使用任何技術。不過，它提供可讓您輕鬆建置微服務的內建程式設計 API。***</span><span class="sxs-lookup"><span data-stu-id="d469b-274">***Service Fabric is agnostic on how you build your service, and you can use any technology. However, it does provide built-in programming APIs that make it easier to build microservices.***</span></span>

### <a name="migrating-existing-applications-to-service-fabric"></a><span data-ttu-id="d469b-275">將現有的應用程式移轉到 Service Fabric</span><span class="sxs-lookup"><span data-stu-id="d469b-275">Migrating existing applications to Service Fabric</span></span>
<span data-ttu-id="d469b-276">Service Fabric 的一個主要方法是重複使用現有的程式碼，而這些程式碼可接著藉由新的微服務來現代化。</span><span class="sxs-lookup"><span data-stu-id="d469b-276">A key approach to Service Fabric is to reuse existing code, which can then be modernized with new microservices.</span></span> <span data-ttu-id="d469b-277">應用程式的現代化階段有五個，而您可以在任何階段開始和停止。</span><span class="sxs-lookup"><span data-stu-id="d469b-277">There are five stages to application modernization, and you can start and stop at any of the stages.</span></span> <span data-ttu-id="d469b-278">這些階段包括：</span><span class="sxs-lookup"><span data-stu-id="d469b-278">These are;</span></span>

1) <span data-ttu-id="d469b-279">選擇一個傳統單體式應用程式</span><span class="sxs-lookup"><span data-stu-id="d469b-279">Take a traditional monolithic application</span></span>
2) <span data-ttu-id="d469b-280">原封不動轉移 - 使用容器或客體可執行檔來裝載 Service Fabric 中現有的程式碼。</span><span class="sxs-lookup"><span data-stu-id="d469b-280">Lift and Shift - Use containers or guest executables to host existing code in Service Fabric.</span></span>
3) <span data-ttu-id="d469b-281">現代化 - 在現有的容器化程式碼之外，再加上新的微服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-281">Modernization - New microservices added alongside existing containerized code.</span></span> 
4) <span data-ttu-id="d469b-282">創新 - 將單體完全根據需求拆解成微服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-282">Innovate - Break the monolithic into microservices purely based on need.</span></span>
5) <span data-ttu-id="d469b-283">轉換成微服務 - 轉換現有的單體式應用程式，或建置新的原創應用程式。</span><span class="sxs-lookup"><span data-stu-id="d469b-283">Transformed into microservices - the transformation of existing monolithic applications or building new greenfield applications.</span></span>

![移轉成微服務][Image3]

<span data-ttu-id="d469b-285">再重新強調一遍，您可以**在這當中任何階段開始和停止**，不會被迫移至下一個階段。</span><span class="sxs-lookup"><span data-stu-id="d469b-285">It is important to emphasis again, that you can **start and stop at any of these stages**, you are not compelled to moved to the next stage.</span></span> <span data-ttu-id="d469b-286">現在，讓我們看看這每一個階段的範例。</span><span class="sxs-lookup"><span data-stu-id="d469b-286">Let's now look at examples for each of these stages.</span></span>

<span data-ttu-id="d469b-287">**原封不動轉移** - 許多公司將現有單體式應用程式原封不動轉移到容器中的原因有兩個：</span><span class="sxs-lookup"><span data-stu-id="d469b-287">**Lift and Shift** - large numbers of companies are lifting and shifting existing monolithic applications into containers to for two reasons;</span></span>

- <span data-ttu-id="d469b-288">降低成本 - 不論是為了合併和移除現有的硬體，還是為了以更高密度的方式執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="d469b-288">Cost reduction either due to consolidation and removal  of existing hardware or running applications at higher density.</span></span> 
- <span data-ttu-id="d469b-289">開發與作業之間的一致性部署合約。</span><span class="sxs-lookup"><span data-stu-id="d469b-289">Consistent deployment contract between development and operations.</span></span>

<span data-ttu-id="d469b-290">降低成本是可理解的，在 Microsoft 內，大量現有的應用程式都正透過容器化來節省數百萬美元。</span><span class="sxs-lookup"><span data-stu-id="d469b-290">Cost reductions are understandable and within Microsoft large numbers of existing applications are being containerized simply to millions of dollars.</span></span> <span data-ttu-id="d469b-291">一致性部署較難以評估，但同樣重要。</span><span class="sxs-lookup"><span data-stu-id="d469b-291">Consistent deployment is harder to evaluate, but equally as important.</span></span> <span data-ttu-id="d469b-292">開發人員仍可自由選擇適合他們的技術，不過，作業將只接受單一的方式來部署和管理這些應用程式。</span><span class="sxs-lookup"><span data-stu-id="d469b-292">It says that developers can still be free to choose the technology that suites them, however the operations will only accept a single way to deploy and manage these applications.</span></span> <span data-ttu-id="d469b-293">它緩和了作業必須處理許多不同技術的複雜性，或是強制開發人員只能選擇特定技術的情況。</span><span class="sxs-lookup"><span data-stu-id="d469b-293">It alleviates the operations from having to deal with the complexity of many different technologies or forcing developers to only choose certain ones.</span></span> <span data-ttu-id="d469b-294">基本上，每個應用程式都會透過容器化成為獨立性部署映像。</span><span class="sxs-lookup"><span data-stu-id="d469b-294">Essentially every application is containerized into self-contained deployment images.</span></span>

<span data-ttu-id="d469b-295">許多組織都在此停止。</span><span class="sxs-lookup"><span data-stu-id="d469b-295">Many organizations stop here.</span></span> <span data-ttu-id="d469b-296">它們已經享有容器的好處，而且 Service Fabric 提供包含了部署、升級、版本設定、復原、健康情況監視等完整的管理體驗。</span><span class="sxs-lookup"><span data-stu-id="d469b-296">They already have the benefits of containers and Service Fabric provides the complete management experience from deployment, upgrades, versioning, rollbacks, health monitoring etc.</span></span>

<span data-ttu-id="d469b-297">**現代化** - 是在現有的容器化程式碼之外，再加上新的服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-297">**Modernization** - is the addition of new services alongside existing containerized code.</span></span> <span data-ttu-id="d469b-298">如果您要撰寫新的程式碼，最好是決定順著微服務的路徑步步為營。</span><span class="sxs-lookup"><span data-stu-id="d469b-298">If you are going to write new code, it is best to decide to take small steps down the microservices path.</span></span> <span data-ttu-id="d469b-299">這可能是新增新的 REST API 端點，或是新的商務邏輯。</span><span class="sxs-lookup"><span data-stu-id="d469b-299">This could be adding a new REST API endpoint, or new business logic.</span></span> <span data-ttu-id="d469b-300">如此一來，您便開始了建置新微服務的旅程，以及練習開發和部署這些微服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-300">This way, you start on the journey of building new microservices and practice developing and deploying them.</span></span>

<span data-ttu-id="d469b-301">**創新** - 還記得本文開頭那些促使採用微服務方法的原始變更業務需求嗎？</span><span class="sxs-lookup"><span data-stu-id="d469b-301">**Innovate** - remember those original changing business needs at the start of this article, that are driving the microservices approach?</span></span> <span data-ttu-id="d469b-302">在此階段，要判斷的是，這些情況是否發生在我目前的應用程式上，如果是，我便需要開始分割單體應用程式或進行創新。</span><span class="sxs-lookup"><span data-stu-id="d469b-302">At this stage the decision is, are these happening to my current application and if so, I need to start splitting the monolith, or innovating.</span></span> <span data-ttu-id="d469b-303">這裡的其中一個範例，就是當資料庫因為作為工作流程佇列而變成處理瓶頸的時候。</span><span class="sxs-lookup"><span data-stu-id="d469b-303">An example here is when a database becomes a processing bottleneck, since it is being used as a workflow queue.</span></span> <span data-ttu-id="d469b-304">隨著工作流程要求數目的增加，將需要分配工作來進行調整。</span><span class="sxs-lookup"><span data-stu-id="d469b-304">As the number of workflow requests increasing the work needs to be distributed for scale.</span></span> <span data-ttu-id="d469b-305">因此針對不進行調整或您需要更頻繁地更新的特定應用程式部分，請將此部分劃分出來成為微服務並進行創新。</span><span class="sxs-lookup"><span data-stu-id="d469b-305">So for that particular piece of the application that is not scaling, or you need to update more frequently, split this out into a microservice and innovate.</span></span> 

<span data-ttu-id="d469b-306">**轉換成微服務** - 這是應用程式完全由微服務構成 (或解構成微服務) 的階段。</span><span class="sxs-lookup"><span data-stu-id="d469b-306">**Transformed into microservices** - this is where your application is fully composed of (or decomposed into) microservices.</span></span> <span data-ttu-id="d469b-307">到此階段，您已完成微服務旅程。</span><span class="sxs-lookup"><span data-stu-id="d469b-307">To reach here, you have made the microservices journey.</span></span> <span data-ttu-id="d469b-308">您可以從這裡開始，但是在沒有微服務平台來協助您的情況下執行此操作會是相當大的投資。</span><span class="sxs-lookup"><span data-stu-id="d469b-308">You can start here, but to do this without a microservices platform to help you is a significant investment.</span></span> 

### <a name="are-microservices-right-for-my-application"></a><span data-ttu-id="d469b-309">微服務適合我的應用程式嗎？</span><span class="sxs-lookup"><span data-stu-id="d469b-309">Are microservices right for my application?</span></span>
<span data-ttu-id="d469b-310">可能。</span><span class="sxs-lookup"><span data-stu-id="d469b-310">Maybe.</span></span> <span data-ttu-id="d469b-311">根據我們的經驗，隨著 Microsoft 中越來越多團隊基於商業理由開始針對雲端進行建置，有許多團隊都了解到採用類似微服務的方法所帶來的優點。</span><span class="sxs-lookup"><span data-stu-id="d469b-311">What we experienced was that as more and more teams in Microsoft began to build for the cloud for business reasons, many of them realized the benefits of taking a microservice-like approach.</span></span> <span data-ttu-id="d469b-312">例如，Bing 多年來一直在開發搜尋方面的微服務。</span><span class="sxs-lookup"><span data-stu-id="d469b-312">Bing, for example, has been developing microservices in search for years.</span></span> <span data-ttu-id="d469b-313">對於其他團隊而言，微服務方法很新穎。</span><span class="sxs-lookup"><span data-stu-id="d469b-313">For other teams, the microservices approach was new.</span></span> <span data-ttu-id="d469b-314">團隊發現在他們的核心強項之外，還有需要解決的困難問題。</span><span class="sxs-lookup"><span data-stu-id="d469b-314">Teams found that there were hard problems to solve outside of their core areas of strength.</span></span> <span data-ttu-id="d469b-315">這就是為什麼 Service Fabric 受到重視而成為建置服務的最佳技術。</span><span class="sxs-lookup"><span data-stu-id="d469b-315">This is why Service Fabric gained traction as the technology of choice for building services.</span></span>

<span data-ttu-id="d469b-316">Service Fabric 的目標是將使用微服務方法建置應用程式時的複雜性降低，讓您不需要經歷許多耗費成本的重新設計工作。</span><span class="sxs-lookup"><span data-stu-id="d469b-316">The objective of Service Fabric is to reduce the complexities of building applications with a microservice approach, so that you do not have to go through as many costly redesigns.</span></span> <span data-ttu-id="d469b-317">方法就是從小規模開始、需要時調整、淘汰服務、加入新服務、隨客戶用法而演化。</span><span class="sxs-lookup"><span data-stu-id="d469b-317">Start small, scale when needed, deprecate services, add new ones, and evolve with customer usage is the approach.</span></span> <span data-ttu-id="d469b-318">我們也知道，為了讓微服務更易於為大部分開發人員所接受，還有許多其他尚待解決的問題。</span><span class="sxs-lookup"><span data-stu-id="d469b-318">We also know that there are many other problems yet to be solved to make microservices more approachable for most developers.</span></span> <span data-ttu-id="d469b-319">容器和 Actor 程式設計模型都是朝此目標前進的一小步，我們確信將會浮現更多創新來輕鬆達成目標。</span><span class="sxs-lookup"><span data-stu-id="d469b-319">Containers and the actor programming model are examples of small steps in that direction, and we are sure that more innovations will emerge to make this easier.</span></span>
 
<!--Every topic should have next steps and links to the next logical set of content to keep the customer engaged-->

## <a name="next-steps"></a><span data-ttu-id="d469b-320">後續步驟</span><span class="sxs-lookup"><span data-stu-id="d469b-320">Next steps</span></span>
* [<span data-ttu-id="d469b-321">Service Fabric 術語概觀</span><span class="sxs-lookup"><span data-stu-id="d469b-321">Service Fabric terminology overview</span></span>](service-fabric-technical-overview.md)
* [<span data-ttu-id="d469b-322">微服務︰採用雲端技術的應用程式革命</span><span class="sxs-lookup"><span data-stu-id="d469b-322">Microservices: An application revolution powered by the cloud</span></span>](https://azure.microsoft.com/en-us/blog/microservices-an-application-revolution-powered-by-the-cloud/)

[Image1]: media/service-fabric-overview-microservices/monolithic-vs-micro.png
[Image2]: media/service-fabric-overview-microservices/statemonolithic-vs-micro.png
[Image3]: media/service-fabric-overview-microservices/microservices-migration.png
