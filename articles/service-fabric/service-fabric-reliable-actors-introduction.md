---
title: "Service Fabric Reliable Actors 概觀 | Microsoft Docs"
description: "Service Fabric Reliable Actors 程式設計模型簡介。"
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: e89be04a0d6fe90a89e293e67d42f0204eb7000a
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="introduction-to-service-fabric-reliable-actors"></a><span data-ttu-id="d6b78-103">Service Fabric Reliable Actor 簡介</span><span class="sxs-lookup"><span data-stu-id="d6b78-103">Introduction to Service Fabric Reliable Actors</span></span>
<span data-ttu-id="d6b78-104">Reliable Actors 是以 [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) 模式為基礎的 Service Fabric 應用程式架構。</span><span class="sxs-lookup"><span data-stu-id="d6b78-104">Reliable Actors is a Service Fabric application framework based on the [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="d6b78-105">Reliable Actors API 提供單一執行緒的程式設計模型，此模型立基於 Service Fabric 所提供的延展性和可靠性保證上。</span><span class="sxs-lookup"><span data-stu-id="d6b78-105">The Reliable Actors API provides a single-threaded programming model built on the scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="d6b78-106">什麼是動作項目？</span><span class="sxs-lookup"><span data-stu-id="d6b78-106">What are Actors?</span></span>
<span data-ttu-id="d6b78-107">動作項目是隔離且獨立的計算與狀態單位，且具備單一執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="d6b78-108">[動作項目模式](https://en.wikipedia.org/wiki/Actor_model) 是適用於並行或分散式系統的運算模型，其中有大量的這類動作項目可以同時且各自獨立的方式來執行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-108">The [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="d6b78-109">動作項目可以彼此通訊，而且可以建立多個動作項目。</span><span class="sxs-lookup"><span data-stu-id="d6b78-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-to-use-reliable-actors"></a><span data-ttu-id="d6b78-110">使用 Reliable Actors 的時機</span><span class="sxs-lookup"><span data-stu-id="d6b78-110">When to use Reliable Actors</span></span>
<span data-ttu-id="d6b78-111">Service Fabric Reliable Actors 是動作項目設計模式的實作。</span><span class="sxs-lookup"><span data-stu-id="d6b78-111">Service Fabric Reliable Actors is an implementation of the actor design pattern.</span></span> <span data-ttu-id="d6b78-112">如同任何軟體設計模式，是否要使用特定模式的決策是根據軟體設計問題是否符合模式來決定。</span><span class="sxs-lookup"><span data-stu-id="d6b78-112">As with any software design pattern, the decision whether to use a specific pattern is made based on whether or not a software design problem fits the pattern.</span></span>

<span data-ttu-id="d6b78-113">雖然動作項目設計模式適用於許多分散式系統問題和案例，但還是必須謹慎考量實作它的模式與架構的限制。</span><span class="sxs-lookup"><span data-stu-id="d6b78-113">Although the actor design pattern can be a good fit to a number of distributed systems problems and scenarios, careful consideration of the constraints of the pattern and the framework implementing it must be made.</span></span> <span data-ttu-id="d6b78-114">做為一般指導方針，請在符合下列情況時，考慮使用動作項目模式來建立您的問題或案例模型︰</span><span class="sxs-lookup"><span data-stu-id="d6b78-114">As general guidance, consider the actor pattern to model your problem or scenario if:</span></span>

* <span data-ttu-id="d6b78-115">您的問題領域涉及大量 (數千個或更多) 小型、獨立且隔離的狀態和邏輯單位。</span><span class="sxs-lookup"><span data-stu-id="d6b78-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="d6b78-116">您想要使用單一執行緒的物件，這類物件不需要與外部元件進行顯著的互動，包括跨一組動作項目查詢狀態。</span><span class="sxs-lookup"><span data-stu-id="d6b78-116">You want to work with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="d6b78-117">您的動作項目執行個體將不會藉由發出 I/O 作業，使用無法預期的延遲來封鎖呼叫端。</span><span class="sxs-lookup"><span data-stu-id="d6b78-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="d6b78-118">Service Fabric 中的動作項目</span><span class="sxs-lookup"><span data-stu-id="d6b78-118">Actors in Service Fabric</span></span>
<span data-ttu-id="d6b78-119">在 Service Fabric 中，動作項目是在 Reliable Actors 架構中實作的︰以動作項目模式為基礎的應用程式架構是建置於 [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md)的頂端。</span><span class="sxs-lookup"><span data-stu-id="d6b78-119">In Service Fabric, actors are implemented in the Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="d6b78-120">您撰寫的每個 Reliable Actor 服務實際上都是已資料分割的具狀態可靠服務。</span><span class="sxs-lookup"><span data-stu-id="d6b78-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="d6b78-121">每個動作項目都會定義為動作項目類型的執行個體，與 .NET 物件是 .NET 類型的執行個體的方式完全相同。</span><span class="sxs-lookup"><span data-stu-id="d6b78-121">Every actor is defined as an instance of an actor type, identical to the way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="d6b78-122">例如，有的動作項目類型會實作計算機的功能，而該類型會有許多動作項目分散到叢集的各種節點上。</span><span class="sxs-lookup"><span data-stu-id="d6b78-122">For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="d6b78-123">每一個這類的動作項目都有唯一的動作項目識別碼識別。</span><span class="sxs-lookup"><span data-stu-id="d6b78-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="d6b78-124">動作項目生命週期</span><span class="sxs-lookup"><span data-stu-id="d6b78-124">Actor Lifetime</span></span>
<span data-ttu-id="d6b78-125">Service Fabric 動作項目是虛擬的，也就是說，其生命週期不會繫結至其記憶體內部表示法。</span><span class="sxs-lookup"><span data-stu-id="d6b78-125">Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</span></span> <span data-ttu-id="d6b78-126">因此，不需要明確地進行建立或終結。</span><span class="sxs-lookup"><span data-stu-id="d6b78-126">As a result, they do not need to be explicitly created or destroyed.</span></span> <span data-ttu-id="d6b78-127">Reliable Actors 執行階段會在第一次接收到動作項目識別碼的要求時自動啟動該動作項目。</span><span class="sxs-lookup"><span data-stu-id="d6b78-127">The Reliable Actors runtime automatically activates an actor the first time it receives a request for that actor ID.</span></span> <span data-ttu-id="d6b78-128">如果動作項目有一段時間未使用，則 Reliable Actors 執行階段會對記憶體內部物件進行記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="d6b78-128">If an actor is not used for a period of time, the Reliable Actors runtime garbage-collects the in-memory object.</span></span> <span data-ttu-id="d6b78-129">它也會維護稍後重新啟動動作項目所需的存在知識。</span><span class="sxs-lookup"><span data-stu-id="d6b78-129">It will also maintain knowledge of the actor's existence should it need to be reactivated later.</span></span> <span data-ttu-id="d6b78-130">如需詳細資訊，請參閱 [動作項目生命週期與記憶體回收](service-fabric-reliable-actors-lifecycle.md)。</span><span class="sxs-lookup"><span data-stu-id="d6b78-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="d6b78-131">此虛擬動作項目存留期抽象概念會傳達一些警告做為虛擬動作項目模型的結果，而事實上，Reliable Actors 有時會偏離此模型。</span><span class="sxs-lookup"><span data-stu-id="d6b78-131">This virtual actor lifetime abstraction carries some caveats as a result of the virtual actor model, and in fact the Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="d6b78-132">動作項目會在訊息第一次傳送到它的動作項目識別碼時自動啟動 (因而造成動作項目物件的建構)。</span><span class="sxs-lookup"><span data-stu-id="d6b78-132">An actor is automatically activated (causing an actor object to be constructed) the first time a message is sent to its actor ID.</span></span> <span data-ttu-id="d6b78-133">在一段時間之後，就會對該動作項目物件進行記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="d6b78-133">After some period of time, the actor object is garbage collected.</span></span> <span data-ttu-id="d6b78-134">未來再次使用動作項目識別碼時，就會導致建構新的動作項目物件。</span><span class="sxs-lookup"><span data-stu-id="d6b78-134">In the future, using the actor ID again, causes a new actor object to be constructed.</span></span> <span data-ttu-id="d6b78-135">將動作項目的狀態儲存於狀態管理員時，其存留時間會超過物件的存留期。</span><span class="sxs-lookup"><span data-stu-id="d6b78-135">An actor's state outlives the object's lifetime when stored in the state manager.</span></span>
* <span data-ttu-id="d6b78-136">針對動作項目識別碼呼叫任何動作項目方法都會啟動該動作項目。</span><span class="sxs-lookup"><span data-stu-id="d6b78-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="d6b78-137">基於這個理由，動作項目類型會透過執行階段隱含地呼叫其建構函式。</span><span class="sxs-lookup"><span data-stu-id="d6b78-137">For this reason, actor types have their constructor called implicitly by the runtime.</span></span> <span data-ttu-id="d6b78-138">因此，用戶端程式碼無法將參數傳遞給動作項目類型的建構函式，雖然可能會由服務本身將參數傳遞給動作項目的建構函式。</span><span class="sxs-lookup"><span data-stu-id="d6b78-138">Therefore, client code cannot pass parameters to the actor type's constructor, although parameters may be passed to the actor's constructor by the service itself.</span></span> <span data-ttu-id="d6b78-139">結果就是，如果動作項目需要來自用戶端的初始化參數，動作項目可能就會依照在其上呼叫其他方法的時間，以部分初始化的狀態來建構。</span><span class="sxs-lookup"><span data-stu-id="d6b78-139">The result is that actors may be constructed in a partially-initialized state by the time other methods are called on it, if the actor requires initialization parameters from the client.</span></span> <span data-ttu-id="d6b78-140">沒有任何單一進入點可從用戶端啟動動作項目。</span><span class="sxs-lookup"><span data-stu-id="d6b78-140">There is no single entry point for the activation of an actor from the client.</span></span>
* <span data-ttu-id="d6b78-141">雖然 Reliable Actors 會以隱含方式建立動作項目物件，但您還是無法明確地刪除動作項目及其狀態。</span><span class="sxs-lookup"><span data-stu-id="d6b78-141">Although Reliable Actors implicitly create actor objects; you do have the ability to explicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="d6b78-142">散佈和容錯移轉</span><span class="sxs-lookup"><span data-stu-id="d6b78-142">Distribution and failover</span></span>
<span data-ttu-id="d6b78-143">為了提供延展性和可靠性，Service Fabric 將動作項目散佈於整個叢集，並視需要讓動作項目從失敗的節點自動移轉到狀況良好的節點。</span><span class="sxs-lookup"><span data-stu-id="d6b78-143">To provide scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</span></span> <span data-ttu-id="d6b78-144">這是 [已資料分割的具狀態可靠服務](service-fabric-concepts-partitioning.md)上的一個抽象概念。</span><span class="sxs-lookup"><span data-stu-id="d6b78-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="d6b78-145">散佈、延展性、可靠性及自動容錯移轉全都是憑藉動作項目正在名為「動作項目服務」 的具狀態可靠服務內執行的事實來提供。</span><span class="sxs-lookup"><span data-stu-id="d6b78-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of the fact that actors are running inside a stateful Reliable Service called the *Actor Service*.</span></span>

<span data-ttu-id="d6b78-146">動作項目會散佈在動作項目服務的分割區上，而這些分割區會散佈到 Service Fabric 叢集中的節點上。</span><span class="sxs-lookup"><span data-stu-id="d6b78-146">Actors are distributed across the partitions of the Actor Service, and those partitions are distributed across the nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="d6b78-147">每個服務分割區都會包含一組動作項目。</span><span class="sxs-lookup"><span data-stu-id="d6b78-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="d6b78-148">Service Fabric 會管理服務分割區的散佈和容錯移轉。</span><span class="sxs-lookup"><span data-stu-id="d6b78-148">Service Fabric manages distribution and failover of the service partitions.</span></span>

<span data-ttu-id="d6b78-149">例如，若動作項目服務具備九個使用預設動作項目分割區配置部署到三個節點的分割區，則會據此進行散佈：</span><span class="sxs-lookup"><span data-stu-id="d6b78-149">For example, an actor service with nine partitions deployed to three nodes using the default actor partition placement would be distributed thusly:</span></span>

![Reliable Actors 散佈][2]

<span data-ttu-id="d6b78-151">動作項目架構會為您管理分割區配置和索引鍵範圍設定。</span><span class="sxs-lookup"><span data-stu-id="d6b78-151">The Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="d6b78-152">這會簡化一些選項，但也會帶來一些考量︰</span><span class="sxs-lookup"><span data-stu-id="d6b78-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="d6b78-153">Reliable Services 可讓您選擇資料分割配置、索引鍵範圍 (使用定界分割配置)，以及分割區計數。</span><span class="sxs-lookup"><span data-stu-id="d6b78-153">Reliable Services allows you to choose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="d6b78-154">Reliable Actors 會限制為定界分割配置 (平均的 Int64 配置)，而且要求您使用完整的 Int64 索引鍵範圍。</span><span class="sxs-lookup"><span data-stu-id="d6b78-154">Reliable Actors is restricted to the range partitioning scheme (the uniform Int64 scheme) and requires you use the full Int64 key range.</span></span>
* <span data-ttu-id="d6b78-155">根據預設，動作項目會隨機放入分割區，形成平均散佈的結果。</span><span class="sxs-lookup"><span data-stu-id="d6b78-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="d6b78-156">由於動作項目是隨機放置的，所以應該預期動作項目作業一律需要網路通訊，包括方法呼叫資料的序列化和還原序列化，因而導致延遲和額外負荷。</span><span class="sxs-lookup"><span data-stu-id="d6b78-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="d6b78-157">在進階案例中，使用對應到特定分割區的 Int64 動作項目識別碼，就能控制動作項目分割區放置。</span><span class="sxs-lookup"><span data-stu-id="d6b78-157">In advanced scenarios, it is possible to control actor partition placement by using Int64 actor IDs that map to specific partitions.</span></span> <span data-ttu-id="d6b78-158">不過，這樣做會導致動作項目以不對稱方式散佈於分割區上。</span><span class="sxs-lookup"><span data-stu-id="d6b78-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="d6b78-159">如需如何分割動作項目服務的詳細資訊，請參閱 [動作項目的分割概念](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors)。</span><span class="sxs-lookup"><span data-stu-id="d6b78-159">For more information on how actor services are partitioned, refer to [partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="d6b78-160">動作項目通訊</span><span class="sxs-lookup"><span data-stu-id="d6b78-160">Actor communication</span></span>
<span data-ttu-id="d6b78-161">定義動作項目互動的介面是實作該介面的動作項目所共用的介面，而用戶端會透過同一個介面取得動作項目的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="d6b78-161">Actor interactions are defined in an interface that is shared by the actor that implements the interface, and the client that gets a proxy to an actor via the same interface.</span></span> <span data-ttu-id="d6b78-162">因為此介面是用來以非同步方式叫用動作項目方法，所以介面上的每個方法都必須傳回工作。</span><span class="sxs-lookup"><span data-stu-id="d6b78-162">Because this interface is used to invoke actor methods asynchronously, every method on the interface must be Task-returning.</span></span>

<span data-ttu-id="d6b78-163">方法引動過程及其回應最終會導致叢集中的網路要求，如此一來，引數與其所傳回之工作的結果類型必須可由平台序列化。</span><span class="sxs-lookup"><span data-stu-id="d6b78-163">Method invocations and their responses ultimately result in network requests across the cluster, so the arguments and the result types of the tasks that they return must be serializable by the platform.</span></span> <span data-ttu-id="d6b78-164">特別是，它們必須是 [資料合約序列化](service-fabric-reliable-actors-notes-on-actor-type-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="d6b78-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="the-actor-proxy"></a><span data-ttu-id="d6b78-165">動作項目 Proxy</span><span class="sxs-lookup"><span data-stu-id="d6b78-165">The actor proxy</span></span>
<span data-ttu-id="d6b78-166">Reliable Actors 用戶端 API 能夠在動作項目執行個體與動作項目用戶端之間提供通訊。</span><span class="sxs-lookup"><span data-stu-id="d6b78-166">The Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="d6b78-167">為了與動作項目通訊，用戶端會建立一個動作項目 Proxy 物件來實作動作項目介面。</span><span class="sxs-lookup"><span data-stu-id="d6b78-167">To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</span></span> <span data-ttu-id="d6b78-168">用戶端會叫用 Proxy 物件上的方法來與動作項目互動。</span><span class="sxs-lookup"><span data-stu-id="d6b78-168">The client interacts with the actor by invoking methods on the proxy object.</span></span> <span data-ttu-id="d6b78-169">動作項目 Proxy 可用於用戶端對動作項目以及動作項目對動作項目的通訊。</span><span class="sxs-lookup"><span data-stu-id="d6b78-169">The actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="d6b78-170">請注意，有兩段資訊用於建立動作項目 Proxy 物件：動作項目 ID 與應用程式名稱。</span><span class="sxs-lookup"><span data-stu-id="d6b78-170">Note that the two pieces of information used to create the actor proxy object are the actor ID and the application name.</span></span> <span data-ttu-id="d6b78-171">動作項目識別碼可唯一識別動作項目，而應用程式名稱可識別動作項目部署所在的 [Service Fabric 應用程式](service-fabric-reliable-actors-platform.md#application-model) 。</span><span class="sxs-lookup"><span data-stu-id="d6b78-171">The actor ID uniquely identifies the actor, while the application name identifies the [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where the actor is deployed.</span></span>

<span data-ttu-id="d6b78-172">用戶端上的 `ActorProxy`(C#) / `ActorProxyBase`(Java) 類别會執行必要的解決方案，以便依識別碼找到動作項目並開啟與該動作項目通訊的管道。</span><span class="sxs-lookup"><span data-stu-id="d6b78-172">The `ActorProxy`(C#) / `ActorProxyBase`(Java) class on the client side performs the necessary resolution to locate the actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="d6b78-173">它也會在通訊失敗和容錯移轉的情況下重新試著尋找動作項目。</span><span class="sxs-lookup"><span data-stu-id="d6b78-173">It also retries to locate the actor in the cases of communication failures and failovers.</span></span> <span data-ttu-id="d6b78-174">因此，訊息傳遞具有下列特性︰</span><span class="sxs-lookup"><span data-stu-id="d6b78-174">As a result, message delivery has the following characteristics:</span></span>

* <span data-ttu-id="d6b78-175">最好進行訊息傳遞。</span><span class="sxs-lookup"><span data-stu-id="d6b78-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="d6b78-176">動作項目可能收到來自相同用戶端的重複訊息。</span><span class="sxs-lookup"><span data-stu-id="d6b78-176">Actors may receive duplicate messages from the same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="d6b78-177">並行</span><span class="sxs-lookup"><span data-stu-id="d6b78-177">Concurrency</span></span>
<span data-ttu-id="d6b78-178">Reliable Actors 執行階段會提供簡單的回合式存取模型來存取動作項目方法。</span><span class="sxs-lookup"><span data-stu-id="d6b78-178">The Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="d6b78-179">這表示動作項目物件代碼內永遠只能有一個執行緒為使用中。</span><span class="sxs-lookup"><span data-stu-id="d6b78-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="d6b78-180">回合式存取會大幅簡化並行系統，因為不需要使用同步機制來進行資料存取。</span><span class="sxs-lookup"><span data-stu-id="d6b78-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="d6b78-181">這也表示系統必須針對每個動作項目執行個體的單一執行緒存取本質的特殊考量來設計。</span><span class="sxs-lookup"><span data-stu-id="d6b78-181">It also means systems must be designed with special considerations for the single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="d6b78-182">單一動作項目執行個體無法一次處理一個以上的要求。</span><span class="sxs-lookup"><span data-stu-id="d6b78-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="d6b78-183">如果預期動作項目執行個體要處理並行要求，可能就會遇到輸送量瓶頸。</span><span class="sxs-lookup"><span data-stu-id="d6b78-183">An actor instance can cause a throughput bottleneck if it is expected to handle concurrent requests.</span></span>
* <span data-ttu-id="d6b78-184">如果兩個動作項目之間有一個循環要求，同時還會對其中一個動作項目提出外部要求，則動作項目會在彼此間產生死結。</span><span class="sxs-lookup"><span data-stu-id="d6b78-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made to one of the actors simultaneously.</span></span> <span data-ttu-id="d6b78-185">動作項目執行階段將會在動作項目呼叫時自動逾時，並將例外狀況擲回呼叫端，以中斷可能發生的死結狀況。</span><span class="sxs-lookup"><span data-stu-id="d6b78-185">The actor runtime will automatically time out on actor calls and throw an exception to the caller to interrupt possible deadlock situations.</span></span>

![Reliable Actors 通訊][3]

#### <a name="turn-based-access"></a><span data-ttu-id="d6b78-187">回合式存取</span><span class="sxs-lookup"><span data-stu-id="d6b78-187">Turn-based access</span></span>
<span data-ttu-id="d6b78-188">一個回合包含完整執行動作項目方法以回應其他動作項目或用戶端的要求，或完整執行 [計時器/提醒](service-fabric-reliable-actors-timers-reminders.md) 回呼。</span><span class="sxs-lookup"><span data-stu-id="d6b78-188">A turn consists of the complete execution of an actor method in response to a request from other actors or clients, or the complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="d6b78-189">即使這些方法和回呼非同步，但動作項目執行階段並不使其交錯。</span><span class="sxs-lookup"><span data-stu-id="d6b78-189">Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them.</span></span> <span data-ttu-id="d6b78-190">必須完整完成一個回合，才能允許進行下一回合。</span><span class="sxs-lookup"><span data-stu-id="d6b78-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="d6b78-191">換句話說，計時器/提醒回呼目前正在執行的動作項目方法或計時器/提醒回呼必須完整完成，才能對方法或回呼進行新的呼叫。</span><span class="sxs-lookup"><span data-stu-id="d6b78-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call to a method or callback is allowed.</span></span> <span data-ttu-id="d6b78-192">如果已從方法或回呼傳回執行，且方法或回呼傳回的工作已完成，則會將方法或回呼視為已完成。</span><span class="sxs-lookup"><span data-stu-id="d6b78-192">A method or callback is considered to have finished if the execution has returned from the method or callback and the task returned by the method or callback has finished.</span></span> <span data-ttu-id="d6b78-193">值得強調的是，即使是在不同的方法、計時器與回呼之間，仍會遵守回合式並行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="d6b78-194">動作項目執行階段會藉由在某回合的開頭取得一個各動作項目鎖定，然後在回合結束時釋放該鎖定，來強制回合式並行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-194">The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</span></span> <span data-ttu-id="d6b78-195">因此，回合式並行會依各個動作項目強制執行，不會在動作項目之間強制執行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="d6b78-196">動作項目方法和計時器/提醒回撥可代表不同的動作項目同時執行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="d6b78-197">以下範例說明上述概念。</span><span class="sxs-lookup"><span data-stu-id="d6b78-197">The following example illustrates the above concepts.</span></span> <span data-ttu-id="d6b78-198">如果有一個動作項目類型實作兩個非同步方法 (假設為 Method1 與 Method2)，也就是計時器與提醒。</span><span class="sxs-lookup"><span data-stu-id="d6b78-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="d6b78-199">下圖顯示代表這兩個屬於此動作項目類型的動作項目 (ActorId1 與 ActorId2) 執行這些方法與回呼的時間軸範例。</span><span class="sxs-lookup"><span data-stu-id="d6b78-199">The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong to this actor type.</span></span>

![Reliable Actors 執行階段回合式並行和存取][1]

<span data-ttu-id="d6b78-201">此圖遵循下列慣例：</span><span class="sxs-lookup"><span data-stu-id="d6b78-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="d6b78-202">每一個垂直線顯示代表特定動作項目執行方法或回撥時的邏輯流程。</span><span class="sxs-lookup"><span data-stu-id="d6b78-202">Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="d6b78-203">每個垂直線上標示的事件依時間順序發生，新發生的事件排在舊事件下方。</span><span class="sxs-lookup"><span data-stu-id="d6b78-203">The events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="d6b78-204">時間軸使用不同的顏色來對應不同的動作項目。</span><span class="sxs-lookup"><span data-stu-id="d6b78-204">Different colors are used for timelines corresponding to different actors.</span></span>
* <span data-ttu-id="d6b78-205">反白顯示用於指出代表方法或回撥保留各動作項目鎖定的持續期間。</span><span class="sxs-lookup"><span data-stu-id="d6b78-205">Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="d6b78-206">有一些需要考慮的重要事項︰</span><span class="sxs-lookup"><span data-stu-id="d6b78-206">Some important points to consider:</span></span>

* <span data-ttu-id="d6b78-207">當 Method1 代表 ActorId2 執行以回應用戶端要求 xyz789 時，另一個抵達的用戶端要求 (abc123) 也需要 Method1 由 ActorId2 執行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-207">While *Method1* is executing on behalf of *ActorId2* in response to client request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* to be executed by *ActorId2*.</span></span> <span data-ttu-id="d6b78-208">不過， *Method1* 的第二次執行會在前一次執行完成後才開始。</span><span class="sxs-lookup"><span data-stu-id="d6b78-208">However, the second execution of *Method1* does not begin until the prior execution has finished.</span></span> <span data-ttu-id="d6b78-209">同樣的，由 ActorId2 註冊的提醒會在 Method1 正在執行時引發，以回應用戶端要求 xyz789。</span><span class="sxs-lookup"><span data-stu-id="d6b78-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response to client request *xyz789*.</span></span> <span data-ttu-id="d6b78-210">提醒回撥只會在 *Method1* 的這兩個執行都完成後才執行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-210">The reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="d6b78-211">所有的一切都是因為對 *ActorId2*強制執行回合式並行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-211">All of this is due to turn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="d6b78-212">同樣地，也會對 ActorId1 強制執行回合式並行，如代表依序發生的 ActorId1 執行 Method1、Method2 和計時器回呼所示。</span><span class="sxs-lookup"><span data-stu-id="d6b78-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by the execution of *Method1*, *Method2*, and the timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="d6b78-213">代表 ActorId1 執行 Method1 與代表 ActorId2 執行重疊。</span><span class="sxs-lookup"><span data-stu-id="d6b78-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="d6b78-214">這是因為回合式並行只會在動作項目內強制執行，不會在動作項目間強制執行。</span><span class="sxs-lookup"><span data-stu-id="d6b78-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="d6b78-215">在某些方法/回呼執行中，方法/回呼傳回的 `Task`(C#)/`CompletableFuture`(Java) 會在方法傳回後完成。</span><span class="sxs-lookup"><span data-stu-id="d6b78-215">In some of the method/callback executions, the `Task`(C#) / `CompletableFuture`(Java) returned by the method/callback finishes after the method returns.</span></span> <span data-ttu-id="d6b78-216">在某些其他執行中，已在方法/回呼傳回的時間前完成非同步作業。</span><span class="sxs-lookup"><span data-stu-id="d6b78-216">In some others, the asynchronous operation has already finished by the time the method/callback returns.</span></span> <span data-ttu-id="d6b78-217">在這兩種情況下，只有在方法/回呼傳回且完成非同步作業後，才會釋放各個動作項目鎖定。</span><span class="sxs-lookup"><span data-stu-id="d6b78-217">In both cases, the per-actor lock is released only after both the method/callback returns and the asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="d6b78-218">重新進入</span><span class="sxs-lookup"><span data-stu-id="d6b78-218">Reentrancy</span></span>
<span data-ttu-id="d6b78-219">動作項目執行階段依預設允許重新進入。</span><span class="sxs-lookup"><span data-stu-id="d6b78-219">The Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="d6b78-220">這表示如果 Actor A 的動作項目方法在 Actor B 上呼叫某一個方法，然後反過來在 Actor A 上呼叫另一個方法，則允許執行該方法。</span><span class="sxs-lookup"><span data-stu-id="d6b78-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed to run.</span></span> <span data-ttu-id="d6b78-221">這是因為該方法是同一個邏輯呼叫鏈結內容的一部分。</span><span class="sxs-lookup"><span data-stu-id="d6b78-221">This is because it is part of the same logical call-chain context.</span></span> <span data-ttu-id="d6b78-222">所有的計時器與提醒呼叫的開頭都是新的邏輯呼叫內容。</span><span class="sxs-lookup"><span data-stu-id="d6b78-222">All timer and reminder calls start with the new logical call context.</span></span> <span data-ttu-id="d6b78-223">如需詳細資訊，請參閱 [Reliable Actors 重新進入](service-fabric-reliable-actors-reentrancy.md) 。</span><span class="sxs-lookup"><span data-stu-id="d6b78-223">See the [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="d6b78-224">並行保證的範圍</span><span class="sxs-lookup"><span data-stu-id="d6b78-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="d6b78-225">動作項目執行階段在控制叫用這些方法的狀況下，提供這些並行保證。</span><span class="sxs-lookup"><span data-stu-id="d6b78-225">The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</span></span> <span data-ttu-id="d6b78-226">例如，動作項目執行階段會對為回應用戶端要求而進行的方法叫用，以及對計時器與提醒回呼提供這些保證。</span><span class="sxs-lookup"><span data-stu-id="d6b78-226">For example, it provides these guarantees for the method invocations that are done in response to a client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="d6b78-227">然而，如果動作項目程式碼在動作項目執行階段提供的機制之外直接叫用這些方法，則執行階段無法提供任何並行保證。</span><span class="sxs-lookup"><span data-stu-id="d6b78-227">However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="d6b78-228">例如，如果在某個與動作項目方法所傳回的工作不相關聯的工作內容中叫用方法，則執行階段無法提供並行保證。</span><span class="sxs-lookup"><span data-stu-id="d6b78-228">For example, if the method is invoked in the context of some task that is not associated with the task returned by the actor methods, then the runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="d6b78-229">如果從動作項目自行建立的執行緒叫用方法，則執行階段也無法提供並行保證。</span><span class="sxs-lookup"><span data-stu-id="d6b78-229">If the method is invoked from a thread that the actor creates on its own, then the runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="d6b78-230">因此，若要執行背景作業，動作項目應使用遵守回合式並行的 [動作項目計時器和動作項目提醒](service-fabric-reliable-actors-timers-reminders.md) 。</span><span class="sxs-lookup"><span data-stu-id="d6b78-230">Therefore, to perform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="d6b78-231">後續步驟</span><span class="sxs-lookup"><span data-stu-id="d6b78-231">Next steps</span></span>
* <span data-ttu-id="d6b78-232">從建置您的第一個 Reliable Actors 服務開始著手：</span><span class="sxs-lookup"><span data-stu-id="d6b78-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="d6b78-233">開始在 .NET 上使用 Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="d6b78-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="d6b78-234">開始在 Java 上使用 Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="d6b78-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
