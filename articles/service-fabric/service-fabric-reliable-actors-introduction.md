---
title: "aaaService 網狀架構可靠的動作項目概觀 |Microsoft 文件"
description: "簡介 toohello 服務網狀架構 Reliable Actors 程式撰寫模型。"
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="8a87c-103">簡介 tooService 網狀架構 Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="8a87c-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="8a87c-104">Reliable Actors 是根據 hello Service Fabric 應用程式架構[Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/)模式。</span><span class="sxs-lookup"><span data-stu-id="8a87c-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="8a87c-105">hello 可靠的執行者 API 提供了單一執行緒程式撰寫模型之上 hello 延展性和可靠性保證服務網狀架構所提供。</span><span class="sxs-lookup"><span data-stu-id="8a87c-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="8a87c-106">什麼是動作項目？</span><span class="sxs-lookup"><span data-stu-id="8a87c-106">What are Actors?</span></span>
<span data-ttu-id="8a87c-107">動作項目是隔離且獨立的計算與狀態單位，且具備單一執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="8a87c-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="8a87c-108">hello [actor 模式](https://en.wikipedia.org/wiki/Actor_model)是並行或分散式系統中的大量的這些執行者可以同時執行，以及各自的運算模型。</span><span class="sxs-lookup"><span data-stu-id="8a87c-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="8a87c-109">動作項目可以彼此通訊，而且可以建立多個動作項目。</span><span class="sxs-lookup"><span data-stu-id="8a87c-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="8a87c-110">當 toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="8a87c-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="8a87c-111">服務網狀架構 Reliable Actors 是 hello 執行者設計模式的實作。</span><span class="sxs-lookup"><span data-stu-id="8a87c-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="8a87c-112">如同任何軟體設計模式中，是否 toouse 特定的模式會根據軟體設計問題 hello 決策符合 hello 模式。</span><span class="sxs-lookup"><span data-stu-id="8a87c-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="8a87c-113">雖然 hello 執行者設計模式可以是很好的調整的 tooa 許多分散式的系統問題及案例、 仔細地考量 hello hello 模式和 hello 架構實作必須進行的條件約束。</span><span class="sxs-lookup"><span data-stu-id="8a87c-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="8a87c-114">做為一般的指導，請考慮 hello actor 模式 toomodel 您的問題或案例如果：</span><span class="sxs-lookup"><span data-stu-id="8a87c-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="8a87c-115">您的問題領域涉及大量 (數千個或更多) 小型、獨立且隔離的狀態和邏輯單位。</span><span class="sxs-lookup"><span data-stu-id="8a87c-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="8a87c-116">您想使用單一執行緒的物件不需要重大的互動，舉凡外部元件，包括跨的執行者集合查詢狀態 toowork。</span><span class="sxs-lookup"><span data-stu-id="8a87c-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="8a87c-117">您的動作項目執行個體將不會藉由發出 I/O 作業，使用無法預期的延遲來封鎖呼叫端。</span><span class="sxs-lookup"><span data-stu-id="8a87c-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="8a87c-118">Service Fabric 中的動作項目</span><span class="sxs-lookup"><span data-stu-id="8a87c-118">Actors in Service Fabric</span></span>
<span data-ttu-id="8a87c-119">在 Service Fabric 動作項目會實作在 hello Reliable Actors framework： 動作項目模式的應用程式架構之上[Service Fabric 可靠服務](service-fabric-reliable-services-introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="8a87c-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="8a87c-120">您撰寫的每個 Reliable Actor 服務實際上都是已資料分割的具狀態可靠服務。</span><span class="sxs-lookup"><span data-stu-id="8a87c-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="8a87c-121">每個動作項目定義為動作項目類型的執行個體，相同 toohello 方式.NET 物件的.NET 型別執行個體。</span><span class="sxs-lookup"><span data-stu-id="8a87c-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="8a87c-122">例如，可能實作計算機 hello 功能動作項目類型，可能是該類型的不同節點分散叢集的許多參與者。</span><span class="sxs-lookup"><span data-stu-id="8a87c-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="8a87c-123">每一個這類的動作項目都有唯一的動作項目識別碼識別。</span><span class="sxs-lookup"><span data-stu-id="8a87c-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="8a87c-124">動作項目生命週期</span><span class="sxs-lookup"><span data-stu-id="8a87c-124">Actor Lifetime</span></span>
<span data-ttu-id="8a87c-125">Service Fabric 動作項目都是虛擬的這表示它們的存留時間不繫結的 tootheir 記憶體中表示。</span><span class="sxs-lookup"><span data-stu-id="8a87c-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="8a87c-126">如此一來，不需要 toobe 明確建立或終結。</span><span class="sxs-lookup"><span data-stu-id="8a87c-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="8a87c-127">hello Reliable Actors 執行階段會自動啟動動作項目 hello 第一次收到要求的動作項目 id。</span><span class="sxs-lookup"><span data-stu-id="8a87c-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="8a87c-128">如果動作項目不是一段時間，hello Reliable Actors 執行階段記憶體回收-收集 hello 記憶體內部物件。</span><span class="sxs-lookup"><span data-stu-id="8a87c-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="8a87c-129">它也會維護知識的動作項目 hello 存在應該需要 toobe 稍後重新啟動。</span><span class="sxs-lookup"><span data-stu-id="8a87c-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="8a87c-130">如需詳細資訊，請參閱 [動作項目生命週期與記憶體回收](service-fabric-reliable-actors-lifecycle.md)。</span><span class="sxs-lookup"><span data-stu-id="8a87c-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="8a87c-131">這個虛擬動作項目存留期抽象層通訊 hello 虛擬執行者模型，因為某些注意事項，且事實上 hello Reliable Actors 實作偏離有時候這種模型。</span><span class="sxs-lookup"><span data-stu-id="8a87c-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="8a87c-132">動作項目會自動啟動 （導致動作項目建構的物件 toobe） hello 第一次將訊息傳送 tooits 動作項目識別碼。</span><span class="sxs-lookup"><span data-stu-id="8a87c-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="8a87c-133">在一段時間之後, hello 動作項目物件是記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="8a87c-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="8a87c-134">Hello 在未來，同樣地，使用 hello 動作項目識別碼可能會建構物件 toobe 新動作項目。</span><span class="sxs-lookup"><span data-stu-id="8a87c-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="8a87c-135">動作項目狀態存留時間超過 hello 物件的存留時間會儲存在 hello 狀態管理員時。</span><span class="sxs-lookup"><span data-stu-id="8a87c-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="8a87c-136">針對動作項目識別碼呼叫任何動作項目方法都會啟動該動作項目。</span><span class="sxs-lookup"><span data-stu-id="8a87c-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="8a87c-137">基於這個理由，動作項目類型都有由 hello 執行階段隱含地呼叫其建構函式。</span><span class="sxs-lookup"><span data-stu-id="8a87c-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="8a87c-138">因此，用戶端程式碼無法成功參數 toohello 動作項目類型的建構函式，雖然參數可能會依據 hello 服務本身傳遞 toohello 執行者建構函式。</span><span class="sxs-lookup"><span data-stu-id="8a87c-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="8a87c-139">hello 結果是，執行者可能會建構部分初始化的狀態，在呼叫其他方法的 hello 時間如果 hello 動作項目需要從 hello 用戶端的初始化參數。</span><span class="sxs-lookup"><span data-stu-id="8a87c-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="8a87c-140">沒有 hello 啟動動作項目從 hello 用戶端的單一進入點。</span><span class="sxs-lookup"><span data-stu-id="8a87c-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="8a87c-141">雖然 Reliable Actors 會隱含地建立動作項目物件。您沒有 hello 能力 tooexplicitly 刪除動作項目和其狀態。</span><span class="sxs-lookup"><span data-stu-id="8a87c-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="8a87c-142">散佈和容錯移轉</span><span class="sxs-lookup"><span data-stu-id="8a87c-142">Distribution and failover</span></span>
<span data-ttu-id="8a87c-143">Service Fabric tooprovide 延展性和可靠性，分散執行者整個 hello 叢集並自動將它們從失敗的節點 toohealthy 的視需要移轉。</span><span class="sxs-lookup"><span data-stu-id="8a87c-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="8a87c-144">這是 [已資料分割的具狀態可靠服務](service-fabric-concepts-partitioning.md)上的一個抽象概念。</span><span class="sxs-lookup"><span data-stu-id="8a87c-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="8a87c-145">發佈、 延展性、 可靠性和自動容錯移轉所有提供必定 hello 事實內呼叫 hello 可設定狀態 Reliable Service 執行執行者*Actor 服務*。</span><span class="sxs-lookup"><span data-stu-id="8a87c-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="8a87c-146">執行者會分散到 hello 的 hello 行動服務的資料分割，分割區區的分散於 hello Service Fabric 叢集中的節點。</span><span class="sxs-lookup"><span data-stu-id="8a87c-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="8a87c-147">每個服務分割區都會包含一組動作項目。</span><span class="sxs-lookup"><span data-stu-id="8a87c-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="8a87c-148">Service Fabric 管理分散和容錯移轉的 hello 服務資料分割。</span><span class="sxs-lookup"><span data-stu-id="8a87c-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="8a87c-149">例如，具有 9 個資料分割的行動服務部署的 toothree 使用 hello 預設動作項目資料分割的位置節點會據此分散式：</span><span class="sxs-lookup"><span data-stu-id="8a87c-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Reliable Actors 散佈][2]

<span data-ttu-id="8a87c-151">hello 執行者架構會管理您的資料分割配置和索引鍵範圍設定。</span><span class="sxs-lookup"><span data-stu-id="8a87c-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="8a87c-152">這會簡化一些選項，但也會帶來一些考量︰</span><span class="sxs-lookup"><span data-stu-id="8a87c-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="8a87c-153">可靠的服務可讓您 toochoose 資料分割配置，索引鍵的範圍 （當使用資料分割配置的範圍），以及資料分割計數。</span><span class="sxs-lookup"><span data-stu-id="8a87c-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="8a87c-154">Reliable Actors 限制的 toohello 範圍的資料分割配置 （hello 統一 Int64 配置），而且需要使用 hello 完整 Int64 範圍。</span><span class="sxs-lookup"><span data-stu-id="8a87c-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="8a87c-155">根據預設，動作項目會隨機放入分割區，形成平均散佈的結果。</span><span class="sxs-lookup"><span data-stu-id="8a87c-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="8a87c-156">由於動作項目是隨機放置的，所以應該預期動作項目作業一律需要網路通訊，包括方法呼叫資料的序列化和還原序列化，因而導致延遲和額外負荷。</span><span class="sxs-lookup"><span data-stu-id="8a87c-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="8a87c-157">在進階案例中，很可能 toocontrol 動作項目資料分割配置使用 Int64 執行者 toospecific 資料分割對應的識別碼。</span><span class="sxs-lookup"><span data-stu-id="8a87c-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="8a87c-158">不過，這樣做會導致動作項目以不對稱方式散佈於分割區上。</span><span class="sxs-lookup"><span data-stu-id="8a87c-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="8a87c-159">如需有關如何資料分割動作項目服務的詳細資訊，請參閱太[分割概念的執行者](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors)。</span><span class="sxs-lookup"><span data-stu-id="8a87c-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="8a87c-160">動作項目通訊</span><span class="sxs-lookup"><span data-stu-id="8a87c-160">Actor communication</span></span>
<span data-ttu-id="8a87c-161">執行者互動的介面，實作 hello 介面 hello 執行者與 hello 用戶端取得 proxy tooan 執行者 hello 透過共用中定義相同的介面。</span><span class="sxs-lookup"><span data-stu-id="8a87c-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="8a87c-162">這個介面會以非同步的方式是使用的 tooinvoke 執行者方法，因為 hello 介面上的每個方法必須傳回工作。</span><span class="sxs-lookup"><span data-stu-id="8a87c-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="8a87c-163">方法引動過程和它們對回應最後會導致在網路要求跨 hello 叢集，因此 hello 引數和傳回必須可序列化 hello 平台的 hello 工作 hello 結果類型。</span><span class="sxs-lookup"><span data-stu-id="8a87c-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="8a87c-164">特別是，它們必須是 [資料合約序列化](service-fabric-reliable-actors-notes-on-actor-type-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="8a87c-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="8a87c-165">hello 執行者 proxy</span><span class="sxs-lookup"><span data-stu-id="8a87c-165">hello actor proxy</span></span>
<span data-ttu-id="8a87c-166">hello Reliable Actors 用戶端應用程式開發介面提供動作項目執行個體與行動用戶端之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="8a87c-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="8a87c-167">與 actor toocommunicate，用戶端會建立實作 hello 執行者介面執行者 proxy 物件。</span><span class="sxs-lookup"><span data-stu-id="8a87c-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="8a87c-168">hello 用戶端會與 hello 執行者互動 hello proxy 物件上的叫用方法。</span><span class="sxs-lookup"><span data-stu-id="8a87c-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="8a87c-169">hello 執行者 proxy 可用於用戶端以動作項目和動作項目以動作項目通訊。</span><span class="sxs-lookup"><span data-stu-id="8a87c-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="8a87c-170">請注意，hello 兩項資訊會使用 toocreate hello 執行者 proxy 物件是 hello 動作項目識別碼和 hello 應用程式名稱。</span><span class="sxs-lookup"><span data-stu-id="8a87c-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="8a87c-171">hello 動作項目識別碼可唯一識別 hello 動作項目，雖然 hello 應用程式名稱會識別 hello [Service Fabric 應用程式](service-fabric-reliable-actors-platform.md#application-model)hello 動作項目部署的位置。</span><span class="sxs-lookup"><span data-stu-id="8a87c-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="8a87c-172">hello `ActorProxy`(C#) / `ActorProxyBase`hello 用戶端 (Java) 類別執行 hello 需要解析 toolocate hello 動作項目識別碼，並使用它開啟的通訊通道。</span><span class="sxs-lookup"><span data-stu-id="8a87c-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="8a87c-173">它也會重試 toolocate hello 動作項目在 hello 的通訊失敗和容錯移轉的情況下。</span><span class="sxs-lookup"><span data-stu-id="8a87c-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="8a87c-174">如此一來，訊息傳遞具有下列特性的 hello:</span><span class="sxs-lookup"><span data-stu-id="8a87c-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="8a87c-175">最好進行訊息傳遞。</span><span class="sxs-lookup"><span data-stu-id="8a87c-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="8a87c-176">動作項目可能會收到 hello 重複的訊息相同的用戶端。</span><span class="sxs-lookup"><span data-stu-id="8a87c-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="8a87c-177">並行</span><span class="sxs-lookup"><span data-stu-id="8a87c-177">Concurrency</span></span>
<span data-ttu-id="8a87c-178">hello Reliable Actors 執行階段會提供簡單開啟為基礎的存取模型的存取動作方法。</span><span class="sxs-lookup"><span data-stu-id="8a87c-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="8a87c-179">這表示動作項目物件代碼內永遠只能有一個執行緒為使用中。</span><span class="sxs-lookup"><span data-stu-id="8a87c-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="8a87c-180">回合式存取會大幅簡化並行系統，因為不需要使用同步機制來進行資料存取。</span><span class="sxs-lookup"><span data-stu-id="8a87c-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="8a87c-181">這也表示系統必須設計成與 hello 單一執行緒存取的情況，每個動作項目執行個體的特殊考量。</span><span class="sxs-lookup"><span data-stu-id="8a87c-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="8a87c-182">單一動作項目執行個體無法一次處理一個以上的要求。</span><span class="sxs-lookup"><span data-stu-id="8a87c-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="8a87c-183">動作項目執行個體可能會造成的輸送量瓶頸，如果預期的 toohandle 並行要求。</span><span class="sxs-lookup"><span data-stu-id="8a87c-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="8a87c-184">如果外部的要求會同時進行的 hello 執行者 tooone 時的兩個執行者之間的循環的要求，另一方動作項目可能會發生死結。</span><span class="sxs-lookup"><span data-stu-id="8a87c-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="8a87c-185">hello 動作項目執行階段會自動動作項目上的逾時的時間呼叫，並擲回例外狀況 toohello 呼叫端 toointerrupt 發生死結狀況。</span><span class="sxs-lookup"><span data-stu-id="8a87c-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Reliable Actors 通訊][3]

#### <a name="turn-based-access"></a><span data-ttu-id="8a87c-187">回合式存取</span><span class="sxs-lookup"><span data-stu-id="8a87c-187">Turn-based access</span></span>
<span data-ttu-id="8a87c-188">開啟包含 hello 完成執行的動作項目中的方法從其他執行者或用戶端的回應 tooa 要求或 hello 完整執行[計時器/提醒](service-fabric-reliable-actors-timers-reminders.md)回呼。</span><span class="sxs-lookup"><span data-stu-id="8a87c-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="8a87c-189">雖然這些方法和回呼是非同步，hello 執行者執行階段不會不會交錯它們。</span><span class="sxs-lookup"><span data-stu-id="8a87c-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="8a87c-190">必須完整完成一個回合，才能允許進行下一回合。</span><span class="sxs-lookup"><span data-stu-id="8a87c-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="8a87c-191">換句話說，目前正在執行的動作項目方法或計時器/提醒回呼必須是完全完成新的呼叫 tooa 方法之前，或允許回呼。</span><span class="sxs-lookup"><span data-stu-id="8a87c-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="8a87c-192">方法或回撥會被視為 toohave 完成如果 hello 方法已傳回 hello 執行或回呼和 hello hello 方法或回撥所傳回的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="8a87c-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="8a87c-193">值得強調的是，即使是在不同的方法、計時器與回呼之間，仍會遵守回合式並行。</span><span class="sxs-lookup"><span data-stu-id="8a87c-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="8a87c-194">hello 執行者執行階段，便會強制關閉並行輪流 hello 開頭處取得每個動作項目鎖定並釋放結尾 hello hello hello 鎖定開啟。</span><span class="sxs-lookup"><span data-stu-id="8a87c-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="8a87c-195">因此，回合式並行會依各個動作項目強制執行，不會在動作項目之間強制執行。</span><span class="sxs-lookup"><span data-stu-id="8a87c-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="8a87c-196">動作項目方法和計時器/提醒回撥可代表不同的動作項目同時執行。</span><span class="sxs-lookup"><span data-stu-id="8a87c-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="8a87c-197">hello 下列範例將說明上述概念 hello。</span><span class="sxs-lookup"><span data-stu-id="8a87c-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="8a87c-198">如果有一個動作項目類型實作兩個非同步方法 (假設為 Method1 與 Method2)，也就是計時器與提醒。</span><span class="sxs-lookup"><span data-stu-id="8a87c-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="8a87c-199">hello 圖顯示以 hello 執行這些方法和回呼代表兩個動作項目以時間表的範例 (*ActorId1*和*ActorId2*) 隸屬 toothis 動作項目類型。</span><span class="sxs-lookup"><span data-stu-id="8a87c-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Reliable Actors 執行階段回合式並行和存取][1]

<span data-ttu-id="8a87c-201">此圖遵循下列慣例：</span><span class="sxs-lookup"><span data-stu-id="8a87c-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="8a87c-202">每個垂直行顯示 hello 邏輯的執行流程方法或回呼代表特定的動作項目。</span><span class="sxs-lookup"><span data-stu-id="8a87c-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="8a87c-203">依時間先後順序，會出現較新的事件發生以下較舊的 hello 標示每個垂直行上的事件。</span><span class="sxs-lookup"><span data-stu-id="8a87c-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="8a87c-204">時間表對應 toodifferent 執行者會使用不同的色彩。</span><span class="sxs-lookup"><span data-stu-id="8a87c-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="8a87c-205">反白顯示為使用的 tooindicate hello 持續時間的 hello 每個動作項目鎖定代表方法或回呼。</span><span class="sxs-lookup"><span data-stu-id="8a87c-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="8a87c-206">一些重點 tooconsider:</span><span class="sxs-lookup"><span data-stu-id="8a87c-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="8a87c-207">雖然*Method1*執行代表*ActorId2*回應 tooclient 要求中*xyz789*，另一個用戶端要求 (*abc123*)到達時，也需要*Method1* toobe 執行者*ActorId2*。</span><span class="sxs-lookup"><span data-stu-id="8a87c-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="8a87c-208">不過，hello 的第二次執行*Method1* hello 之前執行完成之前不會開始。</span><span class="sxs-lookup"><span data-stu-id="8a87c-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="8a87c-209">同樣地，好提醒您註冊*ActorId2*時引發*Method1*是否正以回應 tooclient 要求執行*xyz789*。</span><span class="sxs-lookup"><span data-stu-id="8a87c-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="8a87c-210">hello 提醒執行回呼的這兩個執行後才*Method1*都已完成。</span><span class="sxs-lookup"><span data-stu-id="8a87c-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="8a87c-211">這是因為 tooturn 為基礎的強制執行的並行存取*ActorId2*。</span><span class="sxs-lookup"><span data-stu-id="8a87c-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="8a87c-212">開啟並行也同樣地，強制針對*ActorId1*hello 執行所示*Method1*， *Method2*，和 hello 代表計時器回呼*ActorId1*以序列方式發生。</span><span class="sxs-lookup"><span data-stu-id="8a87c-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="8a87c-213">代表 ActorId1 執行 Method1 與代表 ActorId2 執行重疊。</span><span class="sxs-lookup"><span data-stu-id="8a87c-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="8a87c-214">這是因為回合式並行只會在動作項目內強制執行，不會在動作項目間強制執行。</span><span class="sxs-lookup"><span data-stu-id="8a87c-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="8a87c-215">在某些 hello/回呼方法執行的 hello `Task`(C#) / `CompletableFuture`(Java) 傳回 hello/回呼方法完成之後 hello 方法會傳回。</span><span class="sxs-lookup"><span data-stu-id="8a87c-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="8a87c-216">在某些其他 hello 非同步作業已經完成 hello hello 方法/回呼傳回的時間。</span><span class="sxs-lookup"><span data-stu-id="8a87c-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="8a87c-217">在這兩種情況下，這兩個 hello 方法/回呼傳回和 hello 非同步作業完成之後，才會釋放 hello 每個動作項目鎖定。</span><span class="sxs-lookup"><span data-stu-id="8a87c-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="8a87c-218">重新進入</span><span class="sxs-lookup"><span data-stu-id="8a87c-218">Reentrancy</span></span>
<span data-ttu-id="8a87c-219">hello 執行者執行階段預設允許重新進入。</span><span class="sxs-lookup"><span data-stu-id="8a87c-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="8a87c-220">這表示，如果執行者方法*動作項目 A*上呼叫方法*動作項目 B*，接著呼叫另一個方法上*動作項目 A*，toorun 允許方法。</span><span class="sxs-lookup"><span data-stu-id="8a87c-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="8a87c-221">這是因為它屬於 hello 的相同邏輯的呼叫鏈結的內容。</span><span class="sxs-lookup"><span data-stu-id="8a87c-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="8a87c-222">所有的計時器佇列與提醒呼叫 hello 新邏輯呼叫內容的開頭。</span><span class="sxs-lookup"><span data-stu-id="8a87c-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="8a87c-223">請參閱 hello [Reliable Actors 重新進入](service-fabric-reliable-actors-reentrancy.md)如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="8a87c-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="8a87c-224">並行保證的範圍</span><span class="sxs-lookup"><span data-stu-id="8a87c-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="8a87c-225">hello 執行者執行階段提供這些並行保證在其中它所控制的這些方法的引動過程 hello 的情況下。</span><span class="sxs-lookup"><span data-stu-id="8a87c-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="8a87c-226">例如，它會提供這些保證 hello 方法引動過程會在回應 tooa 用戶端要求中完成，以及計時器和提示的回呼。</span><span class="sxs-lookup"><span data-stu-id="8a87c-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="8a87c-227">不過，如果 hello 行動程式碼直接叫用這些方法之外 hello hello 執行者執行階段所提供的機制，然後 hello 執行階段無法提供任何並行保證。</span><span class="sxs-lookup"><span data-stu-id="8a87c-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="8a87c-228">例如，如果 hello 方法會叫用 hello 內容未與 hello 執行者方法所傳回的 hello 工作相關聯的某些工作中，然後 hello 執行階段無法提供並行保證。</span><span class="sxs-lookup"><span data-stu-id="8a87c-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="8a87c-229">如果 hello 方法從執行緒叫用該 hello 動作項目會建立其本身，則 hello 執行階段也無法提供並行的保證。</span><span class="sxs-lookup"><span data-stu-id="8a87c-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="8a87c-230">因此，tooperform 背景作業，動作項目應該使用[執行者計時器和執行者提醒](service-fabric-reliable-actors-timers-reminders.md)，尊重開啟基礎的並行存取。</span><span class="sxs-lookup"><span data-stu-id="8a87c-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="8a87c-231">後續步驟</span><span class="sxs-lookup"><span data-stu-id="8a87c-231">Next steps</span></span>
* <span data-ttu-id="8a87c-232">從建置您的第一個 Reliable Actors 服務開始著手：</span><span class="sxs-lookup"><span data-stu-id="8a87c-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="8a87c-233">開始在 .NET 上使用 Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="8a87c-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="8a87c-234">開始在 Java 上使用 Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="8a87c-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
