---
title: "Service Fabric 服務的延展性 | Microsoft Docs"
description: "描述如何調整 Service Fabric 服務"
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: ed324f23-242f-47b7-af1a-e55c839e7d5d
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: e2dd48341499b18ebd1433611063746e95a5ac62
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/29/2017
---
# <a name="scaling-in-service-fabric"></a><span data-ttu-id="d83ae-103">Service Fabric 中的縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-103">Scaling in Service Fabric</span></span>
<span data-ttu-id="d83ae-104">Azure Service Fabric 可管理叢集節點上的服務、分割區和複本，讓您輕鬆建置可調整的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d83ae-104">Azure Service Fabric makes it easy to build scalable applications by managing the services, partitions, and replicas on the nodes of a cluster.</span></span> <span data-ttu-id="d83ae-105">在相同硬體上執行許多工作負載時，會獲得最大資源使用量，還可以針對您選擇調整工作負載的方式提供彈性。</span><span class="sxs-lookup"><span data-stu-id="d83ae-105">Running many workloads on the same hardware enables maximum resource utilization, but also provides flexibility in terms of how you choose to scale your workloads.</span></span> 

<span data-ttu-id="d83ae-106">Service Fabric 的縮放比例會以數種不同的方式來完成：</span><span class="sxs-lookup"><span data-stu-id="d83ae-106">Scaling in Service Fabric is accomplished several different ways:</span></span>

1. <span data-ttu-id="d83ae-107">透過建立或移除無狀態服務執行個體進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-107">Scaling by creating or removing stateless service instances</span></span>
2. <span data-ttu-id="d83ae-108">透過建立或移除新的具名服務進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-108">Scaling by creating or removing new named services</span></span>
3. <span data-ttu-id="d83ae-109">透過建立或移除新的具名應用程式執行個體進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-109">Scaling by creating or removing new named application instances</span></span>
4. <span data-ttu-id="d83ae-110">使用分割區的服務進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-110">Scaling by using partitioned services</span></span>
5. <span data-ttu-id="d83ae-111">透過新增和移除叢集中的節點進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-111">Scaling by adding and removing nodes from the cluster</span></span> 
6. <span data-ttu-id="d83ae-112">使用叢集 Resource Manager 計量進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-112">Scaling by using Cluster Resource Manager metrics</span></span>

## <a name="scaling-by-creating-or-removing-stateless-service-instances"></a><span data-ttu-id="d83ae-113">透過建立或移除無狀態服務執行個體進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-113">Scaling by creating or removing stateless service instances</span></span>
<span data-ttu-id="d83ae-114">在 Service Fabric 內進行縮放的其中一種最簡單方式可適用於無狀態服務。</span><span class="sxs-lookup"><span data-stu-id="d83ae-114">One of the simplest ways to scale within Service Fabric works with stateless services.</span></span> <span data-ttu-id="d83ae-115">當您建立無狀態服務時，有機會可定義 `InstanceCount`。</span><span class="sxs-lookup"><span data-stu-id="d83ae-115">When you create a stateless service, you get a chance to define an `InstanceCount`.</span></span> <span data-ttu-id="d83ae-116">`InstanceCount` 會定義服務啟動時要建立幾份該服務程式碼的執行中複本。</span><span class="sxs-lookup"><span data-stu-id="d83ae-116">`InstanceCount` defines how many running copies of that service's code are created when the service starts up.</span></span> <span data-ttu-id="d83ae-117">比方說，叢集中有 100 個節點。</span><span class="sxs-lookup"><span data-stu-id="d83ae-117">Let's say, for example, that there are 100 nodes in the cluster.</span></span> <span data-ttu-id="d83ae-118">另外再假設建立服務時，`InstanceCount` 為 10。</span><span class="sxs-lookup"><span data-stu-id="d83ae-118">Let's also say that a service is created with an `InstanceCount` of 10.</span></span> <span data-ttu-id="d83ae-119">在執行階段期間，程式碼的 10 個執行中複本可能全部會變得太忙碌 (或可能不是足夠忙碌)。</span><span class="sxs-lookup"><span data-stu-id="d83ae-119">During runtime, those 10 running copies of the code could all become too busy (or could be not busy enough).</span></span> <span data-ttu-id="d83ae-120">調整該工作負載的其中一種方式是變更執行個體數目。</span><span class="sxs-lookup"><span data-stu-id="d83ae-120">One way to scale that workload is to change the number of instances.</span></span> <span data-ttu-id="d83ae-121">例如，監視或管理的程式碼有某些部分可以將現有的執行個體數目變更為 50 (或變更為 5)，取決於是否需要以負載作為基礎，將工作負載相應縮小或相應放大。</span><span class="sxs-lookup"><span data-stu-id="d83ae-121">For example, some piece of monitoring or management code can change the existing number of instances to 50, or to 5, depending on whether the workload needs to scale in or out based on the load.</span></span> 

<span data-ttu-id="d83ae-122">C#：</span><span class="sxs-lookup"><span data-stu-id="d83ae-122">C#:</span></span>

```csharp
StatelessServiceUpdateDescription updateDescription = new StatelessServiceUpdateDescription(); 
updateDescription.InstanceCount = 50;
await fabricClient.ServiceManager.UpdateServiceAsync(new Uri("fabric:/app/service"), updateDescription);
```

<span data-ttu-id="d83ae-123">PowerShell：</span><span class="sxs-lookup"><span data-stu-id="d83ae-123">Powershell:</span></span>

```posh
Update-ServiceFabricService -Stateless -ServiceName $serviceName -InstanceCount 50
```
### <a name="using-dynamic-instance-count"></a><span data-ttu-id="d83ae-124">使用動態執行個體計數</span><span class="sxs-lookup"><span data-stu-id="d83ae-124">Using Dynamic Instance Count</span></span>
<span data-ttu-id="d83ae-125">特別針對無狀態服務，Service Fabric 會提供變更執行個體計數的自動方式。</span><span class="sxs-lookup"><span data-stu-id="d83ae-125">Specifically for stateless services, Service Fabric offers an automatic way to change the instance count.</span></span> <span data-ttu-id="d83ae-126">這可讓服務使用可用的節點數目進行動態縮放。</span><span class="sxs-lookup"><span data-stu-id="d83ae-126">This allows the service to scale dynamically with the number of nodes that are available.</span></span> <span data-ttu-id="d83ae-127">選擇此行為的方式，是設定執行個體計數 = -1。</span><span class="sxs-lookup"><span data-stu-id="d83ae-127">The way to opt into this behavior is to set the instance count = -1.</span></span> <span data-ttu-id="d83ae-128">InstanceCount = -1 是 Service Fabric 的指示，顯示「在每個節點上執行此無狀態服務」。</span><span class="sxs-lookup"><span data-stu-id="d83ae-128">InstanceCount = -1 is an instruction to Service Fabric that says "Run this stateless service on every node."</span></span> <span data-ttu-id="d83ae-129">如果節點的數目有所變更，Service Fabric 就會自動變更要比對的執行個體計數，從而確保服務是在所有的有效節點上執行。</span><span class="sxs-lookup"><span data-stu-id="d83ae-129">If the number of nodes changes, Service Fabric automatically changes the instance count to match, ensuring that the service is running on all valid nodes.</span></span> 

<span data-ttu-id="d83ae-130">C#：</span><span class="sxs-lookup"><span data-stu-id="d83ae-130">C#:</span></span>

```csharp
StatelessServiceDescription serviceDescription = new StatelessServiceDescription();
//Set other service properties necessary for creation....
serviceDescription.InstanceCount = -1;
await fc.ServiceManager.CreateServiceAsync(serviceDescription);
```

<span data-ttu-id="d83ae-131">PowerShell：</span><span class="sxs-lookup"><span data-stu-id="d83ae-131">Powershell:</span></span>

```posh
New-ServiceFabricService -ApplicationName $applicationName -ServiceName $serviceName -ServiceTypeName $serviceTypeName -Stateless -PartitionSchemeSingleton -InstanceCount "-1"
```

## <a name="scaling-by-creating-or-removing-new-named-services"></a><span data-ttu-id="d83ae-132">透過建立或移除新的具名服務進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-132">Scaling by creating or removing new named services</span></span>
<span data-ttu-id="d83ae-133">具名服務執行個體是一些叢集中具名應用程式執行個體內的服務類型之特定執行個體 (請參閱 [Service Fabric 應用程式生命週期](service-fabric-application-lifecycle.md))。</span><span class="sxs-lookup"><span data-stu-id="d83ae-133">A named service instance is a specific instance of a service type (see [Service Fabric application life cycle](service-fabric-application-lifecycle.md)) within some named application instance in the cluster.</span></span> 

<span data-ttu-id="d83ae-134">可以在服務的忙碌程度提高或降低時，建立 (或移除) 新的具名服務執行個體。</span><span class="sxs-lookup"><span data-stu-id="d83ae-134">New named service instances can be created (or removed) as services become more or less busy.</span></span> <span data-ttu-id="d83ae-135">這樣可讓要求散佈到多個服務執行個體，通常會使現有服務上的負載降低。</span><span class="sxs-lookup"><span data-stu-id="d83ae-135">This allows requests to be spread across more service instances, usually allowing load on existing services to decrease.</span></span> <span data-ttu-id="d83ae-136">在建立服務時，Service Fabric 叢集 Resource Manager 會以分散式方式將服務置於叢集中。</span><span class="sxs-lookup"><span data-stu-id="d83ae-136">When creating services, the Service Fabric Cluster Resource Manager places the services in the cluster in a distributed fashion.</span></span> <span data-ttu-id="d83ae-137">確切決策是依叢集和其他放置規則中的[計量](service-fabric-cluster-resource-manager-metrics.md)來控管。</span><span class="sxs-lookup"><span data-stu-id="d83ae-137">The exact decisions are governed by the [metrics](service-fabric-cluster-resource-manager-metrics.md) in the cluster and other placement rules.</span></span> <span data-ttu-id="d83ae-138">可以數個不同的方式來建立服務，但最常見的方式是透過系統管理動作 (如某人呼叫[`New-ServiceFabricService`](https://docs.microsoft.com/en-us/powershell/module/servicefabric/new-servicefabricservice?view=azureservicefabricps)，或藉由程式碼呼叫[`CreateServiceAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricclient.servicemanagementclient.createserviceasync?view=azure-dotnet))。</span><span class="sxs-lookup"><span data-stu-id="d83ae-138">Services can be created several different ways, but the most common are either through administrative actions like someone calling [`New-ServiceFabricService`](https://docs.microsoft.com/en-us/powershell/module/servicefabric/new-servicefabricservice?view=azureservicefabricps), or by code calling [`CreateServiceAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricclient.servicemanagementclient.createserviceasync?view=azure-dotnet).</span></span> <span data-ttu-id="d83ae-139">甚至可以從叢集中執行的其他服務內呼叫 `CreateServiceAsync`。</span><span class="sxs-lookup"><span data-stu-id="d83ae-139">`CreateServiceAsync` can even be called from within other services running in the cluster.</span></span>

<span data-ttu-id="d83ae-140">各種情節中皆可使用動態建立服務，且是常見的模式。</span><span class="sxs-lookup"><span data-stu-id="d83ae-140">Creating services dynamically can be used in all sorts of scenarios, and is a common pattern.</span></span> <span data-ttu-id="d83ae-141">例如，假設有一個可代表特定工作流程的具狀態服務。</span><span class="sxs-lookup"><span data-stu-id="d83ae-141">For example, consider a stateful service that represents a particular workflow.</span></span> <span data-ttu-id="d83ae-142">會向這項服務顯示代表工作的呼叫，且此服務會對該工作流程和資料列進度執行這些步驟。</span><span class="sxs-lookup"><span data-stu-id="d83ae-142">Calls representing work are going to show up to this service, and this service is going to execute the steps to that workflow and record progress.</span></span> 

<span data-ttu-id="d83ae-143">您會如何進行此特定的服務規模？</span><span class="sxs-lookup"><span data-stu-id="d83ae-143">How would you make this particular service scale?</span></span> <span data-ttu-id="d83ae-144">服務可能是某種形式的多租用戶，且會接受呼叫並可一次開始進行相同工作流程中許多不同執行個體的所有步驟。</span><span class="sxs-lookup"><span data-stu-id="d83ae-144">The service could be multi-tenant in some form, and accept calls and kick off steps for many different instances of the same workflow all at once.</span></span> <span data-ttu-id="d83ae-145">不過，這樣會讓程式碼更複雜，因為現在必須擔心相同工作流程的許多不同執行個體，全都是不同階段及來自不同客戶。</span><span class="sxs-lookup"><span data-stu-id="d83ae-145">However, that can make the code more complex, since now it has to worry about many different instances of the same workflow, all at different stages and from different customers.</span></span> <span data-ttu-id="d83ae-146">此外，同時處理多個工作流程並無法解決縮放問題。</span><span class="sxs-lookup"><span data-stu-id="d83ae-146">Also, handling multiple workflows at the same time doesn't solve the scale problem.</span></span> <span data-ttu-id="d83ae-147">這是因為在某個時間點，此服務需耗用太多資源才能符合特定的電腦。</span><span class="sxs-lookup"><span data-stu-id="d83ae-147">This is because at some point this service will consume too many resources to fit on a particular machine.</span></span> <span data-ttu-id="d83ae-148">起初未建立此模式的許多服務，也會因程式碼中的某些固有瓶頸或速度變慢而遇到困難。</span><span class="sxs-lookup"><span data-stu-id="d83ae-148">Many services not built for this pattern in the first place also experience difficulty due to some inherent bottleneck or slowdown in their code.</span></span> <span data-ttu-id="d83ae-149">這類問題還會在它所追蹤的同時工作流程數目變大時，造成服務無法運作。</span><span class="sxs-lookup"><span data-stu-id="d83ae-149">These types of issues cause the service not to work as well when the number of concurrent workflows it is tracking gets larger.</span></span>  

<span data-ttu-id="d83ae-150">解決方案是針對您需要追蹤之工作流程的每個不同執行個體，建立此服務的執行個體。這是絕佳的模式，而無論服務是無狀態或具狀態皆可運作。</span><span class="sxs-lookup"><span data-stu-id="d83ae-150">A solution is to create an instance of this service for every different instance of the workflow you want to track. This is a great pattern and works whether the service is stateless or stateful.</span></span> <span data-ttu-id="d83ae-151">若要運作此模式，通常有另一項服務可作為「工作負載管理員服務」。</span><span class="sxs-lookup"><span data-stu-id="d83ae-151">For this pattern to work, there's usually another service that acts as a "Workload Manager Service".</span></span> <span data-ttu-id="d83ae-152">這項服務的作業會接收要求，並將這些要求路由至其他服務。</span><span class="sxs-lookup"><span data-stu-id="d83ae-152">The job of this service is to receive requests and to route those requests to other services.</span></span> <span data-ttu-id="d83ae-153">管理員可以在其接收訊息時動態建立工作負載服務的執行個體，然後再將要求傳遞至這些服務。</span><span class="sxs-lookup"><span data-stu-id="d83ae-153">The manager can dynamically create an instance of the workload service when it receives the message, and then pass on requests to those services.</span></span> <span data-ttu-id="d83ae-154">當指定的工作流程服務完成其作業時，管理員服務可能也會收到回呼。</span><span class="sxs-lookup"><span data-stu-id="d83ae-154">The manager service could also receive callbacks when a given workflow service completes its job.</span></span> <span data-ttu-id="d83ae-155">管理員收到這些回呼時，它可以刪除工作流程服務的執行個體，或是如果有多個呼叫，就會將它保留。</span><span class="sxs-lookup"><span data-stu-id="d83ae-155">When the manager receives these callbacks it could delete that instance of the workflow service, or leave it if more calls are expected.</span></span> 

<span data-ttu-id="d83ae-156">此類型管理員的進階版本甚至可以建立其所管理的服務集區。</span><span class="sxs-lookup"><span data-stu-id="d83ae-156">Advanced versions of this type of manager can even create pools of the services that it manages.</span></span> <span data-ttu-id="d83ae-157">集區可協助確保在新的要求進入時，不必等待服務就能加速。</span><span class="sxs-lookup"><span data-stu-id="d83ae-157">The pool helps ensure that when a new request comes in it doesn't have to wait for the service to spin up.</span></span> <span data-ttu-id="d83ae-158">反之，管理員可以只從集區或路由中隨機挑選目前非忙碌中的工作流程服務。</span><span class="sxs-lookup"><span data-stu-id="d83ae-158">Instead, the manager can just pick a workflow service that is not currently busy from the pool, or route randomly.</span></span> <span data-ttu-id="d83ae-159">將服務集區保持可用能夠加速處理新的要求，因為要求比較不需要等候新服務就能加速。</span><span class="sxs-lookup"><span data-stu-id="d83ae-159">Keeping a pool of services available makes handling new requests faster, since it is less likely that the request has to wait for a new service to be spun up.</span></span> <span data-ttu-id="d83ae-160">建立新的服務很快速，但並非免費或可瞬間完成。</span><span class="sxs-lookup"><span data-stu-id="d83ae-160">Creating new services is quick, but not free or instantaneous.</span></span> <span data-ttu-id="d83ae-161">集區有助於降低要求在接受服務之前所要等待的時間。</span><span class="sxs-lookup"><span data-stu-id="d83ae-161">The pool helps minimize the amount of time the request has to wait before being serviced.</span></span> <span data-ttu-id="d83ae-162">在回應時間至關重要的情況下，您將會經常看到這個管理員和集區模式。</span><span class="sxs-lookup"><span data-stu-id="d83ae-162">You'll often see this manager and pool pattern when response times matter the most.</span></span> <span data-ttu-id="d83ae-163">將要求佇列並在背景中建立服務_然後_加以傳遞，也是常用的管理員模式，如同以該服務目前已暫止的某些追蹤工作量作為基礎，將服務建立和刪除。</span><span class="sxs-lookup"><span data-stu-id="d83ae-163">Queuing the request and creating the service in the background and _then_ passing it on is also a popular manager pattern, as is creating and deleting services based on some tracking of the amount of work that service currently has pending.</span></span> 

## <a name="scaling-by-creating-or-removing-new-named-application-instances"></a><span data-ttu-id="d83ae-164">透過建立或移除新的具名應用程式執行個體進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-164">Scaling by creating or removing new named application instances</span></span>
<span data-ttu-id="d83ae-165">建立和刪除整個應用程式執行個體類似於建立和刪除服務的模式。</span><span class="sxs-lookup"><span data-stu-id="d83ae-165">Creating and deleting whole application instances is similar to the pattern of creating and deleting services.</span></span> <span data-ttu-id="d83ae-166">對於此模式，有一些管理員服務會以它所查看的要求，以及它從叢集內其他服務接收的資訊作為基礎來制定決策。</span><span class="sxs-lookup"><span data-stu-id="d83ae-166">For this pattern, there's some manager service that is making the decision based on the requests that it is seeing and the information it is receiving from the other services inside the cluster.</span></span> 

<span data-ttu-id="d83ae-167">何時應該使用建立新的具名應用程式執行個體，而不是在某些現有的應用程式中建立新的具名服務執行個體？</span><span class="sxs-lookup"><span data-stu-id="d83ae-167">When should creating a new named application instance be used instead of creating a new named service instances in some already existing application?</span></span> <span data-ttu-id="d83ae-168">還有一些案例：</span><span class="sxs-lookup"><span data-stu-id="d83ae-168">There's a few cases:</span></span>

  * <span data-ttu-id="d83ae-169">新的應用程式執行個體適用於程式碼必須在某些特定身分識別或安全性設定下才能執行的客戶。</span><span class="sxs-lookup"><span data-stu-id="d83ae-169">The new application instance is for a customer whose code needs to run under some particular identity or security settings.</span></span>
    * <span data-ttu-id="d83ae-170">Service Fabric 可讓您定義不同的程式碼套件，以在特定的身分識別下執行。</span><span class="sxs-lookup"><span data-stu-id="d83ae-170">Service Fabric allows defining different code packages to run under particular identities.</span></span> <span data-ttu-id="d83ae-171">若要以不同的身分識別啟動相同的程式碼套件，必須在不同的應用程式執行個體中進行啟用。</span><span class="sxs-lookup"><span data-stu-id="d83ae-171">In order to launch the same code package under different identities, the activations need to occur in different application instances.</span></span> <span data-ttu-id="d83ae-172">試想一個案例，您已部署現有客戶的工作負載。</span><span class="sxs-lookup"><span data-stu-id="d83ae-172">Consider a case where you have an existing customer's workloads deployed.</span></span> <span data-ttu-id="d83ae-173">這些可能會以特定的身分識別執行，所以您可以監視及控制它們存取其他資源，例如遠端資料庫或其他系統。</span><span class="sxs-lookup"><span data-stu-id="d83ae-173">These may be running under a particular identity so you can monitor and control their access to other resources, such as remote databases or other systems.</span></span> <span data-ttu-id="d83ae-174">在此情況下，當新客戶註冊時，您可能不需要在相同的內容 (流程空間) 中啟動其程式碼。</span><span class="sxs-lookup"><span data-stu-id="d83ae-174">In this case, when a new customer signs up, you probably don't want to activate their code in the same context (process space).</span></span> <span data-ttu-id="d83ae-175">雖然您可以這樣做，但這會讓您的服務程式碼更難以在特定身分識別的內容中行動。</span><span class="sxs-lookup"><span data-stu-id="d83ae-175">While you could, this makes it harder for your service code to act within the context of a particular identity.</span></span> <span data-ttu-id="d83ae-176">您通常必須有更高的安全性、隔離及身分識別管理程式碼。</span><span class="sxs-lookup"><span data-stu-id="d83ae-176">You typically must have more security, isolation, and identity management code.</span></span> <span data-ttu-id="d83ae-177">您並非在相同的應用程式執行個體而從此在相同的流程空間內使用不同的具名服務執行個體，而是可以使用不同的具名 Service Fabric 應用程式執行個體。</span><span class="sxs-lookup"><span data-stu-id="d83ae-177">Instead of using different named service instances within the same application instance and hence the same process space, you can use different named Service Fabric Application instances.</span></span> <span data-ttu-id="d83ae-178">這可讓您更輕鬆地定義不同的身分識別內容。</span><span class="sxs-lookup"><span data-stu-id="d83ae-178">This makes it easier to define different identity contexts.</span></span>
  * <span data-ttu-id="d83ae-179">新的應用程式執行個體也可作為一種組態</span><span class="sxs-lookup"><span data-stu-id="d83ae-179">The new application instance also serves as a means of configuration</span></span>
    * <span data-ttu-id="d83ae-180">根據預設，應用程式執行個體內所有特定服務類型的具名服務執行個體，都會在指定節點的相同流程中執行。</span><span class="sxs-lookup"><span data-stu-id="d83ae-180">By default, all of the named service instances of a particular service type within an application instance will run in the same process on a given node.</span></span> <span data-ttu-id="d83ae-181">這表示，儘管您可以使用不同的方式設定每個服務執行個體，但這麼做會很複雜。</span><span class="sxs-lookup"><span data-stu-id="d83ae-181">What this means is that while you can configure each service instance differently, doing so is complicated.</span></span> <span data-ttu-id="d83ae-182">服務必須有一些權杖，以供他們用來查閱其組態套件內的組態。</span><span class="sxs-lookup"><span data-stu-id="d83ae-182">Services must have some token they use to look up their config within a configuration package.</span></span> <span data-ttu-id="d83ae-183">通常這只是服務的名稱。</span><span class="sxs-lookup"><span data-stu-id="d83ae-183">Usually this is just the service's name.</span></span> <span data-ttu-id="d83ae-184">這可正常運作，但它會將組態與該應用程式執行個體內的個別具名服務執行個體的名稱結合。</span><span class="sxs-lookup"><span data-stu-id="d83ae-184">This works fine, but it couples the configuration to the names of the individual named service instances within that application instance.</span></span> <span data-ttu-id="d83ae-185">這可能會造成混淆且難以管理，因為組態通常是包含應用程式執行個體之特定值的設計階段成品。</span><span class="sxs-lookup"><span data-stu-id="d83ae-185">This can be confusing and hard to manage since configuration is normally a design time artifact with application instance specific values.</span></span> <span data-ttu-id="d83ae-186">建立更多服務一律表示多個應用程式升級，可變更組態套件內的資訊，或可部署新的讓新的組態套件，讓新的服務可以查閱其特定資訊。</span><span class="sxs-lookup"><span data-stu-id="d83ae-186">Creating more services always means more application upgrades to change the information within the config packages or to deploy new ones so that the new services can look up their specific information.</span></span> <span data-ttu-id="d83ae-187">要建立全新的具名應用程式執行個體通常較為容易。</span><span class="sxs-lookup"><span data-stu-id="d83ae-187">It's often easier to create a whole new named application instance.</span></span> <span data-ttu-id="d83ae-188">然後您可以使用應用程式參數來設定服務所需的任何必要設定。</span><span class="sxs-lookup"><span data-stu-id="d83ae-188">Then you can use the application parameters to set whatever configuration is necessary for the services.</span></span> <span data-ttu-id="d83ae-189">如此一來，該具名應用程式執行個體內建立的所有服務都可以繼承特定的組態設定。</span><span class="sxs-lookup"><span data-stu-id="d83ae-189">This way all of the services that are created within that named application instance can inherit particular configuration settings.</span></span> <span data-ttu-id="d83ae-190">比方說，您並非擁有包含每位客戶之設定和自訂的單一組態檔，例如祕密或每個客戶的資源限制，而是在覆寫這些設定的情況下針對每個客戶擁有不同的應用程式執行個體。</span><span class="sxs-lookup"><span data-stu-id="d83ae-190">For example, instead of having a single configuration file with the settings and customizations for every customer, such as secrets or per customer resource limits, you'd instead have a different application instance for each customer with these settings overridden.</span></span> 
  * <span data-ttu-id="d83ae-191">新的應用程式會作為升級的界限</span><span class="sxs-lookup"><span data-stu-id="d83ae-191">The new application serves as an upgrade boundary</span></span>
    * <span data-ttu-id="d83ae-192">在 Service Fabric 內，不同的具名應用程式執行個體會作為升級的界限。</span><span class="sxs-lookup"><span data-stu-id="d83ae-192">Within Service Fabric, different named application instances serve as boundaries for upgrade.</span></span> <span data-ttu-id="d83ae-193">一個具名應用程式執行個體的升級不會影響另一個具名應用程式執行個體正在執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="d83ae-193">An upgrade of one named application instance will not impact the code that another named application instance is running.</span></span> <span data-ttu-id="d83ae-194">不同的應用程式最終會在相同節點上執行相同程式碼的不同版本。</span><span class="sxs-lookup"><span data-stu-id="d83ae-194">The different applications will end up running different versions of the same code on the same nodes.</span></span> <span data-ttu-id="d83ae-195">當您需要進行縮放比例的決策時，這可能會成為一個因素，因為您可以選擇新的程式碼是否應遵循與另一個服務相同的升級。</span><span class="sxs-lookup"><span data-stu-id="d83ae-195">This can be a factor when you need to make a scaling decision because you can choose whether the new code should follow the same upgrades as another service or not.</span></span> <span data-ttu-id="d83ae-196">例如，假設呼叫抵達負責縮放特定客戶工作負載比例的管理員服務，方法是以動態方式將服務建立或刪除。</span><span class="sxs-lookup"><span data-stu-id="d83ae-196">For example, say that a call arrives at the manager service that is responsible for scaling a particular customer's workloads by creating and deleting services dynamically.</span></span> <span data-ttu-id="d83ae-197">不過，在此情況下，呼叫是針對與_新_客戶相關聯的工作負載。</span><span class="sxs-lookup"><span data-stu-id="d83ae-197">In this case however, the call is for a workload associated with a _new_ customer.</span></span> <span data-ttu-id="d83ae-198">大部分的客戶偏好彼此隔離，不只是基於先前所列出的安全性和設定理由，還因為它針對執行特定版本的軟體，以及在它們升級時進行選擇方面，能提供更多的彈性。</span><span class="sxs-lookup"><span data-stu-id="d83ae-198">Most customers like being isolated from each other not just for the security and configuration reasons listed previously, but because it provides more flexibility in terms of running specific versions of the software and choosing when they get upgraded.</span></span> <span data-ttu-id="d83ae-199">您也可以建立新的應用程式執行個體並就地建立服務，從而進一步將任何一個升級會觸及的服務數量進行分割。</span><span class="sxs-lookup"><span data-stu-id="d83ae-199">You may also create a new application instance and create the service there simply to further partition the amount of your services that any one upgrade will touch.</span></span> <span data-ttu-id="d83ae-200">個別的應用程式執行個體能在進行應用程式升級時提供更大的細微度，還可進行 A/B 測試和藍色/綠色部署。</span><span class="sxs-lookup"><span data-stu-id="d83ae-200">Separate application instances provide greater granularity when doing application upgrades, and also enable A/B testing and Blue/Green deployments.</span></span> 
  * <span data-ttu-id="d83ae-201">現有的應用程式執行個體已滿</span><span class="sxs-lookup"><span data-stu-id="d83ae-201">The existing application instance is full</span></span>
    * <span data-ttu-id="d83ae-202">在 Service Fabric 中，[應用程式容量](service-fabric-cluster-resource-manager-application-groups.md)這個概念，可用來控制特定應用程式執行個體可用的資源數量。</span><span class="sxs-lookup"><span data-stu-id="d83ae-202">In Service Fabric, [application capacity](service-fabric-cluster-resource-manager-application-groups.md) is a concept that you can use to control the amount of resources available for particular application instances.</span></span> <span data-ttu-id="d83ae-203">例如，您可能會決定指定的服務必須建立另一個執行個體才能進行縮放比例。</span><span class="sxs-lookup"><span data-stu-id="d83ae-203">For example, you may decide that a given service needs to have another instance created in order to scale.</span></span> <span data-ttu-id="d83ae-204">不過，此應用程式執行個體已超出特定計量的容量。</span><span class="sxs-lookup"><span data-stu-id="d83ae-204">However, this application instance is out of capacity for a certain metric.</span></span> <span data-ttu-id="d83ae-205">如果仍需授與更多資源給此特定客戶或工作負載，您可以增加該應用程式的現有容量或建立新的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d83ae-205">If this particular customer or workload should still be granted more resources, then you could either increase the existing capacity for that application or create a new application.</span></span> 

## <a name="scaling-at-the-partition-level"></a><span data-ttu-id="d83ae-206">調整資料分割層級</span><span class="sxs-lookup"><span data-stu-id="d83ae-206">Scaling at the partition level</span></span>
<span data-ttu-id="d83ae-207">Service Fabric 支援資料分割。</span><span class="sxs-lookup"><span data-stu-id="d83ae-207">Service Fabric supports partitioning.</span></span> <span data-ttu-id="d83ae-208">分割區會將服務分割成數個邏輯與實體區段，其中每一個都是獨立運作。</span><span class="sxs-lookup"><span data-stu-id="d83ae-208">Partitioning splits a service into several logical and physical sections, each of which operates independently.</span></span> <span data-ttu-id="d83ae-209">使用具狀態服務時這會很有用，因為沒有任何一組複本必須處理所有的呼叫，以及一次操作所有的狀態。</span><span class="sxs-lookup"><span data-stu-id="d83ae-209">This is useful with stateful services, since no one set of replicas has to handle all the calls and manipulate all of the state at once.</span></span> <span data-ttu-id="d83ae-210">[資料分割概觀](service-fabric-concepts-partitioning.md) 提供所支援資料分割配置類型的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="d83ae-210">The [partitioning overview](service-fabric-concepts-partitioning.md) provides information on the types of partitioning schemes that are supported.</span></span> <span data-ttu-id="d83ae-211">每個分割區的複本會分散在叢集中的節點、發佈該服務的負載，並確定服務整體或任何分割區都有單一個失敗點。</span><span class="sxs-lookup"><span data-stu-id="d83ae-211">The replicas of each partition are spread across the nodes in a cluster, distributing that service's load and ensuring that neither the service as a whole or any partition has a single point of failure.</span></span> 

<span data-ttu-id="d83ae-212">假設有一個使用範圍資料分割配置的服務，其中低索引鍵為 0、高索引鍵為 99、資料分割計數為 4。</span><span class="sxs-lookup"><span data-stu-id="d83ae-212">Consider a service that uses a ranged partitioning scheme with a low key of 0, a high key of 99, and a partition count of 4.</span></span> <span data-ttu-id="d83ae-213">在三個節點叢集中，服務可能使用四個複本進行配置，並共用每個節點上的資源，如下所示：</span><span class="sxs-lookup"><span data-stu-id="d83ae-213">In a three-node cluster, the service might be laid out with four replicas that share the resources on each node as shown here:</span></span>

<span data-ttu-id="d83ae-214"><center>
![使用三個節點分割配置](./media/service-fabric-concepts-scalability/layout-three-nodes.png)
</center></span><span class="sxs-lookup"><span data-stu-id="d83ae-214"><center>
![Partition layout with three nodes](./media/service-fabric-concepts-scalability/layout-three-nodes.png)
</center></span></span>

<span data-ttu-id="d83ae-215">如果您增加節點數目，Service Fabric 會將一些現有的複本移至那裡。</span><span class="sxs-lookup"><span data-stu-id="d83ae-215">If you increase the number of nodes, Service Fabric will move some of the existing replicas there.</span></span> <span data-ttu-id="d83ae-216">例如，假設節點的數目增加到四個，且重新發佈複本。</span><span class="sxs-lookup"><span data-stu-id="d83ae-216">For example, let's say the number of nodes increases to four and the replicas get redistributed.</span></span> <span data-ttu-id="d83ae-217">現在，服務有三個複本在每個節點上執行，每個都屬於不同的分割區。</span><span class="sxs-lookup"><span data-stu-id="d83ae-217">Now the service now has three replicas running on each node, each belonging to different partitions.</span></span> <span data-ttu-id="d83ae-218">這可提升資源使用率，因為新的節點並不陌生。</span><span class="sxs-lookup"><span data-stu-id="d83ae-218">This allows better resource utilization since the new node isn't cold.</span></span> <span data-ttu-id="d83ae-219">通常，它也會改善效能，因為每個服務都有較多資源可供其使用。</span><span class="sxs-lookup"><span data-stu-id="d83ae-219">Typically, it also improves performance as each service has more resources available to it.</span></span>

<span data-ttu-id="d83ae-220"><center>
![使用四個節點分割配置](./media/service-fabric-concepts-scalability/layout-four-nodes.png)
</center></span><span class="sxs-lookup"><span data-stu-id="d83ae-220"><center>
![Partition layout with four nodes](./media/service-fabric-concepts-scalability/layout-four-nodes.png)
</center></span></span>

## <a name="scaling-by-using-the-service-fabric-cluster-resource-manager-and-metrics"></a><span data-ttu-id="d83ae-221">使用 Service Fabric 叢集 Resource Manager 和計量進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-221">Scaling by using the Service Fabric Cluster Resource Manager and metrics</span></span>
<span data-ttu-id="d83ae-222">[計量](service-fabric-cluster-resource-manager-metrics.md)是服務表示其對 Service Fabric 資源耗用量的方式。</span><span class="sxs-lookup"><span data-stu-id="d83ae-222">[Metrics](service-fabric-cluster-resource-manager-metrics.md) are how services express their resource consumption to Service Fabric.</span></span> <span data-ttu-id="d83ae-223">使用計量可讓叢集 Resource Manager 有機會將叢集的配置重新組織並最佳化。</span><span class="sxs-lookup"><span data-stu-id="d83ae-223">Using metrics gives the Cluster Resource Manager an opportunity to reorganize and optimize the layout of the cluster.</span></span> <span data-ttu-id="d83ae-224">例如，在叢集中可能有充分的資源，但可能不會配置於目前正在工作的服務。</span><span class="sxs-lookup"><span data-stu-id="d83ae-224">For example, there may be plenty of resources in the cluster, but they might not be allocated to the services that are currently doing work.</span></span> <span data-ttu-id="d83ae-225">使用計量可讓叢集 Resource Manager 重新組織叢集，從而確認服務可存取可用的資源。</span><span class="sxs-lookup"><span data-stu-id="d83ae-225">Using metrics allows the Cluster Resource Manager to reorganize the cluster to ensure that services have access to the available resources.</span></span> 


## <a name="scaling-by-adding-and-removing-nodes-from-the-cluster"></a><span data-ttu-id="d83ae-226">透過新增和移除叢集中的節點進行縮放比例</span><span class="sxs-lookup"><span data-stu-id="d83ae-226">Scaling by adding and removing nodes from the cluster</span></span> 
<span data-ttu-id="d83ae-227">使用 Service Fabric 縮放比例的另一個選項是變更叢集的大小。</span><span class="sxs-lookup"><span data-stu-id="d83ae-227">Another option for scaling with Service Fabric is to change the size of the cluster.</span></span> <span data-ttu-id="d83ae-228">變更叢集大小表示新增或移除叢集中一個或多個節點類型的節點。</span><span class="sxs-lookup"><span data-stu-id="d83ae-228">Changing the size of the cluster means adding or removing nodes for one or more of the node types in the cluster.</span></span> <span data-ttu-id="d83ae-229">例如，試想一個情況，叢集中所有的節點都會作用。</span><span class="sxs-lookup"><span data-stu-id="d83ae-229">For example, consider a case where all of the nodes in the cluster are hot.</span></span> <span data-ttu-id="d83ae-230">這表示叢集的資源幾乎全部耗用。</span><span class="sxs-lookup"><span data-stu-id="d83ae-230">This means that the cluster's resources are almost all consumed.</span></span> <span data-ttu-id="d83ae-231">在此情況下，縮放比例的最佳方式就是將多個節點新增到叢集。</span><span class="sxs-lookup"><span data-stu-id="d83ae-231">In this case, adding more nodes to the cluster is the best way to scale.</span></span> <span data-ttu-id="d83ae-232">一旦新的節點加入叢集，Service Fabric 叢集 Service Fabric 會將服務移動至這些節點，使現有節點上的總負載較低。</span><span class="sxs-lookup"><span data-stu-id="d83ae-232">Once the new nodes join the cluster the Service Fabric Cluster Resource Manager moves services to them, resulting in less total load on the existing nodes.</span></span> <span data-ttu-id="d83ae-233">針對執行個體計數 = -1 的無狀態服務，會自動建立多個服務執行個體。</span><span class="sxs-lookup"><span data-stu-id="d83ae-233">For stateless services with instance count = -1, more service instances are automatically created.</span></span> <span data-ttu-id="d83ae-234">這可讓某些呼叫從現有的節點移至新的節點。</span><span class="sxs-lookup"><span data-stu-id="d83ae-234">This allows some calls to move from the existing nodes to the new nodes.</span></span> 

<span data-ttu-id="d83ae-235">透過 Service Fabric Azure Resource Manager PowerShell 模組，即可完成新增和移除叢集節點。</span><span class="sxs-lookup"><span data-stu-id="d83ae-235">Adding and removing nodes to the cluster can be accomplished via the Service Fabric Azure Resource Manager PowerShell module.</span></span>

```posh
Add-AzureRmServiceFabricNode -ResourceGroupName $resourceGroupName -Name $clusterResourceName -NodeType $nodeTypeName  -NumberOfNodesToAdd 5 
Remove-AzureRmServiceFabricNode -ResourceGroupName $resourceGroupName -Name $clusterResourceName -NodeType $nodeTypeName -NumberOfNodesToRemove 5
```

## <a name="putting-it-all-together"></a><span data-ttu-id="d83ae-236">總整理</span><span class="sxs-lookup"><span data-stu-id="d83ae-236">Putting it all together</span></span>
<span data-ttu-id="d83ae-237">讓我們根據這裡討論的所有概念來探討範例。</span><span class="sxs-lookup"><span data-stu-id="d83ae-237">Let's take all the ideas that we've discussed here and talk through an example.</span></span> <span data-ttu-id="d83ae-238">假設下列服務︰您嘗試建置一個服務作為通訊錄，以儲存名稱和連絡人資訊。</span><span class="sxs-lookup"><span data-stu-id="d83ae-238">Consider the following service: you are trying to build a service that acts as an address book, holding on to names and contact information.</span></span> 

<span data-ttu-id="d83ae-239">就在最前面位置有許多關於縮放比例的問題：您將有多少使用者？</span><span class="sxs-lookup"><span data-stu-id="d83ae-239">Right up front you have a bunch of questions related to scale: How many users are you going to have?</span></span> <span data-ttu-id="d83ae-240">每個使用者會儲存多少連絡人？</span><span class="sxs-lookup"><span data-stu-id="d83ae-240">How many contacts will each user store?</span></span> <span data-ttu-id="d83ae-241">在第一次建立服務時，很難完全釐清這些資料。</span><span class="sxs-lookup"><span data-stu-id="d83ae-241">Trying to figure this all out when you are standing up your service for the first time is difficult.</span></span> <span data-ttu-id="d83ae-242">例如，假設您要搭配單一靜態服務與特定分割區計數。</span><span class="sxs-lookup"><span data-stu-id="d83ae-242">Let's say you were going to go with a single static service with a specific partition count.</span></span> <span data-ttu-id="d83ae-243">挑選錯誤的資料分割計數會導致以後調整時發生問題。</span><span class="sxs-lookup"><span data-stu-id="d83ae-243">The consequences of picking the wrong partition count could cause you to have scale issues later.</span></span> <span data-ttu-id="d83ae-244">同樣地，即使您挑選適當的計數，可能還是無法取得您所需要的所有資訊。</span><span class="sxs-lookup"><span data-stu-id="d83ae-244">Similarly, even if you pick the right count you might not have all the information you need.</span></span> <span data-ttu-id="d83ae-245">比方說，您也必須領先決定叢集的大小，包括節點的數目和其大小等方面。</span><span class="sxs-lookup"><span data-stu-id="d83ae-245">For example, you also have to decide the size of the cluster up front, both in terms of the number of nodes and their sizes.</span></span> <span data-ttu-id="d83ae-246">通常很難預測服務在其存留期內會耗用多少資源。</span><span class="sxs-lookup"><span data-stu-id="d83ae-246">It's usually hard to predict how many resources a service is going to consume over its lifetime.</span></span> <span data-ttu-id="d83ae-247">可能也很難事先了解服務實際上看到的流量模式。</span><span class="sxs-lookup"><span data-stu-id="d83ae-247">It can also be hard to know ahead of time the traffic pattern that the service actually sees.</span></span> <span data-ttu-id="d83ae-248">比方說，或許人員只是在早上先新增和移除他們的連絡人，或它可能在過去一天內平均地發佈。</span><span class="sxs-lookup"><span data-stu-id="d83ae-248">For example, maybe people add and remove their contacts only first thing in the morning, or maybe it's distributed evenly over the course of the day.</span></span> <span data-ttu-id="d83ae-249">您可能需要以這個作為基礎來動態相應放大或相應縮小。</span><span class="sxs-lookup"><span data-stu-id="d83ae-249">Based on this you might need to scale out and in dynamically.</span></span> <span data-ttu-id="d83ae-250">您可能要學習預測何時需要相應放大或相應縮小，但無論如何，您可能必須回應變更您的服務所耗用的資源。</span><span class="sxs-lookup"><span data-stu-id="d83ae-250">Maybe you can learn to predict when you're going to need to scale out and in, but either way you're probably going to need to react to changing resource consumption by your service.</span></span> <span data-ttu-id="d83ae-251">這可能會涉及到變更叢集大小，以在重新組織使用現有的資源不足時能提供更多資源。</span><span class="sxs-lookup"><span data-stu-id="d83ae-251">This can involve changing the size of the cluster in order to provide more resources when reorganizing use of existing resources isn't enough.</span></span> 

<span data-ttu-id="d83ae-252">但為什麼要嘗試為所有使用者挑選單一資料分割配置？</span><span class="sxs-lookup"><span data-stu-id="d83ae-252">But why even try to pick a single partition scheme out for all users?</span></span> <span data-ttu-id="d83ae-253">為何要將自己限制於一個服務以及一個靜態叢集？</span><span class="sxs-lookup"><span data-stu-id="d83ae-253">Why limit yourself to one service and one static cluster?</span></span> <span data-ttu-id="d83ae-254">實際的狀況通常更為動態。</span><span class="sxs-lookup"><span data-stu-id="d83ae-254">The real situation is usually more dynamic.</span></span> 

<span data-ttu-id="d83ae-255">在針對縮放進行建置時，請考慮下列動態模式。</span><span class="sxs-lookup"><span data-stu-id="d83ae-255">When building for scale, consider the following dynamic pattern.</span></span> <span data-ttu-id="d83ae-256">您可能需要縮放來適應您的情況：</span><span class="sxs-lookup"><span data-stu-id="d83ae-256">You may need to adapt it to your situation:</span></span>

1. <span data-ttu-id="d83ae-257">建置「服務管理員」，而不要嘗試事先為每個人挑選資料分割配置。</span><span class="sxs-lookup"><span data-stu-id="d83ae-257">Instead of trying to pick a partitioning scheme for everyone up front, build a "manager service".</span></span>
2. <span data-ttu-id="d83ae-258">當客戶註冊您的服務時，管理員服務就負責查看他們的資訊。</span><span class="sxs-lookup"><span data-stu-id="d83ae-258">The job of the manager service is to look at customer information when they sign up for your service.</span></span> <span data-ttu-id="d83ae-259">然後，根據這項資訊而定，管理員服務會建立「只針對該客戶」建立「實際」連絡人儲存體服務的執行個體。</span><span class="sxs-lookup"><span data-stu-id="d83ae-259">Then depending on that information the manager service create an instance of your _actual_ contact-storage service _just for that customer_.</span></span> <span data-ttu-id="d83ae-260">如果他們需要特定組態、隔離或升級，您也可以決定針對此客戶加速應用程式執行個體。</span><span class="sxs-lookup"><span data-stu-id="d83ae-260">If they require particular configuration, isolation, or upgrades, you can also decide to spin up an Application instance for this customer.</span></span> 

<span data-ttu-id="d83ae-261">此動態建立模式的多項優點：</span><span class="sxs-lookup"><span data-stu-id="d83ae-261">This dynamic creation pattern many benefits:</span></span>

  - <span data-ttu-id="d83ae-262">您不必事先為所有使用者猜測正確的分割區計數，或建置它自己全都要無限縮放的單一服務。</span><span class="sxs-lookup"><span data-stu-id="d83ae-262">You're not trying to guess the correct partition count for all users up front or build a single service that is infinitely scalable all on its own.</span></span> 
  - <span data-ttu-id="d83ae-263">不同的使用者不需要有相同的分割區計數、複本計數、放置限制、計量、預設負載、服務名稱、DNS 設定，或是服務或應用程式層級中指定的任何其他屬性。</span><span class="sxs-lookup"><span data-stu-id="d83ae-263">Different users don't have to have the same partition count, replica count, placement constraints, metrics, default loads, service names, dns settings, or any of the other properties specified at the service or application level.</span></span> 
  - <span data-ttu-id="d83ae-264">您可以取得其他的資料區段。</span><span class="sxs-lookup"><span data-stu-id="d83ae-264">You gain additional data segmentation.</span></span> <span data-ttu-id="d83ae-265">每個客戶都有自己的服務複本</span><span class="sxs-lookup"><span data-stu-id="d83ae-265">Each customer has their own copy of the service</span></span>
    - <span data-ttu-id="d83ae-266">每個客戶服務可以有不同的設定方式並授與較多或較少資源，以預期的縮放作為基礎，視需要使用較多或較少的分割區或複本。</span><span class="sxs-lookup"><span data-stu-id="d83ae-266">Each customer service can be configured differently and granted more or fewer resources, with more or fewer partitions or replicas as necessary based on their expected scale.</span></span>
      - <span data-ttu-id="d83ae-267">例如，假設客戶付費使用「黃金」層次 - 他們可以取得更多複本或更高的分割區計數，且可能會透過計量和應用程式容量取得其服務專用的資源。</span><span class="sxs-lookup"><span data-stu-id="d83ae-267">For example, say the customer paid for the "Gold" tier - they could get more replicas or greater partition count, and potentially resources dedicated to their services via metrics and application capacities.</span></span>
      - <span data-ttu-id="d83ae-268">或者，假設他們提供資訊指出所需的連絡人數目「很少」- 他們只會取得少數分割區，或甚至可能與其他客戶一起放在共用服務集區內。</span><span class="sxs-lookup"><span data-stu-id="d83ae-268">Or say they provided information indicating the number of contacts they needed was "Small" - they would get only a few partitions, or could even be put into a shared service pool with other customers.</span></span>
  - <span data-ttu-id="d83ae-269">在等待客戶出現時，您沒有執行一堆服務執行個體或複本</span><span class="sxs-lookup"><span data-stu-id="d83ae-269">You're not running a bunch of service instances or replicas while you're waiting for customers to show up</span></span>
  - <span data-ttu-id="d83ae-270">一旦客戶離開，就如要求管理員刪除它所建立的服務，即可從您的服務或應用程式中移除客戶的資訊，如此簡單。</span><span class="sxs-lookup"><span data-stu-id="d83ae-270">If a customer ever leaves, then removing their information from your service is as simple as having the manager delete that service or application that it created.</span></span>

## <a name="next-steps"></a><span data-ttu-id="d83ae-271">後續步驟</span><span class="sxs-lookup"><span data-stu-id="d83ae-271">Next steps</span></span>
<span data-ttu-id="d83ae-272">如需有關 Service Fabric 概念的詳細資訊，請參閱下列文章：</span><span class="sxs-lookup"><span data-stu-id="d83ae-272">For more information on Service Fabric concepts, see the following articles:</span></span>

* [<span data-ttu-id="d83ae-273">Service Fabric 服務的可用性</span><span class="sxs-lookup"><span data-stu-id="d83ae-273">Availability of Service Fabric services</span></span>](service-fabric-availability-services.md)
* [<span data-ttu-id="d83ae-274">分割 Service Fabric 服務</span><span class="sxs-lookup"><span data-stu-id="d83ae-274">Partitioning Service Fabric services</span></span>](service-fabric-concepts-partitioning.md)
