---
title: "Azure Service Fabric 可靠的服務的 hello 生命週期的 aaaOverview |Microsoft 文件"
description: "深入了解 Service Fabric 可靠的服務中的 hello 不同的生命週期事件"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 0d75ed5ee7cda85ac9af6a02e160727277804a2b
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="77df3-103">Reliable Services 生命週期概觀</span><span class="sxs-lookup"><span data-stu-id="77df3-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="77df3-104">Windows 上的 C# </span><span class="sxs-lookup"><span data-stu-id="77df3-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="77df3-105">在 Linux 上使用 Java</span><span class="sxs-lookup"><span data-stu-id="77df3-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="77df3-106">在思考 hello 生命週期的可靠的服務，hello 生命週期的 hello 基本概念是最重要的 hello。</span><span class="sxs-lookup"><span data-stu-id="77df3-106">When thinking about hello lifecycles of Reliable Services, hello basics of hello lifecycle are hello most important.</span></span> <span data-ttu-id="77df3-107">一般而言：</span><span class="sxs-lookup"><span data-stu-id="77df3-107">In general:</span></span>

- <span data-ttu-id="77df3-108">在啟動期間</span><span class="sxs-lookup"><span data-stu-id="77df3-108">During Startup</span></span>
  - <span data-ttu-id="77df3-109">建構服務</span><span class="sxs-lookup"><span data-stu-id="77df3-109">Services are constructed</span></span>
  - <span data-ttu-id="77df3-110">它們有機會 tooconstruct 與傳回零個或多個接聽程式</span><span class="sxs-lookup"><span data-stu-id="77df3-110">They have an opportunity tooconstruct and return zero or more listeners</span></span>
  - <span data-ttu-id="77df3-111">任何傳回的接聽程式會開啟，可讓與 hello 服務的通訊</span><span class="sxs-lookup"><span data-stu-id="77df3-111">Any returned listeners are opened, allowing communication with hello service</span></span>
  - <span data-ttu-id="77df3-112">hello 服務 RunAsync 呼叫方法時，允許 hello toodo 長時間執行的服務或背景工作</span><span class="sxs-lookup"><span data-stu-id="77df3-112">hello Service's RunAsync method is called, allowing hello service toodo long running or background work</span></span>
- <span data-ttu-id="77df3-113">在關閉期間</span><span class="sxs-lookup"><span data-stu-id="77df3-113">During shutdown</span></span>
  - <span data-ttu-id="77df3-114">hello 取消語彙基元傳遞的 tooRunAsync 會取消，且會關閉 hello 接聽程式</span><span class="sxs-lookup"><span data-stu-id="77df3-114">hello cancellation token passed tooRunAsync is canceled, and hello listeners are closed</span></span>
  - <span data-ttu-id="77df3-115">完成後，hello 服務物件本身解構</span><span class="sxs-lookup"><span data-stu-id="77df3-115">Once that is complete, hello service object itself is destructed</span></span>

<span data-ttu-id="77df3-116">沒有確切的這些事件排序的 hello 周圍的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="77df3-116">There are details around hello exact ordering of these events.</span></span> <span data-ttu-id="77df3-117">特別是，事件 hello 順序有可能變更根據 hello 可靠的服務是無狀態或可設定狀態。</span><span class="sxs-lookup"><span data-stu-id="77df3-117">In particular, hello order of events may change slightly depending on whether hello Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="77df3-118">此外，可設定狀態服務，我們有 toodeal hello 主要交換案例。</span><span class="sxs-lookup"><span data-stu-id="77df3-118">In addition, for stateful services, we have toodeal with hello Primary swap scenario.</span></span> <span data-ttu-id="77df3-119">在此順序，hello 主要角色是傳送的 tooanother 複本 （或恢復） 沒有 hello 服務正在關閉。</span><span class="sxs-lookup"><span data-stu-id="77df3-119">During this sequence, hello role of Primary is transferred tooanother replica (or comes back) without hello service shutting down.</span></span> <span data-ttu-id="77df3-120">最後，我們有 toothink 相關錯誤或失敗的狀況。</span><span class="sxs-lookup"><span data-stu-id="77df3-120">Finally, we have toothink about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="77df3-121">無狀態服務啟動</span><span class="sxs-lookup"><span data-stu-id="77df3-121">Stateless service startup</span></span>
<span data-ttu-id="77df3-122">無狀態服務的 hello 生命週期是相當簡單。</span><span class="sxs-lookup"><span data-stu-id="77df3-122">hello lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="77df3-123">以下是 hello 的事件順序：</span><span class="sxs-lookup"><span data-stu-id="77df3-123">Here's hello order of events:</span></span>

1. <span data-ttu-id="77df3-124">hello 服務建構期間</span><span class="sxs-lookup"><span data-stu-id="77df3-124">hello Service is constructed</span></span>
2. <span data-ttu-id="77df3-125">接著，兩件事平行發生︰</span><span class="sxs-lookup"><span data-stu-id="77df3-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="77df3-126">叫用 `StatelessService.CreateServiceInstanceListeners()`，並「開啟」任何傳回的接聽程式。</span><span class="sxs-lookup"><span data-stu-id="77df3-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="77df3-127">在每個接聽程式上呼叫 `ICommunicationListener.OpenAsync()`</span><span class="sxs-lookup"><span data-stu-id="77df3-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="77df3-128">hello 服務的`StatelessService.RunAsync()`方法呼叫</span><span class="sxs-lookup"><span data-stu-id="77df3-128">hello service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="77df3-129">如果有的話，hello 服務的`StatelessService.OnOpenAsync()`方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="77df3-129">If present, hello service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="77df3-130">這是不常用的覆寫，但可用。</span><span class="sxs-lookup"><span data-stu-id="77df3-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="77df3-131">很重要的 toonote 沒有 hello 呼叫 toocreate 與開啟的 hello 接聽程式和 RunAsync 之間沒有順序。</span><span class="sxs-lookup"><span data-stu-id="77df3-131">It is important toonote that there is no ordering between hello calls toocreate and open hello listeners and RunAsync.</span></span> <span data-ttu-id="77df3-132">RunAsync 啟動之前，可能會開啟 hello 接聽程式。</span><span class="sxs-lookup"><span data-stu-id="77df3-132">hello listeners may open before RunAsync is started.</span></span> <span data-ttu-id="77df3-133">同樣地，RunAsync 最後可能之前已開啟 hello 通訊接聽程式，或甚至建構叫用。</span><span class="sxs-lookup"><span data-stu-id="77df3-133">Similarly, RunAsync may end up invoked before hello communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="77df3-134">如果任何同步處理，它會保持為練習 toohello 實作者。</span><span class="sxs-lookup"><span data-stu-id="77df3-134">If any synchronization is required, it is left as an exercise toohello implementer.</span></span> <span data-ttu-id="77df3-135">常見的解決方案︰</span><span class="sxs-lookup"><span data-stu-id="77df3-135">Common solutions:</span></span>

  - <span data-ttu-id="77df3-136">有時，必須等到建立其他一些資訊或完成工作後，接聽程式才能運作。</span><span class="sxs-lookup"><span data-stu-id="77df3-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="77df3-137">運作的無狀態服務通常可在其他位置完成，例如：</span><span class="sxs-lookup"><span data-stu-id="77df3-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="77df3-138">在 hello 服務建構函式</span><span class="sxs-lookup"><span data-stu-id="77df3-138">in hello service's constructor</span></span>
    - <span data-ttu-id="77df3-139">在 hello`CreateServiceInstanceListeners()`呼叫</span><span class="sxs-lookup"><span data-stu-id="77df3-139">during hello `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="77df3-140">hello 建構 hello 接聽程式本身的一部分</span><span class="sxs-lookup"><span data-stu-id="77df3-140">as a part of hello construction of hello listener itself</span></span>
  - <span data-ttu-id="77df3-141">有時 hello RunAsync 中的程式碼不想 toostart 直到 hello 接聽程式會開啟。</span><span class="sxs-lookup"><span data-stu-id="77df3-141">Sometimes hello code in RunAsync does not want toostart until hello listeners are open.</span></span> <span data-ttu-id="77df3-142">在此情況下，額外的協調有必要。</span><span class="sxs-lookup"><span data-stu-id="77df3-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="77df3-143">一個常見的解決方案是某些旗標，指出當他們完成時的 hello 接聽程式內。</span><span class="sxs-lookup"><span data-stu-id="77df3-143">One common solution is some flag within hello listeners indicating when they have completed.</span></span> <span data-ttu-id="77df3-144">RunAsync 再檢查此旗標才能繼續 tooactual 工作。</span><span class="sxs-lookup"><span data-stu-id="77df3-144">This flag is then checked in RunAsync before continuing tooactual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="77df3-145">無狀態服務關閉</span><span class="sxs-lookup"><span data-stu-id="77df3-145">Stateless service shutdown</span></span>
<span data-ttu-id="77df3-146">當您關閉無狀態服務，遵循相同的模式，只是在反向 hello:</span><span class="sxs-lookup"><span data-stu-id="77df3-146">When shutting down a stateless service, hello same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="77df3-147">平行</span><span class="sxs-lookup"><span data-stu-id="77df3-147">In parallel</span></span>
    - <span data-ttu-id="77df3-148">任何開啟的接聽程式皆為關閉。</span><span class="sxs-lookup"><span data-stu-id="77df3-148">Any open listeners are Closed.</span></span> <span data-ttu-id="77df3-149">在每個接聽程式上呼叫 `ICommunicationListener.CloseAsync()`。</span><span class="sxs-lookup"><span data-stu-id="77df3-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="77df3-150">hello 取消語彙基元傳遞太`RunAsync()`已取消。</span><span class="sxs-lookup"><span data-stu-id="77df3-150">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="77df3-151">檢查 hello 取消語彙基元的`IsCancellationRequested`屬性會傳回 true，如果呼叫 hello 語彙基元和`ThrowIfCancellationRequested`方法會擲回`OperationCanceledException`。</span><span class="sxs-lookup"><span data-stu-id="77df3-151">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="77df3-152">一次`CloseAsync()`完成每個接聽程式和`RunAsync()`也完成 hello 服務`StatelessService.OnCloseAsync()`呼叫方法時，如果有的話。</span><span class="sxs-lookup"><span data-stu-id="77df3-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="77df3-153">它是不常見 toooverride `StatelessService.OnCloseAsync()`。</span><span class="sxs-lookup"><span data-stu-id="77df3-153">It is uncommon toooverride `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="77df3-154">之後`StatelessService.OnCloseAsync()`完成時，解構 hello 服務物件</span><span class="sxs-lookup"><span data-stu-id="77df3-154">After `StatelessService.OnCloseAsync()` completes, hello service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="77df3-155">具狀態服務啟動</span><span class="sxs-lookup"><span data-stu-id="77df3-155">Stateful service Startup</span></span>
<span data-ttu-id="77df3-156">可設定狀態的服務有類似的模式 toostateless 服務，進行一些變更。</span><span class="sxs-lookup"><span data-stu-id="77df3-156">Stateful services have a similar pattern toostateless services, with a few changes.</span></span> <span data-ttu-id="77df3-157">當可設定狀態的服務啟動時，事件 hello 順序如下所示：</span><span class="sxs-lookup"><span data-stu-id="77df3-157">When starting up a stateful service, hello order of events is as follows:</span></span>

1. <span data-ttu-id="77df3-158">hello 服務建構期間</span><span class="sxs-lookup"><span data-stu-id="77df3-158">hello Service is constructed</span></span>
2. <span data-ttu-id="77df3-159">呼叫 `StatefulServiceBase.OnOpenAsync()`。</span><span class="sxs-lookup"><span data-stu-id="77df3-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="77df3-160">這是在 hello 服務 uncommonly 覆寫。</span><span class="sxs-lookup"><span data-stu-id="77df3-160">This is uncommonly overridden in hello service.</span></span>
3. <span data-ttu-id="77df3-161">hello 會發生下列情況以平行方式</span><span class="sxs-lookup"><span data-stu-id="77df3-161">hello following things happen in parallel</span></span>
    - <span data-ttu-id="77df3-162">叫用 `StatefulServiceBase.CreateServiceReplicaListeners()`</span><span class="sxs-lookup"><span data-stu-id="77df3-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="77df3-163">如果 hello 服務是主要會開啟所有傳回的接聽程式。</span><span class="sxs-lookup"><span data-stu-id="77df3-163">If hello service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="77df3-164">在每個接聽程式上呼叫 `ICommunicationListener.OpenAsync()`。</span><span class="sxs-lookup"><span data-stu-id="77df3-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="77df3-165">如果次要 hello 服務，這些接聽程式會標示為`ListenOnSecondary = true`已開啟。</span><span class="sxs-lookup"><span data-stu-id="77df3-165">If hello service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="77df3-166">在「次要」上開啟的接聽程式較不常見。</span><span class="sxs-lookup"><span data-stu-id="77df3-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="77df3-167">如果 hello 服務目前是主要的 hello 服務 hello`StatefulServiceBase.RunAsync()`方法呼叫</span><span class="sxs-lookup"><span data-stu-id="77df3-167">hello if hello Service is currently a Primary, hello service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="77df3-168">一旦所有 hello 複本接聽程式`OpenAsync()`呼叫完成和`RunAsync()`呼叫時，`StatefulServiceBase.OnChangeRoleAsync()`呼叫。</span><span class="sxs-lookup"><span data-stu-id="77df3-168">Once all hello replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="77df3-169">這是在 hello 服務 uncommonly 覆寫。</span><span class="sxs-lookup"><span data-stu-id="77df3-169">This is uncommonly overridden in hello service.</span></span>

<span data-ttu-id="77df3-170">同樣地 toostateless 服務沒有 hello 順序中的 hello 接聽程式會建立並開啟之間沒有進行協調，且呼叫 RunAsync 的時機。</span><span class="sxs-lookup"><span data-stu-id="77df3-170">Similarly toostateless services, there's no coordination between hello order in which hello listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="77df3-171">如果您需要協調，hello 解決方案會更 hello 相同。</span><span class="sxs-lookup"><span data-stu-id="77df3-171">If you need coordination, hello solutions are much hello same.</span></span> <span data-ttu-id="77df3-172">還有一個額外的案例： 說出 hello 呼叫抵達 hello 通訊接聽程式需要保留一些內的資訊[可靠集合](service-fabric-reliable-services-reliable-collections.md)。</span><span class="sxs-lookup"><span data-stu-id="77df3-172">THere is one additional case: say that hello calls arriving at hello communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="77df3-173">因為 hello 通訊接聽程式無法開啟之前 hello 可靠集合是可讀取或寫入的而且 RunAsync 無法開始之前，某些其他的協調是必要的。</span><span class="sxs-lookup"><span data-stu-id="77df3-173">Because hello communication listeners could open before hello reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="77df3-174">hello 通訊接聽程式 tooreturn hello 用戶端會使用 tooknow tooretry hello 要求一些錯誤程式碼為 hello 最簡單且最常見的方案。</span><span class="sxs-lookup"><span data-stu-id="77df3-174">hello simplest and most common solution is for hello communication listeners tooreturn some error code that hello client uses tooknow tooretry hello request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="77df3-175">具狀態服務關閉</span><span class="sxs-lookup"><span data-stu-id="77df3-175">Stateful service Shutdown</span></span>
<span data-ttu-id="77df3-176">同樣地 tooStateless 服務 hello 生命週期事件在關機期間會 hello 相同期間啟動，但相反。</span><span class="sxs-lookup"><span data-stu-id="77df3-176">Similarly tooStateless services, hello lifecycle events during shutdown are hello same as during startup, but reversed.</span></span> <span data-ttu-id="77df3-177">當具狀態服務正在關閉時，hello 發生下列事件：</span><span class="sxs-lookup"><span data-stu-id="77df3-177">When a stateful service is being shut down, hello following events occur:</span></span>

1. <span data-ttu-id="77df3-178">平行</span><span class="sxs-lookup"><span data-stu-id="77df3-178">In parallel</span></span>
    - <span data-ttu-id="77df3-179">任何開啟的接聽程式皆為關閉。</span><span class="sxs-lookup"><span data-stu-id="77df3-179">Any open listeners are Closed.</span></span> <span data-ttu-id="77df3-180">在每個接聽程式上呼叫 `ICommunicationListener.CloseAsync()`。</span><span class="sxs-lookup"><span data-stu-id="77df3-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="77df3-181">hello 取消語彙基元傳遞太`RunAsync()`已取消。</span><span class="sxs-lookup"><span data-stu-id="77df3-181">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="77df3-182">檢查 hello 取消語彙基元的`IsCancellationRequested`屬性會傳回 true，如果呼叫 hello 語彙基元和`ThrowIfCancellationRequested`方法會擲回`OperationCanceledException`。</span><span class="sxs-lookup"><span data-stu-id="77df3-182">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="77df3-183">一次`CloseAsync()`完成每個接聽程式和`RunAsync()`也完成 hello 服務`StatefulServiceBase.OnChangeRoleAsync()`呼叫。</span><span class="sxs-lookup"><span data-stu-id="77df3-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="77df3-184">（這是 uncommonly 覆寫在 hello 服務）。</span><span class="sxs-lookup"><span data-stu-id="77df3-184">(This is uncommonly overridden in hello service.)</span></span>
    - <span data-ttu-id="77df3-185">等候 RunAsync toocomplete 時才需要這個服務複本是否為主要。</span><span class="sxs-lookup"><span data-stu-id="77df3-185">Waiting for RunAsync toocomplete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="77df3-186">一次 hello`StatefulServiceBase.OnChangeRoleAsync()`方法完成，hello`StatefulServiceBase.OnCloseAsync()`方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="77df3-186">Once hello `StatefulServiceBase.OnChangeRoleAsync()` method completes, hello `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="77df3-187">這是不常用的覆寫，但可用。</span><span class="sxs-lookup"><span data-stu-id="77df3-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="77df3-188">之後`StatefulServiceBase.OnCloseAsync()`完成時，解構 hello 服務物件。</span><span class="sxs-lookup"><span data-stu-id="77df3-188">After `StatefulServiceBase.OnCloseAsync()` completes, hello service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="77df3-189">具狀態服務主要複本互換</span><span class="sxs-lookup"><span data-stu-id="77df3-189">Stateful service primary swaps</span></span>
<span data-ttu-id="77df3-190">當具狀態服務正在執行時，hello，可設定狀態服務的主要複本只有開啟其通訊接聽程式和呼叫其 RunAsync 方法。</span><span class="sxs-lookup"><span data-stu-id="77df3-190">While a stateful service is running, only hello Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="77df3-191">建構次要，但看不到進一步的呼叫。</span><span class="sxs-lookup"><span data-stu-id="77df3-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="77df3-192">但是執行可設定狀態的服務時，可以變更目前是 hello 主要的複本。</span><span class="sxs-lookup"><span data-stu-id="77df3-192">While a stateful service is running however, which replica is currently hello Primary can change.</span></span> <span data-ttu-id="77df3-193">這代表什麼的 hello 生命週期事件，可以看到複本？hello 行為 hello 可設定狀態的複本所看到取決於它是否 hello 複本正在降級或升級 hello 交換期間。</span><span class="sxs-lookup"><span data-stu-id="77df3-193">What does this mean in terms of hello lifecycle events that a replica can see? hello behavior hello stateful replica sees depends on whether it is hello replica being demoted or promoted during hello swap.</span></span>

### <a name="for-hello-primary-being-demoted"></a><span data-ttu-id="77df3-194">正在降級 hello 主要</span><span class="sxs-lookup"><span data-stu-id="77df3-194">For hello primary being demoted</span></span>
<span data-ttu-id="77df3-195">Service Fabric 需要此複本 toostop，處理訊息並結束任何正在進行的背景工作。</span><span class="sxs-lookup"><span data-stu-id="77df3-195">Service Fabric needs this replica toostop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="77df3-196">如此一來，此步驟會尋找類似 toowhen hello 服務正在關閉。</span><span class="sxs-lookup"><span data-stu-id="77df3-196">As a result, this step looks similar toowhen hello service is being shut down.</span></span> <span data-ttu-id="77df3-197">其中一種差異是該 hello 服務並不是解構或已關閉，因為它會保持為次要資料庫。</span><span class="sxs-lookup"><span data-stu-id="77df3-197">One difference is that hello Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="77df3-198">呼叫下列應用程式開發介面的 hello:</span><span class="sxs-lookup"><span data-stu-id="77df3-198">hello following APIs are called:</span></span>

1. <span data-ttu-id="77df3-199">平行</span><span class="sxs-lookup"><span data-stu-id="77df3-199">In parallel</span></span>
    - <span data-ttu-id="77df3-200">任何開啟的接聽程式皆為關閉。</span><span class="sxs-lookup"><span data-stu-id="77df3-200">Any open listeners are Closed.</span></span> <span data-ttu-id="77df3-201">在每個接聽程式上呼叫 `ICommunicationListener.CloseAsync()`。</span><span class="sxs-lookup"><span data-stu-id="77df3-201">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="77df3-202">hello 取消語彙基元傳遞太`RunAsync()`已取消。</span><span class="sxs-lookup"><span data-stu-id="77df3-202">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="77df3-203">檢查 hello 取消語彙基元的`IsCancellationRequested`屬性會傳回 true，如果呼叫 hello 語彙基元和`ThrowIfCancellationRequested`方法會擲回`OperationCanceledException`。</span><span class="sxs-lookup"><span data-stu-id="77df3-203">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="77df3-204">一次`CloseAsync()`完成每個接聽程式和`RunAsync()`也完成 hello 服務`StatefulServiceBase.OnChangeRoleAsync()`呼叫。</span><span class="sxs-lookup"><span data-stu-id="77df3-204">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="77df3-205">這是在 hello 服務 uncommonly 覆寫。</span><span class="sxs-lookup"><span data-stu-id="77df3-205">This is uncommonly overridden in hello service.</span></span>

### <a name="for-hello-secondary-being-promoted"></a><span data-ttu-id="77df3-206">正在升級的次要 hello</span><span class="sxs-lookup"><span data-stu-id="77df3-206">For hello secondary being promoted</span></span>
<span data-ttu-id="77df3-207">同樣地，Service Fabric 需要此複本 toostart，接聽 hello 網路上的訊息，並啟動任何它所關心的背景工作。</span><span class="sxs-lookup"><span data-stu-id="77df3-207">Similarly, Service Fabric needs this replica toostart listening for messages on hello wire and start any background tasks it cares about.</span></span> <span data-ttu-id="77df3-208">如此一來，建立類似 toowhen hello 服務時，此程序會尋找該 hello 複本除了本身已存在。</span><span class="sxs-lookup"><span data-stu-id="77df3-208">As a result, this process looks similar toowhen hello service is created, except that hello replica itself already exists.</span></span> <span data-ttu-id="77df3-209">呼叫下列應用程式開發介面的 hello:</span><span class="sxs-lookup"><span data-stu-id="77df3-209">hello following APIs are called:</span></span>

1. <span data-ttu-id="77df3-210">平行</span><span class="sxs-lookup"><span data-stu-id="77df3-210">In parallel</span></span>
    - <span data-ttu-id="77df3-211">叫用 `StatefulServiceBase.CreateServiceReplicaListeners()`，並「開啟」任何傳回的接聽程式。</span><span class="sxs-lookup"><span data-stu-id="77df3-211">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="77df3-212">在每個接聽程式上呼叫 `ICommunicationListener.OpenAsync()`。</span><span class="sxs-lookup"><span data-stu-id="77df3-212">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="77df3-213">hello 服務的`StatefulServiceBase.RunAsync()`方法呼叫</span><span class="sxs-lookup"><span data-stu-id="77df3-213">hello service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="77df3-214">一旦所有 hello 複本接聽程式`OpenAsync()`呼叫完成和`RunAsync()`呼叫之後`StatefulServiceBase.OnChangeRoleAsync()`呼叫。</span><span class="sxs-lookup"><span data-stu-id="77df3-214">Once all hello replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="77df3-215">這是在 hello 服務 uncommonly 覆寫。</span><span class="sxs-lookup"><span data-stu-id="77df3-215">This is uncommonly overridden in hello service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="77df3-216">具狀態服務關閉和主要降級期間的常見問題</span><span class="sxs-lookup"><span data-stu-id="77df3-216">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="77df3-217">Service Fabric 變更 hello 各種原因而具狀態服務的主要圖像。</span><span class="sxs-lookup"><span data-stu-id="77df3-217">Service Fabric changes hello Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="77df3-218">hello 最常是[叢集重新平衡](service-fabric-cluster-resource-manager-balancing.md)和[應用程式升級](service-fabric-application-upgrade.md)。</span><span class="sxs-lookup"><span data-stu-id="77df3-218">hello most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="77df3-219">這些作業期間 （以及在標準服務關機，您會看到 hello 服務是否已刪除的一樣），很重要的 hello 服務一方面 hello `CancellationToken`。</span><span class="sxs-lookup"><span data-stu-id="77df3-219">During these operations (as well as during normal service shutdown, like you'd see if hello service was deleted), it is important that hello service respect hello `CancellationToken`.</span></span> <span data-ttu-id="77df3-220">未完全處理取消作業的服務將會遇到幾個問題。</span><span class="sxs-lookup"><span data-stu-id="77df3-220">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="77df3-221">特別是，這些作業可能會變慢因為 Service Fabric 等候 hello 服務 toostop 依正常程序。</span><span class="sxs-lookup"><span data-stu-id="77df3-221">In particular, these operations will be slow since Service Fabric waits for hello services toostop gracefully.</span></span> <span data-ttu-id="77df3-222">這可以最終會導致 toofailed 升級時間，並回復。</span><span class="sxs-lookup"><span data-stu-id="77df3-222">This can ultimately lead toofailed upgrades that time out and roll back.</span></span> <span data-ttu-id="77df3-223">失敗 toohonor hello 取消語彙基元也會造成不平衡的叢集節點取得熱，但由於 toomove 太長，無法重新平衡 hello 服務，因為它們在其他地方。</span><span class="sxs-lookup"><span data-stu-id="77df3-223">Failure toohonor hello cancellation token can also cause imbalanced clusters because nodes get hot but hello services can't be rebalanced since it takes too long toomove them elsewhere.</span></span> 

<span data-ttu-id="77df3-224">由於 hello 服務是可設定狀態，也可能時，他們使用 hello[可靠集合](service-fabric-reliable-services-reliable-collections.md)。</span><span class="sxs-lookup"><span data-stu-id="77df3-224">Since hello services are stateful, it is also likely that they are using hello [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="77df3-225">Service Fabric 中主要降級，當所發生的 hello 第一件事是 toohello 基礎狀態時，寫入權被撤銷。</span><span class="sxs-lookup"><span data-stu-id="77df3-225">In Service Fabric, when a Primary is demoted, one of hello first things that happens is that write access toohello underlying state is revoked.</span></span> <span data-ttu-id="77df3-226">這會導致 tooa 問題，可能會影響 hello 服務生命週期的第二個集合。</span><span class="sxs-lookup"><span data-stu-id="77df3-226">This leads tooa second set of issues that can impact hello service lifecycle.</span></span> <span data-ttu-id="77df3-227">傳回例外狀況為基礎 hello 時間控制，以及是否 hello 複本移 hello 集合或關機。</span><span class="sxs-lookup"><span data-stu-id="77df3-227">hello collections return Exceptions based on hello timing and whether hello replica is being moved or shut down.</span></span> <span data-ttu-id="77df3-228">應該正確處理這些例外狀況。</span><span class="sxs-lookup"><span data-stu-id="77df3-228">These exceptions should be handled correctly.</span></span> <span data-ttu-id="77df3-229">Service Fabric 擲回的例外狀況可分為永久性 [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) 和暫時性[(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) 類別。</span><span class="sxs-lookup"><span data-stu-id="77df3-229">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="77df3-230">永久例外狀況要記錄，而且擲回，而 hello 暫時性例外狀況可能會重試根據一些重試邏輯。</span><span class="sxs-lookup"><span data-stu-id="77df3-230">Permanent exceptions should be logged and thrown, while hello transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="77df3-231">來自使用 hello 的 hello 例外狀況處理`ReliableCollections`搭配服務生命週期事件會測試及驗證可靠的服務很重要的一部分。</span><span class="sxs-lookup"><span data-stu-id="77df3-231">Handling hello exceptions that come from use of hello `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="77df3-232">hello 建議一律為 toorun 您在負載下的服務執行升級時， [chaos 測試](service-fabric-controlled-chaos.md)tooproduction 曾經在部署之前。</span><span class="sxs-lookup"><span data-stu-id="77df3-232">hello recommendation is always toorun your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying tooproduction.</span></span> <span data-ttu-id="77df3-233">下列基本步驟協助確保您的服務正確地實作，並正確地處理生命週期事件。</span><span class="sxs-lookup"><span data-stu-id="77df3-233">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="77df3-234">服務生命週期的注意事項</span><span class="sxs-lookup"><span data-stu-id="77df3-234">Notes on service lifecycle</span></span>
  - <span data-ttu-id="77df3-235">這兩個 hello`RunAsync()`方法和 hello`CreateServiceReplicaListeners/CreateServiceInstanceListeners`呼叫是選擇性的。</span><span class="sxs-lookup"><span data-stu-id="77df3-235">Both hello `RunAsync()` method and hello `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="77df3-236">一個服務可能具有其中一個、兩者或都沒有。</span><span class="sxs-lookup"><span data-stu-id="77df3-236">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="77df3-237">例如，hello 服務沒有回應 toouser 呼叫其工作，是否有不需要 tooimplement `RunAsync()`。</span><span class="sxs-lookup"><span data-stu-id="77df3-237">For example, if hello service does all its work in response toouser calls, there is no need for it tooimplement `RunAsync()`.</span></span> <span data-ttu-id="77df3-238">只有 hello 通訊接聽程式和其相關聯的程式碼是必要的。</span><span class="sxs-lookup"><span data-stu-id="77df3-238">Only hello communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="77df3-239">同樣地，建立和傳回通訊接聽程式是選擇性的因為 hello 服務可能會有背景工作 toodo，並因此只需要 tooimplement`RunAsync()`</span><span class="sxs-lookup"><span data-stu-id="77df3-239">Similarly, creating and returning communication listeners is optional, as hello service may have only background work toodo, and so only needs tooimplement `RunAsync()`</span></span>
  - <span data-ttu-id="77df3-240">是有效的服務 toocomplete`RunAsync()`已成功從它傳回。</span><span class="sxs-lookup"><span data-stu-id="77df3-240">It is valid for a service toocomplete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="77df3-241">完成不是失敗情況。</span><span class="sxs-lookup"><span data-stu-id="77df3-241">Completing is not a failure condition.</span></span> <span data-ttu-id="77df3-242">完成`RunAsync()`表示 hello 服務的 hello 背景工作已完成。</span><span class="sxs-lookup"><span data-stu-id="77df3-242">Completing `RunAsync()` indicates that hello background work of hello service has completed.</span></span> <span data-ttu-id="77df3-243">可設定狀態的可靠服務`RunAsync()`hello 複本都已從主要 tooSecondary 降級，然後升級後 tooPrimary 如果再次呼叫。</span><span class="sxs-lookup"><span data-stu-id="77df3-243">For stateful reliable services, `RunAsync()` is called again if hello replica were demoted from Primary tooSecondary and then promoted back tooPrimary.</span></span>
  - <span data-ttu-id="77df3-244">如果服務藉由擲回某些非預期的例外狀況退出 `RunAsync()`，則會構成失敗。</span><span class="sxs-lookup"><span data-stu-id="77df3-244">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="77df3-245">hello 服務物件會關閉，而且一個健全狀況報告錯誤。</span><span class="sxs-lookup"><span data-stu-id="77df3-245">hello service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="77df3-246">雖然在這些方法在傳回沒有沒有時間限制，您會立即失去 hello 能力 toowrite tooReliable 集合，因此無法完成任何實際工作。</span><span class="sxs-lookup"><span data-stu-id="77df3-246">While there is no time limit on returning from these methods, you immediately lose hello ability toowrite tooReliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="77df3-247">建議您傳回為儘速收到 hello 取消要求。</span><span class="sxs-lookup"><span data-stu-id="77df3-247">It is recommended that you return as quickly as possible upon receiving hello cancellation request.</span></span> <span data-ttu-id="77df3-248">如果您的服務沒有回應 toothese API 呼叫，在合理的時間服務網狀架構可能會強制終止您的服務。</span><span class="sxs-lookup"><span data-stu-id="77df3-248">If your service does not respond toothese API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="77df3-249">這通常只發生在應用程式升級期間或刪除服務時。</span><span class="sxs-lookup"><span data-stu-id="77df3-249">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="77df3-250">此逾時預設為 15 分鐘。</span><span class="sxs-lookup"><span data-stu-id="77df3-250">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="77df3-251">Hello 失敗`OnCloseAsync()`path 結果中的`OnAbort()`被呼叫的是最後一個機會最佳效能的機會 hello 註冊服務 tooclean 和釋放它們宣告任何資源。</span><span class="sxs-lookup"><span data-stu-id="77df3-251">Failures in hello `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for hello service tooclean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="77df3-252">後續步驟</span><span class="sxs-lookup"><span data-stu-id="77df3-252">Next steps</span></span>
- [<span data-ttu-id="77df3-253">簡介 tooReliable 服務</span><span class="sxs-lookup"><span data-stu-id="77df3-253">Introduction tooReliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="77df3-254">Reliable Services 快速入門</span><span class="sxs-lookup"><span data-stu-id="77df3-254">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="77df3-255">Reliable Services 的進階用法</span><span class="sxs-lookup"><span data-stu-id="77df3-255">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
