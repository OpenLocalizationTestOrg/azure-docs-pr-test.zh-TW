---
title: "Azure Service Fabric Reliable Services 生命週期的概觀 | Microsoft Docs"
description: "了解 Service Fabric Reliable Services中不同的生命週期事件"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 16021ca72a2f10070b6409417ff0d88009591331
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="89458-103">Reliable Services 生命週期概觀</span><span class="sxs-lookup"><span data-stu-id="89458-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="89458-104">Windows 上的 C# </span><span class="sxs-lookup"><span data-stu-id="89458-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="89458-105">在 Linux 上使用 Java</span><span class="sxs-lookup"><span data-stu-id="89458-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="89458-106">在考慮 Reliable Services 的生命週期時，生命週期的基礎最重要。</span><span class="sxs-lookup"><span data-stu-id="89458-106">When thinking about the lifecycles of Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="89458-107">一般而言：</span><span class="sxs-lookup"><span data-stu-id="89458-107">In general:</span></span>

- <span data-ttu-id="89458-108">在啟動期間</span><span class="sxs-lookup"><span data-stu-id="89458-108">During Startup</span></span>
  - <span data-ttu-id="89458-109">建構服務</span><span class="sxs-lookup"><span data-stu-id="89458-109">Services are constructed</span></span>
  - <span data-ttu-id="89458-110">它們有機會建構和傳回零個以上的接聽程式</span><span class="sxs-lookup"><span data-stu-id="89458-110">They have an opportunity to construct and return zero or more listeners</span></span>
  - <span data-ttu-id="89458-111">開啟任何傳回的接聽程式，能夠與服務進行通訊</span><span class="sxs-lookup"><span data-stu-id="89458-111">Any returned listeners are opened, allowing communication with the service</span></span>
  - <span data-ttu-id="89458-112">呼叫服務的 RunAsync 方法，可讓服務進行長時間執行的工作或背景工作</span><span class="sxs-lookup"><span data-stu-id="89458-112">The Service's RunAsync method is called, allowing the service to do long running or background work</span></span>
- <span data-ttu-id="89458-113">在關閉期間</span><span class="sxs-lookup"><span data-stu-id="89458-113">During shutdown</span></span>
  - <span data-ttu-id="89458-114">取消傳遞給 RunAsync 的取消權杖，並關閉接聽程式</span><span class="sxs-lookup"><span data-stu-id="89458-114">The cancellation token passed to RunAsync is canceled, and the listeners are closed</span></span>
  - <span data-ttu-id="89458-115">完成後，就解構服務物件本身</span><span class="sxs-lookup"><span data-stu-id="89458-115">Once that is complete, the service object itself is destructed</span></span>

<span data-ttu-id="89458-116">這些事件的確切順序還有一些細節可討論。</span><span class="sxs-lookup"><span data-stu-id="89458-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="89458-117">特別的是，根據 Reliable Service 是無狀態或具狀態而定，事件的順序可能稍有變化。</span><span class="sxs-lookup"><span data-stu-id="89458-117">In particular, the order of events may change slightly depending on whether the Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="89458-118">此外，對於具狀態服務，我們必須處理「主要」複本互換情況。</span><span class="sxs-lookup"><span data-stu-id="89458-118">In addition, for stateful services, we have to deal with the Primary swap scenario.</span></span> <span data-ttu-id="89458-119">在此序列期間，「主要」角色會轉移至另一個複本 (或回來)，但服務不會關閉。</span><span class="sxs-lookup"><span data-stu-id="89458-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="89458-120">最後，我們必須考慮錯誤或失敗狀況。</span><span class="sxs-lookup"><span data-stu-id="89458-120">Finally, we have to think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="89458-121">無狀態服務啟動</span><span class="sxs-lookup"><span data-stu-id="89458-121">Stateless service startup</span></span>
<span data-ttu-id="89458-122">無狀態服務的生命週期相當簡單。</span><span class="sxs-lookup"><span data-stu-id="89458-122">The lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="89458-123">以下是事件的順序︰</span><span class="sxs-lookup"><span data-stu-id="89458-123">Here's the order of events:</span></span>

1. <span data-ttu-id="89458-124">建構服務</span><span class="sxs-lookup"><span data-stu-id="89458-124">The Service is constructed</span></span>
2. <span data-ttu-id="89458-125">接著，兩件事平行發生︰</span><span class="sxs-lookup"><span data-stu-id="89458-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="89458-126">叫用 `StatelessService.CreateServiceInstanceListeners()`，並「開啟」任何傳回的接聽程式。</span><span class="sxs-lookup"><span data-stu-id="89458-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="89458-127">在每個接聽程式上呼叫 `ICommunicationListener.OpenAsync()`</span><span class="sxs-lookup"><span data-stu-id="89458-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="89458-128">呼叫服務的 `StatelessService.RunAsync()` 方法</span><span class="sxs-lookup"><span data-stu-id="89458-128">The service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="89458-129">如果有的話，會呼叫服務的 `StatelessService.OnOpenAsync()` 方法。</span><span class="sxs-lookup"><span data-stu-id="89458-129">If present, the service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="89458-130">這是不常用的覆寫，但可用。</span><span class="sxs-lookup"><span data-stu-id="89458-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="89458-131">請務必留意，建立及開啟接聽程式和 RunAsync 時，沒有一定的呼叫順序。</span><span class="sxs-lookup"><span data-stu-id="89458-131">It is important to note that there is no ordering between the calls to create and open the listeners and RunAsync.</span></span> <span data-ttu-id="89458-132">接聽程式可能在 RunAsync 啟動之前開啟。</span><span class="sxs-lookup"><span data-stu-id="89458-132">The listeners may open before RunAsync is started.</span></span> <span data-ttu-id="89458-133">同樣地，在通訊接聽程式開啟或建構之前，可能就已叫用 RunAsync。</span><span class="sxs-lookup"><span data-stu-id="89458-133">Similarly, RunAsync may end up invoked before the communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="89458-134">如果需要任何同步處理，則留給實作者去負責。</span><span class="sxs-lookup"><span data-stu-id="89458-134">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="89458-135">常見的解決方案︰</span><span class="sxs-lookup"><span data-stu-id="89458-135">Common solutions:</span></span>

  - <span data-ttu-id="89458-136">有時，必須等到建立其他一些資訊或完成工作後，接聽程式才能運作。</span><span class="sxs-lookup"><span data-stu-id="89458-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="89458-137">運作的無狀態服務通常可在其他位置完成，例如：</span><span class="sxs-lookup"><span data-stu-id="89458-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="89458-138">在服務的建構函式中</span><span class="sxs-lookup"><span data-stu-id="89458-138">in the service's constructor</span></span>
    - <span data-ttu-id="89458-139">在 `CreateServiceInstanceListeners()` 呼叫期間</span><span class="sxs-lookup"><span data-stu-id="89458-139">during the `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="89458-140">做為接聽程式本身建構的一部分</span><span class="sxs-lookup"><span data-stu-id="89458-140">as a part of the construction of the listener itself</span></span>
  - <span data-ttu-id="89458-141">有時，RunAsync 中的程式碼要等到接聽程式開啟之後才會啟動。</span><span class="sxs-lookup"><span data-stu-id="89458-141">Sometimes the code in RunAsync does not want to start until the listeners are open.</span></span> <span data-ttu-id="89458-142">在此情況下，額外的協調有必要。</span><span class="sxs-lookup"><span data-stu-id="89458-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="89458-143">其中一個常見的解決方案，在於接聽程式中的某些旗標會指出完成的時間。</span><span class="sxs-lookup"><span data-stu-id="89458-143">One common solution is some flag within the listeners indicating when they have completed.</span></span> <span data-ttu-id="89458-144">接著，該旗標會先簽入 RunAsync，然後再繼續進行實際工作。</span><span class="sxs-lookup"><span data-stu-id="89458-144">This flag is then checked in RunAsync before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="89458-145">無狀態服務關閉</span><span class="sxs-lookup"><span data-stu-id="89458-145">Stateless service shutdown</span></span>
<span data-ttu-id="89458-146">關閉無狀態服務時，也依循相同的模式，只是順序相反：</span><span class="sxs-lookup"><span data-stu-id="89458-146">When shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="89458-147">平行</span><span class="sxs-lookup"><span data-stu-id="89458-147">In parallel</span></span>
    - <span data-ttu-id="89458-148">任何開啟的接聽程式皆為關閉。</span><span class="sxs-lookup"><span data-stu-id="89458-148">Any open listeners are Closed.</span></span> <span data-ttu-id="89458-149">在每個接聽程式上呼叫 `ICommunicationListener.CloseAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="89458-150">傳遞至 `RunAsync()` 的取消權杖已取消。</span><span class="sxs-lookup"><span data-stu-id="89458-150">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="89458-151">檢查取消權杖的 `IsCancellationRequested` 屬性傳回 true，還有呼叫權杖的 `ThrowIfCancellationRequested` 方法是否擲回 `OperationCanceledException`。</span><span class="sxs-lookup"><span data-stu-id="89458-151">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="89458-152">當每個接聽程式上完成 `CloseAsync()`，且 `RunAsync()` 也完成時，就呼叫服務的 `StatelessService.OnCloseAsync()` 方法 (若有的話)。</span><span class="sxs-lookup"><span data-stu-id="89458-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="89458-153">覆寫 `StatelessService.OnCloseAsync()` 是不常見的。</span><span class="sxs-lookup"><span data-stu-id="89458-153">It is uncommon to override `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="89458-154">`StatelessService.OnCloseAsync()` 完成之後，就解構服務物件</span><span class="sxs-lookup"><span data-stu-id="89458-154">After `StatelessService.OnCloseAsync()` completes, the service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="89458-155">具狀態服務啟動</span><span class="sxs-lookup"><span data-stu-id="89458-155">Stateful service Startup</span></span>
<span data-ttu-id="89458-156">具狀態服務的模式類似於無狀態服務，只有一些不同。</span><span class="sxs-lookup"><span data-stu-id="89458-156">Stateful services have a similar pattern to stateless services, with a few changes.</span></span> <span data-ttu-id="89458-157">啟動具狀態服務時，事件的順序如下︰</span><span class="sxs-lookup"><span data-stu-id="89458-157">When starting up a stateful service, the order of events is as follows:</span></span>

1. <span data-ttu-id="89458-158">建構服務</span><span class="sxs-lookup"><span data-stu-id="89458-158">The Service is constructed</span></span>
2. <span data-ttu-id="89458-159">呼叫 `StatefulServiceBase.OnOpenAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="89458-160">這是服務中不常用的覆寫。</span><span class="sxs-lookup"><span data-stu-id="89458-160">This is uncommonly overridden in the service.</span></span>
3. <span data-ttu-id="89458-161">下列事情會同時發生</span><span class="sxs-lookup"><span data-stu-id="89458-161">The following things happen in parallel</span></span>
    - <span data-ttu-id="89458-162">叫用 `StatefulServiceBase.CreateServiceReplicaListeners()`</span><span class="sxs-lookup"><span data-stu-id="89458-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="89458-163">如果服務是「主要」，則傳回的所有接聽程式為「已開啟」。</span><span class="sxs-lookup"><span data-stu-id="89458-163">If the service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="89458-164">在每個接聽程式上呼叫 `ICommunicationListener.OpenAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="89458-165">如果服務是「次要」，只有標示為 `ListenOnSecondary = true` 的接聽程式才會開啟。</span><span class="sxs-lookup"><span data-stu-id="89458-165">If the service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="89458-166">在「次要」上開啟的接聽程式較不常見。</span><span class="sxs-lookup"><span data-stu-id="89458-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="89458-167">如果服務目前是「主要」，會呼叫此服務的 `StatefulServiceBase.RunAsync()` 方法</span><span class="sxs-lookup"><span data-stu-id="89458-167">The if the Service is currently a Primary, the service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="89458-168">當所有複本接聽程式的 `OpenAsync()` 呼叫完成，而且呼叫 `RunAsync()` 後，會呼叫 `StatefulServiceBase.OnChangeRoleAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-168">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="89458-169">這是服務中不常用的覆寫。</span><span class="sxs-lookup"><span data-stu-id="89458-169">This is uncommonly overridden in the service.</span></span>

<span data-ttu-id="89458-170">類似於無狀態服務，在建立和開啟接聽程式及呼叫 RunAsync 時，不會協調先後順序。</span><span class="sxs-lookup"><span data-stu-id="89458-170">Similarly to stateless services, there's no coordination between the order in which the listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="89458-171">如果您需要協調，解決方案大致相同。</span><span class="sxs-lookup"><span data-stu-id="89458-171">If you need coordination, the solutions are much the same.</span></span> <span data-ttu-id="89458-172">但有一個額外情況︰假設抵達通訊接聽程式的呼叫需要[可靠的集合](service-fabric-reliable-services-reliable-collections.md)內保留的資訊。</span><span class="sxs-lookup"><span data-stu-id="89458-172">THere is one additional case: say that the calls arriving at the communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="89458-173">因為在還無法讀取或寫入可靠的集合，且 RunAsync 也還無法啟動之前，通訊接聽程式可能先開啟，因此，一些額外的協調有必要。</span><span class="sxs-lookup"><span data-stu-id="89458-173">Because the communication listeners could open before the reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="89458-174">最簡單且最常見的解決方法是由通訊接聽程式傳回某個錯誤碼，讓用戶端知道要重試要求。</span><span class="sxs-lookup"><span data-stu-id="89458-174">The simplest and most common solution is for the communication listeners to return some error code that the client uses to know to retry the request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="89458-175">具狀態服務關閉</span><span class="sxs-lookup"><span data-stu-id="89458-175">Stateful service Shutdown</span></span>
<span data-ttu-id="89458-176">類似於無狀態服務，關閉期間的生命週期事件與啟動期間相同，但順序相反。</span><span class="sxs-lookup"><span data-stu-id="89458-176">Similarly to Stateless services, the lifecycle events during shutdown are the same as during startup, but reversed.</span></span> <span data-ttu-id="89458-177">具狀態服務關閉時會發生下列事件︰</span><span class="sxs-lookup"><span data-stu-id="89458-177">When a stateful service is being shut down, the following events occur:</span></span>

1. <span data-ttu-id="89458-178">平行</span><span class="sxs-lookup"><span data-stu-id="89458-178">In parallel</span></span>
    - <span data-ttu-id="89458-179">任何開啟的接聽程式皆為關閉。</span><span class="sxs-lookup"><span data-stu-id="89458-179">Any open listeners are Closed.</span></span> <span data-ttu-id="89458-180">在每個接聽程式上呼叫 `ICommunicationListener.CloseAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="89458-181">傳遞至 `RunAsync()` 的取消權杖已取消。</span><span class="sxs-lookup"><span data-stu-id="89458-181">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="89458-182">檢查取消權杖的 `IsCancellationRequested` 屬性傳回 true，還有呼叫權杖的 `ThrowIfCancellationRequested` 方法是否擲回 `OperationCanceledException`。</span><span class="sxs-lookup"><span data-stu-id="89458-182">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="89458-183">當每個接聽程式上完成 `CloseAsync()`，且 `RunAsync()` 也完成時，就呼叫服務的 `StatefulServiceBase.OnChangeRoleAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="89458-184">(這是服務中不常用的覆寫)。</span><span class="sxs-lookup"><span data-stu-id="89458-184">(This is uncommonly overridden in the service.)</span></span>
    - <span data-ttu-id="89458-185">只有在服務複本為「主要」時，才需要等待 RunAsync 完成。</span><span class="sxs-lookup"><span data-stu-id="89458-185">Waiting for RunAsync to complete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="89458-186">完成 `StatefulServiceBase.OnChangeRoleAsync()` 方法後，會呼叫 `StatefulServiceBase.OnCloseAsync()` 方法。</span><span class="sxs-lookup"><span data-stu-id="89458-186">Once the `StatefulServiceBase.OnChangeRoleAsync()` method completes, the `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="89458-187">這是不常用的覆寫，但可用。</span><span class="sxs-lookup"><span data-stu-id="89458-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="89458-188">`StatefulServiceBase.OnCloseAsync()` 完成之後，就解構服務物件。</span><span class="sxs-lookup"><span data-stu-id="89458-188">After `StatefulServiceBase.OnCloseAsync()` completes, the service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="89458-189">具狀態服務主要複本互換</span><span class="sxs-lookup"><span data-stu-id="89458-189">Stateful service primary swaps</span></span>
<span data-ttu-id="89458-190">當具狀態服務執行時，只有此具狀態服務的「主要」複本會開啟通訊接聽程式和呼叫 RunAsync 方法。</span><span class="sxs-lookup"><span data-stu-id="89458-190">While a stateful service is running, only the Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="89458-191">建構次要，但看不到進一步的呼叫。</span><span class="sxs-lookup"><span data-stu-id="89458-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="89458-192">不過，當具狀態服務執行時，哪個複本目前是「主要」可能會改變。</span><span class="sxs-lookup"><span data-stu-id="89458-192">While a stateful service is running however, which replica is currently the Primary can change.</span></span> <span data-ttu-id="89458-193">就複本可見的生命週期事件來說，這代表什麼？</span><span class="sxs-lookup"><span data-stu-id="89458-193">What does this mean in terms of the lifecycle events that a replica can see?</span></span> <span data-ttu-id="89458-194">具狀態複本所看到的行為，取決於它在互換期間是降級或升級的複本。</span><span class="sxs-lookup"><span data-stu-id="89458-194">The behavior the stateful replica sees depends on whether it is the replica being demoted or promoted during the swap.</span></span>

### <a name="for-the-primary-being-demoted"></a><span data-ttu-id="89458-195">降級的主要複本</span><span class="sxs-lookup"><span data-stu-id="89458-195">For the primary being demoted</span></span>
<span data-ttu-id="89458-196">Service Fabric 需要此複本停止處理訊息並結束它正在進行的任何背景工作。</span><span class="sxs-lookup"><span data-stu-id="89458-196">Service Fabric needs this replica to stop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="89458-197">因此，這個步驟類似於服務關閉時的情形。</span><span class="sxs-lookup"><span data-stu-id="89458-197">As a result, this step looks similar to when the service is being shut down.</span></span> <span data-ttu-id="89458-198">差別在於服務仍為「次要」，並不會解構或關閉。</span><span class="sxs-lookup"><span data-stu-id="89458-198">One difference is that the Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="89458-199">呼叫下列 API：</span><span class="sxs-lookup"><span data-stu-id="89458-199">The following APIs are called:</span></span>

1. <span data-ttu-id="89458-200">平行</span><span class="sxs-lookup"><span data-stu-id="89458-200">In parallel</span></span>
    - <span data-ttu-id="89458-201">任何開啟的接聽程式皆為關閉。</span><span class="sxs-lookup"><span data-stu-id="89458-201">Any open listeners are Closed.</span></span> <span data-ttu-id="89458-202">在每個接聽程式上呼叫 `ICommunicationListener.CloseAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-202">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="89458-203">傳遞至 `RunAsync()` 的取消權杖已取消。</span><span class="sxs-lookup"><span data-stu-id="89458-203">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="89458-204">檢查取消權杖的 `IsCancellationRequested` 屬性傳回 true，還有呼叫權杖的 `ThrowIfCancellationRequested` 方法是否擲回 `OperationCanceledException`。</span><span class="sxs-lookup"><span data-stu-id="89458-204">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="89458-205">當每個接聽程式上完成 `CloseAsync()`，且 `RunAsync()` 也完成時，就呼叫服務的 `StatefulServiceBase.OnChangeRoleAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-205">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="89458-206">這是服務中不常用的覆寫。</span><span class="sxs-lookup"><span data-stu-id="89458-206">This is uncommonly overridden in the service.</span></span>

### <a name="for-the-secondary-being-promoted"></a><span data-ttu-id="89458-207">升級的次要複本</span><span class="sxs-lookup"><span data-stu-id="89458-207">For the secondary being promoted</span></span>
<span data-ttu-id="89458-208">同樣地，Service Fabric 需要此複本開始接聽網路上的訊息，並啟動其關注的任何背景工作。</span><span class="sxs-lookup"><span data-stu-id="89458-208">Similarly, Service Fabric needs this replica to start listening for messages on the wire and start any background tasks it cares about.</span></span> <span data-ttu-id="89458-209">因此，這個程序類似於建立服務時的情形，差別在於複本它本身已存在。</span><span class="sxs-lookup"><span data-stu-id="89458-209">As a result, this process looks similar to when the service is created, except that the replica itself already exists.</span></span> <span data-ttu-id="89458-210">呼叫下列 API：</span><span class="sxs-lookup"><span data-stu-id="89458-210">The following APIs are called:</span></span>

1. <span data-ttu-id="89458-211">平行</span><span class="sxs-lookup"><span data-stu-id="89458-211">In parallel</span></span>
    - <span data-ttu-id="89458-212">叫用 `StatefulServiceBase.CreateServiceReplicaListeners()`，並「開啟」任何傳回的接聽程式。</span><span class="sxs-lookup"><span data-stu-id="89458-212">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="89458-213">在每個接聽程式上呼叫 `ICommunicationListener.OpenAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-213">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="89458-214">呼叫服務的 `StatefulServiceBase.RunAsync()` 方法</span><span class="sxs-lookup"><span data-stu-id="89458-214">The service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="89458-215">當所有複本接聽程式的 `OpenAsync()` 呼叫完成，而且呼叫 `RunAsync()` 後，會呼叫 `StatefulServiceBase.OnChangeRoleAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-215">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="89458-216">這是服務中不常用的覆寫。</span><span class="sxs-lookup"><span data-stu-id="89458-216">This is uncommonly overridden in the service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="89458-217">具狀態服務關閉和主要降級期間的常見問題</span><span class="sxs-lookup"><span data-stu-id="89458-217">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="89458-218">Service Fabric 基於各種原因變更具狀態服務的「主要」。</span><span class="sxs-lookup"><span data-stu-id="89458-218">Service Fabric changes the Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="89458-219">最常見的是[叢集重新平衡](service-fabric-cluster-resource-manager-balancing.md)和[應用程式升級](service-fabric-application-upgrade.md)。</span><span class="sxs-lookup"><span data-stu-id="89458-219">The most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="89458-220">在這些作業期間 (以及在正常服務關機期間，如您在刪除服務時所見)，服務遵守 `CancellationToken` 是相當重要的。</span><span class="sxs-lookup"><span data-stu-id="89458-220">During these operations (as well as during normal service shutdown, like you'd see if the service was deleted), it is important that the service respect the `CancellationToken`.</span></span> <span data-ttu-id="89458-221">未完全處理取消作業的服務將會遇到幾個問題。</span><span class="sxs-lookup"><span data-stu-id="89458-221">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="89458-222">尤其是這些作業可能會變慢，因為 Service Fabric 會以正常程序等待服務停止。</span><span class="sxs-lookup"><span data-stu-id="89458-222">In particular, these operations will be slow since Service Fabric waits for the services to stop gracefully.</span></span> <span data-ttu-id="89458-223">這可能最終會導致逾時的失敗升級和復原。</span><span class="sxs-lookup"><span data-stu-id="89458-223">This can ultimately lead to failed upgrades that time out and roll back.</span></span> <span data-ttu-id="89458-224">無法採用取消權杖也可能造成不平衡的叢集，因為節點變成經常性存取，但無法重新平衡服務，因為將服務移至其他地方耗費太多時間。</span><span class="sxs-lookup"><span data-stu-id="89458-224">Failure to honor the cancellation token can also cause imbalanced clusters because nodes get hot but the services can't be rebalanced since it takes too long to move them elsewhere.</span></span> 

<span data-ttu-id="89458-225">由於這些服務是具有狀態的，所以它們也有可能使用[可靠集合](service-fabric-reliable-services-reliable-collections.md)。</span><span class="sxs-lookup"><span data-stu-id="89458-225">Since the services are stateful, it is also likely that they are using the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="89458-226">在 Service Fabric 中，當「主要」降級時，首先發生的事情是撤銷基礎狀態的寫入存取權。</span><span class="sxs-lookup"><span data-stu-id="89458-226">In Service Fabric, when a Primary is demoted, one of the first things that happens is that write access to the underlying state is revoked.</span></span> <span data-ttu-id="89458-227">這會導致可能會影響服務生命週期的第二組問題。</span><span class="sxs-lookup"><span data-stu-id="89458-227">This leads to a second set of issues that can impact the service lifecycle.</span></span> <span data-ttu-id="89458-228">集合會根據時間和複本是否正在移動或關機而傳回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="89458-228">The collections return Exceptions based on the timing and whether the replica is being moved or shut down.</span></span> <span data-ttu-id="89458-229">應該正確處理這些例外狀況。</span><span class="sxs-lookup"><span data-stu-id="89458-229">These exceptions should be handled correctly.</span></span> <span data-ttu-id="89458-230">Service Fabric 擲回的例外狀況可分為永久性 [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) 和暫時性[(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) 類別。</span><span class="sxs-lookup"><span data-stu-id="89458-230">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="89458-231">永久性例外狀況應該要記錄並擲回，而暫時性例外狀況可能會根據一些重試邏輯來重試。</span><span class="sxs-lookup"><span data-stu-id="89458-231">Permanent exceptions should be logged and thrown, while the transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="89458-232">處理由於使用與服務生命週期事件搭配使用的 `ReliableCollections` 而造成的例外況況，是測試和驗證可靠服務的重要環節。</span><span class="sxs-lookup"><span data-stu-id="89458-232">Handling the exceptions that come from use of the `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="89458-233">建議一律先在低於負載的情況下執行服務，同時執行升級和[混亂測試](service-fabric-controlled-chaos.md)，然後再部署到生產。</span><span class="sxs-lookup"><span data-stu-id="89458-233">The recommendation is always to run your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying to production.</span></span> <span data-ttu-id="89458-234">下列基本步驟協助確保您的服務正確地實作，並正確地處理生命週期事件。</span><span class="sxs-lookup"><span data-stu-id="89458-234">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="89458-235">服務生命週期的注意事項</span><span class="sxs-lookup"><span data-stu-id="89458-235">Notes on service lifecycle</span></span>
  - <span data-ttu-id="89458-236">`RunAsync()` 方法和 `CreateServiceReplicaListeners/CreateServiceInstanceListeners` 呼叫都是選擇性。</span><span class="sxs-lookup"><span data-stu-id="89458-236">Both the `RunAsync()` method and the `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="89458-237">一個服務可能具有其中一個、兩者或都沒有。</span><span class="sxs-lookup"><span data-stu-id="89458-237">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="89458-238">例如，若服務本身自行負責回應使用者呼叫，則不需要實作 `RunAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-238">For example, if the service does all its work in response to user calls, there is no need for it to implement `RunAsync()`.</span></span> <span data-ttu-id="89458-239">只需要通訊接聽程式及其相關聯的程式碼。</span><span class="sxs-lookup"><span data-stu-id="89458-239">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="89458-240">同樣地，建立和傳回通訊接聽程式是選擇性，因為服務可能只有背景工作要處理，所以只需要實作 `RunAsync()`</span><span class="sxs-lookup"><span data-stu-id="89458-240">Similarly, creating and returning communication listeners is optional, as the service may have only background work to do, and so only needs to implement `RunAsync()`</span></span>
  - <span data-ttu-id="89458-241">服務可以成功完成 `RunAsync()` 並返回。</span><span class="sxs-lookup"><span data-stu-id="89458-241">It is valid for a service to complete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="89458-242">完成不是失敗情況。</span><span class="sxs-lookup"><span data-stu-id="89458-242">Completing is not a failure condition.</span></span> <span data-ttu-id="89458-243">完成 `RunAsync()` 表示服務的背景工作已完成。</span><span class="sxs-lookup"><span data-stu-id="89458-243">Completing `RunAsync()` indicates that the background work of the service has completed.</span></span> <span data-ttu-id="89458-244">對於具狀態可靠服務，如果複本從「主要」降級到「次要」，然後又升級回到「主要」，則會再次呼叫 `RunAsync()`。</span><span class="sxs-lookup"><span data-stu-id="89458-244">For stateful reliable services, `RunAsync()` is called again if the replica were demoted from Primary to Secondary and then promoted back to Primary.</span></span>
  - <span data-ttu-id="89458-245">如果服務藉由擲回某些非預期的例外狀況退出 `RunAsync()`，則會構成失敗。</span><span class="sxs-lookup"><span data-stu-id="89458-245">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="89458-246">服務物件會關閉，而且會報告健康情況錯誤。</span><span class="sxs-lookup"><span data-stu-id="89458-246">The service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="89458-247">雖然從這些方法傳回沒有時間限制，但您會立即喪失寫入到可靠的集合的能力，並因此無法完成任何實際工作。</span><span class="sxs-lookup"><span data-stu-id="89458-247">While there is no time limit on returning from these methods, you immediately lose the ability to write to Reliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="89458-248">建議您盡快在收到取消要求後傳回。</span><span class="sxs-lookup"><span data-stu-id="89458-248">It is recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="89458-249">如果您的服務未於合理的時間內回應這些 API 呼叫，Service Fabric 可能會強制終止服務。</span><span class="sxs-lookup"><span data-stu-id="89458-249">If your service does not respond to these API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="89458-250">這通常只發生在應用程式升級期間或刪除服務時。</span><span class="sxs-lookup"><span data-stu-id="89458-250">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="89458-251">此逾時預設為 15 分鐘。</span><span class="sxs-lookup"><span data-stu-id="89458-251">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="89458-252">`OnCloseAsync()` 路徑失敗會導致呼叫 `OnAbort()`，這是服務清除並釋放已宣告之任何資源的最後努力機會。</span><span class="sxs-lookup"><span data-stu-id="89458-252">Failures in the `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="89458-253">後續步驟</span><span class="sxs-lookup"><span data-stu-id="89458-253">Next steps</span></span>
- [<span data-ttu-id="89458-254">Reliable Services 簡介</span><span class="sxs-lookup"><span data-stu-id="89458-254">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="89458-255">Reliable Services 快速入門</span><span class="sxs-lookup"><span data-stu-id="89458-255">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="89458-256">Reliable Services 的進階用法</span><span class="sxs-lookup"><span data-stu-id="89458-256">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
