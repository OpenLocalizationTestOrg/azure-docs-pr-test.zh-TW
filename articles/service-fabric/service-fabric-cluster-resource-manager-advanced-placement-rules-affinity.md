---
title: "Service Fabric 叢集 Resource Manager - 同質性 | Microsoft Docs"
description: "Service Fabric 服務的設定同質性概觀"
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: 678073e1-d08d-46c4-a811-826e70aba6c4
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 3efda4ee4016245668e5da431d7b8868a21c790e
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/18/2017
---
# <a name="configuring-and-using-service-affinity-in-service-fabric"></a><span data-ttu-id="712ea-103">在 Service Fabric 中設定並使用服務同質性</span><span class="sxs-lookup"><span data-stu-id="712ea-103">Configuring and using service affinity in Service Fabric</span></span>
<span data-ttu-id="712ea-104">同質性是一個控制項，主要提供來協助簡化將較大型的單體式應用程式轉換到雲端和微服務世界的程序。</span><span class="sxs-lookup"><span data-stu-id="712ea-104">Affinity is a control that is provided mainly to help ease the transition of larger monolithic applications into the cloud and microservices world.</span></span> <span data-ttu-id="712ea-105">同質性也可作為最佳化手段來提升服務的效能，不過，這麼做會帶來一些副作用。</span><span class="sxs-lookup"><span data-stu-id="712ea-105">It is also used as an optimization for improving the performance of services, although doing so can have side effects.</span></span>

<span data-ttu-id="712ea-106">假設您正在將較大型的應用程式 (或是在設計時並未考慮到微服務的應用程式) 引進到 Service Fabric (或任何分散式環境)。</span><span class="sxs-lookup"><span data-stu-id="712ea-106">Let’s say you’re bringing a larger app, or one that just wasn’t designed with microservices in mind, to Service Fabric (or any distributed environment).</span></span> <span data-ttu-id="712ea-107">這種轉換很常見。</span><span class="sxs-lookup"><span data-stu-id="712ea-107">This type of transition is common.</span></span> <span data-ttu-id="712ea-108">首先要將整個應用程式提升至環境中，封裝應用程式，並確定可以順暢執行。</span><span class="sxs-lookup"><span data-stu-id="712ea-108">You start by lifting the entire app into the environment, packaging it, and making sure it is running smoothly.</span></span> <span data-ttu-id="712ea-109">接著，開始將其分解成不同的較小服務，使其可彼此通訊。</span><span class="sxs-lookup"><span data-stu-id="712ea-109">Then you start breaking it down into different smaller services that all talk to each other.</span></span>

<span data-ttu-id="712ea-110">最終，您可能會發現應用程式遇到一些問題。</span><span class="sxs-lookup"><span data-stu-id="712ea-110">Eventually you may find that the application is experiencing some issues.</span></span> <span data-ttu-id="712ea-111">這些問題通常屬於下列其中一個類別︰</span><span class="sxs-lookup"><span data-stu-id="712ea-111">The issues usually fall into one of these categories:</span></span>

1. <span data-ttu-id="712ea-112">單體式應用程式中的某個元件 X 對元件 Y 具有不明的相依性，但您將這些元件變成個別的服務。</span><span class="sxs-lookup"><span data-stu-id="712ea-112">Some component X in the monolithic app had an undocumented dependency on component Y, and you just turned those components into separate services.</span></span> <span data-ttu-id="712ea-113">因為現在這些服務是在叢集中不同的節點上執行，它們已中斷。</span><span class="sxs-lookup"><span data-stu-id="712ea-113">Since these services are now running on different nodes in the cluster, they're broken.</span></span>
2. <span data-ttu-id="712ea-114">這些元件透過 (本機具名管道 | 共用記憶體 | 磁碟上的檔案) 來通訊，但基於效能理由，的確需要能夠立即寫入到共用的本機資源。</span><span class="sxs-lookup"><span data-stu-id="712ea-114">These components communicate via (local named pipes | shared memory | files on disk) and they really need to be able to write to a shared local resource for performance reasons right now.</span></span> <span data-ttu-id="712ea-115">您稍後或許會移除該硬式相依性。</span><span class="sxs-lookup"><span data-stu-id="712ea-115">That hard dependency gets removed later, maybe.</span></span>
3. <span data-ttu-id="712ea-116">一切都沒問題，但事實上，這兩個元件具有很多對話/效能敏感的內容。</span><span class="sxs-lookup"><span data-stu-id="712ea-116">Everything is fine, but it turns out that these two components are actually chatty/performance sensitive.</span></span> <span data-ttu-id="712ea-117">當我將它們移到個別服務時，整體應用程式效能會遭到重挫或導致延遲增加。</span><span class="sxs-lookup"><span data-stu-id="712ea-117">When they moved them into separate services overall application performance tanked or latency increased.</span></span> <span data-ttu-id="712ea-118">如此一來，整體應用程式就不會符合預期。</span><span class="sxs-lookup"><span data-stu-id="712ea-118">As a result, the overall application is not meeting expectations.</span></span>

<span data-ttu-id="712ea-119">在這些情況中，我們既不想失去重構工作，也不想要回到單體模式。</span><span class="sxs-lookup"><span data-stu-id="712ea-119">In these cases, we don’t want to lose our refactoring work, and don’t want to go back to the monolith.</span></span> <span data-ttu-id="712ea-120">我們甚至可能會希望是最後一個情況，因為要最佳化很簡單。</span><span class="sxs-lookup"><span data-stu-id="712ea-120">The last condition may even be desirable as a plain optimization.</span></span> <span data-ttu-id="712ea-121">不過，在我們能夠將元件重新設計的像服務一樣自然運作之前 (或能夠以其他某些方式解決效能期望之前)，我們需要有位置方面的概念。</span><span class="sxs-lookup"><span data-stu-id="712ea-121">However, until we can redesign the components to work naturally as services (or until we can solve the performance expectations some other way) we're going to need some sense of locality.</span></span>

<span data-ttu-id="712ea-122">怎麼辦？</span><span class="sxs-lookup"><span data-stu-id="712ea-122">What to do?</span></span> <span data-ttu-id="712ea-123">嗯，您可以嘗試開啟同質性。</span><span class="sxs-lookup"><span data-stu-id="712ea-123">Well, you could try turning on affinity.</span></span>

## <a name="how-to-configure-affinity"></a><span data-ttu-id="712ea-124">如何設定同質性</span><span class="sxs-lookup"><span data-stu-id="712ea-124">How to configure affinity</span></span>
<span data-ttu-id="712ea-125">若要設定同質性，您可以定義兩個不同服務之間的同質關聯性。</span><span class="sxs-lookup"><span data-stu-id="712ea-125">To set up affinity, you define an affinity relationship between two different services.</span></span> <span data-ttu-id="712ea-126">您可以將此同質性想像成在一個服務上「指向」另一個服務，並假設「此服務只有在該服務執行所在的地方才能執行」。</span><span class="sxs-lookup"><span data-stu-id="712ea-126">You can think of affinity as “pointing” one service at another and saying “This service can only run where that service is running.”</span></span> <span data-ttu-id="712ea-127">有時我們會將這些同質性稱為父子式關聯性 (您會在父系上指向子系)。</span><span class="sxs-lookup"><span data-stu-id="712ea-127">Sometimes we refer to affinity as a parent/child relationship (where you point the child at the parent).</span></span> <span data-ttu-id="712ea-128">同質性可確保某一個服務的複本或執行個體是放置在與另一個服務的複本或執行個體相同的節點上。</span><span class="sxs-lookup"><span data-stu-id="712ea-128">Affinity ensures that the replicas or instances of one service are placed on the same nodes as those of another service.</span></span>

```csharp
ServiceCorrelationDescription affinityDescription = new ServiceCorrelationDescription();
affinityDescription.Scheme = ServiceCorrelationScheme.Affinity;
affinityDescription.ServiceName = new Uri("fabric:/otherApplication/parentService");
serviceDescription.Correlations.Add(affinityDescription);
await fabricClient.ServiceManager.CreateServiceAsync(serviceDescription);
```

> [!NOTE]
> <span data-ttu-id="712ea-129">子服務只能參與一個同質關聯性。</span><span class="sxs-lookup"><span data-stu-id="712ea-129">A child service can only participate in a single affinity relationship.</span></span> <span data-ttu-id="712ea-130">如果您想讓子服務一次與兩個父服務產生同質關聯性，有幾個選項可供選擇：</span><span class="sxs-lookup"><span data-stu-id="712ea-130">If you wanted the child to be affinitized to two parent services at once you have a couple options:</span></span>
> - <span data-ttu-id="712ea-131">讓關聯性反轉 (讓 parentService1 和 parentService2 指向目前的子服務)，或是</span><span class="sxs-lookup"><span data-stu-id="712ea-131">Reverse the relationships (have parentService1 and parentService2 point at the current child service), or</span></span>
> - <span data-ttu-id="712ea-132">依照慣例將其中一個父服務指定為中樞，並讓所有服務指向該服務。</span><span class="sxs-lookup"><span data-stu-id="712ea-132">Designate one of the parents as a hub by convention and have all services point at that service.</span></span> 
>
> <span data-ttu-id="712ea-133">叢集中所產生的放置行為應該會相同。</span><span class="sxs-lookup"><span data-stu-id="712ea-133">The resulting placement behavior in the cluster should be the same.</span></span>
>

## <a name="different-affinity-options"></a><span data-ttu-id="712ea-134">各種同質性選項</span><span class="sxs-lookup"><span data-stu-id="712ea-134">Different affinity options</span></span>
<span data-ttu-id="712ea-135">同質性是透過數種相互關聯的結構描述之一來表示，而且有兩種不同的模式。</span><span class="sxs-lookup"><span data-stu-id="712ea-135">Affinity is represented via one of several correlation schemes, and has two different modes.</span></span> <span data-ttu-id="712ea-136">同質性的最常見模式是我們稱為 NonAlignedAffinity 的模式。</span><span class="sxs-lookup"><span data-stu-id="712ea-136">The most common mode of affinity is what we call NonAlignedAffinity.</span></span> <span data-ttu-id="712ea-137">在 NonAlignedAffinity 中，不同服務的複本或執行個體會放在同一個節點上。</span><span class="sxs-lookup"><span data-stu-id="712ea-137">In NonAlignedAffinity, the replicas or instances of the different services are placed on the same nodes.</span></span> <span data-ttu-id="712ea-138">另一個模式是 AlignedAffinity。</span><span class="sxs-lookup"><span data-stu-id="712ea-138">The other mode is AlignedAffinity.</span></span> <span data-ttu-id="712ea-139">對齊的同質性只有在與具狀態服務搭配使用時才有用。</span><span class="sxs-lookup"><span data-stu-id="712ea-139">Aligned Affinity is useful only with stateful services.</span></span> <span data-ttu-id="712ea-140">設定兩個具狀態服務來具備對齊的同質性，可以確保那些服務的主要複本都位於和彼此相同的節點上。</span><span class="sxs-lookup"><span data-stu-id="712ea-140">Configuring two stateful services to have aligned affinity ensures that the primaries of those services are placed on the same nodes as each other.</span></span> <span data-ttu-id="712ea-141">它也會讓那些服務的每一對次要複本位於相同的節點上。</span><span class="sxs-lookup"><span data-stu-id="712ea-141">It also causes each pair of secondaries for those services to be placed on the same nodes.</span></span> <span data-ttu-id="712ea-142">它也可能 (但較不常見) 針對具狀態服務設定 NonAlignedAffinity。</span><span class="sxs-lookup"><span data-stu-id="712ea-142">It is also possible (though less common) to configure NonAlignedAffinity for stateful services.</span></span> <span data-ttu-id="712ea-143">對於 NonAlignedAffinity，兩個具狀態服務的不同複本會在相同節點上執行，但它們的主要複本可以在不同節點上結束。</span><span class="sxs-lookup"><span data-stu-id="712ea-143">For NonAlignedAffinity, the different replicas of the two stateful services would run on the same nodes, but their primaries could end up on different nodes.</span></span>

<span data-ttu-id="712ea-144"><center>
![同質性模式及其效果][Image1]
</center></span><span class="sxs-lookup"><span data-stu-id="712ea-144"><center>
![Affinity Modes and Their Effects][Image1]
</center></span></span>

### <a name="best-effort-desired-state"></a><span data-ttu-id="712ea-145">盡力而為的期望狀態</span><span class="sxs-lookup"><span data-stu-id="712ea-145">Best effort desired state</span></span>
<span data-ttu-id="712ea-146">同質關聯性是盡力而為模式。</span><span class="sxs-lookup"><span data-stu-id="712ea-146">An affinity relationship is best effort.</span></span> <span data-ttu-id="712ea-147">它所提供的共置或可靠性保證不會和在同一個可執行程序中執行所提供的保證相同。</span><span class="sxs-lookup"><span data-stu-id="712ea-147">It does not provide the same guarantees of collocation or reliability that running in the same executable process does.</span></span> <span data-ttu-id="712ea-148">具有同質關聯性的服務是本質上不同的實體，可能會失敗以及被個別移動。</span><span class="sxs-lookup"><span data-stu-id="712ea-148">The services in an affinity relationship are fundamentally different entities that can fail and be moved independently.</span></span> <span data-ttu-id="712ea-149">同質關聯性也可能會中斷，不過這些中斷只是暫時的。</span><span class="sxs-lookup"><span data-stu-id="712ea-149">An affinity relationship could also break, though these breaks are temporary.</span></span> <span data-ttu-id="712ea-150">例如，容量限制可能表示同質關聯性中只有部分服務物件可以適用於指定節點。</span><span class="sxs-lookup"><span data-stu-id="712ea-150">For example, capacity limitations may mean that only some of the service objects in the affinity relationship can fit on a given node.</span></span> <span data-ttu-id="712ea-151">在這些情況下，即使有同質關聯性，也會因為其他條件約束而無法強制執行。</span><span class="sxs-lookup"><span data-stu-id="712ea-151">In these cases even though there's an affinity relationship in place, it can't be enforced due to the other constraints.</span></span> <span data-ttu-id="712ea-152">就算可行，系統之後也會自動更正此違規情形。</span><span class="sxs-lookup"><span data-stu-id="712ea-152">If it is possible to do so, the violation is automatically corrected later.</span></span>

### <a name="chains-vs-stars"></a><span data-ttu-id="712ea-153">鏈結與星形的比較</span><span class="sxs-lookup"><span data-stu-id="712ea-153">Chains vs. stars</span></span>
<span data-ttu-id="712ea-154">目前，叢集資源管理員無法模擬同質關聯性的鏈結。</span><span class="sxs-lookup"><span data-stu-id="712ea-154">Today the Cluster Resource Manager isn't able to model chains of affinity relationships.</span></span> <span data-ttu-id="712ea-155">這表示是，如果有一個服務是某一個同質關聯性中的子系，則該服務不能是另一個同質關聯性中的父系。</span><span class="sxs-lookup"><span data-stu-id="712ea-155">What this means is that a service that is a child in one affinity relationship can’t be a parent in another affinity relationship.</span></span> <span data-ttu-id="712ea-156">如果您想要建立此類型的關聯性模型，您實際上必須將它建立為星形模型，而不是鏈結模型。</span><span class="sxs-lookup"><span data-stu-id="712ea-156">If you want to model this type of relationship, you effectively have to model it as a star, rather than a chain.</span></span> <span data-ttu-id="712ea-157">為了從鏈結轉變為星形，最下面的子系會變成第一個子系的父系。</span><span class="sxs-lookup"><span data-stu-id="712ea-157">To move from a chain to a star, the bottommost child would be parented to the first child’s parent instead.</span></span> <span data-ttu-id="712ea-158">根據服務的排列方式而定，您可能必須這樣做許多次。</span><span class="sxs-lookup"><span data-stu-id="712ea-158">Depending on the arrangement of your services, you may have to do this multiple times.</span></span> <span data-ttu-id="712ea-159">如果沒有自然父系服務，您可能必須建立一個作為預留位置。</span><span class="sxs-lookup"><span data-stu-id="712ea-159">If there's no natural parent service, you may have to create one that serves as a placeholder.</span></span> <span data-ttu-id="712ea-160">根據您的需求而定，您也可能考慮[應用程式群組](service-fabric-cluster-resource-manager-application-groups.md)。</span><span class="sxs-lookup"><span data-stu-id="712ea-160">Depending on your requirements, you may also want to look into [Application Groups](service-fabric-cluster-resource-manager-application-groups.md).</span></span>

<span data-ttu-id="712ea-161"><center>
![同質關聯性內容中的鏈結與星形的比較][Image2]
</center></span><span class="sxs-lookup"><span data-stu-id="712ea-161"><center>
![Chains vs. Stars in the Context of Affinity Relationships][Image2]
</center></span></span>

<span data-ttu-id="712ea-162">目前關於同質關聯性的另一個要注意事項是它們是雙向的。</span><span class="sxs-lookup"><span data-stu-id="712ea-162">Another thing to note about affinity relationships today is that they are directional.</span></span> <span data-ttu-id="712ea-163">這表示同質性規則只會強制讓子系跟隨父系來放置。</span><span class="sxs-lookup"><span data-stu-id="712ea-163">This means that the affinity rule only enforces that the child placed with the parent.</span></span> <span data-ttu-id="712ea-164">它無法確保父系會與子系位於相同位置。</span><span class="sxs-lookup"><span data-stu-id="712ea-164">It does not ensure that the parent is located with the child.</span></span> <span data-ttu-id="712ea-165">也請務必注意，同質關聯性不可能完美無缺或立即強制執行，因為不同的服務會有不同的生命週期，因此可以單獨地失敗和移動。</span><span class="sxs-lookup"><span data-stu-id="712ea-165">It is also important to note that the affinity relationship can't be perfect or instantly enforced since different services have with different lifecycles and can fail and move independently.</span></span> <span data-ttu-id="712ea-166">例如，假設父系因為當機而突然容錯移轉至另一個節點。</span><span class="sxs-lookup"><span data-stu-id="712ea-166">For example, let's say the parent suddenly fails over to another node because it crashed.</span></span> <span data-ttu-id="712ea-167">叢集資源管理員和容錯移轉管理員會先處理容錯移轉，因為其首要任務就是讓服務保持運作、一致性和可用性。</span><span class="sxs-lookup"><span data-stu-id="712ea-167">The Cluster Resource Manager and Failover Manager handle the failover first, since keeping the services up, consistent, and available is the priority.</span></span> <span data-ttu-id="712ea-168">在容錯移轉完成之後，同質關聯性已中斷，但叢集資源管理員會認為一切正常，直到它發現子系並未與父系放在一起。</span><span class="sxs-lookup"><span data-stu-id="712ea-168">Once the failover completes, the affinity relationship is broken, but the Cluster Resource Manager thinks everything is fine until it notices that the child is not located with the parent.</span></span> <span data-ttu-id="712ea-169">系統會定期執行這類檢查。</span><span class="sxs-lookup"><span data-stu-id="712ea-169">These sorts of checks are performed periodically.</span></span> <span data-ttu-id="712ea-170">您可以在[這篇文章](service-fabric-cluster-resource-manager-management-integration.md#constraint-types)中找到更多關於叢集資源管理員如何評估條件約束的資訊，[這篇文章](service-fabric-cluster-resource-manager-balancing.md)則會深入說明如何設定這些條件約束的評估頻率。</span><span class="sxs-lookup"><span data-stu-id="712ea-170">More information on how the Cluster Resource Manager evaluates constraints is available in [this article](service-fabric-cluster-resource-manager-management-integration.md#constraint-types), and [this one](service-fabric-cluster-resource-manager-balancing.md) talks more about how to configure the cadence on which these constraints are evaluated.</span></span>   


### <a name="partitioning-support"></a><span data-ttu-id="712ea-171">支援分割</span><span class="sxs-lookup"><span data-stu-id="712ea-171">Partitioning support</span></span>
<span data-ttu-id="712ea-172">請注意，關於同質性要注意的最後一點是，分割父系的地方不支援同質關聯性。</span><span class="sxs-lookup"><span data-stu-id="712ea-172">The final thing to notice about affinity is that affinity relationships aren’t supported where the parent is partitioned.</span></span> <span data-ttu-id="712ea-173">我們最終可能會支援分割的父服務，但目前尚未允許這麼做。</span><span class="sxs-lookup"><span data-stu-id="712ea-173">Partitioned parent services may be supported eventually, but today it is not allowed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="712ea-174">後續步驟</span><span class="sxs-lookup"><span data-stu-id="712ea-174">Next steps</span></span>
- <span data-ttu-id="712ea-175">如需服務設定的詳細資訊，請[深入了解設定服務](service-fabric-cluster-resource-manager-configure-services.md)</span><span class="sxs-lookup"><span data-stu-id="712ea-175">For more information on configuring services, [Learn about configuring Services](service-fabric-cluster-resource-manager-configure-services.md)</span></span>
- <span data-ttu-id="712ea-176">若要限制只讓一小組機器使用服務或要彙總服務的負載，請使用[應用程式群組](service-fabric-cluster-resource-manager-application-groups.md)</span><span class="sxs-lookup"><span data-stu-id="712ea-176">To limit services to a small set of machines or aggregating the load of services, use [Application Groups](service-fabric-cluster-resource-manager-application-groups.md)</span></span>

[Image1]:./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resrouce-manager-affinity-modes.png
[Image2]:./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resource-manager-chains-vs-stars.png