---
title: "aaaService 網狀架構叢集資源管理員的親和性 |Microsoft 文件"
description: "Service Fabric 服務的設定同質性概觀"
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: 678073e1-d08d-46c4-a811-826e70aba6c4
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 7dc9b6d9c18d9d615d39cff7de9d7cba1c040474
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="configuring-and-using-service-affinity-in-service-fabric"></a><span data-ttu-id="8deb2-103">在 Service Fabric 中設定並使用服務同質性</span><span class="sxs-lookup"><span data-stu-id="8deb2-103">Configuring and using service affinity in Service Fabric</span></span>
<span data-ttu-id="8deb2-104">親和性會提供主要 toohelp 輕鬆 hello 轉換成 hello 雲端和 microservices 世界大型整合應用程式的控制項。</span><span class="sxs-lookup"><span data-stu-id="8deb2-104">Affinity is a control that is provided mainly toohelp ease hello transition of larger monolithic applications into hello cloud and microservices world.</span></span> <span data-ttu-id="8deb2-105">它也會當做使用最佳化來改善 hello 效能的服務，雖然這樣做可能有副作用。</span><span class="sxs-lookup"><span data-stu-id="8deb2-105">It is also used as an optimization for improving hello performance of services, although doing so can have side effects.</span></span>

<span data-ttu-id="8deb2-106">例如，假設您要讓較大的應用程式，或只未設計 microservices 注意、 tooService 網狀架構 （或任何分散式的環境） 中的其中一個。</span><span class="sxs-lookup"><span data-stu-id="8deb2-106">Let’s say you’re bringing a larger app, or one that just wasn’t designed with microservices in mind, tooService Fabric (or any distributed environment).</span></span> <span data-ttu-id="8deb2-107">這種轉換很常見。</span><span class="sxs-lookup"><span data-stu-id="8deb2-107">This type of transition is common.</span></span> <span data-ttu-id="8deb2-108">您啟動提升到 hello 環境的 hello 整個應用程式、 封裝，並確定它可以順利執行。</span><span class="sxs-lookup"><span data-stu-id="8deb2-108">You start by lifting hello entire app into hello environment, packaging it, and making sure it is running smoothly.</span></span> <span data-ttu-id="8deb2-109">然後啟動其分解成較小不同，所有交談 tooeach 其他的服務。</span><span class="sxs-lookup"><span data-stu-id="8deb2-109">Then you start breaking it down into different smaller services that all talk tooeach other.</span></span>

<span data-ttu-id="8deb2-110">最後您可能會發現 hello 應用程式發生一些問題。</span><span class="sxs-lookup"><span data-stu-id="8deb2-110">Eventually you may find that hello application is experiencing some issues.</span></span> <span data-ttu-id="8deb2-111">hello 問題通常可分成下列其中一種：</span><span class="sxs-lookup"><span data-stu-id="8deb2-111">hello issues usually fall into one of these categories:</span></span>

1. <span data-ttu-id="8deb2-112">Hello 整合應用程式中的某些元件 X Y 元件上有未記載的相依性和您剛開啟這些元件到個別的服務。</span><span class="sxs-lookup"><span data-stu-id="8deb2-112">Some component X in hello monolithic app had an undocumented dependency on component Y, and you just turned those components into separate services.</span></span> <span data-ttu-id="8deb2-113">因為這些服務現在 hello 叢集中不同節點上執行，變更就會中斷。</span><span class="sxs-lookup"><span data-stu-id="8deb2-113">Since these services are now running on different nodes in hello cluster, they're broken.</span></span>
2. <span data-ttu-id="8deb2-114">透過這些元件進行通訊 (本機具名管道 | 共用記憶體 | 磁碟上的檔案) 和它們真正需要 toobe 無法 toowrite tooa 共用本機資源的效能立即。</span><span class="sxs-lookup"><span data-stu-id="8deb2-114">These components communicate via (local named pipes | shared memory | files on disk) and they really need toobe able toowrite tooa shared local resource for performance reasons right now.</span></span> <span data-ttu-id="8deb2-115">您稍後或許會移除該硬式相依性。</span><span class="sxs-lookup"><span data-stu-id="8deb2-115">That hard dependency gets removed later, maybe.</span></span>
3. <span data-ttu-id="8deb2-116">一切都沒問題，但事實上，這兩個元件具有很多對話/效能敏感的內容。</span><span class="sxs-lookup"><span data-stu-id="8deb2-116">Everything is fine, but it turns out that these two components are actually chatty/performance sensitive.</span></span> <span data-ttu-id="8deb2-117">當我將它們移到個別服務時，整體應用程式效能會遭到重挫或導致延遲增加。</span><span class="sxs-lookup"><span data-stu-id="8deb2-117">When they moved them into separate services overall application performance tanked or latency increased.</span></span> <span data-ttu-id="8deb2-118">如此一來，hello 整體應用程式不符合預期。</span><span class="sxs-lookup"><span data-stu-id="8deb2-118">As a result, hello overall application is not meeting expectations.</span></span>

<span data-ttu-id="8deb2-119">在這些情況下，我們不要 toolose 重構的工作中，而且不想 toogo 後 toohello monolith。</span><span class="sxs-lookup"><span data-stu-id="8deb2-119">In these cases, we don’t want toolose our refactoring work, and don’t want toogo back toohello monolith.</span></span> <span data-ttu-id="8deb2-120">hello 最後一個條件，甚至可能想要為純文字的最佳化。</span><span class="sxs-lookup"><span data-stu-id="8deb2-120">hello last condition may even be desirable as a plain optimization.</span></span> <span data-ttu-id="8deb2-121">不過，我們可以重新 hello 元件 toowork 設計為服務的自然 （或之前我們可以解決 hello 效能期望其他方式） 我們 tooneed 某種意義上的位置。</span><span class="sxs-lookup"><span data-stu-id="8deb2-121">However, until we can redesign hello components toowork naturally as services (or until we can solve hello performance expectations some other way) we're going tooneed some sense of locality.</span></span>

<span data-ttu-id="8deb2-122">哪些 toodo？</span><span class="sxs-lookup"><span data-stu-id="8deb2-122">What toodo?</span></span> <span data-ttu-id="8deb2-123">嗯，您可以嘗試開啟同質性。</span><span class="sxs-lookup"><span data-stu-id="8deb2-123">Well, you could try turning on affinity.</span></span>

## <a name="how-tooconfigure-affinity"></a><span data-ttu-id="8deb2-124">如何 tooconfigure 親和性</span><span class="sxs-lookup"><span data-stu-id="8deb2-124">How tooconfigure affinity</span></span>
<span data-ttu-id="8deb2-125">tooset 向上親和性，您會定義兩個不同的服務之間的親和性關聯性。</span><span class="sxs-lookup"><span data-stu-id="8deb2-125">tooset up affinity, you define an affinity relationship between two different services.</span></span> <span data-ttu-id="8deb2-126">您可以將此同質性想像成在一個服務上「指向」另一個服務，並假設「此服務只有在該服務執行所在的地方才能執行」。</span><span class="sxs-lookup"><span data-stu-id="8deb2-126">You can think of affinity as “pointing” one service at another and saying “This service can only run where that service is running.”</span></span> <span data-ttu-id="8deb2-127">有時候我們 tooaffinity 父子式關聯性 （其中您指向 hello 子 hello 父）。</span><span class="sxs-lookup"><span data-stu-id="8deb2-127">Sometimes we refer tooaffinity as a parent/child relationship (where you point hello child at hello parent).</span></span> <span data-ttu-id="8deb2-128">確定 hello 複本或一個服務的執行個體位於上 hello 相同親和性可確保與其他服務的節點。</span><span class="sxs-lookup"><span data-stu-id="8deb2-128">Affinity ensures that hello replicas or instances of one service are placed on hello same nodes as those of another service.</span></span>

```csharp
ServiceCorrelationDescription affinityDescription = new ServiceCorrelationDescription();
affinityDescription.Scheme = ServiceCorrelationScheme.Affinity;
affinityDescription.ServiceName = new Uri("fabric:/otherApplication/parentService");
serviceDescription.Correlations.Add(affinityDescription);
await fabricClient.ServiceManager.CreateServiceAsync(serviceDescription);
```

> [!NOTE]
> <span data-ttu-id="8deb2-129">子服務只能參與一個同質關聯性。</span><span class="sxs-lookup"><span data-stu-id="8deb2-129">A child service can only participate in a single affinity relationship.</span></span> <span data-ttu-id="8deb2-130">如果您想 hello 子 toobe 相似化 tootwo 父服務一次您會有幾個選項：</span><span class="sxs-lookup"><span data-stu-id="8deb2-130">If you wanted hello child toobe affinitized tootwo parent services at once you have a couple options:</span></span>
> - <span data-ttu-id="8deb2-131">反向 hello 關聯性 （具有 parentService1 和 parentService2 指向 hello 目前子服務），或</span><span class="sxs-lookup"><span data-stu-id="8deb2-131">Reverse hello relationships (have parentService1 and parentService2 point at hello current child service), or</span></span>
> - <span data-ttu-id="8deb2-132">指定其中一種 hello 父系的集線器，依照慣例，而且有指向該服務的所有服務。</span><span class="sxs-lookup"><span data-stu-id="8deb2-132">Designate one of hello parents as a hub by convention and have all services point at that service.</span></span> 
>
> <span data-ttu-id="8deb2-133">hello 產生 hello 叢集中的放置方式應該 hello 相同。</span><span class="sxs-lookup"><span data-stu-id="8deb2-133">hello resulting placement behavior in hello cluster should be hello same.</span></span>
>

## <a name="different-affinity-options"></a><span data-ttu-id="8deb2-134">各種同質性選項</span><span class="sxs-lookup"><span data-stu-id="8deb2-134">Different affinity options</span></span>
<span data-ttu-id="8deb2-135">同質性是透過數種相互關聯的結構描述之一來表示，而且有兩種不同的模式。</span><span class="sxs-lookup"><span data-stu-id="8deb2-135">Affinity is represented via one of several correlation schemes, and has two different modes.</span></span> <span data-ttu-id="8deb2-136">hello 親和性的最常見的模式是我們呼叫 NonAlignedAffinity。</span><span class="sxs-lookup"><span data-stu-id="8deb2-136">hello most common mode of affinity is what we call NonAlignedAffinity.</span></span> <span data-ttu-id="8deb2-137">在 NonAlignedAffinity，hello 複本或 hello 不同服務的執行個體上放置 hello 相同節點。</span><span class="sxs-lookup"><span data-stu-id="8deb2-137">In NonAlignedAffinity, hello replicas or instances of hello different services are placed on hello same nodes.</span></span> <span data-ttu-id="8deb2-138">hello 其他模式為 AlignedAffinity。</span><span class="sxs-lookup"><span data-stu-id="8deb2-138">hello other mode is AlignedAffinity.</span></span> <span data-ttu-id="8deb2-139">對齊的同質性只有在與具狀態服務搭配使用時才有用。</span><span class="sxs-lookup"><span data-stu-id="8deb2-139">Aligned Affinity is useful only with stateful services.</span></span> <span data-ttu-id="8deb2-140">設定兩個可設定狀態服務 toohave 對齊親和性可確保這些服務的 hello 混雜會置於 hello 相同節點每個其他。</span><span class="sxs-lookup"><span data-stu-id="8deb2-140">Configuring two stateful services toohave aligned affinity ensures that hello primaries of those services are placed on hello same nodes as each other.</span></span> <span data-ttu-id="8deb2-141">它也會讓次要資料庫的每一對這些服務 toobe 置於 hello 相同的節點。</span><span class="sxs-lookup"><span data-stu-id="8deb2-141">It also causes each pair of secondaries for those services toobe placed on hello same nodes.</span></span> <span data-ttu-id="8deb2-142">此外，也可以 （但較不常見，） tooconfigure NonAlignedAffinity 可設定狀態的服務。</span><span class="sxs-lookup"><span data-stu-id="8deb2-142">It is also possible (though less common) tooconfigure NonAlignedAffinity for stateful services.</span></span> <span data-ttu-id="8deb2-143">NonAlignedAffinity，hello 不同複本的兩個可設定狀態的服務會在執行的 hello hello 相同節點，但其主要複本會最後可能會在不同節點上。</span><span class="sxs-lookup"><span data-stu-id="8deb2-143">For NonAlignedAffinity, hello different replicas of hello two stateful services would run on hello same nodes, but their primaries could end up on different nodes.</span></span>

<span data-ttu-id="8deb2-144"><center>
![同質性模式及其效果][Image1]
</center></span><span class="sxs-lookup"><span data-stu-id="8deb2-144"><center>
![Affinity Modes and Their Effects][Image1]
</center></span></span>

### <a name="best-effort-desired-state"></a><span data-ttu-id="8deb2-145">盡力而為的期望狀態</span><span class="sxs-lookup"><span data-stu-id="8deb2-145">Best effort desired state</span></span>
<span data-ttu-id="8deb2-146">同質關聯性是盡力而為模式。</span><span class="sxs-lookup"><span data-stu-id="8deb2-146">An affinity relationship is best effort.</span></span> <span data-ttu-id="8deb2-147">它不提供 hello 共置或可靠性的 hello 中執行相同的可執行程序會執行相同的保證。</span><span class="sxs-lookup"><span data-stu-id="8deb2-147">It does not provide hello same guarantees of collocation or reliability that running in hello same executable process does.</span></span> <span data-ttu-id="8deb2-148">親和性關聯性中的 hello 服務都可能會失敗，而且獨立移動的本質上不同實體。</span><span class="sxs-lookup"><span data-stu-id="8deb2-148">hello services in an affinity relationship are fundamentally different entities that can fail and be moved independently.</span></span> <span data-ttu-id="8deb2-149">同質關聯性也可能會中斷，不過這些中斷只是暫時的。</span><span class="sxs-lookup"><span data-stu-id="8deb2-149">An affinity relationship could also break, though these breaks are temporary.</span></span> <span data-ttu-id="8deb2-150">例如，容量限制可能表示只有部分 hello hello 親和性關聯性中的服務物件可容納指定節點上。</span><span class="sxs-lookup"><span data-stu-id="8deb2-150">For example, capacity limitations may mean that only some of hello service objects in hello affinity relationship can fit on a given node.</span></span> <span data-ttu-id="8deb2-151">在這些情況下即使有親和性關聯性的位置，則無法強制執行到期 toohello 其他條件約束。</span><span class="sxs-lookup"><span data-stu-id="8deb2-151">In these cases even though there's an affinity relationship in place, it can't be enforced due toohello other constraints.</span></span> <span data-ttu-id="8deb2-152">如果可能 toodo 因此，會自動稍後更正 hello 違規。</span><span class="sxs-lookup"><span data-stu-id="8deb2-152">If it is possible toodo so, hello violation is automatically corrected later.</span></span>

### <a name="chains-vs-stars"></a><span data-ttu-id="8deb2-153">鏈結與星形的比較</span><span class="sxs-lookup"><span data-stu-id="8deb2-153">Chains vs. stars</span></span>
<span data-ttu-id="8deb2-154">現今 hello 叢集資源管理員不能 toomodel 親和性關聯性的鏈結。</span><span class="sxs-lookup"><span data-stu-id="8deb2-154">Today hello Cluster Resource Manager isn't able toomodel chains of affinity relationships.</span></span> <span data-ttu-id="8deb2-155">這表示是，如果有一個服務是某一個同質關聯性中的子系，則該服務不能是另一個同質關聯性中的父系。</span><span class="sxs-lookup"><span data-stu-id="8deb2-155">What this means is that a service that is a child in one affinity relationship can’t be a parent in another affinity relationship.</span></span> <span data-ttu-id="8deb2-156">如果您想 toomodel 這種類型的關聯性，您可以實際獲得 toomodel 它為星號，而不是鏈結。</span><span class="sxs-lookup"><span data-stu-id="8deb2-156">If you want toomodel this type of relationship, you effectively have toomodel it as a star, rather than a chain.</span></span> <span data-ttu-id="8deb2-157">toomove 從鏈結 tooa 星形，hello 最底層子會是父代的 toohello 第一個子系的父系。</span><span class="sxs-lookup"><span data-stu-id="8deb2-157">toomove from a chain tooa star, hello bottommost child would be parented toohello first child’s parent instead.</span></span> <span data-ttu-id="8deb2-158">根據您的服務的 hello 排列方式，您可能 toodo 多次。</span><span class="sxs-lookup"><span data-stu-id="8deb2-158">Depending on hello arrangement of your services, you may have toodo this multiple times.</span></span> <span data-ttu-id="8deb2-159">如果沒有自然父系服務，您可能 toocreate 一個用來作為預留位置。</span><span class="sxs-lookup"><span data-stu-id="8deb2-159">If there's no natural parent service, you may have toocreate one that serves as a placeholder.</span></span> <span data-ttu-id="8deb2-160">根據您的需求，您可能也想成 toolook[應用程式群組](service-fabric-cluster-resource-manager-application-groups.md)。</span><span class="sxs-lookup"><span data-stu-id="8deb2-160">Depending on your requirements, you may also want toolook into [Application Groups](service-fabric-cluster-resource-manager-application-groups.md).</span></span>

<span data-ttu-id="8deb2-161"><center>
![同質關聯性內容中的鏈結與Hello 內容的親和性關聯性中顆星][Image2]
</center></span><span class="sxs-lookup"><span data-stu-id="8deb2-161"><center>
![Chains vs. Stars in hello Context of Affinity Relationships][Image2]
</center></span></span>

<span data-ttu-id="8deb2-162">有關親和性關聯性的另一件事 toonote 現今是具有方向性。</span><span class="sxs-lookup"><span data-stu-id="8deb2-162">Another thing toonote about affinity relationships today is that they are directional.</span></span> <span data-ttu-id="8deb2-163">這表示該 hello 親和性規則只會強制 hello 子放置 hello 父代。</span><span class="sxs-lookup"><span data-stu-id="8deb2-163">This means that hello affinity rule only enforces that hello child placed with hello parent.</span></span> <span data-ttu-id="8deb2-164">它無法確保該 hello 父系位於使用 hello 子系。</span><span class="sxs-lookup"><span data-stu-id="8deb2-164">It does not ensure that hello parent is located with hello child.</span></span> <span data-ttu-id="8deb2-165">它也很重要 hello 親和性關聯性的 toonote 無法最佳或立即強制因為不同的服務可以有不同的生命週期，和可以失敗，並且單獨移動。</span><span class="sxs-lookup"><span data-stu-id="8deb2-165">It is also important toonote that hello affinity relationship can't be perfect or instantly enforced since different services have with different lifecycles and can fail and move independently.</span></span> <span data-ttu-id="8deb2-166">例如，假設 hello 父突然失敗 tooanother 節點上發生當機。</span><span class="sxs-lookup"><span data-stu-id="8deb2-166">For example, let's say hello parent suddenly fails over tooanother node because it crashed.</span></span> <span data-ttu-id="8deb2-167">hello 叢集資源管理員和容錯移轉管理員控制代碼 hello 容錯移轉，因為保持 hello 服務、 一致且可用 hello 優先順序。</span><span class="sxs-lookup"><span data-stu-id="8deb2-167">hello Cluster Resource Manager and Failover Manager handle hello failover first, since keeping hello services up, consistent, and available is hello priority.</span></span> <span data-ttu-id="8deb2-168">Hello 容錯移轉完成之後，請 hello 親和性關聯中斷，但 hello 叢集資源管理員認為服務的所有項目是正常的直到它通知 hello 子不是位於 hello 父代。</span><span class="sxs-lookup"><span data-stu-id="8deb2-168">Once hello failover completes, hello affinity relationship is broken, but hello Cluster Resource Manager thinks everything is fine until it notices that hello child is not located with hello parent.</span></span> <span data-ttu-id="8deb2-169">系統會定期執行這類檢查。</span><span class="sxs-lookup"><span data-stu-id="8deb2-169">These sorts of checks are performed periodically.</span></span> <span data-ttu-id="8deb2-170">上如何 hello 叢集資源管理員會評估條件約束的詳細資訊可用於[本文](service-fabric-cluster-resource-manager-management-integration.md#constraint-types)，和[這一個](service-fabric-cluster-resource-manager-balancing.md)深入 tooconfigure hello 的韻律這些條件約束會在其的方式評估。</span><span class="sxs-lookup"><span data-stu-id="8deb2-170">More information on how hello Cluster Resource Manager evaluates constraints is available in [this article](service-fabric-cluster-resource-manager-management-integration.md#constraint-types), and [this one](service-fabric-cluster-resource-manager-balancing.md) talks more about how tooconfigure hello cadence on which these constraints are evaluated.</span></span>   


### <a name="partitioning-support"></a><span data-ttu-id="8deb2-171">支援分割</span><span class="sxs-lookup"><span data-stu-id="8deb2-171">Partitioning support</span></span>
<span data-ttu-id="8deb2-172">hello 最後一件事 toonotice 有關親和性是不支援在資料分割 hello 父親和性關聯性。</span><span class="sxs-lookup"><span data-stu-id="8deb2-172">hello final thing toonotice about affinity is that affinity relationships aren’t supported where hello parent is partitioned.</span></span> <span data-ttu-id="8deb2-173">我們最終可能會支援分割的父服務，但目前尚未允許這麼做。</span><span class="sxs-lookup"><span data-stu-id="8deb2-173">Partitioned parent services may be supported eventually, but today it is not allowed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="8deb2-174">後續步驟</span><span class="sxs-lookup"><span data-stu-id="8deb2-174">Next steps</span></span>
- <span data-ttu-id="8deb2-175">如需服務設定的詳細資訊，請[深入了解設定服務](service-fabric-cluster-resource-manager-configure-services.md)</span><span class="sxs-lookup"><span data-stu-id="8deb2-175">For more information on configuring services, [Learn about configuring Services](service-fabric-cluster-resource-manager-configure-services.md)</span></span>
- <span data-ttu-id="8deb2-176">toolimit 服務 tooa 的一組小型機器或服務，使用的彙總 hello 負載[應用程式群組](service-fabric-cluster-resource-manager-application-groups.md)</span><span class="sxs-lookup"><span data-stu-id="8deb2-176">toolimit services tooa small set of machines or aggregating hello load of services, use [Application Groups](service-fabric-cluster-resource-manager-application-groups.md)</span></span>

[Image1]:./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resrouce-manager-affinity-modes.png
[Image2]:./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resource-manager-chains-vs-stars.png