---
title: "aaaLearn Azure Service Fabric 術語 |Microsoft 文件"
description: "Service Fabric 的術語概觀 討論在 hello hello 文件其餘部分使用主要術語概念和詞彙。"
services: service-fabric
documentationcenter: .net
author: rwike77
manager: timlt
editor: chackdan;subramar
ms.assetid: 3a970679-e19e-43b3-9be8-71773f307c57
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/02/2017
ms.author: ryanwi
ms.openlocfilehash: 4781fc0527b8a58e534183249bc2759aded2730b
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="service-fabric-terminology-overview"></a><span data-ttu-id="9e20a-104">Service Fabric 術語概觀</span><span class="sxs-lookup"><span data-stu-id="9e20a-104">Service Fabric terminology overview</span></span>
<span data-ttu-id="9e20a-105">Service Fabric 是分散式的系統平台，可讓您輕鬆 toopackage、 部署及管理可擴充且可靠的 microservices。</span><span class="sxs-lookup"><span data-stu-id="9e20a-105">Service Fabric is a distributed systems platform that makes it easy toopackage, deploy, and manage scalable and reliable microservices.</span></span> <span data-ttu-id="9e20a-106">使用 Service Fabric toounderstand hello 條款 hello 文件中使用此主題詳細資料 hello 術語。</span><span class="sxs-lookup"><span data-stu-id="9e20a-106">This topic details hello terminology used by Service Fabric toounderstand hello terms used in hello documentation.</span></span>

<span data-ttu-id="9e20a-107">hello 本節所列的概念也將討論在 hello 遵循 Microsoft Virtual Academy 影片：<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=tbuZM46yC_5206218965">核心概念</a>，<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=tlkI046yC_2906218965">設計階段概念</a>，和<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=x7CVH56yC_1406218965">執行階段概念</a>.</span><span class="sxs-lookup"><span data-stu-id="9e20a-107">hello concepts listed in this section are also discussed in hello following Microsoft Virtual Academy videos: <a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=tbuZM46yC_5206218965">Core concepts</a>, <a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=tlkI046yC_2906218965">Design-time concepts</a>, and <a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=x7CVH56yC_1406218965">Run-time concepts</a>.</span></span>

## <a name="infrastructure-concepts"></a><span data-ttu-id="9e20a-108">基礎結構概念</span><span class="sxs-lookup"><span data-stu-id="9e20a-108">Infrastructure concepts</span></span>
<span data-ttu-id="9e20a-109">**叢集**：由虛擬或實體機器連結組成的網路，微服務可於其中部署和管理。</span><span class="sxs-lookup"><span data-stu-id="9e20a-109">**Cluster**: A network-connected set of virtual or physical machines into which your microservices are deployed and managed.</span></span>  <span data-ttu-id="9e20a-110">叢集可以調整 toothousands 的機器。</span><span class="sxs-lookup"><span data-stu-id="9e20a-110">Clusters can scale toothousands of machines.</span></span>

<span data-ttu-id="9e20a-111">**節點**：屬於叢集一部分的電腦或 VM 都稱為節點。</span><span class="sxs-lookup"><span data-stu-id="9e20a-111">**Node**: A machine or VM that is part of a cluster is called a node.</span></span> <span data-ttu-id="9e20a-112">需為每個節點指派節點名稱 (字串)。</span><span class="sxs-lookup"><span data-stu-id="9e20a-112">Each node is assigned a node name (a string).</span></span> <span data-ttu-id="9e20a-113">節點具有各種特性，如 placement 屬性。</span><span class="sxs-lookup"><span data-stu-id="9e20a-113">Nodes have characteristics such as placement properties.</span></span> <span data-ttu-id="9e20a-114">每個電腦或 VM 皆有自動啟動的 Windows 服務 `FabricHost.exe`，該服務會在開機時開始執行，然後啟動兩個執行檔：`Fabric.exe` 和 `FabricGateway.exe`。</span><span class="sxs-lookup"><span data-stu-id="9e20a-114">Each machine or VM has an auto-start Windows service, `FabricHost.exe`, which starts running upon boot and then starts two executables: `Fabric.exe` and `FabricGateway.exe`.</span></span> <span data-ttu-id="9e20a-115">這些兩個可執行檔組成 hello 節點。</span><span class="sxs-lookup"><span data-stu-id="9e20a-115">These two executables make up hello node.</span></span> <span data-ttu-id="9e20a-116">在測試案例中，您可以藉由執行 `Fabric.exe` 和 `FabricGateway.exe` 的多個執行個體，在單一電腦或 VM 上裝載多個節點。</span><span class="sxs-lookup"><span data-stu-id="9e20a-116">For testing scenarios, you can host multiple nodes on a single machine or VM by running multiple instances of `Fabric.exe` and `FabricGateway.exe`.</span></span>

## <a name="application-concepts"></a><span data-ttu-id="9e20a-117">應用程式概念</span><span class="sxs-lookup"><span data-stu-id="9e20a-117">Application concepts</span></span>
<span data-ttu-id="9e20a-118">**應用程式類型**: hello 指派的名稱/版本 tooa 集合的服務型別。</span><span class="sxs-lookup"><span data-stu-id="9e20a-118">**Application Type**: hello name/version assigned tooa collection of service types.</span></span> <span data-ttu-id="9e20a-119">定義在`ApplicationManifest.xml`檔案中，內嵌在應用程式封裝目錄，然後複製 toohello Service Fabric 叢集的映像存放區。</span><span class="sxs-lookup"><span data-stu-id="9e20a-119">Defined in an `ApplicationManifest.xml` file, embedded in an application package directory, which is then copied toohello Service Fabric cluster's image store.</span></span> <span data-ttu-id="9e20a-120">然後，您可以從這個應用程式類型，hello 叢集內建立具名的應用程式。</span><span class="sxs-lookup"><span data-stu-id="9e20a-120">You can then create a named application from this application type within hello cluster.</span></span>

<span data-ttu-id="9e20a-121">讀取 hello[應用程式模型](service-fabric-application-model.md)文件以取得詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="9e20a-121">Read hello [Application Model](service-fabric-application-model.md) article for more information.</span></span>

<span data-ttu-id="9e20a-122">**應用程式封裝**: hello 應用程式類型的磁碟目錄`ApplicationManifest.xml`檔案。</span><span class="sxs-lookup"><span data-stu-id="9e20a-122">**Application Package**: A disk directory containing hello application type's `ApplicationManifest.xml` file.</span></span> <span data-ttu-id="9e20a-123">參考 hello 組成 hello 應用程式類型每種服務類型的服務封裝。</span><span class="sxs-lookup"><span data-stu-id="9e20a-123">References hello service packages for each service type that makes up hello application type.</span></span> <span data-ttu-id="9e20a-124">hello 應用程式封裝目錄中的 hello 檔案會複製的 tooService 網狀架構叢集的映像存放區。</span><span class="sxs-lookup"><span data-stu-id="9e20a-124">hello files in hello application package directory are copied tooService Fabric cluster's image store.</span></span> <span data-ttu-id="9e20a-125">例如，電子郵件應用程式類型應用程式封裝可能包含參考 tooa 佇列服務封裝、 前端服務套件和資料庫的服務封裝。</span><span class="sxs-lookup"><span data-stu-id="9e20a-125">For example, an application package for an email application type could contain references tooa queue service package, a frontend service package, and a database service package.</span></span>

<span data-ttu-id="9e20a-126">**應用程式命名為**： 應用程式封裝複製的 toohello 映像存放區後，您藉由指定 hello 應用程式套件的應用程式類型 （使用其名稱/版本） 建立 hello hello 叢集內的應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="9e20a-126">**Named Application**: After an application package is copied toohello image store, you create an instance of hello application within hello cluster by specifying hello application package's application type (using its name/version).</span></span> <span data-ttu-id="9e20a-127">每個應用程式類型的執行個體會被指派一個看起來像這樣的 URI 名稱： `"fabric:/MyNamedApp"`。</span><span class="sxs-lookup"><span data-stu-id="9e20a-127">Each application type instance is assigned a URI name that looks like: `"fabric:/MyNamedApp"`.</span></span> <span data-ttu-id="9e20a-128">在叢集中，您可以從單一應用程式類型建立多個具名應用程式。</span><span class="sxs-lookup"><span data-stu-id="9e20a-128">Within a cluster, you can create multiple named applications from a single application type.</span></span> <span data-ttu-id="9e20a-129">也可以從不同的應用程式類型建立具名應用程式。</span><span class="sxs-lookup"><span data-stu-id="9e20a-129">You can also create named applications from different application types.</span></span> <span data-ttu-id="9e20a-130">每個具名應用程式都是獨立管理和控制版本。</span><span class="sxs-lookup"><span data-stu-id="9e20a-130">Each named application is managed and versioned independently.</span></span>      

<span data-ttu-id="9e20a-131">**服務類型**: hello 名稱/版本指派 tooa 服務的程式碼封裝、 資料封裝和組態的封裝。</span><span class="sxs-lookup"><span data-stu-id="9e20a-131">**Service Type**: hello name/version assigned tooa service's code packages, data packages, and configuration packages.</span></span> <span data-ttu-id="9e20a-132">定義在`ServiceManifest.xml`內嵌在服務封裝目錄與 hello 服務封裝目錄中的檔案，然後應用程式封裝所參考`ApplicationManifest.xml`檔案。</span><span class="sxs-lookup"><span data-stu-id="9e20a-132">Defined in a `ServiceManifest.xml` file, embedded in a service package directory and hello service package directory is then referenced by an application package's `ApplicationManifest.xml` file.</span></span> <span data-ttu-id="9e20a-133">Hello 叢集內建立具名的應用程式之後, 您可以建立指定的服務從 hello 的其中一個應用程式類型的服務型別。</span><span class="sxs-lookup"><span data-stu-id="9e20a-133">Within hello cluster, after creating a named application, you can create a named service from one of hello application type's service types.</span></span> <span data-ttu-id="9e20a-134">hello 服務類型`ServiceManifest.xml`檔案描述 hello 服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-134">hello service type's `ServiceManifest.xml` file describes hello service.</span></span>

<span data-ttu-id="9e20a-135">讀取 hello[應用程式模型](service-fabric-application-model.md)文件以取得詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="9e20a-135">Read hello [Application Model](service-fabric-application-model.md) article for more information.</span></span>

<span data-ttu-id="9e20a-136">服務分為兩種：</span><span class="sxs-lookup"><span data-stu-id="9e20a-136">There are two types of services:</span></span>

* <span data-ttu-id="9e20a-137">**無狀態：** hello 服務的永續性狀態會儲存在外部儲存體服務，例如 Azure 儲存體、 Azure SQL Database 或 Azure Cosmos DB 時，請使用無狀態的服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-137">**Stateless:** Use a stateless service when hello service's persistent state is stored in an external storage service such as Azure Storage, Azure SQL Database, or Azure Cosmos DB.</span></span> <span data-ttu-id="9e20a-138">Hello 服務完全沒有持續性儲存體時，請使用無狀態的服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-138">Use a stateless service when hello service has no persistent storage at all.</span></span> <span data-ttu-id="9e20a-139">例如，計算機服務其中值會傳遞 toohello 服務，就會使用這些值執行計算並傳回結果。</span><span class="sxs-lookup"><span data-stu-id="9e20a-139">For example, a calculator service where values are passed toohello service, a computation is performed using these values, and a result is returned.</span></span>
* <span data-ttu-id="9e20a-140">**可設定狀態：**具狀態服務要使用 Service Fabric toomanage 其可靠的集合或 Reliable Actors 程式設計模型透過您的服務狀態。</span><span class="sxs-lookup"><span data-stu-id="9e20a-140">**Stateful:** Use a stateful service when you want Service Fabric toomanage your service's state via its Reliable Collections or Reliable Actors programming models.</span></span> <span data-ttu-id="9e20a-141">指定您想 toospread 您那一州透過 （適用於延展性） 當多少個資料分割建立具名的服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-141">Specify how many partitions you want toospread your state over (for scalability) when creating a named service.</span></span> <span data-ttu-id="9e20a-142">也會指定多少次 tooreplicate 您 （提供可靠性） 的節點之間的狀態。</span><span class="sxs-lookup"><span data-stu-id="9e20a-142">Also specify how many times tooreplicate your state across nodes (for reliability).</span></span> <span data-ttu-id="9e20a-143">每個具名服務都有一個主要複本和多個次要複本。</span><span class="sxs-lookup"><span data-stu-id="9e20a-143">Each named service has a single primary replica and multiple secondary replicas.</span></span> <span data-ttu-id="9e20a-144">您可以撰寫 toohello 主要複本，以修改您指定的服務狀態。</span><span class="sxs-lookup"><span data-stu-id="9e20a-144">You modify your named service's state by writing toohello primary replica.</span></span> <span data-ttu-id="9e20a-145">Service Fabric 然後複寫此狀態 tooall hello 次要複本保持同步您的狀態。當主要複本失敗，且會升級現有的次要複本 tooa 主要複本時，會自動偵測 Service Fabric。</span><span class="sxs-lookup"><span data-stu-id="9e20a-145">Service Fabric then replicates this state tooall hello secondary replicas keeping your state in sync. Service Fabric automatically detects when a primary replica fails and promotes an existing secondary replica tooa primary replica.</span></span> <span data-ttu-id="9e20a-146">然後 Service Fabric 會建立新的次要複本。</span><span class="sxs-lookup"><span data-stu-id="9e20a-146">Service Fabric then creates a new secondary replica.</span></span>  

<span data-ttu-id="9e20a-147">**服務封裝**: hello 服務類型的磁碟目錄`ServiceManifest.xml`檔案。</span><span class="sxs-lookup"><span data-stu-id="9e20a-147">**Service Package**: A disk directory containing hello service type's `ServiceManifest.xml` file.</span></span> <span data-ttu-id="9e20a-148">這個檔案會參考 hello 程式碼、 靜態資料和設定封裝 hello 服務類型。</span><span class="sxs-lookup"><span data-stu-id="9e20a-148">This file references hello code, static data, and configuration packages for hello service type.</span></span> <span data-ttu-id="9e20a-149">hello 服務封裝目錄中的 hello 檔案正由 hello 應用程式類型的`ApplicationManifest.xml`檔案。</span><span class="sxs-lookup"><span data-stu-id="9e20a-149">hello files in hello service package directory are referenced by hello application type's `ApplicationManifest.xml` file.</span></span> <span data-ttu-id="9e20a-150">例如，服務套件無法參照 toohello 程式碼、 靜態資料和設定套件組成資料庫服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-150">For example, a service package could refer toohello code, static data, and configuration packages that make up a database service.</span></span>

<span data-ttu-id="9e20a-151">**名為 Service**： 之後建立具名的應用程式，您可以藉由指定 hello 服務類型 （使用其名稱/版本） 建立的其中一個 hello 叢集內的服務類型執行個體。</span><span class="sxs-lookup"><span data-stu-id="9e20a-151">**Named Service**: After creating a named application, you can create an instance of one of its service types within hello cluster by specifying hello service type (using its name/version).</span></span> <span data-ttu-id="9e20a-152">需為每個服務類型執行個體指派一個 URI (名稱範圍需在其具名應用程式的 URI 之下)。</span><span class="sxs-lookup"><span data-stu-id="9e20a-152">Each service type instance is assigned a URI name scoped under its named application's URI.</span></span> <span data-ttu-id="9e20a-153">例如，如果您建立服務應用程式命名為"MyNamedApp"中的名為"MyDatabase"，hello URI 看起來像： `"fabric:/MyNamedApp/MyDatabase"`。</span><span class="sxs-lookup"><span data-stu-id="9e20a-153">For example, if you create a "MyDatabase" named service within a "MyNamedApp" named application, hello URI looks like: `"fabric:/MyNamedApp/MyDatabase"`.</span></span> <span data-ttu-id="9e20a-154">在具名應用程式中，可以建立數個具名服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-154">Within a named application, you can create several named services.</span></span> <span data-ttu-id="9e20a-155">每個具名服務可以有自己的分割配置和執行個體/複本計數。</span><span class="sxs-lookup"><span data-stu-id="9e20a-155">Each named service can have its own partition scheme and instance/replica counts.</span></span>

<span data-ttu-id="9e20a-156">**程式碼封裝**: hello 服務類型的可執行檔 （通常是 EXE 或 DLL 檔案） 的磁碟目錄。</span><span class="sxs-lookup"><span data-stu-id="9e20a-156">**Code Package**: A disk directory containing hello service type's executable files (typically EXE/DLL files).</span></span> <span data-ttu-id="9e20a-157">hello 程式碼封裝目錄中的 hello 檔案正由 hello 服務型別的`ServiceManifest.xml`檔案。</span><span class="sxs-lookup"><span data-stu-id="9e20a-157">hello files in hello code package directory are referenced by hello service type's `ServiceManifest.xml` file.</span></span> <span data-ttu-id="9e20a-158">建立指定的服務時，hello 程式碼封裝是複製的 toohello 節點選取的 toorun hello 名為 service。</span><span class="sxs-lookup"><span data-stu-id="9e20a-158">When a named service is created, hello code package is copied toohello node or nodes selected toorun hello named service.</span></span> <span data-ttu-id="9e20a-159">然後 hello 程式碼開始執行。</span><span class="sxs-lookup"><span data-stu-id="9e20a-159">Then hello code starts running.</span></span> <span data-ttu-id="9e20a-160">程式碼封裝執行檔分成兩種：</span><span class="sxs-lookup"><span data-stu-id="9e20a-160">There are two types of code package executables:</span></span>

* <span data-ttu-id="9e20a-161">**客體可執行檔**： 可執行檔，以執行-hello 主機作業系統上 （Windows 或 Linux）。</span><span class="sxs-lookup"><span data-stu-id="9e20a-161">**Guest executables**: Executables that run as-is on hello host operating system (Windows or Linux).</span></span> <span data-ttu-id="9e20a-162">也就是這些可執行檔連結 tooor 參考任何 Service Fabric 執行階段檔案，並因此不會使用程式設計模型的任何服務網狀架構。</span><span class="sxs-lookup"><span data-stu-id="9e20a-162">That is, these executables do not link tooor reference any Service Fabric runtime files and therefore do not use any Service Fabric programming models.</span></span> <span data-ttu-id="9e20a-163">這些可執行檔都無法 toouse 某些 Service Fabric 功能，例如 hello 命名服務端點的探索。</span><span class="sxs-lookup"><span data-stu-id="9e20a-163">These executables are unable toouse some Service Fabric features such as hello naming service for endpoint discovery.</span></span> <span data-ttu-id="9e20a-164">客體可執行檔無法報告負載度量特定 tooeach 服務執行個體。</span><span class="sxs-lookup"><span data-stu-id="9e20a-164">Guest executables cannot report load metrics specific tooeach service instance.</span></span>
* <span data-ttu-id="9e20a-165">**服務主機的可執行檔**： 使用 Service Fabric 連結 tooService 網狀架構執行階段檔案，程式設計模型啟用 Service Fabric 功能的可執行檔。</span><span class="sxs-lookup"><span data-stu-id="9e20a-165">**Service Host Executables**: Executables that use Service Fabric programming models by linking tooService Fabric runtime files, enabling Service Fabric features.</span></span> <span data-ttu-id="9e20a-166">例如，具名服務執行個體可以在 Service Fabric 命名服務註冊端點，也可以報告負載度量。</span><span class="sxs-lookup"><span data-stu-id="9e20a-166">For example, a named service instance can register endpoints with Service Fabric's Naming Service and can also report load metrics.</span></span>      

<span data-ttu-id="9e20a-167">**資料封裝**: hello 服務類型的靜態、 唯讀資料檔案 （通常相片，音效及視訊檔案） 的磁碟目錄。</span><span class="sxs-lookup"><span data-stu-id="9e20a-167">**Data Package**: A disk directory containing hello service type's static, read-only data files (typically photo, sound, and video files).</span></span> <span data-ttu-id="9e20a-168">hello 資料封裝目錄中的 hello 檔案正由 hello 服務型別的`ServiceManifest.xml`檔案。</span><span class="sxs-lookup"><span data-stu-id="9e20a-168">hello files in hello data package directory are referenced by hello service type's `ServiceManifest.xml` file.</span></span> <span data-ttu-id="9e20a-169">Hello 資料套件建立具名的服務時，就複製的 toohello 節點選取的 toorun hello 名為 service。</span><span class="sxs-lookup"><span data-stu-id="9e20a-169">When a named service is created, hello data package is copied toohello node or nodes selected toorun hello named service.</span></span>  <span data-ttu-id="9e20a-170">hello 程式碼開始執行，並且現在可以存取 hello 資料檔案。</span><span class="sxs-lookup"><span data-stu-id="9e20a-170">hello code starts running and can now access hello data files.</span></span>

<span data-ttu-id="9e20a-171">**組態封裝**： 包含 hello 服務類型的靜態的磁碟目錄，唯讀的組態檔 （通常是文字檔案）。</span><span class="sxs-lookup"><span data-stu-id="9e20a-171">**Configuration Package**: A disk directory containing hello service type's static, read-only configuration files (typically text files).</span></span> <span data-ttu-id="9e20a-172">hello 組態封裝目錄中的 hello 檔案正由 hello 服務型別的`ServiceManifest.xml`檔案。</span><span class="sxs-lookup"><span data-stu-id="9e20a-172">hello files in hello configuration package directory are referenced by hello service type's `ServiceManifest.xml` file.</span></span> <span data-ttu-id="9e20a-173">建立指定的服務時，hello 組態套件中的 hello 檔案複製的 toohello 其中一個或多個節點選取的 toorun hello 名為 service。</span><span class="sxs-lookup"><span data-stu-id="9e20a-173">When a named service is created, hello files in hello configuration package are copied toohello one or more nodes selected toorun hello named service.</span></span> <span data-ttu-id="9e20a-174">然後 hello 程式碼開始執行，並且現在可以存取 hello 設定檔。</span><span class="sxs-lookup"><span data-stu-id="9e20a-174">Then hello code starts running and can now access hello configuration files.</span></span>

<span data-ttu-id="9e20a-175">**容器**：根據預設，Service Fabric 會以處理序形式部署和啟動這些服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-175">**Containers**: By default, Service Fabric deploys and activates services as processes.</span></span> <span data-ttu-id="9e20a-176">Service Fabric 也可以在容器映像中部署服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-176">Service Fabric can also deploy services in container images.</span></span> <span data-ttu-id="9e20a-177">容器是虛擬化 hello 基礎作業系統與應用程式的虛擬化技術。</span><span class="sxs-lookup"><span data-stu-id="9e20a-177">Containers are a virtualization technology that virtualizes hello underlying operating system from applications.</span></span> <span data-ttu-id="9e20a-178">應用程式和其執行階段、 相依性，以及系統程式庫容器內執行的作業系統建構完整的私用存取 toohello 容器自己隔離檢視中。</span><span class="sxs-lookup"><span data-stu-id="9e20a-178">An application and its runtime, dependencies, and system libraries run inside a container with full, private access toohello container's own isolated view of operating system constructs.</span></span> <span data-ttu-id="9e20a-179">Service Fabric 支援 Linux 上的 Docker 容器和 Windows Server 容器。</span><span class="sxs-lookup"><span data-stu-id="9e20a-179">Service Fabric supports Docker containers on Linux and Windows Server containers.</span></span>  <span data-ttu-id="9e20a-180">如需詳細資訊，請參閱 [Service Fabric 和容器](service-fabric-containers-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="9e20a-180">For more information, read [Service Fabric and containers](service-fabric-containers-overview.md).</span></span>

<span data-ttu-id="9e20a-181">**分割配置**：建立具名的服務時，要指定分割配置。</span><span class="sxs-lookup"><span data-stu-id="9e20a-181">**Partition Scheme**: When creating a named service, you specify a partition scheme.</span></span> <span data-ttu-id="9e20a-182">含有大量狀態服務分割 hello 資料跨資料分割，hello 叢集節點間散佈 hello 狀態。</span><span class="sxs-lookup"><span data-stu-id="9e20a-182">Services with large amounts of state split hello data across partitions, which spreads hello state across hello cluster's nodes.</span></span> <span data-ttu-id="9e20a-183">這可讓您指定的服務狀態 tooscale。</span><span class="sxs-lookup"><span data-stu-id="9e20a-183">This allows your named service's state tooscale.</span></span> <span data-ttu-id="9e20a-184">在分割內，無狀態的具名服務會有執行個體，而具狀態的具名服務則有複本。</span><span class="sxs-lookup"><span data-stu-id="9e20a-184">Within a partition, stateless named services have instances while stateful named services have replicas.</span></span> <span data-ttu-id="9e20a-185">通常，無狀態具名服務只會有 1 個分割，因為它們有沒有內部狀態。</span><span class="sxs-lookup"><span data-stu-id="9e20a-185">Usually, stateless named services only ever have one partition since they have no internal state.</span></span> <span data-ttu-id="9e20a-186">hello 磁碟分割執行個體提供可用性。如果一個執行個體失敗，其他執行個體 toooperate 會繼續正常執行，並接著服務網狀架構將會建立新的執行個體。</span><span class="sxs-lookup"><span data-stu-id="9e20a-186">hello partition instances provide for availability; if one instance fails, other instances continue toooperate normally and then Service Fabric will create a new instance.</span></span> <span data-ttu-id="9e20a-187">名為服務的可設定狀態會維持其複本中的狀態和每個分割區有自己的複本集中，所有 hello 狀態保持同步。Service Fabric 複本應該失敗、 建立新的複本，從 hello 現有複本。</span><span class="sxs-lookup"><span data-stu-id="9e20a-187">Stateful named services maintain their state within replicas and each partition has its own replica set with all hello state being kept in sync. Should a replica fail, Service Fabric builds a new replica from hello existing replicas.</span></span>

<span data-ttu-id="9e20a-188">讀取 hello[可靠的資料分割 Service Fabric 服務](service-fabric-concepts-partitioning.md)文件以取得詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="9e20a-188">Read hello [Partition Service Fabric reliable services](service-fabric-concepts-partitioning.md) article for more information.</span></span>

## <a name="system-services"></a><span data-ttu-id="9e20a-189">系統服務</span><span class="sxs-lookup"><span data-stu-id="9e20a-189">System services</span></span>
<span data-ttu-id="9e20a-190">有系統所建立的每個群集提供服務的 hello Service Fabric 平台功能。</span><span class="sxs-lookup"><span data-stu-id="9e20a-190">There are system services that are created in every cluster that provide hello platform capabilities of Service Fabric.</span></span>

<span data-ttu-id="9e20a-191">**命名服務**： 每個 Service Fabric 叢集已命名的服務，它會解析 hello 叢集中的服務名稱 tooa 位置。</span><span class="sxs-lookup"><span data-stu-id="9e20a-191">**Naming Service**: Each Service Fabric cluster has a Naming service, which resolves service names tooa location in hello cluster.</span></span> <span data-ttu-id="9e20a-192">您可以管理 hello 服務名稱和屬性、 類似 tooan 網際網路網域名稱服務 (DNS) 設定為 hello 叢集。</span><span class="sxs-lookup"><span data-stu-id="9e20a-192">You manage hello service names and properties, similar tooan internet Domain Name Service (DNS) for hello cluster.</span></span> <span data-ttu-id="9e20a-193">服務名稱和位置，則用戶端安全地進行通訊與使用 hello 命名服務 tooresolve hello 叢集中任何節點。</span><span class="sxs-lookup"><span data-stu-id="9e20a-193">Clients securely communicate with any node in hello cluster using hello Naming Service tooresolve a service name and its location.</span></span>  <span data-ttu-id="9e20a-194">應用程式移動，例如因為 toofailures、 資源平衡或 hello 叢集的調整大小的 hello hello 叢集內。</span><span class="sxs-lookup"><span data-stu-id="9e20a-194">Applications move within hello cluster for example due toofailures, resource balancing, or hello resizing of hello cluster.</span></span> <span data-ttu-id="9e20a-195">您可以開發服務和用戶端，但解析 hello 目前網路位置。</span><span class="sxs-lookup"><span data-stu-id="9e20a-195">You can develop services and clients which resolve hello current network location.</span></span> <span data-ttu-id="9e20a-196">用戶端取得 hello 實際電腦 IP 位址和連接埠目前正在執行。</span><span class="sxs-lookup"><span data-stu-id="9e20a-196">Clients obtain hello actual machine IP address and port where it is currently running.</span></span>

<span data-ttu-id="9e20a-197">讀取[與服務通訊](service-fabric-connect-and-communicate-with-services.md)如需有關 hello 用戶端與服務通訊 hello 命名服務所使用的 Api。</span><span class="sxs-lookup"><span data-stu-id="9e20a-197">Read [Communicate with services](service-fabric-connect-and-communicate-with-services.md) for more information on hello client and service communication APIs that work with hello Naming service.</span></span>

<span data-ttu-id="9e20a-198">**映像儲存區服務**︰每個 Service Fabric 叢集都有一個映像儲存區服務，其中保存已部署且版本化的應用程式封裝。</span><span class="sxs-lookup"><span data-stu-id="9e20a-198">**Image Store Service**: Each Service Fabric cluster has an Image Store service where deployed, versioned application packages are kept.</span></span> <span data-ttu-id="9e20a-199">複製應用程式封裝 toohello 映像存放區，然後再註冊該應用程式封裝內所包含的 hello 應用程式型別。</span><span class="sxs-lookup"><span data-stu-id="9e20a-199">Copy an application package toohello Image Store and then register hello application type contained within that application package.</span></span> <span data-ttu-id="9e20a-200">佈建 hello 應用程式類型之後，您會從它建立具名的應用程式。</span><span class="sxs-lookup"><span data-stu-id="9e20a-200">After hello application type is provisioned, you create a named application from it.</span></span> <span data-ttu-id="9e20a-201">刪除所有其具名的應用程式之後，您可以取消註冊從 hello 映像存放區的服務應用程式類型。</span><span class="sxs-lookup"><span data-stu-id="9e20a-201">You can unregister an application type from hello Image Store service after all its named applications have been deleted.</span></span>

<span data-ttu-id="9e20a-202">讀取[了解 hello ImageStoreConnectionString 設定](service-fabric-image-store-connection-string.md)如需有關 hello 映像存放區服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-202">Read [Understand hello ImageStoreConnectionString setting](service-fabric-image-store-connection-string.md) for more information about hello Image Store service.</span></span>

<span data-ttu-id="9e20a-203">讀取 hello[部署應用程式](service-fabric-deploy-remove-applications.md)發行項，如需有關部署應用程式 toohello 映像存放區服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-203">Read hello [Deploy an application](service-fabric-deploy-remove-applications.md) article for more information on deploying applications toohello Image store service.</span></span>

## <a name="built-in-programming-models"></a><span data-ttu-id="9e20a-204">內建的程式設計模型</span><span class="sxs-lookup"><span data-stu-id="9e20a-204">Built-in programming models</span></span>
<span data-ttu-id="9e20a-205">有可供您 toobuild Service Fabric 服務的.NET Framework 程式設計模型：</span><span class="sxs-lookup"><span data-stu-id="9e20a-205">There are .NET Framework programming models available for you toobuild Service Fabric services:</span></span>

<span data-ttu-id="9e20a-206">**可靠的服務**: API toobuild 無狀態與可設定狀態服務。</span><span class="sxs-lookup"><span data-stu-id="9e20a-206">**Reliable Services**: An API toobuild stateless and stateful services.</span></span> <span data-ttu-id="9e20a-207">具狀態服務將其狀態儲存在 Reliable Collections 中 (例如字典或佇列)。</span><span class="sxs-lookup"><span data-stu-id="9e20a-207">Stateful service store their state in Reliable Collections (such as a dictionary or a queue).</span></span> <span data-ttu-id="9e20a-208">您也可以取得 tooplug 中各種的通訊堆疊，例如 Web API 和 Windows Communication Foundation (WCF)。</span><span class="sxs-lookup"><span data-stu-id="9e20a-208">You also get tooplug in various communication stacks such as Web API and Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="9e20a-209">**Reliable Actors**: API toobuild 無狀態與可設定狀態的物件透過 hello 虛擬執行者的程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="9e20a-209">**Reliable Actors**: An API toobuild stateless and stateful objects through hello virtual Actor programming model.</span></span> <span data-ttu-id="9e20a-210">當您有多個獨立的計算/狀態單位時，此模型相當實用。</span><span class="sxs-lookup"><span data-stu-id="9e20a-210">This model can be useful when you have lots of independent units of computation/state.</span></span> <span data-ttu-id="9e20a-211">因為此模型使用輪流式執行緒模型，所以呼叫 tooother 執行者或服務，因為個別的動作項目無法處理其他內送要求，直到其所有的傳出要求已完成的最佳 tooavoid 程式碼。</span><span class="sxs-lookup"><span data-stu-id="9e20a-211">Because this model uses a turn-based threading model, it is best tooavoid code that calls out tooother actors or services since an individual actor cannot process other incoming requests until all its outbound requests have completed.</span></span>

<span data-ttu-id="9e20a-212">讀取 hello[選擇服務的程式設計模型](service-fabric-choose-framework.md)文件以取得詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="9e20a-212">Read hello [Choose a Programming Model for your service](service-fabric-choose-framework.md) article for more information.</span></span>

<!--Every topic should have next steps and links toohello next logical set of content tookeep hello customer engaged-->
## <a name="next-steps"></a><span data-ttu-id="9e20a-213">後續步驟</span><span class="sxs-lookup"><span data-stu-id="9e20a-213">Next steps</span></span>
<span data-ttu-id="9e20a-214">深入了解 Service Fabric toolearn:</span><span class="sxs-lookup"><span data-stu-id="9e20a-214">toolearn more about Service Fabric:</span></span>

* [<span data-ttu-id="9e20a-215">Service Fabric 概觀</span><span class="sxs-lookup"><span data-stu-id="9e20a-215">Overview of Service Fabric</span></span>](service-fabric-overview.md)
* [<span data-ttu-id="9e20a-216">為什麼 microservices 接近 toobuilding 應用程式嗎？</span><span class="sxs-lookup"><span data-stu-id="9e20a-216">Why a microservices approach toobuilding applications?</span></span>](service-fabric-overview-microservices.md)
* [<span data-ttu-id="9e20a-217">應用程式案例</span><span class="sxs-lookup"><span data-stu-id="9e20a-217">Application scenarios</span></span>](service-fabric-application-scenarios.md)

