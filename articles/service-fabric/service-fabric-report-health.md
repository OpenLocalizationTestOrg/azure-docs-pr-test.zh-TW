---
title: "加入自訂 Service Fabric 健康狀態報告 | Microsoft Docs"
description: "描述如何將自訂健康狀態報告傳送給 Azure Service Fabric 健康狀態實體。 提供設計和實作高品質健康狀態報告的建議。"
services: service-fabric
documentationcenter: .net
author: oanapl
manager: timlt
editor: 
ms.assetid: 0a00a7d2-510e-47d0-8aa8-24c851ea847f
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 07/19/2017
ms.author: oanapl
ms.openlocfilehash: ed10eef347d4d93012078456b3a145589e66d30e
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/18/2017
---
# <a name="add-custom-service-fabric-health-reports"></a><span data-ttu-id="15468-104">新增自訂 Service Fabric 健康狀態報告</span><span class="sxs-lookup"><span data-stu-id="15468-104">Add custom Service Fabric health reports</span></span>
<span data-ttu-id="15468-105">Azure Service Fabric 引入了 [健康狀態模型](service-fabric-health-introduction.md) ，主要用於在特定實體上標示狀況不良的叢集和應用程式條件。</span><span class="sxs-lookup"><span data-stu-id="15468-105">Azure Service Fabric introduces a [health model](service-fabric-health-introduction.md) designed to flag unhealthy cluster and application conditions on specific entities.</span></span> <span data-ttu-id="15468-106">健康狀態模型使用 **健康狀態報告程式** (系統元件及看門狗)。</span><span class="sxs-lookup"><span data-stu-id="15468-106">The health model uses **health reporters** (system components and watchdogs).</span></span> <span data-ttu-id="15468-107">目標為輕易迅速的診斷並修復問題。</span><span class="sxs-lookup"><span data-stu-id="15468-107">The goal is easy and fast diagnosis and repair.</span></span> <span data-ttu-id="15468-108">服務寫入器必須預先考慮到健康狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-108">Service writers need to think upfront about health.</span></span> <span data-ttu-id="15468-109">任何可能會影響到健康狀態的條件都需加以回報，尤其是如果它有助標示出接近根目錄的問題。</span><span class="sxs-lookup"><span data-stu-id="15468-109">Any condition that can impact health should be reported on, especially if it can help flag problems close to the root.</span></span> <span data-ttu-id="15468-110">健康情況資訊將可有效減少偵錯和調查工作所需的時間和心力。</span><span class="sxs-lookup"><span data-stu-id="15468-110">The health information can save time and effort on debugging and investigation.</span></span> <span data-ttu-id="15468-111">一旦在雲端 (私人或 Azure) 大規模啟動並執行服務，效益特別明顯。</span><span class="sxs-lookup"><span data-stu-id="15468-111">The usefulness is especially clear once the service is up and running at scale in the cloud (private or Azure).</span></span>

<span data-ttu-id="15468-112">Service Fabric 報告程式可監控感興趣的已識別條件。</span><span class="sxs-lookup"><span data-stu-id="15468-112">The Service Fabric reporters monitor identified conditions of interest.</span></span> <span data-ttu-id="15468-113">它們會依據其本機檢視回報這些條件。</span><span class="sxs-lookup"><span data-stu-id="15468-113">They report on those conditions based on their local view.</span></span> <span data-ttu-id="15468-114">[健康狀態存放區](service-fabric-health-introduction.md#health-store) 可彙總報告程式送出的所有健康狀態資料，以判斷實體的健康狀態是否為全域良好。</span><span class="sxs-lookup"><span data-stu-id="15468-114">The [health store](service-fabric-health-introduction.md#health-store) aggregates health data sent by all reporters to determine whether entities are globally healthy.</span></span> <span data-ttu-id="15468-115">必須為豐富、彈性且容易使用的模型。</span><span class="sxs-lookup"><span data-stu-id="15468-115">The model is intended to be rich, flexible, and easy to use.</span></span> <span data-ttu-id="15468-116">健康狀態報告的品質可決定叢集的健康狀態檢視準確度。</span><span class="sxs-lookup"><span data-stu-id="15468-116">The quality of the health reports determines the accuracy of the health view of the cluster.</span></span> <span data-ttu-id="15468-117">不正確顯示出健康不良的問題之誤報，會對升級或其他使用健康狀態資料的服務產生負面影響。</span><span class="sxs-lookup"><span data-stu-id="15468-117">False positives that wrongly show unhealthy issues can negatively impact upgrades or other services that use health data.</span></span> <span data-ttu-id="15468-118">這類服務的範例包括修復服務和警示機制。</span><span class="sxs-lookup"><span data-stu-id="15468-118">Examples of such services are repair services and alerting mechanisms.</span></span> <span data-ttu-id="15468-119">因此，需要針對報告加以考量，才能讓其以最佳的方式擷取感興趣的條件。</span><span class="sxs-lookup"><span data-stu-id="15468-119">Therefore, some thought is needed to provide reports that capture conditions of interest in the best possible way.</span></span>

<span data-ttu-id="15468-120">若要設計與實作健康情況的報告，看門狗及系統元件必須：</span><span class="sxs-lookup"><span data-stu-id="15468-120">To design and implement health reporting, watchdogs and system components must:</span></span>

* <span data-ttu-id="15468-121">定義它們感興趣的條件，受監視的方式，以及對叢集或應用程式功能的影響。</span><span class="sxs-lookup"><span data-stu-id="15468-121">Define the condition they are interested in, the way it is monitored, and the impact on the cluster or application functionality.</span></span> <span data-ttu-id="15468-122">根據這項資訊，決定健康狀態報告的屬性和健康狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-122">Based on this information, decide on the health report property and health state.</span></span>
* <span data-ttu-id="15468-123">決定報告適用的 [實體](service-fabric-health-introduction.md#health-entities-and-hierarchy) 。</span><span class="sxs-lookup"><span data-stu-id="15468-123">Determine the [entity](service-fabric-health-introduction.md#health-entities-and-hierarchy) that the report applies to.</span></span>
* <span data-ttu-id="15468-124">決定完成報告的位置，從服務內部或從內部或外部監視程式。</span><span class="sxs-lookup"><span data-stu-id="15468-124">Determine where the reporting is done, from within the service or from an internal or external watchdog.</span></span>
* <span data-ttu-id="15468-125">定義用於識別報告程式的來源。</span><span class="sxs-lookup"><span data-stu-id="15468-125">Define a source used to identify the reporter.</span></span>
* <span data-ttu-id="15468-126">選擇報告策略是定期或是轉換時。</span><span class="sxs-lookup"><span data-stu-id="15468-126">Choose a reporting strategy, either periodically or on transitions.</span></span> <span data-ttu-id="15468-127">建議以定期的方式，因為它只需較簡單的程式碼，因此較不容易發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="15468-127">The recommended way is periodically, as it requires simpler code and is less prone to errors.</span></span>
* <span data-ttu-id="15468-128">決定健康狀態不良條件的報告，可在健康狀態存放區中停留多久，以及應該如何清除。</span><span class="sxs-lookup"><span data-stu-id="15468-128">Determine how long the report for unhealthy conditions should stay in the health store and how it should be cleared.</span></span> <span data-ttu-id="15468-129">使用這項資訊，決定報告的存留時間和到期移除行為。</span><span class="sxs-lookup"><span data-stu-id="15468-129">Using this information, decide the report's time to live and remove-on-expiration behavior.</span></span>

<span data-ttu-id="15468-130">如前所述，報告可以從以下項目完成：</span><span class="sxs-lookup"><span data-stu-id="15468-130">As mentioned, reporting can be done from:</span></span>

* <span data-ttu-id="15468-131">受監視的 Service Fabric 服務複本。</span><span class="sxs-lookup"><span data-stu-id="15468-131">The monitored Service Fabric service replica.</span></span>
* <span data-ttu-id="15468-132">內部監視程式會部署為 Service Fabric 服務 (例如，可監視條件和問題報告的 Service Fabric 無狀態服務)。</span><span class="sxs-lookup"><span data-stu-id="15468-132">Internal watchdogs deployed as a Service Fabric service (for example, a Service Fabric stateless service that monitors conditions and issues reports).</span></span> <span data-ttu-id="15468-133">可以將監視程式部署為所有節點，或可以與受監視的服務相關。</span><span class="sxs-lookup"><span data-stu-id="15468-133">The watchdogs can be deployed an all nodes or can be affinitized to the monitored service.</span></span>
* <span data-ttu-id="15468-134">在 Service Fabric 節點上執行，但未  以 Service Fabric 服務實作的內部監視程式。</span><span class="sxs-lookup"><span data-stu-id="15468-134">Internal watchdogs that run on the Service Fabric nodes but are *not* implemented as Service Fabric services.</span></span>
* <span data-ttu-id="15468-135">從 Service Fabric 叢集「外」  探查資源的外部看門狗 (例如，監視 Gomez 等服務)。</span><span class="sxs-lookup"><span data-stu-id="15468-135">External watchdogs that probe the resource from *outside* the Service Fabric cluster (for example, monitoring service like Gomez).</span></span>

> [!NOTE]
> <span data-ttu-id="15468-136">根據現有設定，叢集會填入系統元件傳送的健康狀態報告。</span><span class="sxs-lookup"><span data-stu-id="15468-136">Out of the box, the cluster is populated with health reports sent by the system components.</span></span> <span data-ttu-id="15468-137">在此閱讀更多 [使用系統健康狀態報告進行疑難排解](service-fabric-understand-and-troubleshoot-with-system-health-reports.md)的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="15468-137">Read more at [Using system health reports for troubleshooting](service-fabric-understand-and-troubleshoot-with-system-health-reports.md).</span></span> <span data-ttu-id="15468-138">必須在系統所建立的 [健康狀態實體](service-fabric-health-introduction.md#health-entities-and-hierarchy) 上傳送使用者報告。</span><span class="sxs-lookup"><span data-stu-id="15468-138">The user reports must be sent on [health entities](service-fabric-health-introduction.md#health-entities-and-hierarchy) that have already been created by the system.</span></span>
> 
> 

<span data-ttu-id="15468-139">一旦健康狀態報告設計清楚，即可輕鬆傳送健康狀態報告。</span><span class="sxs-lookup"><span data-stu-id="15468-139">Once the health reporting design is clear, health reports can be sent easily.</span></span> <span data-ttu-id="15468-140">如果叢集不[安全](service-fabric-cluster-security.md)，或者網狀架構用戶端有系統管理員權限，您就可以使用 [FabricClient](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient) 來回報健康狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-140">You can use [FabricClient](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient) to report health if the cluster is not [secure](service-fabric-cluster-security.md) or if the fabric client has admin privileges.</span></span> <span data-ttu-id="15468-141">透過 API (使用 [FabricClient.HealthManager.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth))、透過 PowerShell 或透過 REST 即可進行報告。</span><span class="sxs-lookup"><span data-stu-id="15468-141">Reporting can be done through the API by using [FabricClient.HealthManager.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth), through PowerShell, or through REST.</span></span> <span data-ttu-id="15468-142">組態旋鈕批次報告可提升效能。</span><span class="sxs-lookup"><span data-stu-id="15468-142">Configuration knobs batch reports for improved performance.</span></span>

> [!NOTE]
> <span data-ttu-id="15468-143">報告健康狀態會同步處理，且只代表用戶端上的驗證工作。</span><span class="sxs-lookup"><span data-stu-id="15468-143">Report health is synchronous, and it represents only the validation work on the client side.</span></span> <span data-ttu-id="15468-144">健康狀態用戶端或是 `Partition` 或 `CodePackageActivationContext` 物件接受報告的這項事實，並不表示該報告會在存放區中套用。</span><span class="sxs-lookup"><span data-stu-id="15468-144">The fact that the report is accepted by the health client or the `Partition` or `CodePackageActivationContext` objects doesn't mean that it is applied in the store.</span></span> <span data-ttu-id="15468-145">它會以非同步方式傳送並可能與其他報告進行批次處理。</span><span class="sxs-lookup"><span data-stu-id="15468-145">It is sent asynchronously and possibly batched with other reports.</span></span> <span data-ttu-id="15468-146">在伺服器上處理仍可能會失敗：序號過時、必須套用報告的實體已被刪除等。</span><span class="sxs-lookup"><span data-stu-id="15468-146">The processing on the server may still fail: the sequence number could be stale, the entity on which the report must be applied has been deleted, etc.</span></span>
> 
> 

## <a name="health-client"></a><span data-ttu-id="15468-147">健康狀態用戶端</span><span class="sxs-lookup"><span data-stu-id="15468-147">Health client</span></span>
<span data-ttu-id="15468-148">健康狀態報告會透過存在於該網狀架構用戶端內的健康狀態用戶端來傳送至健康狀態存放區。</span><span class="sxs-lookup"><span data-stu-id="15468-148">The health reports are sent to the health store through a health client, which lives inside the fabric client.</span></span> <span data-ttu-id="15468-149">可以使用下列設定來設定健康情況用戶端：</span><span class="sxs-lookup"><span data-stu-id="15468-149">The health client can be configured with the following settings:</span></span>

* <span data-ttu-id="15468-150">**HealthReportSendInterval**：報告新增至該用戶端，與其傳送至健康狀態存放區之間的時間延遲。</span><span class="sxs-lookup"><span data-stu-id="15468-150">**HealthReportSendInterval**: The delay between the time the report is added to the client and the time it is sent to the health store.</span></span> <span data-ttu-id="15468-151">用於將報告批次處理為單一訊息，而不是針對每份報告傳送一則訊息。</span><span class="sxs-lookup"><span data-stu-id="15468-151">Used to batch reports into a single message, rather than sending one message for each report.</span></span> <span data-ttu-id="15468-152">批次處理可改善效能。</span><span class="sxs-lookup"><span data-stu-id="15468-152">The batching improves performance.</span></span> <span data-ttu-id="15468-153">預設值：30 秒。</span><span class="sxs-lookup"><span data-stu-id="15468-153">Default: 30 seconds.</span></span>
* <span data-ttu-id="15468-154">**HealthReportRetrySendInterval**：健康狀態用戶端重新傳送累積的健康狀態報告至健康狀態存放區的間隔時間。</span><span class="sxs-lookup"><span data-stu-id="15468-154">**HealthReportRetrySendInterval**: The interval at which the health client resends accumulated health reports to the health store.</span></span> <span data-ttu-id="15468-155">預設值：30 秒。</span><span class="sxs-lookup"><span data-stu-id="15468-155">Default: 30 seconds.</span></span>
* <span data-ttu-id="15468-156">**HealthOperationTimeout**：報告訊息傳送至健康狀態存放區的逾時期間。</span><span class="sxs-lookup"><span data-stu-id="15468-156">**HealthOperationTimeout**: The timeout period for a report message sent to the health store.</span></span> <span data-ttu-id="15468-157">如果訊息逾時，健康狀態用戶端就會不斷重試，直到健康狀態存放區確認報告已處理。</span><span class="sxs-lookup"><span data-stu-id="15468-157">If a message times out, the health client retries it until the health store confirms that the report has been processed.</span></span> <span data-ttu-id="15468-158">預設值：兩分鐘。</span><span class="sxs-lookup"><span data-stu-id="15468-158">Default: two minutes.</span></span>

> [!NOTE]
> <span data-ttu-id="15468-159">批次處理報告時，網狀架構用戶端必須至少保持運作長達 HealthReportSendInterval，以確保報告已傳送。</span><span class="sxs-lookup"><span data-stu-id="15468-159">When the reports are batched, the fabric client must be kept alive for at least the HealthReportSendInterval to ensure that they are sent.</span></span> <span data-ttu-id="15468-160">如果訊息遺失或健康狀態存放區因為暫時性錯誤而無法套用它們，則網狀架構用戶端必須保持運作久一點，讓其有再試一次的機會。</span><span class="sxs-lookup"><span data-stu-id="15468-160">If the message is lost or the health store cannot apply them due to transient errors, the fabric client must be kept alive longer to give it a chance to retry.</span></span>
> 
> 

<span data-ttu-id="15468-161">用戶端上的緩衝會將報告的唯一性納入考量。</span><span class="sxs-lookup"><span data-stu-id="15468-161">The buffering on the client takes the uniqueness of the reports into consideration.</span></span> <span data-ttu-id="15468-162">例如，如果特定的錯誤報告程式在相同實體的相同屬性上每秒產生 100 個報告，則會以最後一個版本取代報告。</span><span class="sxs-lookup"><span data-stu-id="15468-162">For example, if a particular bad reporter is reporting 100 reports per second on the same property of the same entity, the reports are replaced with the last version.</span></span> <span data-ttu-id="15468-163">最多只有一份這類報告存在於用戶端佇列中。</span><span class="sxs-lookup"><span data-stu-id="15468-163">At most one such report exists in the client queue.</span></span> <span data-ttu-id="15468-164">如果設定批次處理，則傳送至健康狀態存放區的報告數目為每次傳送間隔一份報告。</span><span class="sxs-lookup"><span data-stu-id="15468-164">If batching is configured, the number of reports sent to the health store is just one per send interval.</span></span> <span data-ttu-id="15468-165">這是最後新增的報告，可反映實體的最新狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-165">This report is the last added report, which reflects the most current state of the entity.</span></span>
<span data-ttu-id="15468-166">建立 `FabricClient` 時，藉由傳遞 [FabricClientSettings](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclientsettings) 以及健康情況相關項目所需的值，即可指定組態參數。</span><span class="sxs-lookup"><span data-stu-id="15468-166">Specify configuration parameters when `FabricClient` is created by passing [FabricClientSettings](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclientsettings) with the desired values for health-related entries.</span></span>

<span data-ttu-id="15468-167">以下範例會建立網狀架構用戶端，並指定新增報告後就應該傳送報告。</span><span class="sxs-lookup"><span data-stu-id="15468-167">The following example creates a fabric client and specifies that the reports should be sent when they are added.</span></span> <span data-ttu-id="15468-168">在可重試的錯誤或逾時發生時，會每 40 秒重試一次。</span><span class="sxs-lookup"><span data-stu-id="15468-168">On timeouts and errors that can be retried, retries happen every 40 seconds.</span></span>

```csharp
var clientSettings = new FabricClientSettings()
{
    HealthOperationTimeout = TimeSpan.FromSeconds(120),
    HealthReportSendInterval = TimeSpan.FromSeconds(0),
    HealthReportRetrySendInterval = TimeSpan.FromSeconds(40),
};
var fabricClient = new FabricClient(clientSettings);
```

<span data-ttu-id="15468-169">建議保留預設的網狀架構用戶端設定，其將 `HealthReportSendInterval` 設定為 30 秒。</span><span class="sxs-lookup"><span data-stu-id="15468-169">We recommend keeping the default fabric client settings, which set `HealthReportSendInterval` to 30 seconds.</span></span> <span data-ttu-id="15468-170">此設定可藉由批次處理確保最佳效能。</span><span class="sxs-lookup"><span data-stu-id="15468-170">This setting ensures optimal performance due to batching.</span></span> <span data-ttu-id="15468-171">對於必須儘速傳送的重要報告，在 [FabricClient.HealthClient.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth) API 中使用 `HealthReportSendOptions` 且 Immediate 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="15468-171">For critical reports that must be sent as soon as possible, use `HealthReportSendOptions` with Immediate `true` in [FabricClient.HealthClient.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth) API.</span></span> <span data-ttu-id="15468-172">立即報告會略過批次處理間隔。</span><span class="sxs-lookup"><span data-stu-id="15468-172">Immediate reports bypass the batching interval.</span></span> <span data-ttu-id="15468-173">請小心使用這個旗標；我們想要盡可能利用健康情況用戶端批次處理。</span><span class="sxs-lookup"><span data-stu-id="15468-173">Use this flag with care; we want to take advantage of the health client batching whenever possible.</span></span> <span data-ttu-id="15468-174">關閉網狀架構用戶端時，立即傳送也很實用 (例如，程序已判斷狀態無效且必須關閉，以免產生副作用)。</span><span class="sxs-lookup"><span data-stu-id="15468-174">Immediate send is also useful when the fabric client is closing (for example, the process has determined invalid state and needs to shut down to prevent side effects).</span></span> <span data-ttu-id="15468-175">它可確保以最佳方式傳送累積報告。</span><span class="sxs-lookup"><span data-stu-id="15468-175">It ensures a best-effort send of the accumulated reports.</span></span> <span data-ttu-id="15468-176">若一份報告加上 Immediate 旗標，則健康情況用戶端會分批處理上次傳送後的所有累積報告。</span><span class="sxs-lookup"><span data-stu-id="15468-176">When one report is added with Immediate flag, the health client batches all the accumulated reports since last send.</span></span>

<span data-ttu-id="15468-177">透過 PowerShell 建立叢集連線時，可以指定相同的參數。</span><span class="sxs-lookup"><span data-stu-id="15468-177">Same parameters can be specified when a connection to a cluster is created through PowerShell.</span></span> <span data-ttu-id="15468-178">下列範例可啟動本機叢集的連線：</span><span class="sxs-lookup"><span data-stu-id="15468-178">The following example starts a connection to a local cluster:</span></span>

```powershell
PS C:\> Connect-ServiceFabricCluster -HealthOperationTimeoutInSec 120 -HealthReportSendIntervalInSec 0 -HealthReportRetrySendIntervalInSec 40
True

ConnectionEndpoint   :
FabricClientSettings : {
                       ClientFriendlyName                   : PowerShell-1944858a-4c6d-465f-89c7-9021c12ac0bb
                       PartitionLocationCacheLimit          : 100000
                       PartitionLocationCacheBucketCount    : 1024
                       ServiceChangePollInterval            : 00:02:00
                       ConnectionInitializationTimeout      : 00:00:02
                       KeepAliveInterval                    : 00:00:20
                       HealthOperationTimeout               : 00:02:00
                       HealthReportSendInterval             : 00:00:00
                       HealthReportRetrySendInterval        : 00:00:40
                       NotificationGatewayConnectionTimeout : 00:00:00
                       NotificationCacheUpdateTimeout       : 00:00:00
                       }
GatewayInformation   : {
                       NodeAddress                          : localhost:19000
                       NodeId                               : 1880ec88a3187766a6da323399721f53
                       NodeInstanceId                       : 130729063464981219
                       NodeName                             : Node.1
                       }
```

<span data-ttu-id="15468-179">類似於 API，不論 `HealthReportSendInterval` 值為何，使用 `-Immediate` 參數即可立即傳送報告。</span><span class="sxs-lookup"><span data-stu-id="15468-179">Similarly to API, reports can be sent using `-Immediate` switch to be sent immediately, regardless of the `HealthReportSendInterval` value.</span></span>

<span data-ttu-id="15468-180">對於 REST，報告會傳送到 Service Fabric 閘道，其具有內部網狀架構用戶端。</span><span class="sxs-lookup"><span data-stu-id="15468-180">For REST, the reports are sent to the Service Fabric gateway, which has an internal fabric client.</span></span> <span data-ttu-id="15468-181">根據預設，此用戶端會設定為每隔 30 秒分批傳送報告。</span><span class="sxs-lookup"><span data-stu-id="15468-181">By default, this client is configured to send reports batched every 30 seconds.</span></span> <span data-ttu-id="15468-182">您可以在 `HttpGateway` 上使用叢集組態設定 `HttpGatewayHealthReportSendInterval` 來變更批次間隔。</span><span class="sxs-lookup"><span data-stu-id="15468-182">You can change the batch interval with the cluster configuration setting `HttpGatewayHealthReportSendInterval` on `HttpGateway`.</span></span> <span data-ttu-id="15468-183">如先前所述，以 `Immediate` 為 true 傳送報告是比較理想的選項。</span><span class="sxs-lookup"><span data-stu-id="15468-183">As mentioned, a better option is to send the reports with `Immediate` true.</span></span> 

> [!NOTE]
> <span data-ttu-id="15468-184">若要確保未授權的服務無法針對叢集中的實體回報健康情況，請將伺服器設定為只接受來自受保護用戶端的要求。</span><span class="sxs-lookup"><span data-stu-id="15468-184">To ensure that unauthorized services can't report health against the entities in the cluster, configure the server to accept requests only from secured clients.</span></span> <span data-ttu-id="15468-185">用於報告的 `FabricClient` 必須啟用安全性，才能與叢集通訊 (例如，利用 Kerberos 或憑證驗證)。</span><span class="sxs-lookup"><span data-stu-id="15468-185">The `FabricClient` used for reporting must have security enabled to be able to communicate with the cluster (for example, with Kerberos or certificate authentication).</span></span> <span data-ttu-id="15468-186">深入了解 [叢集安全性](service-fabric-cluster-security.md)。</span><span class="sxs-lookup"><span data-stu-id="15468-186">Read more about [cluster security](service-fabric-cluster-security.md).</span></span>
> 
> 

## <a name="report-from-within-low-privilege-services"></a><span data-ttu-id="15468-187">在低權限的服務內進行報告</span><span class="sxs-lookup"><span data-stu-id="15468-187">Report from within low privilege services</span></span>
<span data-ttu-id="15468-188">如果 Service Fabric 服務沒有叢集的系統管理員存取權，您可以透過 `Partition` 或 `CodePackageActivationContext` 回報目前內容中實體的健康情況。</span><span class="sxs-lookup"><span data-stu-id="15468-188">If Service Fabric services do not have admin access to the cluster, you can report health on entities from the current context through `Partition` or `CodePackageActivationContext`.</span></span>

* <span data-ttu-id="15468-189">針對無狀態服務，使用 [IStatelessServicePartition.ReportInstanceHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatelessservicepartition.reportinstancehealth) 來回報目前服務執行個體的健康狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-189">For stateless services, use [IStatelessServicePartition.ReportInstanceHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatelessservicepartition.reportinstancehealth) to report on the current service instance.</span></span>
* <span data-ttu-id="15468-190">針對具狀態服務，使用 [IStatefulServicePartition.ReportReplicaHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatefulservicepartition.reportreplicahealth) 來回報目前複本的健康狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-190">For stateful services, use [IStatefulServicePartition.ReportReplicaHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatefulservicepartition.reportreplicahealth) to report on current replica.</span></span>
* <span data-ttu-id="15468-191">使用 [IServicePartition.ReportPartitionHealth](https://docs.microsoft.com/dotnet/api/system.fabric.iservicepartition.reportpartitionhealth) 來回報目前分割區實體的健康狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-191">Use [IServicePartition.ReportPartitionHealth](https://docs.microsoft.com/dotnet/api/system.fabric.iservicepartition.reportpartitionhealth) to report on the current partition entity.</span></span>
* <span data-ttu-id="15468-192">使用 [CodePackageActivationContext.ReportApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportapplicationhealth) 來回報目前應用程式的健康狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-192">Use [CodePackageActivationContext.ReportApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportapplicationhealth) to report on current application.</span></span>
* <span data-ttu-id="15468-193">使用 [CodePackageActivationContext.ReportDeployedApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedapplicationhealth) ，來回報現在部署於目前節點上的應用程式健康狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-193">Use [CodePackageActivationContext.ReportDeployedApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedapplicationhealth) to report on the current application deployed on the current node.</span></span>
* <span data-ttu-id="15468-194">使用 [CodePackageActivationContext.ReportDeployedServicePackageHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedservicepackagehealth)，回報部署於目前節點上之應用程式的服務套件健康情況。</span><span class="sxs-lookup"><span data-stu-id="15468-194">Use [CodePackageActivationContext.ReportDeployedServicePackageHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedservicepackagehealth) to report on a service package for the application deployed on the current node.</span></span>

> [!NOTE]
> <span data-ttu-id="15468-195">就內部而言，`Partition` 和 `CodePackageActivationContext` 會保存使用預設設定的健康狀態用戶端。</span><span class="sxs-lookup"><span data-stu-id="15468-195">Internally, the `Partition` and the `CodePackageActivationContext` hold a health client configured with default settings.</span></span> <span data-ttu-id="15468-196">如[健康情況用戶端](service-fabric-report-health.md#health-client)的說明，報表會依照計時器分批處理和傳送。</span><span class="sxs-lookup"><span data-stu-id="15468-196">As explained for the [health client](service-fabric-report-health.md#health-client), reports are batched and sent on a timer.</span></span> <span data-ttu-id="15468-197">物件應該保持運作，才有機會傳送報告。</span><span class="sxs-lookup"><span data-stu-id="15468-197">The objects should be kept alive to have a chance to send the report.</span></span>
> 
> 

<span data-ttu-id="15468-198">您可以在透過 `Partition` 和 `CodePackageActivationContext` 健康情況 API 傳送報告時指定 `HealthReportSendOptions`。</span><span class="sxs-lookup"><span data-stu-id="15468-198">You can specify `HealthReportSendOptions` when sending reports through `Partition` and `CodePackageActivationContext` health APIs.</span></span> <span data-ttu-id="15468-199">如果您有必須儘速傳送的重要報表，請使用`HealthReportSendOptions` 且 Immediate 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="15468-199">If you have critical reports that must be sent as soon as possible, use `HealthReportSendOptions` with Immediate `true`.</span></span> <span data-ttu-id="15468-200">立即報告會略過內部健康情況用戶端的批次處理間隔。</span><span class="sxs-lookup"><span data-stu-id="15468-200">Immediate reports bypass the batching interval of the internal health client.</span></span> <span data-ttu-id="15468-201">如先前所述，請小心使用這個旗標；我們想要盡可能利用健康情況用戶端批次處理。</span><span class="sxs-lookup"><span data-stu-id="15468-201">As mentioned before, use this flag with care; we want to take advantage of the health client batching whenever possible.</span></span>

## <a name="design-health-reporting"></a><span data-ttu-id="15468-202">設計健康狀態報告</span><span class="sxs-lookup"><span data-stu-id="15468-202">Design health reporting</span></span>
<span data-ttu-id="15468-203">產生高品質報告的第一個步驟，是識別可能影響該服務健康狀態的條件。</span><span class="sxs-lookup"><span data-stu-id="15468-203">The first step in generating high-quality reports is identifying the conditions that can impact the health of the service.</span></span> <span data-ttu-id="15468-204">在條件啟動或甚至在發生之前，任何有助於在服務或在叢集中標示問題的條件，都有可能替您省下數十億元。</span><span class="sxs-lookup"><span data-stu-id="15468-204">Any condition that can help flag problems in the service or cluster when it starts--or even better, before a problem happens--can potentially save billions of dollars.</span></span> <span data-ttu-id="15468-205">好處包含停機時間變少，花在調查和修復問題的夜間時間也變少，且客戶滿意度變高。</span><span class="sxs-lookup"><span data-stu-id="15468-205">The benefits include less down time, fewer night hours spent investigating and repairing issues, and higher customer satisfaction.</span></span>

<span data-ttu-id="15468-206">一旦識別出條件，監視程式寫入器需要找出最佳的監視方式，以取得額外負荷和實用性之間的平衡。</span><span class="sxs-lookup"><span data-stu-id="15468-206">Once the conditions are identified, watchdog writers need to figure out the best way to monitor them for balance between overhead and usefulness.</span></span> <span data-ttu-id="15468-207">例如，考慮可使用共用上的一些暫存檔案進行複雜計算的服務。</span><span class="sxs-lookup"><span data-stu-id="15468-207">For example, consider a service that does complex calculations that use some temporary files on a share.</span></span> <span data-ttu-id="15468-208">監視程式可以監視共用，以確保有足夠的空間。</span><span class="sxs-lookup"><span data-stu-id="15468-208">A watchdog could monitor the share to ensure that enough space is available.</span></span> <span data-ttu-id="15468-209">它可以接聽檔案或目錄變更的通知。</span><span class="sxs-lookup"><span data-stu-id="15468-209">It could listen for notifications of file or directory changes.</span></span> <span data-ttu-id="15468-210">它可以在達到預先臨界值時回報警告，並在共用已滿時回報錯誤。</span><span class="sxs-lookup"><span data-stu-id="15468-210">It could report a warning if an upfront threshold is reached, and report an error if the share is full.</span></span> <span data-ttu-id="15468-211">在警告時，修復系統可以開始清除共用上較舊的檔案。</span><span class="sxs-lookup"><span data-stu-id="15468-211">On a warning, a repair system could start cleaning up older files on the share.</span></span> <span data-ttu-id="15468-212">在錯誤時，修復系統可將服務複本移至另一個節點。</span><span class="sxs-lookup"><span data-stu-id="15468-212">On an error, a repair system could move the service replica to another node.</span></span> <span data-ttu-id="15468-213">請注意從健康情況方面描述條件狀態的方式：可被視為狀況良好 (OK) 或狀況不良 (警告或錯誤) 的條件狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-213">Note how the condition states are described in terms of health: the state of the condition that can be considered healthy (ok) or unhealthy (warning or error).</span></span>

<span data-ttu-id="15468-214">一旦設定好監視的詳細資料，監視程式寫入器需要了解如何實作監視程式。</span><span class="sxs-lookup"><span data-stu-id="15468-214">Once the monitoring details are set, a watchdog writer needs to figure out how to implement the watchdog.</span></span> <span data-ttu-id="15468-215">如果條件可在服務內決定，則該監視程式可以成為監視服務本身的一部分。</span><span class="sxs-lookup"><span data-stu-id="15468-215">If the conditions can be determined from within the service, the watchdog can be part of the monitored service itself.</span></span> <span data-ttu-id="15468-216">例如，服務程式碼可以在每次嘗試寫入檔案時，檢查並回報共用使用量。</span><span class="sxs-lookup"><span data-stu-id="15468-216">For example, the service code can check the share usage, and then report every time it tries to write a file.</span></span> <span data-ttu-id="15468-217">這個方法的優點是報告變得輕而易舉。</span><span class="sxs-lookup"><span data-stu-id="15468-217">The advantage of this approach is that reporting is simple.</span></span> <span data-ttu-id="15468-218">為避免看門狗的錯誤影響到服務功能，因此需多加留意。</span><span class="sxs-lookup"><span data-stu-id="15468-218">Care must be taken to prevent watchdog bugs from impacting the service functionality.</span></span>

<span data-ttu-id="15468-219">您並非一定要選擇在受監視的服務內報告。</span><span class="sxs-lookup"><span data-stu-id="15468-219">Reporting from within the monitored service is not always an option.</span></span> <span data-ttu-id="15468-220">服務中的監視程式可能無法偵測條件。</span><span class="sxs-lookup"><span data-stu-id="15468-220">A watchdog within the service may not be able to detect the conditions.</span></span> <span data-ttu-id="15468-221">可能沒有邏輯或資料可供做決定。</span><span class="sxs-lookup"><span data-stu-id="15468-221">It may not have the logic or data to make the determination.</span></span> <span data-ttu-id="15468-222">監視條件的額外負荷可能很高。</span><span class="sxs-lookup"><span data-stu-id="15468-222">The overhead of monitoring the conditions may be high.</span></span> <span data-ttu-id="15468-223">條件也可能不專屬某項服務，但是會影響服務之間的互動。</span><span class="sxs-lookup"><span data-stu-id="15468-223">The conditions also may not be specific to a service, but instead affect interactions between services.</span></span> <span data-ttu-id="15468-224">另一個選項是在叢集中以監視程式做為個別處理序。</span><span class="sxs-lookup"><span data-stu-id="15468-224">Another option is to have watchdogs in the cluster as separate processes.</span></span> <span data-ttu-id="15468-225">看門狗會監視條件和報告，不會以任何方式影響主要服務。</span><span class="sxs-lookup"><span data-stu-id="15468-225">The watchdogs monitor the conditions and report, without affecting the main services in any way.</span></span> <span data-ttu-id="15468-226">例如，這些監視程式可在相同應用程式上以無狀態服務實作，或是當作服務在所有節點或相同節點上部署。</span><span class="sxs-lookup"><span data-stu-id="15468-226">For example, these watchdogs could be implemented as stateless services in the same application, deployed on all nodes or on the same nodes as the service.</span></span>

<span data-ttu-id="15468-227">有時在叢集中執行監視程式也並非必要選項。</span><span class="sxs-lookup"><span data-stu-id="15468-227">Sometimes, a watchdog running in the cluster is not an option either.</span></span> <span data-ttu-id="15468-228">如果監視條件是使用者所見的服務可用性或功能，監視程式最好能與使用者用戶端在相同的位置。</span><span class="sxs-lookup"><span data-stu-id="15468-228">If the monitored condition is the availability or functionality of the service as users see it, it's best to have the watchdogs in the same place as the user clients.</span></span> <span data-ttu-id="15468-229">在那裡，監視程式可以使用者呼叫它們的相同方式測試作業。</span><span class="sxs-lookup"><span data-stu-id="15468-229">There, they can test the operations in the same way users call them.</span></span> <span data-ttu-id="15468-230">例如，您的看門狗可以留存在叢集以外、對服務發出要求，然後檢查結果的延遲性和正確性。</span><span class="sxs-lookup"><span data-stu-id="15468-230">For example, you can have a watchdog that lives outside the cluster, issues requests to the service, and checks the latency and correctness of the result.</span></span> <span data-ttu-id="15468-231">(例如在計算機服務中，2+2 是否會在合理的時間內傳回 4？)</span><span class="sxs-lookup"><span data-stu-id="15468-231">(For a calculator service, for example, does 2+2 return 4 in a reasonable amount of time?)</span></span>

<span data-ttu-id="15468-232">一旦確定監視程式詳細資料，您應決定可識別它的唯一來源 ID。</span><span class="sxs-lookup"><span data-stu-id="15468-232">Once the watchdog details have been finalized, you should decide on a source ID that uniquely identifies it.</span></span> <span data-ttu-id="15468-233">如果叢集中有多個相同類型的看門狗在運作，它們必須報告不同的實體，如果它們報告相同的實體，請使用不同的來源 ID 或屬性。</span><span class="sxs-lookup"><span data-stu-id="15468-233">If multiple watchdogs of the same type are living in the cluster, they must report on different entities, or, if they report on the same entity, use different source ID or property.</span></span> <span data-ttu-id="15468-234">如此一來，其報告才可並存。</span><span class="sxs-lookup"><span data-stu-id="15468-234">This way, their reports can coexist.</span></span> <span data-ttu-id="15468-235">健康狀態報告的屬性應該能擷取受監視的條件。</span><span class="sxs-lookup"><span data-stu-id="15468-235">The property of the health report should capture the monitored condition.</span></span> <span data-ttu-id="15468-236">(針對上述範例，該屬性可能是 **ShareSize**)。如果多份報告套用至相同的條件，該屬性應該包含一些動態資訊，才可讓報告共存。</span><span class="sxs-lookup"><span data-stu-id="15468-236">(For the example above, the property could be **ShareSize**.) If multiple reports apply to the same condition, the property should contain some dynamic information that allows reports to coexist.</span></span> <span data-ttu-id="15468-237">例如，如果需要監視多個共用，該屬性名稱可以是 **ShareSize-sharename**。</span><span class="sxs-lookup"><span data-stu-id="15468-237">For example, if multiple shares need to be monitored, the property name can be **ShareSize-sharename**.</span></span>

> [!NOTE]
> <span data-ttu-id="15468-238">請「勿」使用健康情況存放區來保留狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="15468-238">Do *not* use the health store to keep status information.</span></span> <span data-ttu-id="15468-239">只有與健康狀態相關的資訊才該回報健康狀態，因為此資訊會影響實體的健康狀態評估資訊。</span><span class="sxs-lookup"><span data-stu-id="15468-239">Only health-related information should be reported as health, as this information impacts the health evaluation of an entity.</span></span> <span data-ttu-id="15468-240">健康狀態存放區並非設計做為一般用途存放區。</span><span class="sxs-lookup"><span data-stu-id="15468-240">The health store was not designed as a general-purpose store.</span></span> <span data-ttu-id="15468-241">它會使用健康狀態評估邏輯來彙總健康狀態的所有資料。</span><span class="sxs-lookup"><span data-stu-id="15468-241">It uses health evaluation logic to aggregate all data into the health state.</span></span> <span data-ttu-id="15468-242">傳送與健康情況不相關的資訊 (例如在健康情況良好下報告狀態) 不會影響到彙總的健康情況，但可能對健康情況態存放區的效能造成負面影響。</span><span class="sxs-lookup"><span data-stu-id="15468-242">Sending information unrelated to health (like reporting status with a health state of OK) doesn't impact the aggregated health state, but it can negatively affect the performance of the health store.</span></span>
> 
> 

<span data-ttu-id="15468-243">下一個決策點是在報告哪個實體。</span><span class="sxs-lookup"><span data-stu-id="15468-243">The next decision point is which entity to report on.</span></span> <span data-ttu-id="15468-244">大部分的情況下，此條件可清楚識別實體。</span><span class="sxs-lookup"><span data-stu-id="15468-244">Most of the time, the condition clearly idetifies the entity.</span></span> <span data-ttu-id="15468-245">選擇可能具最佳細微性的實體。</span><span class="sxs-lookup"><span data-stu-id="15468-245">Choose the entity with best possible granularity.</span></span> <span data-ttu-id="15468-246">如果條件在分割中會影響到所有複本，則在分割中回報，而非在服務中回報。</span><span class="sxs-lookup"><span data-stu-id="15468-246">If a condition impacts all replicas in a partition, report on the partition, not on the service.</span></span> <span data-ttu-id="15468-247">以下為需要仔細考量的極端例子。</span><span class="sxs-lookup"><span data-stu-id="15468-247">There are corner cases where more thought is needed, though.</span></span> <span data-ttu-id="15468-248">如果條件影響到實體 (例如複本)，但所需標示條件要比複本存留期間更久，則應該要在資料分割上回報。</span><span class="sxs-lookup"><span data-stu-id="15468-248">If the condition impacts an entity, such as a replica, but the desire is to have the condition flagged for more than the duration of replica life, then it should be reported on the partition.</span></span> <span data-ttu-id="15468-249">否則，刪除複本後，健康情況存放區會清除其所有報告。</span><span class="sxs-lookup"><span data-stu-id="15468-249">Otherwise, when the replica is deleted, the health store cleans up all its reports.</span></span> <span data-ttu-id="15468-250">看門狗寫入器必須將實體和報告的存留期納入考量。</span><span class="sxs-lookup"><span data-stu-id="15468-250">Watchdog writers must think about the lifetimes of the entity and the report.</span></span> <span data-ttu-id="15468-251">報告需從存放區中清除的時間點必須清楚說明 (例如，當實體上回報的錯誤不再適用時)。</span><span class="sxs-lookup"><span data-stu-id="15468-251">It must be clear when a report should be cleaned up from a store (for example, when an error reported on an entity no longer applies).</span></span>

<span data-ttu-id="15468-252">讓我們以一個例子解釋上述的要點。</span><span class="sxs-lookup"><span data-stu-id="15468-252">Let's look at an example that puts together the points I described.</span></span> <span data-ttu-id="15468-253">假設有一個由主要具狀態保存服務和所有節點上部署的次要無狀態服務所組成的 Service Fabric 應用程式 (每種工作類型有一個次要服務類型)。</span><span class="sxs-lookup"><span data-stu-id="15468-253">Consider a Service Fabric application composed of a master stateful persistent service and secondary stateless services deployed on all nodes (one secondary service type for each type of task).</span></span> <span data-ttu-id="15468-254">主要服務有一個處理佇列，其中包含次要服務所要執行的命令。</span><span class="sxs-lookup"><span data-stu-id="15468-254">The master has a processing queue that contains commands to be executed by secondaries.</span></span> <span data-ttu-id="15468-255">次要服務會執行傳入要求並送回認可訊號。</span><span class="sxs-lookup"><span data-stu-id="15468-255">The secondaries execute the incoming requests and send back acknowledgement signals.</span></span> <span data-ttu-id="15468-256">可以監視的其中一個條件是主要服務處理佇列的長度。</span><span class="sxs-lookup"><span data-stu-id="15468-256">One condition that could be monitored is the length of the master processing queue.</span></span> <span data-ttu-id="15468-257">如果主要服務佇列長度達到臨界值，則會回報警告。</span><span class="sxs-lookup"><span data-stu-id="15468-257">If the master queue length reaches a threshold, a warning is reported.</span></span> <span data-ttu-id="15468-258">此警告表示次要服務無法處理負載。</span><span class="sxs-lookup"><span data-stu-id="15468-258">The warning indicates that the secondaries can't handle the load.</span></span> <span data-ttu-id="15468-259">如果佇列達到長度上限，而且命令已卸除，則會因為服務無法復原而回報錯誤。</span><span class="sxs-lookup"><span data-stu-id="15468-259">If the queue reaches the maximum length and commands are dropped, an error is reported, as the service can't recover.</span></span> <span data-ttu-id="15468-260">可以在 **QueueStatus**屬性上回報。</span><span class="sxs-lookup"><span data-stu-id="15468-260">The reports can be on the property **QueueStatus**.</span></span> <span data-ttu-id="15468-261">監視程式存留於服務內部，而它會在主要服務上的主要複本定期傳送。</span><span class="sxs-lookup"><span data-stu-id="15468-261">The watchdog lives inside the service, and it's sent periodically on the master primary replica.</span></span> <span data-ttu-id="15468-262">存留時間為 2 分鐘，其會於每隔 30 秒定期傳送。</span><span class="sxs-lookup"><span data-stu-id="15468-262">The time to live is two minutes, and it's sent periodically every 30 seconds.</span></span> <span data-ttu-id="15468-263">如果主要複本無法作用，報告會自動從存放區中清除。</span><span class="sxs-lookup"><span data-stu-id="15468-263">If the primary goes down, the report is cleaned up automatically from store.</span></span> <span data-ttu-id="15468-264">如果該服務複本已啟用，但發生死結或有其他問題，該報告將在健康狀態資料存放區中過期。</span><span class="sxs-lookup"><span data-stu-id="15468-264">If the service replica is up, but it is deadlocked or having other issues, the report expires in the health store.</span></span> <span data-ttu-id="15468-265">在此情況下會將實體評估為錯誤。</span><span class="sxs-lookup"><span data-stu-id="15468-265">In this case, the entity is evaluated at error.</span></span>

<span data-ttu-id="15468-266">其他可監視的條件為工作執行時間。</span><span class="sxs-lookup"><span data-stu-id="15468-266">Another condition that can be monitored is task execution time.</span></span> <span data-ttu-id="15468-267">主要服務會依據工作類型散發工作給次要服務。</span><span class="sxs-lookup"><span data-stu-id="15468-267">The master distributes tasks to the secondaries based on the task type.</span></span> <span data-ttu-id="15468-268">根據設計而定，主要服務可以輪詢次要服務，以取得工作狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-268">Depending on the design, the master could poll the secondaries for task status.</span></span> <span data-ttu-id="15468-269">也可以等候次要服務在完成時送回認可。</span><span class="sxs-lookup"><span data-stu-id="15468-269">It could also wait for secondaries to send back acknowledgement signals when they are done.</span></span> <span data-ttu-id="15468-270">在第二個案例中，您必須特別注意並偵測出次要服務停止或訊息遺失的情況。</span><span class="sxs-lookup"><span data-stu-id="15468-270">In the second case, care must be taken to detect situations where secondaries die or messages are lost.</span></span> <span data-ttu-id="15468-271">其中一種方法是主要服務傳送 Ping 要求給相同的次要服務，而次要服務會傳回其狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-271">One option is for the master to send a ping request to the same secondary, which sends back its status.</span></span> <span data-ttu-id="15468-272">如果未收到狀態，則主要服務會將此視為失敗並重新排程工作。</span><span class="sxs-lookup"><span data-stu-id="15468-272">If no status is received, the master considers it a failure and reschedules the task.</span></span> <span data-ttu-id="15468-273">此行為假設工作為等冪。</span><span class="sxs-lookup"><span data-stu-id="15468-273">This behavior assumes that the tasks are idempotent.</span></span>

<span data-ttu-id="15468-274">如果工作未於一定時間內完成 (**t1**，例如 10 分鐘)，受監視的條件可能轉換成警告。</span><span class="sxs-lookup"><span data-stu-id="15468-274">The monitored condition can be translated as a warning if the task is not done in a certain time (**t1**, for example 10 minutes).</span></span> <span data-ttu-id="15468-275">如果工作未及時完成 (**t2**，例如 20 分鐘)，受監視的條件可能轉換為「錯誤」。</span><span class="sxs-lookup"><span data-stu-id="15468-275">If the task is not completed in time (**t2**, for example 20 minutes), the monitored condition can be translated as Error.</span></span> <span data-ttu-id="15468-276">此報告可以多種方式完成：</span><span class="sxs-lookup"><span data-stu-id="15468-276">This reporting can be done in multiple ways:</span></span>

* <span data-ttu-id="15468-277">主要服務的主要複本本身會定期回報。</span><span class="sxs-lookup"><span data-stu-id="15468-277">The master primary replica reports on itself periodically.</span></span> <span data-ttu-id="15468-278">針對在佇列中的所有暫止工作可以有一個屬性。</span><span class="sxs-lookup"><span data-stu-id="15468-278">You can have one property for all pending tasks in the queue.</span></span> <span data-ttu-id="15468-279">如果至少有一個工作耗時較久，則 **PendingTasks** 屬性的報告狀態為警告或錯誤 (視情況而定)。</span><span class="sxs-lookup"><span data-stu-id="15468-279">If at least one task takes longer, the report status on the property **PendingTasks** is a warning or error, as appropriate.</span></span> <span data-ttu-id="15468-280">如果沒有暫止的工作或所有工作已開始執行，則報告狀態為「正常」。</span><span class="sxs-lookup"><span data-stu-id="15468-280">If there are no pending tasks or all tasks started execution, the report status is OK.</span></span> <span data-ttu-id="15468-281">工作會持續進行。</span><span class="sxs-lookup"><span data-stu-id="15468-281">The tasks are persistent.</span></span> <span data-ttu-id="15468-282">如果主要服務停止時，新升級的主要服務即可繼續適當地回報。</span><span class="sxs-lookup"><span data-stu-id="15468-282">If the primary goes down, the newly promoted primary can continue to report properly.</span></span>
* <span data-ttu-id="15468-283">在雲端或外部的另一個監視程式處理序會檢查工作 (根據所需的工作結果從外部檢查)，以查看它們是否已完成。</span><span class="sxs-lookup"><span data-stu-id="15468-283">Another watchdog process (in the cloud or external) checks the tasks (from outside, based on the desired task result) to see if they are completed.</span></span> <span data-ttu-id="15468-284">如果它們不採用臨界值，則會傳送主要服務的報告。</span><span class="sxs-lookup"><span data-stu-id="15468-284">If they do not respect the thresholds, a report is sent on the master service.</span></span> <span data-ttu-id="15468-285">也會傳送每個工作的報告，其中包含工作識別碼，例如 **PendingTask+taskId**。</span><span class="sxs-lookup"><span data-stu-id="15468-285">A report is also sent on each task that includes the task identifier, like **PendingTask+taskId**.</span></span> <span data-ttu-id="15468-286">只有在狀況不良的狀態才需傳送報告。</span><span class="sxs-lookup"><span data-stu-id="15468-286">Reports should be sent only on unhealthy states.</span></span> <span data-ttu-id="15468-287">將存留時間設為幾分鐘，並將報告標記為過期時移除，以確保完成清除動作。</span><span class="sxs-lookup"><span data-stu-id="15468-287">Set time to live to a few minutes, and mark the reports to be removed when they expire to ensure cleanup.</span></span>
* <span data-ttu-id="15468-288">如果執行時間超過預期時間，執行工作的次要服務就會回報。</span><span class="sxs-lookup"><span data-stu-id="15468-288">The secondary that is executing a task reports when it takes longer than expected to run it.</span></span> <span data-ttu-id="15468-289">它會回報 **PendingTasks**屬性上的服務執行個體。</span><span class="sxs-lookup"><span data-stu-id="15468-289">It reports on the service instance on the property **PendingTasks**.</span></span> <span data-ttu-id="15468-290">報告會指出服務執行個體有問題，但它不會擷取執行個體停止的情況。</span><span class="sxs-lookup"><span data-stu-id="15468-290">The report pinpoints the service instance that has issues, but it doesn't capture the situation where the instance dies.</span></span> <span data-ttu-id="15468-291">接著就會清除報告。</span><span class="sxs-lookup"><span data-stu-id="15468-291">The reports are cleaned up then.</span></span> <span data-ttu-id="15468-292">它可以回報次要服務。</span><span class="sxs-lookup"><span data-stu-id="15468-292">It could report on the secondary service.</span></span> <span data-ttu-id="15468-293">如果次要服務完成工作，則次要執行個體會從存放區清除報告。</span><span class="sxs-lookup"><span data-stu-id="15468-293">If the secondary completes the task, the secondary instance clears the report from the store.</span></span> <span data-ttu-id="15468-294">報告並不會擷取到認可訊息遺失的情況，而從主要服務觀點看來，工作並未完成。</span><span class="sxs-lookup"><span data-stu-id="15468-294">The report doesn't capture the situation where the acknowledgement message is lost and the task is not finished from the master's point of view.</span></span>

<span data-ttu-id="15468-295">不過，在上述情況報告已完成，則評估過健康狀態後，會擷取應用程式健康狀態的報告。</span><span class="sxs-lookup"><span data-stu-id="15468-295">However the reporting is done in the cases described above, the reports are captured in application health when health is evaluated.</span></span>

## <a name="report-periodically-vs-on-transition"></a><span data-ttu-id="15468-296">定期報告與轉換時報告</span><span class="sxs-lookup"><span data-stu-id="15468-296">Report periodically vs. on transition</span></span>
<span data-ttu-id="15468-297">使用健康狀態報告模型，監視程式可以定期或於轉換時傳送報告。</span><span class="sxs-lookup"><span data-stu-id="15468-297">By using the health reporting model, watchdogs can send reports periodically or on transitions.</span></span> <span data-ttu-id="15468-298">使用看門狗報告的建議方式是定期報告，因為程式碼較為簡單且比較不容易發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="15468-298">The recommended way for watchdog reporting is periodically, because the code is much simpler and less prone to errors.</span></span> <span data-ttu-id="15468-299">監視程式必須盡可能越簡單越好，以避免觸發誤報的錯誤。</span><span class="sxs-lookup"><span data-stu-id="15468-299">The watchdogs must strive to be as simple as possible to avoid bugs that trigger incorrect reports.</span></span> <span data-ttu-id="15468-300">不正確的狀況不良  報告將會影響健康狀態評估以及需依據健康狀態的情況，包括升級。</span><span class="sxs-lookup"><span data-stu-id="15468-300">Incorrect *unhealthy* reports impact health evaluations and scenarios based on health, including upgrades.</span></span> <span data-ttu-id="15468-301">不正確的狀況良好  報告會隱藏叢集中的問題，我們不希望發生此情況。</span><span class="sxs-lookup"><span data-stu-id="15468-301">Incorrect *healthy* reports hide issues in the cluster, which is not desired.</span></span>

<span data-ttu-id="15468-302">針對定期報告，您可以用計時器實作監視程式。</span><span class="sxs-lookup"><span data-stu-id="15468-302">For periodic reporting, the watchdog can be implemented with a timer.</span></span> <span data-ttu-id="15468-303">計時器回呼時，監視程式可以檢查狀態並依照目前情況傳送報告。</span><span class="sxs-lookup"><span data-stu-id="15468-303">On a timer callback, the watchdog can check the state and send a report based on the current state.</span></span> <span data-ttu-id="15468-304">不需要查看先前已傳送的報告或在傳訊方面進行任何最佳化。</span><span class="sxs-lookup"><span data-stu-id="15468-304">There is no need to see which report was sent previously or make any optimizations in terms of messaging.</span></span> <span data-ttu-id="15468-305">健康狀態用戶端具有批次邏輯，有助於提高效能。</span><span class="sxs-lookup"><span data-stu-id="15468-305">The health client has batching logic to help with performance.</span></span> <span data-ttu-id="15468-306">只要健康狀態用戶端持續作用，就會在內部重試，直到報告被健康狀態資料存放區認可，或是監視程式產生具有相同實體、屬性與來源的較新報告時。</span><span class="sxs-lookup"><span data-stu-id="15468-306">While the health client is kept alive, it retries internally until the report is acknowledged by the health store or the watchdog generates a newer report with the same entity, property, and source.</span></span>

<span data-ttu-id="15468-307">轉換時的回報需要注意狀態處理。</span><span class="sxs-lookup"><span data-stu-id="15468-307">Reporting on transitions requires careful handling of state.</span></span> <span data-ttu-id="15468-308">監視程式會監視某些條件，只會在條件改變時才回報。</span><span class="sxs-lookup"><span data-stu-id="15468-308">The watchdog monitors some conditions and reports only when the conditions change.</span></span> <span data-ttu-id="15468-309">此方法的優點是需要較少的報告。</span><span class="sxs-lookup"><span data-stu-id="15468-309">The upside of this approach is that fewer reports are needed.</span></span> <span data-ttu-id="15468-310">缺點是監視程式的邏輯很複雜。</span><span class="sxs-lookup"><span data-stu-id="15468-310">The downside is that the logic of the watchdog is complex.</span></span> <span data-ttu-id="15468-311">看門狗必須維護條件或報告，如此才可進行檢查以判斷狀態變更。</span><span class="sxs-lookup"><span data-stu-id="15468-311">The watchdog must maintain the conditions or the reports, so that they can be inspected to determine state changes.</span></span> <span data-ttu-id="15468-312">在容錯移轉時，必須小心新增報告，但尚未傳送到健康情況存放區。</span><span class="sxs-lookup"><span data-stu-id="15468-312">On failover, care must be taken with reports added, but not yet sent to the health store.</span></span> <span data-ttu-id="15468-313">序號必須持續增加。</span><span class="sxs-lookup"><span data-stu-id="15468-313">The sequence number must be ever-increasing.</span></span> <span data-ttu-id="15468-314">若非如此，報告會因為過時而被拒絕。</span><span class="sxs-lookup"><span data-stu-id="15468-314">If not, the reports are rejected as stale.</span></span> <span data-ttu-id="15468-315">在造成資料遺失的少數情況下，可能需要同步處理報告程式的狀態與健康狀態存放區的狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-315">In the rare cases where data loss is incurred, synchronization may be needed between the state of the reporter and the state of the health store.</span></span>

<span data-ttu-id="15468-316">透過 `Partition` 或 `CodePackageActivationContext` 進行轉換報告，對服務自行報告而言較為合理。</span><span class="sxs-lookup"><span data-stu-id="15468-316">Reporting on transitions makes sense for services reporting on themselves, through `Partition` or `CodePackageActivationContext`.</span></span> <span data-ttu-id="15468-317">移除本機物件 (複本或已部署的服務封裝 / 已部署的應用程式) 時，也會移除它的所有報告。</span><span class="sxs-lookup"><span data-stu-id="15468-317">When the local object (replica or deployed service package / deployed application) is removed, all its reports are also removed.</span></span> <span data-ttu-id="15468-318">此自動清除動作會放寬在報告程式和健康狀態資料存放區之間同步處理的需求。</span><span class="sxs-lookup"><span data-stu-id="15468-318">This automatic cleanup relaxes the need for synchronization between reporter and health store.</span></span> <span data-ttu-id="15468-319">如果報告是針對父分割區或父應用程式所製作，在容錯移轉時就必須小心謹慎，以避免在健康狀態資料存放區中產生過時的報告。</span><span class="sxs-lookup"><span data-stu-id="15468-319">If the report is for parent partition or parent application, care must be taken on failover to avoid stale reports in the health store.</span></span> <span data-ttu-id="15468-320">您必須新增邏輯來維護正確的狀態，並從存放區中清除不再需要的報告。</span><span class="sxs-lookup"><span data-stu-id="15468-320">Logic must be added to maintain the correct state and clear the report from store when not needed anymore.</span></span>

## <a name="implement-health-reporting"></a><span data-ttu-id="15468-321">實作健康狀態報告</span><span class="sxs-lookup"><span data-stu-id="15468-321">Implement health reporting</span></span>
<span data-ttu-id="15468-322">一旦清除了實體和報告的詳細資訊，即可透過 API、PowerShell 或 REST 完成傳送健康狀態報告。</span><span class="sxs-lookup"><span data-stu-id="15468-322">Once the entity and report details are clear, sending health reports can be done through the API, PowerShell, or REST.</span></span>

### <a name="api"></a><span data-ttu-id="15468-323">API</span><span class="sxs-lookup"><span data-stu-id="15468-323">API</span></span>
<span data-ttu-id="15468-324">若要透過 API 回報，您必須建立其想要回報的實體類型特有的健康狀態報告。</span><span class="sxs-lookup"><span data-stu-id="15468-324">To report through the API, you need to create a health report specific to the entity type they want to report on.</span></span> <span data-ttu-id="15468-325">將此報告提供給健康狀態用戶端。</span><span class="sxs-lookup"><span data-stu-id="15468-325">Give the report to a health client.</span></span> <span data-ttu-id="15468-326">或者，建立健康狀態資訊，並將它傳遞至 `Partition` 或 `CodePackageActivationContext` 上正確的報告方法，以報告目前實體的健康狀態。</span><span class="sxs-lookup"><span data-stu-id="15468-326">Alternatively, create a health information and pass it to correct reporting methods on `Partition` or `CodePackageActivationContext` to report on current entities.</span></span>

<span data-ttu-id="15468-327">下列範例示範如何從叢集內的監視程式中定期回報。</span><span class="sxs-lookup"><span data-stu-id="15468-327">The following example shows periodic reporting from a watchdog within the cluster.</span></span> <span data-ttu-id="15468-328">監控程式會檢查是否能在節點內存取外部資源。</span><span class="sxs-lookup"><span data-stu-id="15468-328">The watchdog checks whether an external resource can be accessed from within a node.</span></span> <span data-ttu-id="15468-329">應用程式內服務資訊清單的所需資源。</span><span class="sxs-lookup"><span data-stu-id="15468-329">The resource is needed by a service manifest within the application.</span></span> <span data-ttu-id="15468-330">如果無法使用該資源，應用程式內的其他服務仍然可以正常運作。</span><span class="sxs-lookup"><span data-stu-id="15468-330">If the resource is unavailable, the other services within the application can still function properly.</span></span> <span data-ttu-id="15468-331">因此，會每隔 30 秒在已部署的服務封裝實體上傳送報告。</span><span class="sxs-lookup"><span data-stu-id="15468-331">Therefore, the report is sent on the deployed service package entity every 30 seconds.</span></span>

```csharp
private static Uri ApplicationName = new Uri("fabric:/WordCount");
private static string ServiceManifestName = "WordCount.Service";
private static string NodeName = FabricRuntime.GetNodeContext().NodeName;
private static Timer ReportTimer = new Timer(new TimerCallback(SendReport), null, 30 * 1000, 30 * 1000);
private static FabricClient Client = new FabricClient(new FabricClientSettings() { HealthReportSendInterval = TimeSpan.FromSeconds(0) });

public static void SendReport(object obj)
{
    // Test whether the resource can be accessed from the node
    HealthState healthState = this.TestConnectivityToExternalResource();

    // Send report on deployed service package, as the connectivity is needed by the specific service manifest
    // and can be different on different nodes
    var deployedServicePackageHealthReport = new DeployedServicePackageHealthReport(
        ApplicationName,
        ServiceManifestName,
        NodeName,
        new HealthInformation("ExternalSourceWatcher", "Connectivity", healthState));

    // TODO: handle exception. Code omitted for snippet brevity.
    // Possible exceptions: FabricException with error codes
    // FabricHealthStaleReport (non-retryable, the report is already queued on the health client),
    // FabricHealthMaxReportsReached (retryable; user should retry with exponential delay until the report is accepted).
    Client.HealthManager.ReportHealth(deployedServicePackageHealthReport);
}
```

### <a name="powershell"></a><span data-ttu-id="15468-332">PowerShell</span><span class="sxs-lookup"><span data-stu-id="15468-332">PowerShell</span></span>
<span data-ttu-id="15468-333">使用 **Send-ServiceFabric*EntityType*HealthReport** 傳送健康狀態報告。</span><span class="sxs-lookup"><span data-stu-id="15468-333">Send health reports with **Send-ServiceFabric*EntityType*HealthReport**.</span></span>

<span data-ttu-id="15468-334">下列範例會示範節點上 CPU 值的定期報告。</span><span class="sxs-lookup"><span data-stu-id="15468-334">The following example shows periodic reporting on CPU values on a node.</span></span> <span data-ttu-id="15468-335">報告應該每隔 30 秒傳送一次，其存留時間為 2 分鐘。</span><span class="sxs-lookup"><span data-stu-id="15468-335">The reports should be sent every 30 seconds, and they have a time to live of two minutes.</span></span> <span data-ttu-id="15468-336">如果過期，則報告程式有問題，因此會在錯誤時評估節點。</span><span class="sxs-lookup"><span data-stu-id="15468-336">If they expire, the reporter has issues, so the node is evaluated at error.</span></span> <span data-ttu-id="15468-337">當 CPU 高於臨界值時，報告的健康狀態為警告。</span><span class="sxs-lookup"><span data-stu-id="15468-337">When the CPU is above a threshold, the report has a health state of warning.</span></span> <span data-ttu-id="15468-338">當 CPU 保持高於臨界值超過設定的時間時，則會將其回報為錯誤。</span><span class="sxs-lookup"><span data-stu-id="15468-338">When the CPU remains above a threshold for more than the configured time, it's reported as an error.</span></span> <span data-ttu-id="15468-339">否則，報告程式傳送的健康狀態為 [正常]。</span><span class="sxs-lookup"><span data-stu-id="15468-339">Otherwise, the reporter sends a health state of OK.</span></span>

```powershell
PS C:\> Send-ServiceFabricNodeHealthReport -NodeName Node.1 -HealthState Warning -SourceId PowershellWatcher -HealthProperty CPU -Description "CPU is above 80% threshold" -TimeToLiveSec 120

PS C:\> Get-ServiceFabricNodeHealth -NodeName Node.1
NodeName              : Node.1
AggregatedHealthState : Warning
UnhealthyEvaluations  :
                        Unhealthy event: SourceId='PowershellWatcher', Property='CPU', HealthState='Warning', ConsiderWarningAsError=false.

HealthEvents          :
                        SourceId              : System.FM
                        Property              : State
                        HealthState           : Ok
                        SequenceNumber        : 5
                        SentAt                : 4/21/2015 8:01:17 AM
                        ReceivedAt            : 4/21/2015 8:02:12 AM
                        TTL                   : Infinite
                        Description           : Fabric node is up.
                        RemoveWhenExpired     : False
                        IsExpired             : False
                        Transitions           : ->Ok = 4/21/2015 8:02:12 AM

                        SourceId              : PowershellWatcher
                        Property              : CPU
                        HealthState           : Warning
                        SequenceNumber        : 130741236814913394
                        SentAt                : 4/21/2015 9:01:21 PM
                        ReceivedAt            : 4/21/2015 9:01:21 PM
                        TTL                   : 00:02:00
                        Description           : CPU is above 80% threshold
                        RemoveWhenExpired     : False
                        IsExpired             : False
                        Transitions           : ->Warning = 4/21/2015 9:01:21 PM
```

<span data-ttu-id="15468-340">下列範例會回報在複本上的暫時性警告。</span><span class="sxs-lookup"><span data-stu-id="15468-340">The following example reports a transient warning on a replica.</span></span> <span data-ttu-id="15468-341">它會先取得資料分割識別碼，再取得感興趣之服務的複本識別碼。</span><span class="sxs-lookup"><span data-stu-id="15468-341">It first gets the partition ID and then the replica ID for the service it is interested in.</span></span> <span data-ttu-id="15468-342">然後從 **ResourceDependency** 屬性上的 **PowershellWatcher** 傳送報告。</span><span class="sxs-lookup"><span data-stu-id="15468-342">It then sends a report from **PowershellWatcher** on the property **ResourceDependency**.</span></span> <span data-ttu-id="15468-343">此報告只需要存在 2 分鐘，就會從存放區中自動移除。</span><span class="sxs-lookup"><span data-stu-id="15468-343">The report is of interest for only two minutes, and it is removed from the store automatically.</span></span>

```powershell
PS C:\> $partitionId = (Get-ServiceFabricPartition -ServiceName fabric:/WordCount/WordCount.Service).PartitionId

PS C:\> $replicaId = (Get-ServiceFabricReplica -PartitionId $partitionId | where {$_.ReplicaRole -eq "Primary"}).ReplicaId

PS C:\> Send-ServiceFabricReplicaHealthReport -PartitionId $partitionId -ReplicaId $replicaId -HealthState Warning -SourceId PowershellWatcher -HealthProperty ResourceDependency -Description "The external resource that the primary is using has been rebooted at 4/21/2015 9:01:21 PM. Expect processing delays for a few minutes." -TimeToLiveSec 120 -RemoveWhenExpired

PS C:\> Get-ServiceFabricReplicaHealth  -PartitionId $partitionId -ReplicaOrInstanceId $replicaId


PartitionId           : 8f82daff-eb68-4fd9-b631-7a37629e08c0
ReplicaId             : 130740415594605869
AggregatedHealthState : Warning
UnhealthyEvaluations  :
                        Unhealthy event: SourceId='PowershellWatcher', Property='ResourceDependency', HealthState='Warning', ConsiderWarningAsError=false.

HealthEvents          :
                        SourceId              : System.RA
                        Property              : State
                        HealthState           : Ok
                        SequenceNumber        : 130740768777734943
                        SentAt                : 4/21/2015 8:01:17 AM
                        ReceivedAt            : 4/21/2015 8:02:12 AM
                        TTL                   : Infinite
                        Description           : Replica has been created.
                        RemoveWhenExpired     : False
                        IsExpired             : False
                        Transitions           : ->Ok = 4/21/2015 8:02:12 AM

                        SourceId              : PowershellWatcher
                        Property              : ResourceDependency
                        HealthState           : Warning
                        SequenceNumber        : 130741243777723555
                        SentAt                : 4/21/2015 9:12:57 PM
                        ReceivedAt            : 4/21/2015 9:12:57 PM
                        TTL                   : 00:02:00
                        Description           : The external resource that the primary is using has been rebooted at 4/21/2015 9:01:21 PM. Expect processing delays for a few minutes.
                        RemoveWhenExpired     : True
                        IsExpired             : False
                        Transitions           : ->Warning = 4/21/2015 9:12:32 PM
```

### <a name="rest"></a><span data-ttu-id="15468-344">REST</span><span class="sxs-lookup"><span data-stu-id="15468-344">REST</span></span>
<span data-ttu-id="15468-345">透過 REST 並利用 POST 要求傳送健康狀態報告，這些要求會傳送至所需的實體，且其本文中含有健康狀態報告描述。</span><span class="sxs-lookup"><span data-stu-id="15468-345">Send health reports using REST with POST requests that go to the desired entity and have in the body the health report description.</span></span> <span data-ttu-id="15468-346">例如，請參閱如何傳送 REST [叢集健康狀態報告](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-cluster)或[服務健康狀態報告](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-service)。</span><span class="sxs-lookup"><span data-stu-id="15468-346">For example, see how to send REST [cluster health reports](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-cluster) or [service health reports](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-service).</span></span> <span data-ttu-id="15468-347">支援所有實體。</span><span class="sxs-lookup"><span data-stu-id="15468-347">All entities are supported.</span></span>

## <a name="next-steps"></a><span data-ttu-id="15468-348">後續步驟</span><span class="sxs-lookup"><span data-stu-id="15468-348">Next steps</span></span>
<span data-ttu-id="15468-349">根據健康狀態資料，服務寫入器和叢集/應用程式管理員可想出使用該資訊的多種方式。</span><span class="sxs-lookup"><span data-stu-id="15468-349">Based on the health data, service writers and cluster/application administrators can think of ways to consume the information.</span></span> <span data-ttu-id="15468-350">例如，他們可以依據健康狀態為基礎設定警示，以便於嚴重問題誘發中斷前加以攔截。</span><span class="sxs-lookup"><span data-stu-id="15468-350">For example, they can set up alerts based on health status to catch severe issues before they provoke outages.</span></span> <span data-ttu-id="15468-351">系統管理員也可以設定修復系統來自動修復問題。</span><span class="sxs-lookup"><span data-stu-id="15468-351">Administrators can also set up repair systems to fix issues automatically.</span></span>

[<span data-ttu-id="15468-352">Service Fabric 健康狀態監視簡介</span><span class="sxs-lookup"><span data-stu-id="15468-352">Introduction to Service Fabric health Monitoring</span></span>](service-fabric-health-introduction.md)

[<span data-ttu-id="15468-353">檢視 Service Fabric 健康狀態報告</span><span class="sxs-lookup"><span data-stu-id="15468-353">View Service Fabric health reports</span></span>](service-fabric-view-entities-aggregated-health.md)

[<span data-ttu-id="15468-354">如何回報和檢查服務健全狀況</span><span class="sxs-lookup"><span data-stu-id="15468-354">How to report and check service health</span></span>](service-fabric-diagnostics-how-to-report-and-check-service-health.md)

[<span data-ttu-id="15468-355">使用系統健康狀態報告進行疑難排解</span><span class="sxs-lookup"><span data-stu-id="15468-355">Use system health reports for troubleshooting</span></span>](service-fabric-understand-and-troubleshoot-with-system-health-reports.md)

[<span data-ttu-id="15468-356">在本機上監視及診斷服務</span><span class="sxs-lookup"><span data-stu-id="15468-356">Monitor and diagnose services locally</span></span>](service-fabric-diagnostics-how-to-monitor-and-diagnose-services-locally.md)

[<span data-ttu-id="15468-357">Service Fabric 應用程式升級</span><span class="sxs-lookup"><span data-stu-id="15468-357">Service Fabric application upgrade</span></span>](service-fabric-application-upgrade.md)

