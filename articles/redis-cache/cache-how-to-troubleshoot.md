---
title: "aaaHow tootroubleshoot Azure Redis 快取 |Microsoft 文件"
description: "了解如何 tooresolve 常見問題與 Azure Redis 快取。"
services: redis-cache
documentationcenter: 
author: steved0x
manager: douge
editor: 
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: sdanie
ms.openlocfilehash: 4e736fce2b6d5200a2a8d802f3f1384b63458cab
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="how-tootroubleshoot-azure-redis-cache"></a><span data-ttu-id="1c8d4-103">如何 tootroubleshoot Azure Redis 快取</span><span class="sxs-lookup"><span data-stu-id="1c8d4-103">How tootroubleshoot Azure Redis Cache</span></span>
<span data-ttu-id="1c8d4-104">本文章提供 hello 下列類別的 Azure Redis 快取問題的疑難排解指引。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-104">This article provides guidance for troubleshooting hello following categories of Azure Redis Cache issues.</span></span>

* <span data-ttu-id="1c8d4-105">[用戶端端疑難排解](#client-side-troubleshooting)-此章節提供的指導方針識別並解決問題 hello 連接 tooAzure Redis 快取的應用程式所造成。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-105">[Client side troubleshooting](#client-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused by hello application connecting tooAzure Redis Cache.</span></span>
* <span data-ttu-id="1c8d4-106">[伺服器端疑難排解](#server-side-troubleshooting)-此章節提供的指導方針識別並解決問題造成 hello Azure Redis 快取伺服器端。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-106">[Server side troubleshooting](#server-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused on hello Azure Redis Cache server side.</span></span>
* <span data-ttu-id="1c8d4-107">[StackExchange.Redis 逾時例外狀況](#stackexchangeredis-timeout-exceptions)-此章節提供有關疑難排解時使用 hello StackExchange.Redis 用戶端的問題。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-107">[StackExchange.Redis timeout exceptions](#stackexchangeredis-timeout-exceptions) - This section provides information on troubleshooting issues when using hello StackExchange.Redis client.</span></span>

> [!NOTE]
> <span data-ttu-id="1c8d4-108">疑難排解步驟，本指南中的 hello 的數個包含 toorun Redis 命令，並監視各種效能度量的指示。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-108">Several of hello troubleshooting steps in this guide include instructions toorun Redis commands and monitor various performance metrics.</span></span> <span data-ttu-id="1c8d4-109">如需詳細資訊和指示，請參閱 hello 文件以 hello[更多資訊](#additional-information)> 一節。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-109">For more information and instructions, see hello articles in hello [Additional information](#additional-information) section.</span></span>
> 
> 

## <a name="client-side-troubleshooting"></a><span data-ttu-id="1c8d4-110">用戶端疑難排解</span><span class="sxs-lookup"><span data-stu-id="1c8d4-110">Client side troubleshooting</span></span>
<span data-ttu-id="1c8d4-111">本節討論因為 hello 用戶端應用程式上的條件而產生的疑難排解問題。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-111">This section discusses troubleshooting issues that occur because of a condition on hello client application.</span></span>

* [<span data-ttu-id="1c8d4-112">記憶體不足的壓力 hello 用戶端上</span><span class="sxs-lookup"><span data-stu-id="1c8d4-112">Memory pressure on hello client</span></span>](#memory-pressure-on-the-client)
* [<span data-ttu-id="1c8d4-113">流量暴增</span><span class="sxs-lookup"><span data-stu-id="1c8d4-113">Burst of traffic</span></span>](#burst-of-traffic)
* [<span data-ttu-id="1c8d4-114">用戶端 CPU 使用量很高</span><span class="sxs-lookup"><span data-stu-id="1c8d4-114">High client CPU usage</span></span>](#high-client-cpu-usage)
* [<span data-ttu-id="1c8d4-115">超過用戶端頻寬</span><span class="sxs-lookup"><span data-stu-id="1c8d4-115">Client Side Bandwidth Exceeded</span></span>](#client-side-bandwidth-exceeded)
* [<span data-ttu-id="1c8d4-116">要求/回應大小很大</span><span class="sxs-lookup"><span data-stu-id="1c8d4-116">Large Request/Response Size</span></span>](#large-requestresponse-size)
* [<span data-ttu-id="1c8d4-117">Redis 在何種情形的 toomy 資料？</span><span class="sxs-lookup"><span data-stu-id="1c8d4-117">What happened toomy data in Redis?</span></span>](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-hello-client"></a><span data-ttu-id="1c8d4-118">記憶體不足的壓力 hello 用戶端上</span><span class="sxs-lookup"><span data-stu-id="1c8d4-118">Memory pressure on hello client</span></span>
#### <a name="problem"></a><span data-ttu-id="1c8d4-119">問題</span><span class="sxs-lookup"><span data-stu-id="1c8d4-119">Problem</span></span>
<span data-ttu-id="1c8d4-120">Hello 用戶端電腦上的記憶體壓力會導致 tooall 類效能問題可能會延遲處理已送出 hello Redis 執行個體沒有任何延遲的資料。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-120">Memory pressure on hello client machine leads tooall kinds of performance problems that can delay processing of data that was sent by hello Redis instance without any delay.</span></span> <span data-ttu-id="1c8d4-121">當叫用的記憶體不足的壓力時，hello 系統通常會有 toopage 資料從實體記憶體 toovirtual 記憶體，也就是在磁碟上。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-121">When memory pressure hits, hello system typically has toopage data from physical memory toovirtual memory which is on disk.</span></span> <span data-ttu-id="1c8d4-122">這*頁面判定為失敗*原因 hello 系統 tooslow 向明顯。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-122">This *page faulting* causes hello system tooslow down significantly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="1c8d4-123">測量</span><span class="sxs-lookup"><span data-stu-id="1c8d4-123">Measurement</span></span>
1. <span data-ttu-id="1c8d4-124">監視電腦 toomake 確定它不會超過可用的記憶體上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-124">Monitor memory usage on machine toomake sure that it does not exceed available memory.</span></span> 
2. <span data-ttu-id="1c8d4-125">監視 hello`Page Faults/Sec`效能計數器。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-125">Monitor hello `Page Faults/Sec` performance counter.</span></span> <span data-ttu-id="1c8d4-126">即使在正常作業期間，大部分的系統還是會有一些分頁錯誤，因此請留意這個與逾時對應的分頁錯誤效能計數器尖峰。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-126">Most systems will have some page faults even during normal operation, so watch for spikes in this page faults performance counter which correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="1c8d4-127">解決方案</span><span class="sxs-lookup"><span data-stu-id="1c8d4-127">Resolution</span></span>
<span data-ttu-id="1c8d4-128">升級用戶端 tooa 較大用戶端更多記憶體的 VM 大小，或深入了解您的記憶體使用量模式 tooreduce 記憶體 consuption。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-128">Upgrade your client tooa larger client VM size with more memory or dig into your memory usage patterns tooreduce memory consuption.</span></span>

### <a name="burst-of-traffic"></a><span data-ttu-id="1c8d4-129">流量暴增</span><span class="sxs-lookup"><span data-stu-id="1c8d4-129">Burst of traffic</span></span>
#### <a name="problem"></a><span data-ttu-id="1c8d4-130">問題</span><span class="sxs-lookup"><span data-stu-id="1c8d4-130">Problem</span></span>
<span data-ttu-id="1c8d4-131">暴增的流量結合不良`ThreadPool`設定可能會導致延遲處理已由 hello Redis 伺服器傳送，但尚未使用 hello 用戶端上的資料。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-131">Bursts of traffic combined with poor `ThreadPool` settings can result in delays in processing data already sent by hello Redis Server but not yet consumed on hello client side.</span></span>

#### <a name="measurement"></a><span data-ttu-id="1c8d4-132">測量</span><span class="sxs-lookup"><span data-stu-id="1c8d4-132">Measurement</span></span>
<span data-ttu-id="1c8d4-133">使用[如這裡所提供的](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs)程式碼，監視 `ThreadPool` 統計資料如何隨著時間變更。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-133">Monitor how your `ThreadPool` statistics change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs).</span></span> <span data-ttu-id="1c8d4-134">您也可以查看 hello `TimeoutException` StackExchange.Redis 中的訊息。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-134">You can also look at hello `TimeoutException` message from StackExchange.Redis.</span></span> <span data-ttu-id="1c8d4-135">範例如下：</span><span class="sxs-lookup"><span data-stu-id="1c8d4-135">Here is an example :</span></span>

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

<span data-ttu-id="1c8d4-136">在上面訊息 hello，有幾個有趣的問題：</span><span class="sxs-lookup"><span data-stu-id="1c8d4-136">In hello above message, there are several issues that are interesting:</span></span>

1. <span data-ttu-id="1c8d4-137">請注意，在 hello`IOCP`區段和 hello `WORKER` > 一節，您有`Busy`值大於 hello`Min`值。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-137">Notice that in hello `IOCP` section and hello `WORKER` section you have a `Busy` value that is greater than hello `Min` value.</span></span> <span data-ttu-id="1c8d4-138">這表示 `ThreadPool` 設定需要調整。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-138">This means that your `ThreadPool` settings need adjusting.</span></span>
2. <span data-ttu-id="1c8d4-139">您也可以查看 `in: 64221`。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-139">You can also see `in: 64221`.</span></span> <span data-ttu-id="1c8d4-140">這表示已在 hello 核心通訊端層接收 64211 位元組，但您尚未尚未讀取 hello 應用程式 (例如 StackExchange.Redis)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-140">This indicates that 64211 bytes have been received at hello kernel socket layer but haven't yet been read by hello application (e.g. StackExchange.Redis).</span></span> <span data-ttu-id="1c8d4-141">這通常表示，您的應用程式不從 hello 網路的速度一樣快 hello 伺服器傳送它 tooyou 讀取資料。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-141">This typically means that your application isn't reading data from hello network as quickly as hello server is sending it tooyou.</span></span>

#### <a name="resolution"></a><span data-ttu-id="1c8d4-142">解決方案</span><span class="sxs-lookup"><span data-stu-id="1c8d4-142">Resolution</span></span>
<span data-ttu-id="1c8d4-143">設定您[執行緒集區設定](https://gist.github.com/JonCole/e65411214030f0d823cb)toomake 確定您在執行緒集區將會快速地在向上發送案例。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-143">Configure your [ThreadPool Settings](https://gist.github.com/JonCole/e65411214030f0d823cb) toomake sure that your thread pool will scale up quickly under burst scenarios.</span></span>

### <a name="high-client-cpu-usage"></a><span data-ttu-id="1c8d4-144">用戶端 CPU 使用量很高</span><span class="sxs-lookup"><span data-stu-id="1c8d4-144">High client CPU usage</span></span>
#### <a name="problem"></a><span data-ttu-id="1c8d4-145">問題</span><span class="sxs-lookup"><span data-stu-id="1c8d4-145">Problem</span></span>
<span data-ttu-id="1c8d4-146">Hello 用戶端上的高 CPU 使用量是 hello 系統趕不上它已被要求 tooperform hello 工作指示。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-146">High CPU usage on hello client is an indication that hello system cannot keep up with hello work that it has been asked tooperform.</span></span> <span data-ttu-id="1c8d4-147">這表示即使 Redis 非常快速地傳送 hello 回應 hello 用戶端可能會失敗 tooprocess Redis 能夠及時的回應。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-147">This means that hello client may fail tooprocess a response from Redis in a timely fashion even though Redis sent hello response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="1c8d4-148">測量</span><span class="sxs-lookup"><span data-stu-id="1c8d4-148">Measurement</span></span>
<span data-ttu-id="1c8d4-149">監視 hello 透過 hello Azure 入口網站或透過 hello 系統寬 CPU 使用量相關效能計數器。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-149">Monitor hello System Wide CPU usage through hello Azure Portal or through hello associated performance counter.</span></span> <span data-ttu-id="1c8d4-150">請小心不 toomonitor*程序*CPU 因為單一處理序可以有低 CPU 使用率在 hello 相同時間整體系統 CPU 可能會很高。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-150">Be careful not toomonitor *process* CPU because a single process can have low CPU usage at hello same time that overall system CPU can be high.</span></span> <span data-ttu-id="1c8d4-151">請監看與逾時對應的 CPU 使用量暴增。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-151">Watch for spikes in CPU usage that correspond with timeouts.</span></span> <span data-ttu-id="1c8d4-152">由於高 CPU，您可能也會看到高`in: XXX`值`TimeoutException`hello 中所述的錯誤訊息[批突發之流量](#burst-of-traffic)> 一節。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-152">As a result of high CPU, you may also see high `in: XXX` values in `TimeoutException` error messages as described in hello [Burst of traffic](#burst-of-traffic) section.</span></span>

> [!NOTE]
> <span data-ttu-id="1c8d4-153">StackExchange.Redis 1.1.603 和更新版本包含 hello`local-cpu`度量中`TimeoutException`錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-153">StackExchange.Redis 1.1.603 and later includes hello `local-cpu` metric in `TimeoutException` error messages.</span></span> <span data-ttu-id="1c8d4-154">請確定您使用 hello 最新版 hello [StackExchange.Redis NuGet 封裝](https://www.nuget.org/packages/StackExchange.Redis/)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-154">Ensure you using hello latest version of hello [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="1c8d4-155">錯誤經常被中修正 hello 程式碼 toomake 它更穩固 tootimeouts hello 最新版本相當重要，因此。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-155">There are bugs constantly being fixed in hello code toomake it more robust tootimeouts so having hello latest version is important.</span></span>
> 
> 

#### <a name="resolution"></a><span data-ttu-id="1c8d4-156">解決方案</span><span class="sxs-lookup"><span data-stu-id="1c8d4-156">Resolution</span></span>
<span data-ttu-id="1c8d4-157">升級具有更多的 CPU 容量 tooa 較大 VM 大小，或調查導致 CPU 尖峰。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-157">Upgrade tooa larger VM size with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="client-side-bandwidth-exceeded"></a><span data-ttu-id="1c8d4-158">超過用戶端頻寬</span><span class="sxs-lookup"><span data-stu-id="1c8d4-158">Client side bandwidth exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="1c8d4-159">問題</span><span class="sxs-lookup"><span data-stu-id="1c8d4-159">Problem</span></span>
<span data-ttu-id="1c8d4-160">不同大小的用戶端電腦對於其可用的網路頻寬多寡會有限制。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-160">Different sized client machines have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="1c8d4-161">如果超過 hello 用戶端 hello 可用頻寬，則資料將不會處理 hello 用戶端盡 hello 伺服器傳送它。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-161">If hello client exceeds hello available bandwidth, then data will not be processed on hello client side as quickly as hello server is sending it.</span></span> <span data-ttu-id="1c8d4-162">這可能會導致 tootimeouts。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-162">This can lead tootimeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="1c8d4-163">測量</span><span class="sxs-lookup"><span data-stu-id="1c8d4-163">Measurement</span></span>
<span data-ttu-id="1c8d4-164">使用 [如這裡所提供的](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs)程式碼，監視頻寬使用量如何隨著時間變更。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-164">Monitor how your Bandwidth usage change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs).</span></span> <span data-ttu-id="1c8d4-165">請注意，此程式碼可能無法在具有限制權限的某些環境 (例如 Azure 網站) 中順利執行。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-165">Note that this code may not run successfully in some environments with restricted permissions (like Azure web sites).</span></span>

#### <a name="resolution"></a><span data-ttu-id="1c8d4-166">解決方案</span><span class="sxs-lookup"><span data-stu-id="1c8d4-166">Resolution</span></span>
<span data-ttu-id="1c8d4-167">增加用戶端 VM 大小或減少網路頻寬耗用。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-167">Increase Client VM size or reduce network bandwidth consumption.</span></span>

### <a name="large-requestresponse-size"></a><span data-ttu-id="1c8d4-168">要求/回應大小很大</span><span class="sxs-lookup"><span data-stu-id="1c8d4-168">Large Request/Response Size</span></span>
#### <a name="problem"></a><span data-ttu-id="1c8d4-169">問題</span><span class="sxs-lookup"><span data-stu-id="1c8d4-169">Problem</span></span>
<span data-ttu-id="1c8d4-170">大型的要求/回應可能會導致逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-170">A large request/response can cause timeouts.</span></span> <span data-ttu-id="1c8d4-171">例如，假設您在用戶端上設定的逾時值為 1 秒。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-171">As an example, Suppose your timeout value configured on your client is 1 second.</span></span> <span data-ttu-id="1c8d4-172">應用程式同時 (使用相同的實體網路連線) 要求'A' 和 'B'） 在 hello 相同的時間 (使用 hello 相同的實體網路連線)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-172">Your application requests two keys (e.g. 'A' and 'B') at hello same time (using hello same physical network connection).</span></span> <span data-ttu-id="1c8d4-173">大部分的用戶端支援 「 Pipelining"的要求，例如，'A' 和 'B' 這兩個要求傳送一個 hello 網路 toohello 伺服器上之後 hello 其他不需等到 hello 回應。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-173">Most clients support "Pipelining" of requests, such that both requests 'A' and 'B' are sent on hello wire toohello server one after hello other without waiting for hello responses.</span></span> <span data-ttu-id="1c8d4-174">hello 伺服器會傳送 hello 回應 hello 中相同的順序。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-174">hello server will send hello responses back in hello same order.</span></span> <span data-ttu-id="1c8d4-175">如果回應 'A' 大夠它可以吃掉大部分的 hello 逾時的後續要求。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-175">If response 'A' is large enough it can eat up most of hello timeout for subsequent requests.</span></span> 

<span data-ttu-id="1c8d4-176">hello 下列範例示範此案例。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-176">hello following example demonstrates this scenario.</span></span> <span data-ttu-id="1c8d4-177">在此案例中，'A' 和 'B' 傳送快速，hello 伺服器啟動快速，傳送回應，'A' 和 'B'，但是因為資料傳輸的時間，'B' 堵塞背後的要求 hello 其他要求，並發生逾時即使 hello 伺服器快速回應。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-177">In this scenario, Request 'A' and 'B' are sent quickly, hello server starts sending responses 'A' and 'B' quickly, but because of data transfer times, 'B' get stuck behind hello other request and times out even though hello server responded quickly.</span></span>

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a><span data-ttu-id="1c8d4-178">測量</span><span class="sxs-lookup"><span data-stu-id="1c8d4-178">Measurement</span></span>
<span data-ttu-id="1c8d4-179">這是很困難的一個 toomeasure。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-179">This is a difficult one toomeasure.</span></span> <span data-ttu-id="1c8d4-180">您的用戶端程式碼 tootrack 大型要求和回應時，基本上有 tooinstrument。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-180">You basically have tooinstrument your client code tootrack large requests and responses.</span></span> 

#### <a name="resolution"></a><span data-ttu-id="1c8d4-181">解決方案</span><span class="sxs-lookup"><span data-stu-id="1c8d4-181">Resolution</span></span>
1. <span data-ttu-id="1c8d4-182">Redis 最適合大量的較小值，而不是少數幾個較大值。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-182">Redis is optimized for a large number of small values, rather than a few large values.</span></span> <span data-ttu-id="1c8d4-183">hello 慣用的解決方案是 toobreak 註冊您的資料相關的較小值。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-183">hello preferred solution is toobreak up your data into related smaller values.</span></span> <span data-ttu-id="1c8d4-184">請參閱 hello [hello redis 的理想值大小範圍是什麼？100 KB 是否會太大？](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ)文章，以取得為何建議使用較小值的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-184">See hello [What is hello ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details around why smaller values are recommended.</span></span>
2. <span data-ttu-id="1c8d4-185">Hello 大小增加您的 VM （適用於用戶端和 Redis 快取伺服器），tooget 高頻寬的功能，減少資料傳輸的較大的回應時間。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-185">Increase hello size of your VM (for client and Redis Cache Server), tooget higher bandwidth capabilities, reducing data transfer times for larger responses.</span></span> <span data-ttu-id="1c8d4-186">請注意，只需要 hello 伺服器上，取得更多的頻寬，或只在 hello 用戶端可能不夠。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-186">Note that getting more bandwidth on just hello server or just on hello client may not be enough.</span></span> <span data-ttu-id="1c8d4-187">測量您的頻寬使用量，並比較您目前擁有的 VM 大小與 hello toohello 功能。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-187">Measure your bandwidth usage and compare it toohello capabilities of hello size of VM you currently have.</span></span>
3. <span data-ttu-id="1c8d4-188">Hello 數目增加`ConnectionMultiplexer`透過不同的連接使用和循環配置資源的要求物件。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-188">Increase hello number of `ConnectionMultiplexer` objects you use and round-robin requests over different connections.</span></span>

### <a name="what-happened-toomy-data-in-redis"></a><span data-ttu-id="1c8d4-189">Redis 在何種情形的 toomy 資料？</span><span class="sxs-lookup"><span data-stu-id="1c8d4-189">What happened toomy data in Redis?</span></span>
#### <a name="problem"></a><span data-ttu-id="1c8d4-190">問題</span><span class="sxs-lookup"><span data-stu-id="1c8d4-190">Problem</span></span>
<span data-ttu-id="1c8d4-191">我應該針對特定資料 toobe 我的 Azure Redis 快取執行個體中但似乎未那里的 toobe。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-191">I expected for certain data toobe in my Azure Redis Cache instance but it didn't seem toobe there.</span></span>

#### <a name="resolution"></a><span data-ttu-id="1c8d4-192">解決方案</span><span class="sxs-lookup"><span data-stu-id="1c8d4-192">Resolution</span></span>
<span data-ttu-id="1c8d4-193">請參閱[Redis 在何種情形的 toomy 資料？](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md)的可能原因和解決方式。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-193">See [What happened toomy data in Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) for possible causes and resolutions.</span></span>

## <a name="server-side-troubleshooting"></a><span data-ttu-id="1c8d4-194">伺服器端疑難排解</span><span class="sxs-lookup"><span data-stu-id="1c8d4-194">Server side troubleshooting</span></span>
<span data-ttu-id="1c8d4-195">本節討論因為 hello 快取伺服器上的條件而產生的疑難排解問題。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-195">This section discusses troubleshooting issues that occur because of a condition on hello cache server.</span></span>

* [<span data-ttu-id="1c8d4-196">記憶體不足的壓力 hello 伺服器上</span><span class="sxs-lookup"><span data-stu-id="1c8d4-196">Memory Pressure on hello server</span></span>](#memory-pressure-on-the-server)
* [<span data-ttu-id="1c8d4-197">高 CPU 使用率/伺服器負載</span><span class="sxs-lookup"><span data-stu-id="1c8d4-197">High CPU usage / Server Load</span></span>](#high-cpu-usage-server-load)
* [<span data-ttu-id="1c8d4-198">超過伺服器端頻寬</span><span class="sxs-lookup"><span data-stu-id="1c8d4-198">Server Side Bandwidth Exceeded</span></span>](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-hello-server"></a><span data-ttu-id="1c8d4-199">記憶體不足的壓力 hello 伺服器上</span><span class="sxs-lookup"><span data-stu-id="1c8d4-199">Memory Pressure on hello server</span></span>
#### <a name="problem"></a><span data-ttu-id="1c8d4-200">問題</span><span class="sxs-lookup"><span data-stu-id="1c8d4-200">Problem</span></span>
<span data-ttu-id="1c8d4-201">Hello 伺服器端上的記憶體壓力會導致效能問題可能會延遲處理要求的 tooall 種類。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-201">Memory pressure on hello server side leads tooall kinds of performance problems that can delay processing of requests.</span></span> <span data-ttu-id="1c8d4-202">當叫用的記憶體不足的壓力時，hello 系統通常會有 toopage 資料從實體記憶體 toovirtual 記憶體，也就是在磁碟上。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-202">When memory pressure hits, hello system typically has toopage data from physical memory toovirtual memory which is on disk.</span></span> <span data-ttu-id="1c8d4-203">這*頁面判定為失敗*原因 hello 系統 tooslow 向明顯。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-203">This *page faulting* causes hello system tooslow down significantly.</span></span> <span data-ttu-id="1c8d4-204">此記憶體壓力有幾個可能的原因︰</span><span class="sxs-lookup"><span data-stu-id="1c8d4-204">There are several possible causes of this memory pressure:</span></span> 

1. <span data-ttu-id="1c8d4-205">您已填入 hello 快取 toofull 容量資料。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-205">You have filled hello cache toofull capacity with data.</span></span> 
2. <span data-ttu-id="1c8d4-206">Redis 查看高記憶體分散-最常造成儲存大型物件 (Redis 最適合用於小型物件，請參閱 hello [hello redis 的理想值大小範圍是什麼？100 KB 是否會太大？](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ)文章)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-206">Redis is seeing high memory fragmentation - most often caused by storing large objects (Redis is optimized for a small objects - See hello [What is hello ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details).</span></span> 

#### <a name="measurement"></a><span data-ttu-id="1c8d4-207">測量</span><span class="sxs-lookup"><span data-stu-id="1c8d4-207">Measurement</span></span>
<span data-ttu-id="1c8d4-208">Redis 會公開兩個可協助您識別此問題的度量。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-208">Redis exposes two metrics that can help you identify this issue.</span></span> <span data-ttu-id="1c8d4-209">第一個是 hello `used_memory` hello 其他且`used_memory_rss`。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-209">hello first is `used_memory` and hello other is `used_memory_rss`.</span></span> <span data-ttu-id="1c8d4-210">[這些度量](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)可用在 hello Azure 入口網站或透過 hello [Redis 資訊](http://redis.io/commands/info)命令。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-210">[These metrics](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) are available in hello Azure Portal or through hello [Redis INFO](http://redis.io/commands/info) command.</span></span>

#### <a name="resolution"></a><span data-ttu-id="1c8d4-211">解決方案</span><span class="sxs-lookup"><span data-stu-id="1c8d4-211">Resolution</span></span>
<span data-ttu-id="1c8d4-212">有數個可能發生的變更，您可以進行 toohelp 保留記憶體使用量狀況良好：</span><span class="sxs-lookup"><span data-stu-id="1c8d4-212">There are several possible changes that you can make toohelp keep memory usage healthy:</span></span>

1. <span data-ttu-id="1c8d4-213">[設定記憶體原則](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) 並在金鑰上設定到期時間。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-213">[Configure a memory policy](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) and set expiration times on your keys.</span></span> <span data-ttu-id="1c8d4-214">請注意，如果記憶體分散，這麼做可能還不夠。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-214">Note that this may not be sufficient if you have fragmentation.</span></span>
2. <span data-ttu-id="1c8d4-215">[設定 maxmemory 保留值](cache-configure.md#maxmemory-policy-and-maxmemory-reserved)也就是夠大 toocompensate 的記憶體分散程度。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-215">[Configure a maxmemory-reserved value](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) that is large enough toocompensate for memory fragmentation.</span></span>
3. <span data-ttu-id="1c8d4-216">將大型快取物件分割為較小的相關物件。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-216">Break up your large cached objects into smaller related objects.</span></span>
4. <span data-ttu-id="1c8d4-217">[標尺](cache-how-to-scale.md)tooa 較大的快取大小。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-217">[Scale](cache-how-to-scale.md) tooa larger cache size.</span></span>
5. <span data-ttu-id="1c8d4-218">如果您使用[進階版快取與啟用的 Redis 叢集](cache-how-to-premium-clustering.md)可以[hello 分區數目增加](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-218">If you are using a [premium cache with Redis cluster enabled](cache-how-to-premium-clustering.md) you can [increase hello number of shards](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).</span></span>

### <a name="high-cpu-usage--server-load"></a><span data-ttu-id="1c8d4-219">高 CPU 使用率/伺服器負載</span><span class="sxs-lookup"><span data-stu-id="1c8d4-219">High CPU usage / Server Load</span></span>
#### <a name="problem"></a><span data-ttu-id="1c8d4-220">問題</span><span class="sxs-lookup"><span data-stu-id="1c8d4-220">Problem</span></span>
<span data-ttu-id="1c8d4-221">高 CPU 使用率可能代表即使 Redis 非常快速地傳送 hello 回應 hello 用戶端可以失敗 tooprocess Redis 能夠及時的回應。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-221">High CPU usage can mean that hello client side can fail tooprocess a response from Redis in a timely fashion even though Redis sent hello response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="1c8d4-222">測量</span><span class="sxs-lookup"><span data-stu-id="1c8d4-222">Measurement</span></span>
<span data-ttu-id="1c8d4-223">監視 hello 透過 hello Azure 入口網站或透過 hello 系統寬 CPU 使用量相關效能計數器。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-223">Monitor hello System Wide CPU usage through hello Azure Portal or through hello associated performance counter.</span></span> <span data-ttu-id="1c8d4-224">請小心不 toomonitor*程序*CPU 因為單一處理序可以有低 CPU 使用率在 hello 相同時間整體系統 CPU 可能會很高。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-224">Be careful not toomonitor *process* CPU because a single process can have low CPU usage at hello same time that overall system CPU can be high.</span></span> <span data-ttu-id="1c8d4-225">請監看與逾時對應的 CPU 使用量暴增。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-225">Watch for spikes in CPU usage that correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="1c8d4-226">解決方案</span><span class="sxs-lookup"><span data-stu-id="1c8d4-226">Resolution</span></span>
<span data-ttu-id="1c8d4-227">[標尺](cache-how-to-scale.md)tooa 大的快取層與更多的 CPU 容量，或調查導致 CPU 尖峰。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-227">[Scale](cache-how-to-scale.md) tooa larger cache tier with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="server-side-bandwidth-exceeded"></a><span data-ttu-id="1c8d4-228">超過伺服器端頻寬</span><span class="sxs-lookup"><span data-stu-id="1c8d4-228">Server Side Bandwidth Exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="1c8d4-229">問題</span><span class="sxs-lookup"><span data-stu-id="1c8d4-229">Problem</span></span>
<span data-ttu-id="1c8d4-230">不同大小的快取執行個體對於其可用的網路頻寬多寡會有限制。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-230">Different sized cache instances have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="1c8d4-231">如果伺服器 hello 超過 hello 可用頻寬，然後資料會傳送 toohello 用戶端快速。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-231">If hello server exceeds hello available bandwidth, then data will not be sent toohello client as quickly.</span></span> <span data-ttu-id="1c8d4-232">這可能會導致 tootimeouts。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-232">This can lead tootimeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="1c8d4-233">測量</span><span class="sxs-lookup"><span data-stu-id="1c8d4-233">Measurement</span></span>
<span data-ttu-id="1c8d4-234">您可以監視 hello`Cache Read`度量 hello hello 指定報告的時間間隔期間，從以 mb 為單位每秒 (MB/s) 的 hello 快取讀取的資料量。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-234">You can monitor hello `Cache Read` metric, which is hello amount of data read from hello cache in Megabytes per second (MB/s) during hello specified reporting interval.</span></span> <span data-ttu-id="1c8d4-235">此值與這個快取所使用的 toohello 網路頻寬。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-235">This value corresponds toohello network bandwidth used by this cache.</span></span> <span data-ttu-id="1c8d4-236">如果您想要的警示 tooset 伺服器端網路頻寬限制，您可以建立使用這個它們`Cache Read`計數器。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-236">If you want tooset up alerts for server side network bandwidth limits, you can create them using this `Cache Read` counter.</span></span> <span data-ttu-id="1c8d4-237">比較中的 hello 值與您讀數[本表](cache-faq.md#cache-performance)hello 觀察到的定價層和大小的各種快取的頻寬限制。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-237">Compare your readings with hello values in [this table](cache-faq.md#cache-performance) for hello observed bandwidth limits for various cache pricing tiers and sizes.</span></span>

#### <a name="resolution"></a><span data-ttu-id="1c8d4-238">解決方案</span><span class="sxs-lookup"><span data-stu-id="1c8d4-238">Resolution</span></span>
<span data-ttu-id="1c8d4-239">如果您持續觀察到的定價層和快取大小的最大頻寬的 hello 附近，請考慮[調整](cache-how-to-scale.md)tooa 定價層或有更大的網路頻寬的大小、 使用中的 hello 值[本表](cache-faq.md#cache-performance)作為指南。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-239">If you are consistently near hello observed maximum bandwidth for your pricing tier and cache size, consider [scaling](cache-how-to-scale.md) tooa pricing tier or size that has greater network bandwidth, using hello values in [this table](cache-faq.md#cache-performance) as a guide.</span></span>

## <a name="stackexchangeredis-timeout-exceptions"></a><span data-ttu-id="1c8d4-240">StackExchange.Redis 逾時例外狀況</span><span class="sxs-lookup"><span data-stu-id="1c8d4-240">StackExchange.Redis timeout exceptions</span></span>
<span data-ttu-id="1c8d4-241">StackExchange.Redis 使用名為 `synctimeout` 的組態設定來進行預設值為 1000 毫秒的同步作業。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-241">StackExchange.Redis uses a configuration setting named `synctimeout` for synchronous operations which has a default value  of 1000 ms.</span></span> <span data-ttu-id="1c8d4-242">如果在未完成的同步呼叫 hello 約定 hello StackExchange.Redis 用戶端會擲回的時間，下列範例逾時的錯誤類似 toohello。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-242">If a synchronous call doesn’t complete in hello stipulated time, hello StackExchange.Redis client throws a timeout error similar toohello following example.</span></span>

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


<span data-ttu-id="1c8d4-243">這則錯誤訊息包含可協助您點 toohello hello 問題的原因和可能的解析的度量。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-243">This error message contains metrics that can help point you toohello cause and possible resolution of hello issue.</span></span> <span data-ttu-id="1c8d4-244">hello 下表包含有關 hello 錯誤訊息計量的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-244">hello following table contains details about hello error message metrics.</span></span>

| <span data-ttu-id="1c8d4-245">錯誤訊息度量</span><span class="sxs-lookup"><span data-stu-id="1c8d4-245">Error message metric</span></span> | <span data-ttu-id="1c8d4-246">詳細資料</span><span class="sxs-lookup"><span data-stu-id="1c8d4-246">Details</span></span> |
| --- | --- |
| <span data-ttu-id="1c8d4-247">inst</span><span class="sxs-lookup"><span data-stu-id="1c8d4-247">inst</span></span> |<span data-ttu-id="1c8d4-248">在最後一個時間配量 hello: 0 命令已發行</span><span class="sxs-lookup"><span data-stu-id="1c8d4-248">In hello last time slice: 0 commands have been issued</span></span> |
| <span data-ttu-id="1c8d4-249">mgr</span><span class="sxs-lookup"><span data-stu-id="1c8d4-249">mgr</span></span> |<span data-ttu-id="1c8d4-250">hello 通訊端管理員正在執行`socket.select`這表示它正在詢問 hello OS tooindicate 具有內容的通訊端 toodo; 基本上： hello 讀取器不是正在主動讀取從 hello 網路因為它不會認為有任何項目 toodo</span><span class="sxs-lookup"><span data-stu-id="1c8d4-250">hello socket manager is performing `socket.select` which means it is asking hello OS tooindicate a socket that has something toodo; basically: hello reader is not actively reading from hello network because it doesn't think there is anything toodo</span></span> |
| <span data-ttu-id="1c8d4-251">佇列</span><span class="sxs-lookup"><span data-stu-id="1c8d4-251">queue</span></span> |<span data-ttu-id="1c8d4-252">總共有 73 個進行中的作業</span><span class="sxs-lookup"><span data-stu-id="1c8d4-252">There are 73 total in-progress operations</span></span> |
| <span data-ttu-id="1c8d4-253">qu</span><span class="sxs-lookup"><span data-stu-id="1c8d4-253">qu</span></span> |<span data-ttu-id="1c8d4-254">6 hello 進行中作業的 hello 未傳送佇列中，尚未寫入 toohello 輸出網路</span><span class="sxs-lookup"><span data-stu-id="1c8d4-254">6 of hello in-progress operations are in hello unsent queue and have not yet been written toohello outbound network</span></span> |
| <span data-ttu-id="1c8d4-255">qs</span><span class="sxs-lookup"><span data-stu-id="1c8d4-255">qs</span></span> |<span data-ttu-id="1c8d4-256">已傳送的他進行中作業的 67 toohello 伺服器，但回應尚無法使用。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-256">67 of he in-progress operations have been sent toohello server but a response is not yet available.</span></span> <span data-ttu-id="1c8d4-257">可能是 hello 回應`Not yet sent by hello server`或`sent by hello server but not yet processed by hello client.`</span><span class="sxs-lookup"><span data-stu-id="1c8d4-257">hello response could be `Not yet sent by hello server` or `sent by hello server but not yet processed by hello client.`</span></span> |
| <span data-ttu-id="1c8d4-258">qc</span><span class="sxs-lookup"><span data-stu-id="1c8d4-258">qc</span></span> |<span data-ttu-id="1c8d4-259">0 的 hello 進行中作業已經看過的回覆，但尚未尚未標示為完成，因為 toowaiting hello 完成迴圈上</span><span class="sxs-lookup"><span data-stu-id="1c8d4-259">0 of hello in-progress operations have seen replies but have not yet been marked as complete due toowaiting on hello completion loop</span></span> |
| <span data-ttu-id="1c8d4-260">wr</span><span class="sxs-lookup"><span data-stu-id="1c8d4-260">wr</span></span> |<span data-ttu-id="1c8d4-261">沒有使用中的寫入器 （這表示 hello 6 未傳送的要求沒有被忽略） 位元組/activewriters</span><span class="sxs-lookup"><span data-stu-id="1c8d4-261">There is an active writer (meaning hello 6 unsent requests are not being ignored) bytes/activewriters</span></span> |
| <span data-ttu-id="1c8d4-262">了嗎</span><span class="sxs-lookup"><span data-stu-id="1c8d4-262">in</span></span> |<span data-ttu-id="1c8d4-263">有任何作用中的讀取裝置，而零個位元組可用 toobe hello NIC 位元組/activereaders 上讀取</span><span class="sxs-lookup"><span data-stu-id="1c8d4-263">There are no active readers and zero bytes are available toobe read on hello NIC bytes/activereaders</span></span> |

### <a name="steps-tooinvestigate"></a><span data-ttu-id="1c8d4-264">步驟 tooinvestigate</span><span class="sxs-lookup"><span data-stu-id="1c8d4-264">Steps tooinvestigate</span></span>
1. <span data-ttu-id="1c8d4-265">最佳作法請確定您正在使用時使用 hello StackExchange.Redis 用戶端，下列模式 tooconnect hello。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-265">As a best practice make sure you are using hello following pattern tooconnect when using hello StackExchange.Redis client.</span></span>

    ```c#
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
    });
    
    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ````

    <span data-ttu-id="1c8d4-266">如需詳細資訊，請參閱[連接 toohello 快取使用 StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-266">For more information, see [Connect toohello cache using StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).</span></span>

1. <span data-ttu-id="1c8d4-267">請確定您的 Azure Redis 快取和 hello 用戶端應用程式中 hello Azure 中相同的區域。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-267">Ensure that your Azure Redis Cache and hello client application are in hello same region in Azure.</span></span> <span data-ttu-id="1c8d4-268">例如，您可能會收到逾時後您的快取在美國東部但 hello 用戶端位於美國西部 hello 要求未完成內 hello`synctimeout`間隔，或您可能會發生逾時從本機開發電腦的偵錯時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-268">For example, you might be getting timeouts when your cache is in East US but hello client is in West US and hello request doesn't complete within hello `synctimeout` interval or you might be getting timeouts when you are debugging from your local development machine.</span></span> 
   
    <span data-ttu-id="1c8d4-269">強烈建議您 toohave hello 快取並 hello 中的用戶端 hello 相同 Azure 區域。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-269">It’s highly recommended toohave hello cache and in hello client in hello same Azure region.</span></span> <span data-ttu-id="1c8d4-270">如果您有包含跨區域呼叫的案例中，您應該設定 hello`synctimeout`間隔 tooa 值高於 hello 預設 1000 毫秒的間隔，藉以`synctimeout`hello 連接字串中的屬性。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-270">If you have a scenario that includes cross region calls, you should set hello `synctimeout` interval tooa value higher than hello default 1000 ms interval by including a `synctimeout` property in hello connection string.</span></span> <span data-ttu-id="1c8d4-271">hello 下列範例示範 StackExchange.Redis 快取的連接字串的程式碼片段`synctimeout`為 2000 毫秒。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-271">hello following example shows a StackExchange.Redis cache connection string snippet with a `synctimeout` of 2000 ms.</span></span>
   
        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
2. <span data-ttu-id="1c8d4-272">請確定您使用 hello 最新版 hello [StackExchange.Redis NuGet 封裝](https://www.nuget.org/packages/StackExchange.Redis/)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-272">Ensure you using hello latest version of hello [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="1c8d4-273">錯誤經常被中修正 hello 程式碼 toomake 它更穩固 tootimeouts hello 最新版本相當重要，因此。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-273">There are bugs constantly being fixed in hello code toomake it more robust tootimeouts so having hello latest version is important.</span></span>
3. <span data-ttu-id="1c8d4-274">如果沒有要求取得繫結的 hello 伺服器或用戶端上的頻寬限制，它會比較長，toocomplete 因而導致逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-274">If there are requests that are getting bound by bandwidth limitations on hello server or client, it will take longer for them toocomplete and thereby cause timeouts.</span></span> <span data-ttu-id="1c8d4-275">toosee 如果您的逾時到期 toonetwork 頻寬 hello 在伺服器上，請參閱[超過伺服器端頻寬](#server-side-bandwidth-exceeded)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-275">toosee if your timeout is due toonetwork bandwidth on hello server, see [Server side bandwidth exceeded](#server-side-bandwidth-exceeded).</span></span> <span data-ttu-id="1c8d4-276">toosee，如果您的逾時到期 tooclient 網路頻寬，請參閱[超過用戶端端頻寬](#client-side-bandwidth-exceeded)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-276">toosee if your timeout is due tooclient network bandwidth, see [Client side bandwidth exceeded](#client-side-bandwidth-exceeded).</span></span>
4. <span data-ttu-id="1c8d4-277">您可以取得 CPU 繫結 hello 伺服器或 hello 用戶端上？</span><span class="sxs-lookup"><span data-stu-id="1c8d4-277">Are you getting CPU bound on hello server or on hello client?</span></span>
   
   * <span data-ttu-id="1c8d4-278">如果您取得繫結 cpu 可能會導致 hello 要求 toonot 用戶端上的核取 hello 內處理`synctimeout`間隔，因此會造成逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-278">Check if you are getting bound by CPU on your client which could cause hello request toonot be processed within hello `synctimeout` interval, thus causing a timeout.</span></span> <span data-ttu-id="1c8d4-279">移動 tooa 大用戶端或 hello 負載可以幫助 toocontrol 這。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-279">Moving tooa larger client size or distributing hello load can help toocontrol this.</span></span> 
   * <span data-ttu-id="1c8d4-280">如果您要取得 CPU 的核取受限於 hello 伺服器上監視 hello `CPU` [快取效能計量](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-280">Check if you are getting CPU bound on hello server by monitoring hello `CPU` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="1c8d4-281">雖然 Redis 會受限於 CPU 可能會導致這些傳入要求要求 tootimeout。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-281">Requests coming in while Redis is CPU bound can cause those requests tootimeout.</span></span> <span data-ttu-id="1c8d4-282">您可以將發佈 hello 這橫跨多個分區進階版快取中載入或 tooa 較大的大小或定價層升級 tooaddress。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-282">tooaddress this you can distribute hello load across multiple shards in a premium cache, or upgrade tooa larger size or pricing tier.</span></span> <span data-ttu-id="1c8d4-283">如需詳細資訊，請參閱 [超過伺服器端頻寬](#server-side-bandwidth-exceeded)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-283">For more information, see [Server Side Bandwidth Exceeded](#server-side-bandwidth-exceeded).</span></span>
5. <span data-ttu-id="1c8d4-284">是否有花費很長的時間 tooprocess hello 伺服器上的命令？</span><span class="sxs-lookup"><span data-stu-id="1c8d4-284">Are there commands taking long time tooprocess on hello server?</span></span> <span data-ttu-id="1c8d4-285">長時間執行的很長的時間 tooprocess hello redis 伺服器的命令可能會導致逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-285">Long running commands that are taking long time tooprocess on hello redis-server can cause timeouts.</span></span> <span data-ttu-id="1c8d4-286">長時間執行之命令的部分範例包括有大量金鑰的 `mget`、`keys *` 或編寫得不好的 lua 指令碼。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-286">Some examples of long running commands are `mget` with large numbers of keys, `keys *` or poorly written lua scripts.</span></span> <span data-ttu-id="1c8d4-287">您可以使用 hello redis cli 用戶端 tooyour Azure Redis 快取執行個體連接，或使用 hello [Redis 主控台](cache-configure.md#redis-console)和執行的 hello [SlowLog](http://redis.io/commands/slowlog)命令 toosee 如果沒有要求花費時間超出預期。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-287">You can connect tooyour Azure Redis Cache instance using hello redis-cli client or use hello [Redis Console](cache-configure.md#redis-console) and run hello [SlowLog](http://redis.io/commands/slowlog) command toosee if there are requests taking longer than expected.</span></span> <span data-ttu-id="1c8d4-288">Redis 伺服器和 StackExchange.Redis 最適合許多小型要求，而非少數幾個大型要求。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-288">Redis Server and StackExchange.Redis are optimized for many small requests rather than fewer large requests.</span></span> <span data-ttu-id="1c8d4-289">將資料分割成較小的區塊可以改善這些問題。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-289">Splitting your data into smaller chunks may improve things here.</span></span> 
   
    <span data-ttu-id="1c8d4-290">如需使用 redis cli 和 stunnel toohello Azure Redis 快取 SSL 端點連接資訊，請參閱 hello[宣佈適用於 ASP.NET 工作階段狀態提供者 Redis 預覽版本](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx)部落格文章。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-290">For information on connecting toohello Azure Redis Cache SSL endpoint using redis-cli and stunnel, see hello [Announcing ASP.NET Session State Provider for Redis Preview Release](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) blog post.</span></span> <span data-ttu-id="1c8d4-291">如需詳細資訊，請參閱 [SlowLog](http://redis.io/commands/slowlog)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-291">For more information, see [SlowLog](http://redis.io/commands/slowlog).</span></span>
6. <span data-ttu-id="1c8d4-292">高 Redis 伺服器負載可能會導致逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-292">High Redis server load can cause timeouts.</span></span> <span data-ttu-id="1c8d4-293">您可以監視 hello 伺服器負載，藉由監視 hello `Redis Server Load` [快取效能計量](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-293">You can monitor hello server load by monitoring hello `Redis Server Load` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="1c8d4-294">伺服器負載為 100 （最大值），表示該 hello redis 伺服器已經過忙碌中，沒有閒置的時間，處理要求。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-294">A server load of 100 (maximum value) signifies that hello redis server has been busy, with no idle time, processing requests.</span></span> <span data-ttu-id="1c8d4-295">toosee 如果特定要求會佔用所有 hello 伺服器功能，請在 hello 前段中所述執行 hello SlowLog 命令。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-295">toosee if certain requests are taking up all of hello server capability, run hello SlowLog command, as described in hello previous paragraph.</span></span> <span data-ttu-id="1c8d4-296">如需詳細資訊，請參閱 [高 CPU 使用率/伺服器負載](#high-cpu-usage-server-load)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-296">For more information, see [High CPU usage / Server Load](#high-cpu-usage-server-load).</span></span>
7. <span data-ttu-id="1c8d4-297">可能是造成網路 blip 的 hello 用戶端上是否有任何其他事件？</span><span class="sxs-lookup"><span data-stu-id="1c8d4-297">Was there any other event on hello client side that could have caused a network blip?</span></span> <span data-ttu-id="1c8d4-298">檢查 hello 用戶端 （web、 背景工作角色或 Iaas VM） 時發生的事件，例如向上或向下調整的用戶端執行個體的 hello 數目，或部署的 hello 用戶端新版本，或已啟用自動調整規模嗎？在我們的測試中我們發現自動調整或調整向上/向下可能會導致輸出的網路連線的幾秒鐘的時間可能會遺失的。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-298">Check on hello client (web, worker role or an Iaas VM) if there was an event like scaling hello number of client instances up or down, or deploying a new version of hello client or auto-scale is enabled?In our testing we have found that autoscale or scaling up/down can cause outbound network connectivity can be lost for several seconds.</span></span> <span data-ttu-id="1c8d4-299">StackExchange.Redis 程式碼是有彈性的 toosuch 事件，並會重新連線。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-299">StackExchange.Redis code is resilient toosuch events and will reconnect.</span></span> <span data-ttu-id="1c8d4-300">在這段時間重新連線的 hello 佇列中的任何要求可以逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-300">During this time of re-connection any requests in hello queue can time out.</span></span>
8. <span data-ttu-id="1c8d4-301">是否有大型的要求前幾個小型要求 toohello 已逾時的 Redis 快取？hello 參數`qs`hello 錯誤訊息會告知您 toohello hello 用戶端的伺服器，從所送出多少要求，但尚未處理回應。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-301">Was there a big request preceding several small requests toohello Redis Cache that timed out? hello parameter `qs` in hello error message tells you how many requests were sent from hello client toohello server, but have not yet processed a response.</span></span> <span data-ttu-id="1c8d4-302">這個值會不斷成長，因為 StackExchange.Redis 使用單一 TCP 連線，而且一次只能讀取一個回應。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-302">This value can keep growing because StackExchange.Redis uses a single TCP connection and can only read one response at a time.</span></span> <span data-ttu-id="1c8d4-303">即使 hello 第一項作業已逾時，不會停止從 hello 伺服器送出 hello 資料和其他要求會封鎖，直到完成這個作業時，造成逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-303">Even though hello first operation timed out, it does not stop hello data being sent to/from hello server, and other requests are blocked until this is finished, causing time outs.</span></span> <span data-ttu-id="1c8d4-304">其中一種解決方案是確保您的快取已經很大，您的工作負載，並將較大的值分割成較小區塊 toominimize hello 可能發生逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-304">One solution is toominimize hello chance of timeouts by ensuring that your cache is large enough for your workload and splitting large values into smaller chunks.</span></span> <span data-ttu-id="1c8d4-305">另一個可能的解決方案是 toouse 的集區`ConnectionMultiplexer`在您的用戶端物件，並選擇至少載入 hello`ConnectionMultiplexer`時，傳送新的要求。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-305">Another possible solution is toouse a pool of `ConnectionMultiplexer` objects in your client, and choose hello least loaded `ConnectionMultiplexer` when sending a new request.</span></span> <span data-ttu-id="1c8d4-306">這應該防止單一逾時引發的其他要求 tooalso 逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-306">This should prevent a single timeout from causing other requests tooalso timeout.</span></span>
9. <span data-ttu-id="1c8d4-307">如果您使用`RedisSessionStateprovider`，請確定您已正確設定 hello 重試逾時。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-307">If you are using `RedisSessionStateprovider`, ensure you have set hello retry timeout correctly.</span></span> <span data-ttu-id="1c8d4-308">`retrytimeoutInMilliseconds` 應高於 `operationTimeoutinMilliseonds`，否則不會發生任何重試。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-308">`retrytimeoutInMilliseconds` should be higher than `operationTimeoutinMilliseonds`, otherwise no retries will occur.</span></span> <span data-ttu-id="1c8d4-309">在下列範例中的 hello `retrytimeoutInMilliseconds` too3000 設定。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-309">In hello following example `retrytimeoutInMilliseconds` is set too3000.</span></span> <span data-ttu-id="1c8d4-310">如需詳細資訊，請參閱[Azure Redis 快取的 ASP.NET 工作階段狀態提供者](cache-aspnet-session-state-provider.md)和[toouse hello 工作階段狀態提供者和輸出快取提供者的組態參數的方式](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-310">For more information, see [ASP.NET Session State Provider for Azure Redis Cache](cache-aspnet-session-state-provider.md) and [How toouse hello configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).</span></span>

    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


1. <span data-ttu-id="1c8d4-311">請檢查 hello Azure Redis 快取伺服器上的記憶體使用量[監視](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)`Used Memory RSS`和`Used Memory`。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-311">Check memory usage on hello Azure Redis Cache server by [monitoring](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` and `Used Memory`.</span></span> <span data-ttu-id="1c8d4-312">如果收回原則位於，Redis 會開始收回金鑰時`Used_Memory`到達 hello 快取大小。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-312">If an eviction policy is in place, Redis starts evicting keys when `Used_Memory` reaches hello cache size.</span></span> <span data-ttu-id="1c8d4-313">理想情況下，`Used Memory RSS` 應該只稍微高於 `Used memory`。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-313">Ideally, `Used Memory RSS` should be only slightly higher than `Used memory`.</span></span> <span data-ttu-id="1c8d4-314">差異很大表示記憶體分散 (內部或外部)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-314">A large difference means there is memory fragmentation (internal or external.</span></span> <span data-ttu-id="1c8d4-315">當`Used Memory RSS`是小於`Used Memory`，則表示已 hello 作業系統所交換的 hello 快取記憶體的一部分。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-315">When `Used Memory RSS` is less than `Used Memory`, it means part of hello cache memory has been swapped  by hello operating system.</span></span> <span data-ttu-id="1c8d4-316">如果發生這種情況，您應該就會遇到顯著的延遲。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-316">If this occurs you can expect some significant latencies.</span></span> <span data-ttu-id="1c8d4-317">因為透過 Redis 沒有控制其配置的方式對應 toomemory 頁面，高`Used Memory RSS`通常是記憶體使用量的高峰 hello 結果。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-317">Because Redis does not have control over how its allocations are mapped toomemory pages, high `Used Memory RSS` is often hello result of a spike in memory usage.</span></span> <span data-ttu-id="1c8d4-318">當 Redis 會釋出記憶體時，hello 記憶體提供回 toohello 配置器，並 hello 配置器可能會或可能不會產生 hello 記憶體後 toohello 系統。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-318">When Redis frees memory, hello memory is given back toohello allocator, and hello allocator may or may not give hello memory back toohello system.</span></span> <span data-ttu-id="1c8d4-319">Hello 之間可能有不一致的情形`Used Memory`值和記憶體耗用量 hello 作業系統所報告。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-319">There may be a discrepancy between hello `Used Memory` value and memory consumption as reported by hello operating system.</span></span> <span data-ttu-id="1c8d4-320">可能是因為已用記憶體和釋放 Redis，但不是指定回復 toohello 系統 toohello 事實。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-320">It may be due toohello fact memory has been used and released by Redis, but not given back toohello system.</span></span> <span data-ttu-id="1c8d4-321">toohelp 降低記憶體問題，您可以執行下列步驟的 hello。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-321">toohelp mitigate memory issues you can perform hello following steps.</span></span>
   
   * <span data-ttu-id="1c8d4-322">升級 hello 快取 tooa 較大的大小，以便讓您不執行記憶體限制樣板 hello 系統上。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-322">Upgrade hello cache tooa larger size so that you are not running up against memory limitations on hello system.</span></span>
   * <span data-ttu-id="1c8d4-323">設定，讓較舊的值會主動收回 hello 金鑰到期時間。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-323">Set expiration times on hello keys so that older values are evicted proactively.</span></span>
   * <span data-ttu-id="1c8d4-324">監視 hello hello`used_memory_rss`快取度量。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-324">Monitor hello hello `used_memory_rss` cache metric.</span></span> <span data-ttu-id="1c8d4-325">當這個值會接近 hello 其快取大小時，您會發現效能問題的可能 toostart。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-325">When this value approaches hello size of their cache, you are likely toostart seeing performance issues.</span></span> <span data-ttu-id="1c8d4-326">如果您使用進階版快取，或升級 tooa 較大的快取大小，請將 hello 資料分散在多個分區。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-326">Distribute hello data across multiple shards if you are using a premium cache, or upgrade tooa larger cache size.</span></span>
   
   <span data-ttu-id="1c8d4-327">如需詳細資訊，請參閱[hello 伺服器上記憶體不足的壓力](#memory-pressure-on-the-server)。</span><span class="sxs-lookup"><span data-stu-id="1c8d4-327">For more information, see [Memory Pressure on hello server](#memory-pressure-on-the-server).</span></span>

## <a name="additional-information"></a><span data-ttu-id="1c8d4-328">其他資訊</span><span class="sxs-lookup"><span data-stu-id="1c8d4-328">Additional information</span></span>
* [<span data-ttu-id="1c8d4-329">應該使用哪個 Redis 快取供應項目和大小？</span><span class="sxs-lookup"><span data-stu-id="1c8d4-329">What Redis Cache offering and size should I use?</span></span>](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
* [<span data-ttu-id="1c8d4-330">如何建立基準和測試 hello 我快取的效能？</span><span class="sxs-lookup"><span data-stu-id="1c8d4-330">How can I benchmark and test hello performance of my cache?</span></span>](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
* [<span data-ttu-id="1c8d4-331">如何執行 Redis 命令？</span><span class="sxs-lookup"><span data-stu-id="1c8d4-331">How can I run Redis commands?</span></span>](cache-faq.md#how-can-i-run-redis-commands)
* [<span data-ttu-id="1c8d4-332">如何 toomonitor Azure Redis 快取</span><span class="sxs-lookup"><span data-stu-id="1c8d4-332">How toomonitor Azure Redis Cache</span></span>](cache-how-to-monitor.md)

