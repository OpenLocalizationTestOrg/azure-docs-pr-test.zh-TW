---
title: "如何針對 Azure Redis 快取進行疑難排解 | Microsoft Docs"
description: "了解如何解決 Azure Redis 快取的常見問題。"
services: redis-cache
documentationcenter: 
author: steved0x
manager: douge
editor: 
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: sdanie
ms.openlocfilehash: 2e9d1b644f1e80c7d916a261a6c47fcc11a1ffe0
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="how-to-troubleshoot-azure-redis-cache"></a><span data-ttu-id="8bc8e-103">如何針對 Azure Redis 快取進行疑難排解</span><span class="sxs-lookup"><span data-stu-id="8bc8e-103">How to troubleshoot Azure Redis Cache</span></span>
<span data-ttu-id="8bc8e-104">本文提供以下類別的 Azure Redis 快取問題疑難排解指引。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-104">This article provides guidance for troubleshooting the following categories of Azure Redis Cache issues.</span></span>

* <span data-ttu-id="8bc8e-105">[用戶端疑難排解](#client-side-troubleshooting) - 本節提供連接到 Azure Redis 快取的應用程式所造成之問題的識別和解決指引。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-105">[Client side troubleshooting](#client-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused by the application connecting to Azure Redis Cache.</span></span>
* <span data-ttu-id="8bc8e-106">[伺服器端疑難排解](#server-side-troubleshooting) - 本節提供 Azure Redis 快取伺服器端上所造成之問題的識別和解決指引。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-106">[Server side troubleshooting](#server-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused on the Azure Redis Cache server side.</span></span>
* <span data-ttu-id="8bc8e-107">[StackExchange.Redis 逾時例外狀況](#stackexchangeredis-timeout-exceptions) - 本節提供使用 StackExchange.Redis 用戶端時之問題的疑難排解資訊。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-107">[StackExchange.Redis timeout exceptions](#stackexchangeredis-timeout-exceptions) - This section provides information on troubleshooting issues when using the StackExchange.Redis client.</span></span>

> [!NOTE]
> <span data-ttu-id="8bc8e-108">本指南中的數個疑難排解步驟包含如何執行 Redis 命令和監視各種效能度量的指示。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-108">Several of the troubleshooting steps in this guide include instructions to run Redis commands and monitor various performance metrics.</span></span> <span data-ttu-id="8bc8e-109">如需詳細資訊和指示，請參閱 [其他資訊](#additional-information) 一節中的文章。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-109">For more information and instructions, see the articles in the [Additional information](#additional-information) section.</span></span>
> 
> 

## <a name="client-side-troubleshooting"></a><span data-ttu-id="8bc8e-110">用戶端疑難排解</span><span class="sxs-lookup"><span data-stu-id="8bc8e-110">Client side troubleshooting</span></span>
<span data-ttu-id="8bc8e-111">本節討論因為用戶端應用程式的某種情況而發生之問題的疑難排解。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-111">This section discusses troubleshooting issues that occur because of a condition on the client application.</span></span>

* [<span data-ttu-id="8bc8e-112">用戶端上的記憶體壓力</span><span class="sxs-lookup"><span data-stu-id="8bc8e-112">Memory pressure on the client</span></span>](#memory-pressure-on-the-client)
* [<span data-ttu-id="8bc8e-113">流量暴增</span><span class="sxs-lookup"><span data-stu-id="8bc8e-113">Burst of traffic</span></span>](#burst-of-traffic)
* [<span data-ttu-id="8bc8e-114">用戶端 CPU 使用量很高</span><span class="sxs-lookup"><span data-stu-id="8bc8e-114">High client CPU usage</span></span>](#high-client-cpu-usage)
* [<span data-ttu-id="8bc8e-115">超過用戶端頻寬</span><span class="sxs-lookup"><span data-stu-id="8bc8e-115">Client Side Bandwidth Exceeded</span></span>](#client-side-bandwidth-exceeded)
* [<span data-ttu-id="8bc8e-116">要求/回應大小很大</span><span class="sxs-lookup"><span data-stu-id="8bc8e-116">Large Request/Response Size</span></span>](#large-requestresponse-size)
* [<span data-ttu-id="8bc8e-117">我在 Redis 中的資料怎麼了？</span><span class="sxs-lookup"><span data-stu-id="8bc8e-117">What happened to my data in Redis?</span></span>](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-the-client"></a><span data-ttu-id="8bc8e-118">用戶端上的記憶體壓力</span><span class="sxs-lookup"><span data-stu-id="8bc8e-118">Memory pressure on the client</span></span>
#### <a name="problem"></a><span data-ttu-id="8bc8e-119">問題</span><span class="sxs-lookup"><span data-stu-id="8bc8e-119">Problem</span></span>
<span data-ttu-id="8bc8e-120">用戶端電腦上的記憶體壓力會導致各種效能問題，而可能延遲處理 Redis 執行個體所傳送的資料，但不會有任何延遲。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-120">Memory pressure on the client machine leads to all kinds of performance problems that can delay processing of data that was sent by the Redis instance without any delay.</span></span> <span data-ttu-id="8bc8e-121">到達記憶體壓力時，系統通常必須將資料從實體記憶體分頁處理到磁碟上的虛擬記憶體。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-121">When memory pressure hits, the system typically has to page data from physical memory to virtual memory which is on disk.</span></span> <span data-ttu-id="8bc8e-122">此「分頁錯誤」  會使系統明顯變慢。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-122">This *page faulting* causes the system to slow down significantly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="8bc8e-123">測量</span><span class="sxs-lookup"><span data-stu-id="8bc8e-123">Measurement</span></span>
1. <span data-ttu-id="8bc8e-124">監視電腦上的記憶體使用量，以確定它不會超過可用記憶體。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-124">Monitor memory usage on machine to make sure that it does not exceed available memory.</span></span> 
2. <span data-ttu-id="8bc8e-125">監視 `Page Faults/Sec` 效能計數器。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-125">Monitor the `Page Faults/Sec` performance counter.</span></span> <span data-ttu-id="8bc8e-126">即使在正常作業期間，大部分的系統還是會有一些分頁錯誤，因此請留意這個與逾時對應的分頁錯誤效能計數器尖峰。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-126">Most systems will have some page faults even during normal operation, so watch for spikes in this page faults performance counter which correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="8bc8e-127">解決方案</span><span class="sxs-lookup"><span data-stu-id="8bc8e-127">Resolution</span></span>
<span data-ttu-id="8bc8e-128">將用戶端升級至擁有更多記憶體的較大用戶端 VM 大小，或深入了解記憶體使用量模式以減少記憶體的耗用。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-128">Upgrade your client to a larger client VM size with more memory or dig into your memory usage patterns to reduce memory consuption.</span></span>

### <a name="burst-of-traffic"></a><span data-ttu-id="8bc8e-129">流量暴增</span><span class="sxs-lookup"><span data-stu-id="8bc8e-129">Burst of traffic</span></span>
#### <a name="problem"></a><span data-ttu-id="8bc8e-130">問題</span><span class="sxs-lookup"><span data-stu-id="8bc8e-130">Problem</span></span>
<span data-ttu-id="8bc8e-131">流量暴增加上不當的 `ThreadPool` 設定，可能會導致延遲處理 Redis 伺服器已傳送但用戶端上尚未使用的資料。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-131">Bursts of traffic combined with poor `ThreadPool` settings can result in delays in processing data already sent by the Redis Server but not yet consumed on the client side.</span></span>

#### <a name="measurement"></a><span data-ttu-id="8bc8e-132">測量</span><span class="sxs-lookup"><span data-stu-id="8bc8e-132">Measurement</span></span>
<span data-ttu-id="8bc8e-133">使用[如這裡所提供的](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs)程式碼，監視 `ThreadPool` 統計資料如何隨著時間變更。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-133">Monitor how your `ThreadPool` statistics change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs).</span></span> <span data-ttu-id="8bc8e-134">您也可以查看來自 StackExchange.Redis 的 `TimeoutException` 訊息。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-134">You can also look at the `TimeoutException` message from StackExchange.Redis.</span></span> <span data-ttu-id="8bc8e-135">範例如下：</span><span class="sxs-lookup"><span data-stu-id="8bc8e-135">Here is an example :</span></span>

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

<span data-ttu-id="8bc8e-136">在上述訊息中，有幾個有趣的問題︰</span><span class="sxs-lookup"><span data-stu-id="8bc8e-136">In the above message, there are several issues that are interesting:</span></span>

1. <span data-ttu-id="8bc8e-137">請注意，在 `IOCP` 區段和 `WORKER` 區段中，`Busy` 值大於 `Min` 值。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-137">Notice that in the `IOCP` section and the `WORKER` section you have a `Busy` value that is greater than the `Min` value.</span></span> <span data-ttu-id="8bc8e-138">這表示 `ThreadPool` 設定需要調整。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-138">This means that your `ThreadPool` settings need adjusting.</span></span>
2. <span data-ttu-id="8bc8e-139">您也可以查看 `in: 64221`。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-139">You can also see `in: 64221`.</span></span> <span data-ttu-id="8bc8e-140">這表示已在核心通訊端層接收到 64211 位元組，但應用程式 (例如 StackExchange.Redis) 尚未讀取。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-140">This indicates that 64211 bytes have been received at the kernel socket layer but haven't yet been read by the application (e.g. StackExchange.Redis).</span></span> <span data-ttu-id="8bc8e-141">這通常表示應用程式從網路讀取資料的速度，比伺服器傳送資料給您的速度還慢。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-141">This typically means that your application isn't reading data from the network as quickly as the server is sending it to you.</span></span>

#### <a name="resolution"></a><span data-ttu-id="8bc8e-142">解決方案</span><span class="sxs-lookup"><span data-stu-id="8bc8e-142">Resolution</span></span>
<span data-ttu-id="8bc8e-143">設定 [ThreadPool 設定](https://gist.github.com/JonCole/e65411214030f0d823cb) 以確保執行緒集區會在流量暴增的情況下相應增加。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-143">Configure your [ThreadPool Settings](https://gist.github.com/JonCole/e65411214030f0d823cb) to make sure that your thread pool will scale up quickly under burst scenarios.</span></span>

### <a name="high-client-cpu-usage"></a><span data-ttu-id="8bc8e-144">用戶端 CPU 使用量很高</span><span class="sxs-lookup"><span data-stu-id="8bc8e-144">High client CPU usage</span></span>
#### <a name="problem"></a><span data-ttu-id="8bc8e-145">問題</span><span class="sxs-lookup"><span data-stu-id="8bc8e-145">Problem</span></span>
<span data-ttu-id="8bc8e-146">用戶端上的 CPU 使用量很高表示系統跟不上其應該執行的工作。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-146">High CPU usage on the client is an indication that the system cannot keep up with the work that it has been asked to perform.</span></span> <span data-ttu-id="8bc8e-147">這表示用戶端可能無法及時處理 Redis 傳來的回應，即使 Redis 非常快速地傳送回應也是一樣。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-147">This means that the client may fail to process a response from Redis in a timely fashion even though Redis sent the response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="8bc8e-148">測量</span><span class="sxs-lookup"><span data-stu-id="8bc8e-148">Measurement</span></span>
<span data-ttu-id="8bc8e-149">透過 Azure 入口網站或相關聯的效能計數器，監視全系統的 CPU 使用量。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-149">Monitor the System Wide CPU usage through the Azure Portal or through the associated performance counter.</span></span> <span data-ttu-id="8bc8e-150">請注意不要監視「處理程序」  CPU，因為有可能單一處理程序的 CPU 使用率很低，但同時間的整體系統 CPU 卻很高。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-150">Be careful not to monitor *process* CPU because a single process can have low CPU usage at the same time that overall system CPU can be high.</span></span> <span data-ttu-id="8bc8e-151">請監看與逾時對應的 CPU 使用量暴增。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-151">Watch for spikes in CPU usage that correspond with timeouts.</span></span> <span data-ttu-id="8bc8e-152">由於高 CPU，您也可能會在 `TimeoutException` 錯誤訊息中看到高 `in: XXX` 值，如[流量暴增](#burst-of-traffic)一節所述。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-152">As a result of high CPU, you may also see high `in: XXX` values in `TimeoutException` error messages as described in the [Burst of traffic](#burst-of-traffic) section.</span></span>

> [!NOTE]
> <span data-ttu-id="8bc8e-153">StackExchange.Redis 1.1.603 和更新版本在 `TimeoutException` 錯誤訊息中包含 `local-cpu` 度量。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-153">StackExchange.Redis 1.1.603 and later includes the `local-cpu` metric in `TimeoutException` error messages.</span></span> <span data-ttu-id="8bc8e-154">請確定您使用最新版的 [StackExchange.Redis NuGet 封裝](https://www.nuget.org/packages/StackExchange.Redis/)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-154">Ensure you using the latest version of the [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="8bc8e-155">程式碼中的錯誤會經常修正，以便更能應付逾時問題，因此請務必要擁有最新版本。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-155">There are bugs constantly being fixed in the code to make it more robust to timeouts so having the latest version is important.</span></span>
> 
> 

#### <a name="resolution"></a><span data-ttu-id="8bc8e-156">解決方案</span><span class="sxs-lookup"><span data-stu-id="8bc8e-156">Resolution</span></span>
<span data-ttu-id="8bc8e-157">升級為擁有更多 CPU 容量的較大 VM 大小，或調查導致 CPU 尖峰的原因。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-157">Upgrade to a larger VM size with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="client-side-bandwidth-exceeded"></a><span data-ttu-id="8bc8e-158">超過用戶端頻寬</span><span class="sxs-lookup"><span data-stu-id="8bc8e-158">Client side bandwidth exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="8bc8e-159">問題</span><span class="sxs-lookup"><span data-stu-id="8bc8e-159">Problem</span></span>
<span data-ttu-id="8bc8e-160">不同大小的用戶端電腦對於其可用的網路頻寬多寡會有限制。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-160">Different sized client machines have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="8bc8e-161">如果用戶端超過可用的頻寬，則資料在用戶端上的處理速度不會和伺服器傳送資料的速度一樣快。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-161">If the client exceeds the available bandwidth, then data will not be processed on the client side as quickly as the server is sending it.</span></span> <span data-ttu-id="8bc8e-162">這可能會導致逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-162">This can lead to timeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="8bc8e-163">測量</span><span class="sxs-lookup"><span data-stu-id="8bc8e-163">Measurement</span></span>
<span data-ttu-id="8bc8e-164">使用 [如這裡所提供的](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs)程式碼，監視頻寬使用量如何隨著時間變更。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-164">Monitor how your Bandwidth usage change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs).</span></span> <span data-ttu-id="8bc8e-165">請注意，此程式碼可能無法在具有限制權限的某些環境 (例如 Azure 網站) 中順利執行。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-165">Note that this code may not run successfully in some environments with restricted permissions (like Azure web sites).</span></span>

#### <a name="resolution"></a><span data-ttu-id="8bc8e-166">解決方案</span><span class="sxs-lookup"><span data-stu-id="8bc8e-166">Resolution</span></span>
<span data-ttu-id="8bc8e-167">增加用戶端 VM 大小或減少網路頻寬耗用。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-167">Increase Client VM size or reduce network bandwidth consumption.</span></span>

### <a name="large-requestresponse-size"></a><span data-ttu-id="8bc8e-168">要求/回應大小很大</span><span class="sxs-lookup"><span data-stu-id="8bc8e-168">Large Request/Response Size</span></span>
#### <a name="problem"></a><span data-ttu-id="8bc8e-169">問題</span><span class="sxs-lookup"><span data-stu-id="8bc8e-169">Problem</span></span>
<span data-ttu-id="8bc8e-170">大型的要求/回應可能會導致逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-170">A large request/response can cause timeouts.</span></span> <span data-ttu-id="8bc8e-171">例如，假設您在用戶端上設定的逾時值為 1 秒。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-171">As an example, Suppose your timeout value configured on your client is 1 second.</span></span> <span data-ttu-id="8bc8e-172">應用程式同時 (使用相同的實體網路連線) 要求兩個金鑰 (例如 'A' 和 'B')。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-172">Your application requests two keys (e.g. 'A' and 'B') at the same time (using the same physical network connection).</span></span> <span data-ttu-id="8bc8e-173">大部分用戶端支援「管線傳送」要求，因此 'A' 和 'B' 這兩個要求沒有等待回應，就在網路上相繼傳送至伺服器。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-173">Most clients support "Pipelining" of requests, such that both requests 'A' and 'B' are sent on the wire to the server one after the other without waiting for the responses.</span></span> <span data-ttu-id="8bc8e-174">伺服器會以相同順序傳回回應。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-174">The server will send the responses back in the same order.</span></span> <span data-ttu-id="8bc8e-175">如果回應 'A' 夠大，它可能會用掉後續要求的大部分逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-175">If response 'A' is large enough it can eat up most of the timeout for subsequent requests.</span></span> 

<span data-ttu-id="8bc8e-176">下列範例示範此案例。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-176">The following example demonstrates this scenario.</span></span> <span data-ttu-id="8bc8e-177">在此案例中，要求 'A' 和 'B' 快速傳送，伺服器也開始快速傳送回應 'A' 和 'B'，但因為資料傳輸需要時間，'B' 被擋在其他要求後面，因此即使伺服器已迅速回應仍然會逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-177">In this scenario, Request 'A' and 'B' are sent quickly, the server starts sending responses 'A' and 'B' quickly, but because of data transfer times, 'B' get stuck behind the other request and times out even though the server responded quickly.</span></span>

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a><span data-ttu-id="8bc8e-178">測量</span><span class="sxs-lookup"><span data-stu-id="8bc8e-178">Measurement</span></span>
<span data-ttu-id="8bc8e-179">這很難測量。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-179">This is a difficult one to measure.</span></span> <span data-ttu-id="8bc8e-180">基本上，您必須檢測用戶端程式碼來追蹤大量要求和回應。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-180">You basically have to instrument your client code to track large requests and responses.</span></span> 

#### <a name="resolution"></a><span data-ttu-id="8bc8e-181">解決方案</span><span class="sxs-lookup"><span data-stu-id="8bc8e-181">Resolution</span></span>
1. <span data-ttu-id="8bc8e-182">Redis 最適合大量的較小值，而不是少數幾個較大值。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-182">Redis is optimized for a large number of small values, rather than a few large values.</span></span> <span data-ttu-id="8bc8e-183">比較好的解決方案是將資料分割成相關的較小值。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-183">The preferred solution is to break up your data into related smaller values.</span></span> <span data-ttu-id="8bc8e-184">請參閱 [Redis 的理想值大小範圍為何？100 KB 是否會太大？](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ)文章，以取得為何建議使用較小值的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-184">See the [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details around why smaller values are recommended.</span></span>
2. <span data-ttu-id="8bc8e-185">增加 VM (適用於用戶端和 Redis 快取伺服器) 的大小，以取得更高的頻寬功能，減少較大回應的資料傳輸時間。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-185">Increase the size of your VM (for client and Redis Cache Server), to get higher bandwidth capabilities, reducing data transfer times for larger responses.</span></span> <span data-ttu-id="8bc8e-186">請注意，只在伺服器或用戶端上取得更多頻寬可能並不夠。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-186">Note that getting more bandwidth on just the server or just on the client may not be enough.</span></span> <span data-ttu-id="8bc8e-187">請測量頻寬使用量，並與您目前擁有的 VM 大小的功能做比較。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-187">Measure your bandwidth usage and compare it to the capabilities of the size of VM you currently have.</span></span>
3. <span data-ttu-id="8bc8e-188">增加您使用的 `ConnectionMultiplexer` 物件數目，並透過不同的連線循環配置要求。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-188">Increase the number of `ConnectionMultiplexer` objects you use and round-robin requests over different connections.</span></span>

### <a name="what-happened-to-my-data-in-redis"></a><span data-ttu-id="8bc8e-189">我在 Redis 中的資料怎麼了？</span><span class="sxs-lookup"><span data-stu-id="8bc8e-189">What happened to my data in Redis?</span></span>
#### <a name="problem"></a><span data-ttu-id="8bc8e-190">問題</span><span class="sxs-lookup"><span data-stu-id="8bc8e-190">Problem</span></span>
<span data-ttu-id="8bc8e-191">我預期 Azure Redis 快取執行個體中會有某些資料，但是裡面似乎沒有。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-191">I expected for certain data to be in my Azure Redis Cache instance but it didn't seem to be there.</span></span>

#### <a name="resolution"></a><span data-ttu-id="8bc8e-192">解決方案</span><span class="sxs-lookup"><span data-stu-id="8bc8e-192">Resolution</span></span>
<span data-ttu-id="8bc8e-193">如需可能的原因和解決方案，請參閱 [我在 Redis 中的資料怎麼了？](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) 。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-193">See [What happened to my data in Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) for possible causes and resolutions.</span></span>

## <a name="server-side-troubleshooting"></a><span data-ttu-id="8bc8e-194">伺服器端疑難排解</span><span class="sxs-lookup"><span data-stu-id="8bc8e-194">Server side troubleshooting</span></span>
<span data-ttu-id="8bc8e-195">本節討論因為快取伺服器的某種情況而發生之問題的疑難排解。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-195">This section discusses troubleshooting issues that occur because of a condition on the cache server.</span></span>

* [<span data-ttu-id="8bc8e-196">伺服器上的記憶體壓力</span><span class="sxs-lookup"><span data-stu-id="8bc8e-196">Memory Pressure on the server</span></span>](#memory-pressure-on-the-server)
* [<span data-ttu-id="8bc8e-197">高 CPU 使用率/伺服器負載</span><span class="sxs-lookup"><span data-stu-id="8bc8e-197">High CPU usage / Server Load</span></span>](#high-cpu-usage-server-load)
* [<span data-ttu-id="8bc8e-198">超過伺服器端頻寬</span><span class="sxs-lookup"><span data-stu-id="8bc8e-198">Server Side Bandwidth Exceeded</span></span>](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-the-server"></a><span data-ttu-id="8bc8e-199">伺服器上的記憶體壓力</span><span class="sxs-lookup"><span data-stu-id="8bc8e-199">Memory Pressure on the server</span></span>
#### <a name="problem"></a><span data-ttu-id="8bc8e-200">問題</span><span class="sxs-lookup"><span data-stu-id="8bc8e-200">Problem</span></span>
<span data-ttu-id="8bc8e-201">伺服器端上的記憶體壓力會導致各種效能問題，而可能延遲處理要求。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-201">Memory pressure on the server side leads to all kinds of performance problems that can delay processing of requests.</span></span> <span data-ttu-id="8bc8e-202">到達記憶體壓力時，系統通常必須將資料從實體記憶體分頁處理到磁碟上的虛擬記憶體。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-202">When memory pressure hits, the system typically has to page data from physical memory to virtual memory which is on disk.</span></span> <span data-ttu-id="8bc8e-203">此「分頁錯誤」  會使系統明顯變慢。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-203">This *page faulting* causes the system to slow down significantly.</span></span> <span data-ttu-id="8bc8e-204">此記憶體壓力有幾個可能的原因︰</span><span class="sxs-lookup"><span data-stu-id="8bc8e-204">There are several possible causes of this memory pressure:</span></span> 

1. <span data-ttu-id="8bc8e-205">您已在快取中填滿資料。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-205">You have filled the cache to full capacity with data.</span></span> 
2. <span data-ttu-id="8bc8e-206">Redis 遇到高度記憶體分散情形，儲存大型物件時最常造成此現象 (Redis 最適合小型物件，如需詳細資訊，請參閱 [Redis 的理想值大小範圍為何？100 KB 是否會太大？](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ)文章)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-206">Redis is seeing high memory fragmentation - most often caused by storing large objects (Redis is optimized for a small objects - See the [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details).</span></span> 

#### <a name="measurement"></a><span data-ttu-id="8bc8e-207">測量</span><span class="sxs-lookup"><span data-stu-id="8bc8e-207">Measurement</span></span>
<span data-ttu-id="8bc8e-208">Redis 會公開兩個可協助您識別此問題的度量。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-208">Redis exposes two metrics that can help you identify this issue.</span></span> <span data-ttu-id="8bc8e-209">第一個是 `used_memory`，另一個是 `used_memory_rss`。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-209">The first is `used_memory` and the other is `used_memory_rss`.</span></span> <span data-ttu-id="8bc8e-210">[這些度量](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)可在 Azure 入口網站中或透過 [Redis INFO](http://redis.io/commands/info) 命令來取得。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-210">[These metrics](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) are available in the Azure Portal or through the [Redis INFO](http://redis.io/commands/info) command.</span></span>

#### <a name="resolution"></a><span data-ttu-id="8bc8e-211">解決方案</span><span class="sxs-lookup"><span data-stu-id="8bc8e-211">Resolution</span></span>
<span data-ttu-id="8bc8e-212">您可以進行幾項可能的變更，以協助讓記憶體使用量保持良好狀況︰</span><span class="sxs-lookup"><span data-stu-id="8bc8e-212">There are several possible changes that you can make to help keep memory usage healthy:</span></span>

1. <span data-ttu-id="8bc8e-213">[設定記憶體原則](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) 並在金鑰上設定到期時間。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-213">[Configure a memory policy](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) and set expiration times on your keys.</span></span> <span data-ttu-id="8bc8e-214">請注意，如果記憶體分散，這麼做可能還不夠。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-214">Note that this may not be sufficient if you have fragmentation.</span></span>
2. <span data-ttu-id="8bc8e-215">[設定 maxmemory-reserved 值](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) ，讓此值大到足以彌補記憶體分散情形。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-215">[Configure a maxmemory-reserved value](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) that is large enough to compensate for memory fragmentation.</span></span>
3. <span data-ttu-id="8bc8e-216">將大型快取物件分割為較小的相關物件。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-216">Break up your large cached objects into smaller related objects.</span></span>
4. <span data-ttu-id="8bc8e-217">[調整](cache-how-to-scale.md) 為更大的快取大小。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-217">[Scale](cache-how-to-scale.md) to a larger cache size.</span></span>
5. <span data-ttu-id="8bc8e-218">如果您使用[已啟用 Redis 叢集的高階快取](cache-how-to-premium-clustering.md)，則可以[增加分區數目](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-218">If you are using a [premium cache with Redis cluster enabled](cache-how-to-premium-clustering.md) you can [increase the number of shards](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).</span></span>

### <a name="high-cpu-usage--server-load"></a><span data-ttu-id="8bc8e-219">高 CPU 使用率/伺服器負載</span><span class="sxs-lookup"><span data-stu-id="8bc8e-219">High CPU usage / Server Load</span></span>
#### <a name="problem"></a><span data-ttu-id="8bc8e-220">問題</span><span class="sxs-lookup"><span data-stu-id="8bc8e-220">Problem</span></span>
<span data-ttu-id="8bc8e-221">高 CPU 使用率可能表示用戶端可能無法及時處理 Redis 傳來的回應，即使 Redis 非常快速地傳送回應也是一樣。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-221">High CPU usage can mean that the client side can fail to process a response from Redis in a timely fashion even though Redis sent the response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="8bc8e-222">測量</span><span class="sxs-lookup"><span data-stu-id="8bc8e-222">Measurement</span></span>
<span data-ttu-id="8bc8e-223">透過 Azure 入口網站或相關聯的效能計數器，監視全系統的 CPU 使用量。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-223">Monitor the System Wide CPU usage through the Azure Portal or through the associated performance counter.</span></span> <span data-ttu-id="8bc8e-224">請注意不要監視「處理程序」  CPU，因為有可能單一處理程序的 CPU 使用率很低，但同時間的整體系統 CPU 卻很高。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-224">Be careful not to monitor *process* CPU because a single process can have low CPU usage at the same time that overall system CPU can be high.</span></span> <span data-ttu-id="8bc8e-225">請監看與逾時對應的 CPU 使用量暴增。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-225">Watch for spikes in CPU usage that correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="8bc8e-226">解決方案</span><span class="sxs-lookup"><span data-stu-id="8bc8e-226">Resolution</span></span>
<span data-ttu-id="8bc8e-227">[擴充](cache-how-to-scale.md) 為擁有更多 CPU 容量的較大快取層，或調查導致 CPU 尖峰的原因。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-227">[Scale](cache-how-to-scale.md) to a larger cache tier with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="server-side-bandwidth-exceeded"></a><span data-ttu-id="8bc8e-228">超過伺服器端頻寬</span><span class="sxs-lookup"><span data-stu-id="8bc8e-228">Server Side Bandwidth Exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="8bc8e-229">問題</span><span class="sxs-lookup"><span data-stu-id="8bc8e-229">Problem</span></span>
<span data-ttu-id="8bc8e-230">不同大小的快取執行個體對於其可用的網路頻寬多寡會有限制。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-230">Different sized cache instances have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="8bc8e-231">如果伺服器超過可用的頻寬，則資料不會一樣快地傳送至用戶端。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-231">If the server exceeds the available bandwidth, then data will not be sent to the client as quickly.</span></span> <span data-ttu-id="8bc8e-232">這可能會導致逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-232">This can lead to timeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="8bc8e-233">測量</span><span class="sxs-lookup"><span data-stu-id="8bc8e-233">Measurement</span></span>
<span data-ttu-id="8bc8e-234">您可以監視 `Cache Read` 度量，這是所指定報告間隔期間，從快取讀取的資料量 (以 MB/s 為單位)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-234">You can monitor the `Cache Read` metric, which is the amount of data read from the cache in Megabytes per second (MB/s) during the specified reporting interval.</span></span> <span data-ttu-id="8bc8e-235">這個值對應於此快取所使用的網路頻寬。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-235">This value corresponds to the network bandwidth used by this cache.</span></span> <span data-ttu-id="8bc8e-236">如果您想要設定伺服器端網路頻寬限制的警示，則可以使用此 `Cache Read` 計數器加以建立。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-236">If you want to set up alerts for server side network bandwidth limits, you can create them using this `Cache Read` counter.</span></span> <span data-ttu-id="8bc8e-237">如需不同快取定價層和大小的觀察頻寬限制，請比較您的數據與 [本表](cache-faq.md#cache-performance) 中的值。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-237">Compare your readings with the values in [this table](cache-faq.md#cache-performance) for the observed bandwidth limits for various cache pricing tiers and sizes.</span></span>

#### <a name="resolution"></a><span data-ttu-id="8bc8e-238">解決方案</span><span class="sxs-lookup"><span data-stu-id="8bc8e-238">Resolution</span></span>
<span data-ttu-id="8bc8e-239">如果您一直逼近定價層和快取大小的最大觀察頻寬，請考慮使用[本表](cache-faq.md#cache-performance)中的值做為指南，來[調整](cache-how-to-scale.md)為具有更大網路頻寬的定價層或大小。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-239">If you are consistently near the observed maximum bandwidth for your pricing tier and cache size, consider [scaling](cache-how-to-scale.md) to a pricing tier or size that has greater network bandwidth, using the values in [this table](cache-faq.md#cache-performance) as a guide.</span></span>

## <a name="stackexchangeredis-timeout-exceptions"></a><span data-ttu-id="8bc8e-240">StackExchange.Redis 逾時例外狀況</span><span class="sxs-lookup"><span data-stu-id="8bc8e-240">StackExchange.Redis timeout exceptions</span></span>
<span data-ttu-id="8bc8e-241">StackExchange.Redis 使用名為 `synctimeout` 的組態設定來進行預設值為 1000 毫秒的同步作業。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-241">StackExchange.Redis uses a configuration setting named `synctimeout` for synchronous operations which has a default value  of 1000 ms.</span></span> <span data-ttu-id="8bc8e-242">如果同步呼叫未在約定的時間內完成，StackExchange.Redis 用戶端會擲回類似下列範例的逾時錯誤。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-242">If a synchronous call doesn’t complete in the stipulated time, the StackExchange.Redis client throws a timeout error similar to the following example.</span></span>

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


<span data-ttu-id="8bc8e-243">此錯誤訊息包含的度量可協助指出問題的原因和可能的解決方案。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-243">This error message contains metrics that can help point you to the cause and possible resolution of the issue.</span></span> <span data-ttu-id="8bc8e-244">下表包含有關錯誤訊息度量的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-244">The following table contains details about the error message metrics.</span></span>

| <span data-ttu-id="8bc8e-245">錯誤訊息度量</span><span class="sxs-lookup"><span data-stu-id="8bc8e-245">Error message metric</span></span> | <span data-ttu-id="8bc8e-246">詳細資料</span><span class="sxs-lookup"><span data-stu-id="8bc8e-246">Details</span></span> |
| --- | --- |
| <span data-ttu-id="8bc8e-247">inst</span><span class="sxs-lookup"><span data-stu-id="8bc8e-247">inst</span></span> |<span data-ttu-id="8bc8e-248">在最後一個時間配量︰已發出 0 個命令</span><span class="sxs-lookup"><span data-stu-id="8bc8e-248">In the last time slice: 0 commands have been issued</span></span> |
| <span data-ttu-id="8bc8e-249">mgr</span><span class="sxs-lookup"><span data-stu-id="8bc8e-249">mgr</span></span> |<span data-ttu-id="8bc8e-250">通訊端管理員正在執行 `socket.select` ，這表示它會要求 OS 指出有工作需要執行的通訊端；基本上︰讀取器不會主動從網路讀取，因為它不認為有工作需要執行</span><span class="sxs-lookup"><span data-stu-id="8bc8e-250">The socket manager is performing `socket.select` which means it is asking the OS to indicate a socket that has something to do; basically: the reader is not actively reading from the network because it doesn't think there is anything to do</span></span> |
| <span data-ttu-id="8bc8e-251">佇列</span><span class="sxs-lookup"><span data-stu-id="8bc8e-251">queue</span></span> |<span data-ttu-id="8bc8e-252">總共有 73 個進行中的作業</span><span class="sxs-lookup"><span data-stu-id="8bc8e-252">There are 73 total in-progress operations</span></span> |
| <span data-ttu-id="8bc8e-253">qu</span><span class="sxs-lookup"><span data-stu-id="8bc8e-253">qu</span></span> |<span data-ttu-id="8bc8e-254">在進行中的作業中，有 6 個位於未傳送的佇列，尚未寫入至輸出網路</span><span class="sxs-lookup"><span data-stu-id="8bc8e-254">6 of the in-progress operations are in the unsent queue and have not yet been written to the outbound network</span></span> |
| <span data-ttu-id="8bc8e-255">qs</span><span class="sxs-lookup"><span data-stu-id="8bc8e-255">qs</span></span> |<span data-ttu-id="8bc8e-256">在進行中的作業中，有 67 個已傳送至伺服器，但尚未取得回應。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-256">67 of he in-progress operations have been sent to the server but a response is not yet available.</span></span> <span data-ttu-id="8bc8e-257">回應可能是 `Not yet sent by the server` 或 `sent by the server but not yet processed by the client.`</span><span class="sxs-lookup"><span data-stu-id="8bc8e-257">The response could be `Not yet sent by the server` or `sent by the server but not yet processed by the client.`</span></span> |
| <span data-ttu-id="8bc8e-258">qc</span><span class="sxs-lookup"><span data-stu-id="8bc8e-258">qc</span></span> |<span data-ttu-id="8bc8e-259">在進行中的作業中，有 0 個已看見回覆，但尚未標示為已完成，因為正在等候完成迴圈</span><span class="sxs-lookup"><span data-stu-id="8bc8e-259">0 of the in-progress operations have seen replies but have not yet been marked as complete due to waiting on the completion loop</span></span> |
| <span data-ttu-id="8bc8e-260">wr</span><span class="sxs-lookup"><span data-stu-id="8bc8e-260">wr</span></span> |<span data-ttu-id="8bc8e-261">有作用的寫入器 (亦即不會忽略 6 個未傳送的要求) 位元組/activewriter</span><span class="sxs-lookup"><span data-stu-id="8bc8e-261">There is an active writer (meaning the 6 unsent requests are not being ignored) bytes/activewriters</span></span> |
| <span data-ttu-id="8bc8e-262">了嗎</span><span class="sxs-lookup"><span data-stu-id="8bc8e-262">in</span></span> |<span data-ttu-id="8bc8e-263">沒有作用中的讀取器，在 NIC 位元組/activereader 上可供讀取的位元組為零</span><span class="sxs-lookup"><span data-stu-id="8bc8e-263">There are no active readers and zero bytes are available to be read on the NIC bytes/activereaders</span></span> |

### <a name="steps-to-investigate"></a><span data-ttu-id="8bc8e-264">調查步驟</span><span class="sxs-lookup"><span data-stu-id="8bc8e-264">Steps to investigate</span></span>
1. <span data-ttu-id="8bc8e-265">最佳作法是確定您在使用 StackExchange.Redis 用戶端來連線時，使用的是下列模式。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-265">As a best practice make sure you are using the following pattern to connect when using the StackExchange.Redis client.</span></span>

    ```c#
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
    });
    
    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ````

    <span data-ttu-id="8bc8e-266">如需詳細資訊，請參閱 [使用 StackExchange.Redis 來連線到快取](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-266">For more information, see [Connect to the cache using StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).</span></span>

1. <span data-ttu-id="8bc8e-267">確定 Azure Redis 快取和用戶端應用程式位在 Azure 中的相同區域。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-267">Ensure that your Azure Redis Cache and the client application are in the same region in Azure.</span></span> <span data-ttu-id="8bc8e-268">例如，當快取位在美國東部，但用戶端位在美國西部，而要求未在 `synctimeout` 間隔內完成時，您可能會收到逾時，或者當您從本機開發電腦進行偵錯時，您可能會收到逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-268">For example, you might be getting timeouts when your cache is in East US but the client is in West US and the request doesn't complete within the `synctimeout` interval or you might be getting timeouts when you are debugging from your local development machine.</span></span> 
   
    <span data-ttu-id="8bc8e-269">強烈建議您讓快取和用戶端位在相同的 Azure 區域中。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-269">It’s highly recommended to have the cache and in the client in the same Azure region.</span></span> <span data-ttu-id="8bc8e-270">如果您有包含跨區域呼叫的案例，您應該將 `synctimeout` 間隔設定為大於預設值 1000 毫秒間隔的值，方法是在連接字串中加入 `synctimeout` 屬性。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-270">If you have a scenario that includes cross region calls, you should set the `synctimeout` interval to a value higher than the default 1000 ms interval by including a `synctimeout` property in the connection string.</span></span> <span data-ttu-id="8bc8e-271">下列範例示範 `synctimeout` 為 2000 毫秒的 StackExchange.Redis 快取連接字串程式碼片段。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-271">The following example shows a StackExchange.Redis cache connection string snippet with a `synctimeout` of 2000 ms.</span></span>
   
        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
2. <span data-ttu-id="8bc8e-272">請確定您使用最新版的 [StackExchange.Redis NuGet 封裝](https://www.nuget.org/packages/StackExchange.Redis/)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-272">Ensure you using the latest version of the [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="8bc8e-273">程式碼中的錯誤會經常修正，以便更能應付逾時問題，因此請務必要擁有最新版本。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-273">There are bugs constantly being fixed in the code to make it more robust to timeouts so having the latest version is important.</span></span>
3. <span data-ttu-id="8bc8e-274">如果伺服器或用戶端上有要求受到頻寬限制所侷限，則可能需要較長時間才能完成，因而會導致逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-274">If there are requests that are getting bound by bandwidth limitations on the server or client, it will take longer for them to complete and thereby cause timeouts.</span></span> <span data-ttu-id="8bc8e-275">若要確認逾時是不是因為伺服器上的網路頻寬所導致，請參閱 [超過伺服器端頻寬](#server-side-bandwidth-exceeded)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-275">To see if your timeout is due to network bandwidth on the server, see [Server side bandwidth exceeded](#server-side-bandwidth-exceeded).</span></span> <span data-ttu-id="8bc8e-276">若要確認逾時是不是因為用戶端網路頻寬所導致，請參閱 [超過用戶端頻寬](#client-side-bandwidth-exceeded)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-276">To see if your timeout is due to client network bandwidth, see [Client side bandwidth exceeded](#client-side-bandwidth-exceeded).</span></span>
4. <span data-ttu-id="8bc8e-277">您是否在伺服器或用戶端上受到 CPU 限制？</span><span class="sxs-lookup"><span data-stu-id="8bc8e-277">Are you getting CPU bound on the server or on the client?</span></span>
   
   * <span data-ttu-id="8bc8e-278">確認您是否在用戶端上受到 CPU 限制，而可能造成要求未在 `synctimeout` 間隔內進行處理，進而導致逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-278">Check if you are getting bound by CPU on your client which could cause the request to not be processed within the `synctimeout` interval, thus causing a timeout.</span></span> <span data-ttu-id="8bc8e-279">改用較大的用戶端或分散負載有助於控制此問題。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-279">Moving to a larger client size or distributing the load can help to control this.</span></span> 
   * <span data-ttu-id="8bc8e-280">確認您是否在伺服器上受到 CPU 限制，方法是監視 `CPU` [快取效能度量](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-280">Check if you are getting CPU bound on the server by monitoring the `CPU` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="8bc8e-281">如果要求在 Redis 受到 CPU 限制時傳入，則可能會造成這些要求逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-281">Requests coming in while Redis is CPU bound can cause those requests to timeout.</span></span> <span data-ttu-id="8bc8e-282">若要解決此問題，您可以將負載分散在高階快取的多個分區中，或升級至較大的大小或定價層。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-282">To address this you can distribute the load across multiple shards in a premium cache, or upgrade to a larger size or pricing tier.</span></span> <span data-ttu-id="8bc8e-283">如需詳細資訊，請參閱 [超過伺服器端頻寬](#server-side-bandwidth-exceeded)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-283">For more information, see [Server Side Bandwidth Exceeded](#server-side-bandwidth-exceeded).</span></span>
5. <span data-ttu-id="8bc8e-284">伺服器上是否有命令需要很長的處理時間？</span><span class="sxs-lookup"><span data-stu-id="8bc8e-284">Are there commands taking long time to process on the server?</span></span> <span data-ttu-id="8bc8e-285">Redis 伺服器上處理時間很長的長時間執行命令可能會導致逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-285">Long running commands that are taking long time to process on the redis-server can cause timeouts.</span></span> <span data-ttu-id="8bc8e-286">長時間執行之命令的部分範例包括有大量金鑰的 `mget`、`keys *` 或編寫得不好的 lua 指令碼。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-286">Some examples of long running commands are `mget` with large numbers of keys, `keys *` or poorly written lua scripts.</span></span> <span data-ttu-id="8bc8e-287">您可以使用 redis-cli 用戶端連線到 Azure Redis 快取執行個體，或使用 [Redis 主控台](cache-configure.md#redis-console)並執行 [SlowLog](http://redis.io/commands/slowlog) 命令，以查看是否有要求花費的時間超出預期。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-287">You can connect to your Azure Redis Cache instance using the redis-cli client or use the [Redis Console](cache-configure.md#redis-console) and run the [SlowLog](http://redis.io/commands/slowlog) command to see if there are requests taking longer than expected.</span></span> <span data-ttu-id="8bc8e-288">Redis 伺服器和 StackExchange.Redis 最適合許多小型要求，而非少數幾個大型要求。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-288">Redis Server and StackExchange.Redis are optimized for many small requests rather than fewer large requests.</span></span> <span data-ttu-id="8bc8e-289">將資料分割成較小的區塊可以改善這些問題。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-289">Splitting your data into smaller chunks may improve things here.</span></span> 
   
    <span data-ttu-id="8bc8e-290">如需使用 redis-cli 和 stunnel 連線到 Azure Redis 快取 SSL 端點的相關資訊，請參閱 [宣佈 Redis 預覽版本的 ASP.NET 工作階段狀態提供者](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) 部落格文章。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-290">For information on connecting to the Azure Redis Cache SSL endpoint using redis-cli and stunnel, see the [Announcing ASP.NET Session State Provider for Redis Preview Release](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) blog post.</span></span> <span data-ttu-id="8bc8e-291">如需詳細資訊，請參閱 [SlowLog](http://redis.io/commands/slowlog)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-291">For more information, see [SlowLog](http://redis.io/commands/slowlog).</span></span>
6. <span data-ttu-id="8bc8e-292">高 Redis 伺服器負載可能會導致逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-292">High Redis server load can cause timeouts.</span></span> <span data-ttu-id="8bc8e-293">您可以藉由監視 `Redis Server Load` [快取效能度量](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)來監視伺服器負載。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-293">You can monitor the server load by monitoring the `Redis Server Load` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="8bc8e-294">伺服器負載為 100 (最大值) 表示 Redis 伺服器正忙碌處理要求，並沒有閒置的時間。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-294">A server load of 100 (maximum value) signifies that the redis server has been busy, with no idle time, processing requests.</span></span> <span data-ttu-id="8bc8e-295">若要確認特定要求是否會佔用所有伺服器功能，請執行 SlowLog 命令，如上一段所述。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-295">To see if certain requests are taking up all of the server capability, run the SlowLog command, as described in the previous paragraph.</span></span> <span data-ttu-id="8bc8e-296">如需詳細資訊，請參閱 [高 CPU 使用率/伺服器負載](#high-cpu-usage-server-load)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-296">For more information, see [High CPU usage / Server Load](#high-cpu-usage-server-load).</span></span>
7. <span data-ttu-id="8bc8e-297">用戶端上是否有其他任何事件可能導致網路問題？</span><span class="sxs-lookup"><span data-stu-id="8bc8e-297">Was there any other event on the client side that could have caused a network blip?</span></span> <span data-ttu-id="8bc8e-298">檢查用戶端 (Web、背景工作角色或 Iaas VM) 上是否有用戶端執行個體數目相應增加或相應減少，或部署新版用戶端或已啟用自動調整之類的事件？我們在測試中發現，自動調整或相應增加/相應減少可能會導致輸出網路連線中斷幾秒鐘。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-298">Check on the client (web, worker role or an Iaas VM) if there was an event like scaling the number of client instances up or down, or deploying a new version of the client or auto-scale is enabled?In our testing we have found that autoscale or scaling up/down can cause outbound network connectivity can be lost for several seconds.</span></span> <span data-ttu-id="8bc8e-299">StackExchange.Redis 程式碼對於這類事件具有復原能力，因此將會重新連線。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-299">StackExchange.Redis code is resilient to such events and will reconnect.</span></span> <span data-ttu-id="8bc8e-300">在重新連線的這段時間內，佇列中的任何要求都會逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-300">During this time of re-connection any requests in the queue can time out.</span></span>
8. <span data-ttu-id="8bc8e-301">針對 Redis 快取，在幾個小型要求之前是否有大型要求已逾時？</span><span class="sxs-lookup"><span data-stu-id="8bc8e-301">Was there a big request preceding several small requests to the Redis Cache that timed out?</span></span> <span data-ttu-id="8bc8e-302">錯誤訊息中的參數 `qs` 會告訴您有多少要求已從用戶端傳送到伺服器，但尚未處理回應。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-302">The parameter `qs` in the error message tells you how many requests were sent from the client to the server, but have not yet processed a response.</span></span> <span data-ttu-id="8bc8e-303">這個值會不斷成長，因為 StackExchange.Redis 使用單一 TCP 連線，而且一次只能讀取一個回應。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-303">This value can keep growing because StackExchange.Redis uses a single TCP connection and can only read one response at a time.</span></span> <span data-ttu-id="8bc8e-304">即使第一項作業已逾時，它也不會停止傳送資料到伺服器/從伺服器傳出資料，在這項作業完成之前，其他要求都會遭到封鎖，因而導致逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-304">Even though the first operation timed out, it does not stop the data being sent to/from the server, and other requests are blocked until this is finished, causing time outs.</span></span> <span data-ttu-id="8bc8e-305">有一個解決方案是確保快取足以容納工作負載，並將較大的值分割成較小的區塊，以將逾時的機會降到最低。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-305">One solution is to minimize the chance of timeouts by ensuring that your cache is large enough for your workload and splitting large values into smaller chunks.</span></span> <span data-ttu-id="8bc8e-306">另一個可能的解決方案是在用戶端中使用 `ConnectionMultiplexer` 物件集區，並在傳送新要求時選擇最少負載的 `ConnectionMultiplexer`。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-306">Another possible solution is to use a pool of `ConnectionMultiplexer` objects in your client, and choose the least loaded `ConnectionMultiplexer` when sending a new request.</span></span> <span data-ttu-id="8bc8e-307">這應該就能防止單一逾時造成其他要求也逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-307">This should prevent a single timeout from causing other requests to also timeout.</span></span>
9. <span data-ttu-id="8bc8e-308">如果您使用 `RedisSessionStateprovider`，請確定您已正確設定重試逾時。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-308">If you are using `RedisSessionStateprovider`, ensure you have set the retry timeout correctly.</span></span> <span data-ttu-id="8bc8e-309">`retrytimeoutInMilliseconds` 應高於 `operationTimeoutinMilliseonds`，否則不會發生任何重試。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-309">`retrytimeoutInMilliseconds` should be higher than `operationTimeoutinMilliseonds`, otherwise no retries will occur.</span></span> <span data-ttu-id="8bc8e-310">在下列範例中， `retrytimeoutInMilliseconds` 已設定為 3000。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-310">In the following example `retrytimeoutInMilliseconds` is set to 3000.</span></span> <span data-ttu-id="8bc8e-311">如需詳細資訊，請參閱 [Azure Redis 快取的 ASP.NET 工作階段狀態供應器](cache-aspnet-session-state-provider.md)和[如何使用工作階段狀態供應器與輸出快取提供者的組態參數](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-311">For more information, see [ASP.NET Session State Provider for Azure Redis Cache](cache-aspnet-session-state-provider.md) and [How to use the configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).</span></span>

    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


1. <span data-ttu-id="8bc8e-312">請透過[監視](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` 和 `Used Memory`，檢查 Azure Redis 快取伺服器上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-312">Check memory usage on the Azure Redis Cache server by [monitoring](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` and `Used Memory`.</span></span> <span data-ttu-id="8bc8e-313">如果已備有收回原則，Redis 就會在 `Used_Memory` 達到快取大小時開始收回金鑰。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-313">If an eviction policy is in place, Redis starts evicting keys when `Used_Memory` reaches the cache size.</span></span> <span data-ttu-id="8bc8e-314">理想情況下，`Used Memory RSS` 應該只稍微高於 `Used memory`。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-314">Ideally, `Used Memory RSS` should be only slightly higher than `Used memory`.</span></span> <span data-ttu-id="8bc8e-315">差異很大表示記憶體分散 (內部或外部)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-315">A large difference means there is memory fragmentation (internal or external.</span></span> <span data-ttu-id="8bc8e-316">當 `Used Memory RSS` 小於 `Used Memory` 時，則表示作業系統已交換部分快取記憶體。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-316">When `Used Memory RSS` is less than `Used Memory`, it means part of the cache memory has been swapped  by the operating system.</span></span> <span data-ttu-id="8bc8e-317">如果發生這種情況，您應該就會遇到顯著的延遲。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-317">If this occurs you can expect some significant latencies.</span></span> <span data-ttu-id="8bc8e-318">因為 Redis 無法控制其配置對應到記憶體分頁的方式，高 `Used Memory RSS` 通常是記憶體使用量突然增加的結果。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-318">Because Redis does not have control over how its allocations are mapped to memory pages, high `Used Memory RSS` is often the result of a spike in memory usage.</span></span> <span data-ttu-id="8bc8e-319">當 Redis 釋放記憶體時，記憶體會回到配置器，但配置器不一定會重新提供記憶體給系統。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-319">When Redis frees memory, the memory is given back to the allocator, and the allocator may or may not give the memory back to the system.</span></span> <span data-ttu-id="8bc8e-320">`Used Memory` 值和作業系統報告的記憶體耗用量可能會有差異。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-320">There may be a discrepancy between the `Used Memory` value and memory consumption as reported by the operating system.</span></span> <span data-ttu-id="8bc8e-321">原因可能是 Redis 已使用並釋放記憶體，但未交回給系統。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-321">It may be due to the fact memory has been used and released by Redis, but not given back to the system.</span></span> <span data-ttu-id="8bc8e-322">若要降低記憶體問題，您可以執行下列步驟。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-322">To help mitigate memory issues you can perform the following steps.</span></span>
   
   * <span data-ttu-id="8bc8e-323">將快取升級為更大的大小，以免達到系統的記憶體限制。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-323">Upgrade the cache to a larger size so that you are not running up against memory limitations on the system.</span></span>
   * <span data-ttu-id="8bc8e-324">設定金鑰的到期時間，以便主動收回較舊的值。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-324">Set expiration times on the keys so that older values are evicted proactively.</span></span>
   * <span data-ttu-id="8bc8e-325">監視 `used_memory_rss` 快取度量。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-325">Monitor the the `used_memory_rss` cache metric.</span></span> <span data-ttu-id="8bc8e-326">當這個值接近其快取的大小時，您可能會開始看到效能問題。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-326">When this value approaches the size of their cache, you are likely to start seeing performance issues.</span></span> <span data-ttu-id="8bc8e-327">請將資料分散到多個分區 (如果您使用高階快取)，或升級至較大的快取大小。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-327">Distribute the data across multiple shards if you are using a premium cache, or upgrade to a larger cache size.</span></span>
   
   <span data-ttu-id="8bc8e-328">如需詳細資訊，請參閱 [伺服器上的記憶體壓力](#memory-pressure-on-the-server)。</span><span class="sxs-lookup"><span data-stu-id="8bc8e-328">For more information, see [Memory Pressure on the server](#memory-pressure-on-the-server).</span></span>

## <a name="additional-information"></a><span data-ttu-id="8bc8e-329">其他資訊</span><span class="sxs-lookup"><span data-stu-id="8bc8e-329">Additional information</span></span>
* [<span data-ttu-id="8bc8e-330">應該使用哪個 Redis 快取供應項目和大小？</span><span class="sxs-lookup"><span data-stu-id="8bc8e-330">What Redis Cache offering and size should I use?</span></span>](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
* [<span data-ttu-id="8bc8e-331">如何效能評定和測試我快取的效能？</span><span class="sxs-lookup"><span data-stu-id="8bc8e-331">How can I benchmark and test the performance of my cache?</span></span>](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
* [<span data-ttu-id="8bc8e-332">如何執行 Redis 命令？</span><span class="sxs-lookup"><span data-stu-id="8bc8e-332">How can I run Redis commands?</span></span>](cache-faq.md#how-can-i-run-redis-commands)
* [<span data-ttu-id="8bc8e-333">如何監視 Azure Redis 快取</span><span class="sxs-lookup"><span data-stu-id="8bc8e-333">How to monitor Azure Redis Cache</span></span>](cache-how-to-monitor.md)

