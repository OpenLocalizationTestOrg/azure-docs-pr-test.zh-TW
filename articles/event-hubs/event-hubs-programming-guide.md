---
title: "Azure 事件中樞的程式設計指南 | Microsoft Docs"
description: "使用 Azure .NET SDK 撰寫 Azure 事件中樞的程式碼。"
services: event-hubs
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 64cbfd3d-4a0e-4455-a90a-7f3d4f080323
ms.service: event-hubs
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: tbd
ms.date: 08/17/2017
ms.author: sethm
ms.openlocfilehash: 405ec2b27b488b570c4a5c86e4950ff98233360e
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/18/2017
---
# <a name="event-hubs-programming-guide"></a><span data-ttu-id="56b8b-103">事件中樞程式設計指南</span><span class="sxs-lookup"><span data-stu-id="56b8b-103">Event Hubs programming guide</span></span>

<span data-ttu-id="56b8b-104">本文會討論一些使用 Azure 事件中樞和 Azure .NET SDK 來撰寫程式碼的常見案例。</span><span class="sxs-lookup"><span data-stu-id="56b8b-104">This article discusses some common scenarios in writing code using Azure Event Hubs and the Azure .NET SDK.</span></span> <span data-ttu-id="56b8b-105">它假設使用者對事件中樞已有初步了解。</span><span class="sxs-lookup"><span data-stu-id="56b8b-105">It assumes a preliminary understanding of Event Hubs.</span></span> <span data-ttu-id="56b8b-106">如需事件中樞的概念概觀，請參閱 [事件中樞概觀](event-hubs-what-is-event-hubs.md)。</span><span class="sxs-lookup"><span data-stu-id="56b8b-106">For a conceptual overview of Event Hubs, see the [Event Hubs overview](event-hubs-what-is-event-hubs.md).</span></span>

## <a name="event-publishers"></a><span data-ttu-id="56b8b-107">事件發佈者</span><span class="sxs-lookup"><span data-stu-id="56b8b-107">Event publishers</span></span>

<span data-ttu-id="56b8b-108">您可以使用 HTTP POST 或透過 AMQP 1.0 連線，將事件傳送到事件中樞。</span><span class="sxs-lookup"><span data-stu-id="56b8b-108">You send events to an event hub either using HTTP POST or via an AMQP 1.0 connection.</span></span> <span data-ttu-id="56b8b-109">使用選擇取決於應用的特定案例。</span><span class="sxs-lookup"><span data-stu-id="56b8b-109">The choice of which to use and when depends on the specific scenario being addressed.</span></span> <span data-ttu-id="56b8b-110">AMQP 1.0 連線是以服務匯流排中的代理連線形式計量，其較適合經常出現大量訊息且需要低延遲的案例，因為它們可提供持續的傳訊通道。</span><span class="sxs-lookup"><span data-stu-id="56b8b-110">AMQP 1.0 connections are metered as brokered connections in Service Bus and are more appropriate in scenarios with frequent higher message volumes and lower latency requirements, as they provide a persistent messaging channel.</span></span>

<span data-ttu-id="56b8b-111">您可以使用 [NamespaceManager][] 類別來建立及管理事件中樞。</span><span class="sxs-lookup"><span data-stu-id="56b8b-111">You create and manage Event Hubs using the [NamespaceManager][] class.</span></span> <span data-ttu-id="56b8b-112">在使用 .NET Managed API 時，用於將資料發佈到事件中樞的主要建構是 [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) 和 [EventData][] 類別。</span><span class="sxs-lookup"><span data-stu-id="56b8b-112">When using the .NET managed APIs, the primary constructs for publishing data to Event Hubs are the [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) and [EventData][] classes.</span></span> <span data-ttu-id="56b8b-113">[EventHubClient][] 提供將事件傳送到事件中樞時所透過的 AMQP 通訊通道。</span><span class="sxs-lookup"><span data-stu-id="56b8b-113">[EventHubClient][] provides the AMQP communication channel over which events are sent to the event hub.</span></span> <span data-ttu-id="56b8b-114">[EventData][] 類別代表事件，可用來將訊息發佈到事件中樞。</span><span class="sxs-lookup"><span data-stu-id="56b8b-114">The [EventData][] class represents an event, and is used to publish messages to an event hub.</span></span> <span data-ttu-id="56b8b-115">這個類別包含主體、一些中繼資料，以及有關事件的標頭資訊。</span><span class="sxs-lookup"><span data-stu-id="56b8b-115">This class includes the body, some metadata, and header information about the event.</span></span> <span data-ttu-id="56b8b-116">當 [EventData][] 物件通過事件中樞時，系統會為它新增其他屬性。</span><span class="sxs-lookup"><span data-stu-id="56b8b-116">Other properties are added to the [EventData][] object as it passes through an event hub.</span></span>

## <a name="get-started"></a><span data-ttu-id="56b8b-117">開始使用</span><span class="sxs-lookup"><span data-stu-id="56b8b-117">Get started</span></span>

<span data-ttu-id="56b8b-118">Microsoft.ServiceBus.dll 組件中會提供支援事件中樞的 .NET 類別。</span><span class="sxs-lookup"><span data-stu-id="56b8b-118">The .NET classes that support Event Hubs are provided in the Microsoft.ServiceBus.dll assembly.</span></span> <span data-ttu-id="56b8b-119">要參考服務匯流排 API，並設定應用程式以使用所有服務匯流排相依性，最簡單方法是下載 [服務匯流排 NuGet 封裝](https://www.nuget.org/packages/WindowsAzure.ServiceBus)。</span><span class="sxs-lookup"><span data-stu-id="56b8b-119">The easiest way to reference the Service Bus API and to configure your application with all of the Service Bus dependencies is to download the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span></span> <span data-ttu-id="56b8b-120">或者，您也可以在 Visual Studio 中使用 [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) 。</span><span class="sxs-lookup"><span data-stu-id="56b8b-120">Alternatively, you can use the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) in Visual Studio.</span></span> <span data-ttu-id="56b8b-121">若要這樣做，請在 [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) 視窗中發出下列命令：</span><span class="sxs-lookup"><span data-stu-id="56b8b-121">To do so, issue the following command in the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) window:</span></span>

```
Install-Package WindowsAzure.ServiceBus
```

## <a name="create-an-event-hub"></a><span data-ttu-id="56b8b-122">建立事件中心</span><span class="sxs-lookup"><span data-stu-id="56b8b-122">Create an event hub</span></span>
<span data-ttu-id="56b8b-123">您可以使用 [NamespaceManager][] 類別來建立事件中樞。</span><span class="sxs-lookup"><span data-stu-id="56b8b-123">You can use the [NamespaceManager][] class to create Event Hubs.</span></span> <span data-ttu-id="56b8b-124">例如：</span><span class="sxs-lookup"><span data-stu-id="56b8b-124">For example:</span></span>

```csharp
var manager = new Microsoft.ServiceBus.NamespaceManager("mynamespace.servicebus.windows.net");
var description = manager.CreateEventHub("MyEventHub");
```

<span data-ttu-id="56b8b-125">在大部分情況下，建議您使用 [CreateEventHubIfNotExists][] 方法，以避免在服務重新啟動時產生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="56b8b-125">In most cases, it is recommended that you use the [CreateEventHubIfNotExists][] methods to avoid generating exceptions if the service restarts.</span></span> <span data-ttu-id="56b8b-126">例如：</span><span class="sxs-lookup"><span data-stu-id="56b8b-126">For example:</span></span>

```csharp
var description = manager.CreateEventHubIfNotExists("MyEventHub");
```

<span data-ttu-id="56b8b-127">所有事件中樞建立作業 (包括 [CreateEventHubIfNotExists][])，都需要論述之命名空間的 **管理** 權限。</span><span class="sxs-lookup"><span data-stu-id="56b8b-127">All Event Hubs creation operations, including [CreateEventHubIfNotExists][], require **Manage** permissions on the namespace in question.</span></span> <span data-ttu-id="56b8b-128">如果您想要限制發佈者或取用者應用程式的權限，可以在使用有限權限認證時，於實際執行程式碼中避免這些建立作業呼叫。</span><span class="sxs-lookup"><span data-stu-id="56b8b-128">If you want to limit the permissions of your publisher or consumer applications, you can avoid these create operation calls in production code when you use credentials with limited permissions.</span></span>

<span data-ttu-id="56b8b-129">[EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) 類別含有事件中樞的相關詳細資料，包括授權規則、訊息保留間隔、資料分割識別碼、狀態及路徑。</span><span class="sxs-lookup"><span data-stu-id="56b8b-129">The [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) class contains details about an event hub, including the authorization rules, the message retention interval, partition IDs, status, and path.</span></span> <span data-ttu-id="56b8b-130">您可以使用這個類別來更新事件中樞上的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="56b8b-130">You can use this class to update the metadata on an event hub.</span></span>

## <a name="create-an-event-hubs-client"></a><span data-ttu-id="56b8b-131">建立事件中樞用戶端</span><span class="sxs-lookup"><span data-stu-id="56b8b-131">Create an Event Hubs client</span></span>
<span data-ttu-id="56b8b-132">與事件中樞互動的主要類別是 [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient]。</span><span class="sxs-lookup"><span data-stu-id="56b8b-132">The primary class for interacting with Event Hubs is [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient].</span></span> <span data-ttu-id="56b8b-133">這個類別提供傳送者和接收者功能。</span><span class="sxs-lookup"><span data-stu-id="56b8b-133">This class provides both sender and receiver capabilities.</span></span> <span data-ttu-id="56b8b-134">您可以使用 [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) 方法來具現化這個類別，如以下範例所示。</span><span class="sxs-lookup"><span data-stu-id="56b8b-134">You can instantiate this class using the [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) method, as shown in the following example.</span></span>

```csharp
var client = EventHubClient.Create(description.Path);
```

<span data-ttu-id="56b8b-135">這個方法會使用 App.config 檔案之 `appSettings` 區段中的服務匯流排連線資訊。</span><span class="sxs-lookup"><span data-stu-id="56b8b-135">This method uses the Service Bus connection information in the App.config file, in the `appSettings` section.</span></span> <span data-ttu-id="56b8b-136">如需用來儲存服務匯流排連線資訊之 `appSettings` XML 的範例，請參閱 [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) 方法的文件。</span><span class="sxs-lookup"><span data-stu-id="56b8b-136">For an example of the `appSettings` XML used to store the Service Bus connection information, see the documentation for the [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method.</span></span>

<span data-ttu-id="56b8b-137">另一個選項是從連接字串建立用戶端。</span><span class="sxs-lookup"><span data-stu-id="56b8b-137">Another option is to create the client from a connection string.</span></span> <span data-ttu-id="56b8b-138">這個選項適合用來搭配 Azure 背景工作角色，因為您可以將字串儲存在背景工作的組態屬性中。</span><span class="sxs-lookup"><span data-stu-id="56b8b-138">This option works well when using Azure worker roles, because you can store the string in the configuration properties for the worker.</span></span> <span data-ttu-id="56b8b-139">例如：</span><span class="sxs-lookup"><span data-stu-id="56b8b-139">For example:</span></span>

```csharp
EventHubClient.CreateFromConnectionString("your_connection_string");
```

<span data-ttu-id="56b8b-140">連接字串的格式與在前述方法之 App.config 檔案中的格式相同：</span><span class="sxs-lookup"><span data-stu-id="56b8b-140">The connection string will be in the same format as it appears in the App.config file for the previous methods:</span></span>

```
Endpoint=sb://[namespace].servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=[key]
```

<span data-ttu-id="56b8b-141">最後，它也可以建立從 [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) 執行個體建立 [EventHubClient][] 物件，如以下範例所示。</span><span class="sxs-lookup"><span data-stu-id="56b8b-141">Finally, it is also possible to create an [EventHubClient][] object from a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance, as shown in the following example.</span></span>

```csharp
var factory = MessagingFactory.CreateFromConnectionString("your_connection_string");
var client = factory.CreateEventHubClient("MyEventHub");
```

<span data-ttu-id="56b8b-142">請務必注意，從傳訊處理站執行個體建立的額外 [EventHubClient][] 物件，將重複使用相同的基礎 TCP 連線。</span><span class="sxs-lookup"><span data-stu-id="56b8b-142">It is important to note that additional [EventHubClient][] objects created from a messaging factory instance will reuse the same underlying TCP connection.</span></span> <span data-ttu-id="56b8b-143">因此，這些物件對用戶端的輸送量將受到限制。</span><span class="sxs-lookup"><span data-stu-id="56b8b-143">Therefore, these objects have a client-side limit on throughput.</span></span> <span data-ttu-id="56b8b-144">[Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) 方法會重複使用一個傳訊處理站。</span><span class="sxs-lookup"><span data-stu-id="56b8b-144">The [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method reuses a single messaging factory.</span></span> <span data-ttu-id="56b8b-145">如果您與單一傳送者之間需要大量輸送量，可以建立多個訊息處理站，並從每個傳訊處理站建立一個 [EventHubClient][] 物件。</span><span class="sxs-lookup"><span data-stu-id="56b8b-145">If you need very high throughput from a single sender, then you can create multiple message factories and one [EventHubClient][] object from each messaging factory.</span></span>

## <a name="send-events-to-an-event-hub"></a><span data-ttu-id="56b8b-146">將事件傳送到事件中樞</span><span class="sxs-lookup"><span data-stu-id="56b8b-146">Send events to an event hub</span></span>
<span data-ttu-id="56b8b-147">您可以藉由建立 [EventData][] 執行個體並透過 [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) 方法傳送它，將事件傳送到事件中樞。</span><span class="sxs-lookup"><span data-stu-id="56b8b-147">You send events to an event hub by creating an [EventData][] instance and sending it via the [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) method.</span></span> <span data-ttu-id="56b8b-148">這個方法會採用單一 [EventData][] 執行個體參數，並以同步方式將它傳送到事件中樞。</span><span class="sxs-lookup"><span data-stu-id="56b8b-148">This method takes a single [EventData][] instance parameter and synchronously sends it to an event hub.</span></span>

## <a name="event-serialization"></a><span data-ttu-id="56b8b-149">事件序列化</span><span class="sxs-lookup"><span data-stu-id="56b8b-149">Event serialization</span></span>
<span data-ttu-id="56b8b-150">[EventData][] 類別具有[四個多載建構函式](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_)，它們會採用許多不同的參數，如物件和序列化程式、位元組陣列或串流。</span><span class="sxs-lookup"><span data-stu-id="56b8b-150">The [EventData][] class has [four overloaded constructors](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_) that take a variety of parameters, such as an object and serializer, a byte array, or a stream.</span></span> <span data-ttu-id="56b8b-151">您也可以具現化 [EventData][] 類別，並在之後設定內文串流。</span><span class="sxs-lookup"><span data-stu-id="56b8b-151">It is also possible to instantiate the [EventData][] class and set the body stream afterwards.</span></span> <span data-ttu-id="56b8b-152">在搭配使用 JSON 和 [EventData][]時，您可以使用 **Encoding.UTF8.GetBytes()** 來擷取 JSON 編碼字串的位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="56b8b-152">When using JSON with [EventData][], you can use **Encoding.UTF8.GetBytes()** to retrieve the byte array for a JSON-encoded string.</span></span>

## <a name="partition-key"></a><span data-ttu-id="56b8b-153">資料分割索引鍵</span><span class="sxs-lookup"><span data-stu-id="56b8b-153">Partition key</span></span>
<span data-ttu-id="56b8b-154">[EventData][] 類別具有 [PartitionKey][] 屬性，可讓傳送者指定雜湊的值，以便產生資料分割指派。</span><span class="sxs-lookup"><span data-stu-id="56b8b-154">The [EventData][] class has a [PartitionKey][] property that enables the sender to specify a value that is hashed to produce a partition assignment.</span></span> <span data-ttu-id="56b8b-155">使用資料分割索引鍵可確保將所有具有相同索引鍵的事件，都傳送到事件中樞內的相同資料分割。</span><span class="sxs-lookup"><span data-stu-id="56b8b-155">Using a partition key ensures that all the events with the same key are sent to the same partition in the event hub.</span></span> <span data-ttu-id="56b8b-156">常見的資料分割索引鍵包含使用者工作階段識別碼和唯一的傳送者識別碼。</span><span class="sxs-lookup"><span data-stu-id="56b8b-156">Common partition keys include user session IDs and unique sender IDs.</span></span> <span data-ttu-id="56b8b-157">[PartitionKey][] 屬性是選擇性的，您可以在使用 [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) 或 [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) 方法時提供。</span><span class="sxs-lookup"><span data-stu-id="56b8b-157">The [PartitionKey][] property is optional and can be provided when using the [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) or [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) methods.</span></span> <span data-ttu-id="56b8b-158">如果您未提供 [PartitionKey][]值，系統會使用循環配置資源模型將傳送的事件散佈到多個資料分割。</span><span class="sxs-lookup"><span data-stu-id="56b8b-158">If you do not provide a value for [PartitionKey][], sent events are distributed to partitions using a round-robin model.</span></span>

### <a name="availability-considerations"></a><span data-ttu-id="56b8b-159">可用性考量</span><span class="sxs-lookup"><span data-stu-id="56b8b-159">Availability considerations</span></span>

<span data-ttu-id="56b8b-160">您可以選擇使用資料分割索引鍵，至於是否要使用，請您慎重考慮。</span><span class="sxs-lookup"><span data-stu-id="56b8b-160">Using a partition key is optional, and you should consider carefully whether or not to use one.</span></span> <span data-ttu-id="56b8b-161">在許多情況下，如果事件的順序很重要，您最好選擇使用資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="56b8b-161">In many cases, using a partition key is a good choice if event ordering is important.</span></span> <span data-ttu-id="56b8b-162">當您使用資料分割索引鍵時，這些資料分割必須在單一節點上可供使用，但經過一段時間後，節點有可能會發生中斷，例如在計算節點重新開機及修補時。</span><span class="sxs-lookup"><span data-stu-id="56b8b-162">When you use a partition key, these partitions require availability on a single node, and outages can occur over time; for example, when compute nodes reboot and patch.</span></span> <span data-ttu-id="56b8b-163">因此，如果您設定了資料分割識別碼，但該資料分割因為某些緣故變得無法使用，您就無法嘗試存取該資料分割中的資料。</span><span class="sxs-lookup"><span data-stu-id="56b8b-163">As such, if you set a partition ID and that partition becomes unavailable for some reason, an attempt to access the data in that partition will fail.</span></span> <span data-ttu-id="56b8b-164">如果您最重視的是高可用性，請勿指定資料分割索引鍵，因為在該情況下，事件會使用先前所述的循環配置資源模型傳送到資料分割。</span><span class="sxs-lookup"><span data-stu-id="56b8b-164">If high availability is most important, do not specify a partition key; in that case events will be sent to partitions using the round-robin model described previously.</span></span> <span data-ttu-id="56b8b-165">在此案例中，您必須在可用性 (沒有資料分割識別碼) 和一致性 (將事件繫結至資料分割識別碼) 之間做出明確抉擇。</span><span class="sxs-lookup"><span data-stu-id="56b8b-165">In this scenario, you are making an explicit choice between availability (no partition ID) and consistency (pinning events to a partition ID).</span></span>

<span data-ttu-id="56b8b-166">另一項考量是對處理事件的延遲進行處理。</span><span class="sxs-lookup"><span data-stu-id="56b8b-166">Another consideration is handling delays in processing events.</span></span> <span data-ttu-id="56b8b-167">有時候，捨棄資料並重試會比試著跟上處理腳步來得好，因為後者可能會導致下游處理延遲得更久。</span><span class="sxs-lookup"><span data-stu-id="56b8b-167">In some cases it might be better to drop data and retry than to try and keep up with processing, which can potentially cause further downstream processing delays.</span></span> <span data-ttu-id="56b8b-168">例如，拿股票行情即時看板來說，等待完整的最新資料會比較好，但在即時聊天或 VOIP 的案例中，您會寧願先收到資料，即便資料並不完整也沒關係。</span><span class="sxs-lookup"><span data-stu-id="56b8b-168">For example, with a stock ticker it's better to wait for complete up-to-date data, but in a live chat or VOIP scenario you'd rather have the data quickly, even if it isn't complete.</span></span>

<span data-ttu-id="56b8b-169">有鑑於上述可用性考量，您可能會在這些案例中選擇下列其中一個錯誤處理策略︰</span><span class="sxs-lookup"><span data-stu-id="56b8b-169">Given these availability considerations, in these scenarios you might choose one of the following error handling strategies:</span></span>

- <span data-ttu-id="56b8b-170">停止 (停止讀取事件中樞，直到情況獲得修正)</span><span class="sxs-lookup"><span data-stu-id="56b8b-170">Stop (stop reading from Event Hubs until things are fixed)</span></span>
- <span data-ttu-id="56b8b-171">捨棄 (訊息並不重要，將其卸除)</span><span class="sxs-lookup"><span data-stu-id="56b8b-171">Drop (messages aren’t important, drop them)</span></span>
- <span data-ttu-id="56b8b-172">重試 (視情況重試訊息)</span><span class="sxs-lookup"><span data-stu-id="56b8b-172">Retry (retry the messages as you see fit)</span></span>
- <span data-ttu-id="56b8b-173">[無效信件](../service-bus-messaging/service-bus-dead-letter-queues.md) (使用佇列或另一個事件中樞，以只將您無法處理的訊息設為無效)</span><span class="sxs-lookup"><span data-stu-id="56b8b-173">[Dead letter](../service-bus-messaging/service-bus-dead-letter-queues.md) (use a queue or another event hub to dead letter only the messages you couldn’t process)</span></span>

<span data-ttu-id="56b8b-174">如需可用性和一致性之間利弊得失的詳細資訊與討論，請參閱[事件中樞的可用性和一致性](event-hubs-availability-and-consistency.md)。</span><span class="sxs-lookup"><span data-stu-id="56b8b-174">For more information and a discussion about the trade-offs between availability and consistency, see [Availability and consistency in Event Hubs](event-hubs-availability-and-consistency.md).</span></span> 

## <a name="batch-event-send-operations"></a><span data-ttu-id="56b8b-175">批次事件傳送作業</span><span class="sxs-lookup"><span data-stu-id="56b8b-175">Batch event send operations</span></span>
<span data-ttu-id="56b8b-176">分批傳送事件能大幅增加輸送量。</span><span class="sxs-lookup"><span data-stu-id="56b8b-176">Sending events in batches can dramatically increase throughput.</span></span> <span data-ttu-id="56b8b-177">[SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) 方法會採用 [EventData][] 類型的 **IEnumerable** 參數，並將整個批次以不可部分完成的作業形式傳送到事件中樞。</span><span class="sxs-lookup"><span data-stu-id="56b8b-177">The [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) method takes an **IEnumerable** parameter of type [EventData][] and sends the entire batch as an atomic operation to the event hub.</span></span>

```csharp
public void SendBatch(IEnumerable<EventData> eventDataList);
```

<span data-ttu-id="56b8b-178">請注意，單一批次不能超過每個事件 256 KB 的限制。</span><span class="sxs-lookup"><span data-stu-id="56b8b-178">Note that a single batch must not exceed the 256 KB limit of an event.</span></span> <span data-ttu-id="56b8b-179">此外，批次中的每個訊息都會使用相同的身分識別。</span><span class="sxs-lookup"><span data-stu-id="56b8b-179">Additionally, each message in the batch uses the same publisher identity.</span></span> <span data-ttu-id="56b8b-180">確保批次未超過最大事件大小是傳送者的責任。</span><span class="sxs-lookup"><span data-stu-id="56b8b-180">It is the responsibility of the sender to ensure that the batch does not exceed the maximum event size.</span></span> <span data-ttu-id="56b8b-181">如果超過的話，系統會產生用戶端 **Send** 錯誤。</span><span class="sxs-lookup"><span data-stu-id="56b8b-181">If it does, a client **Send** error is generated.</span></span>

## <a name="send-asynchronously-and-send-at-scale"></a><span data-ttu-id="56b8b-182">以非同步方式傳送和大規模傳送</span><span class="sxs-lookup"><span data-stu-id="56b8b-182">Send asynchronously and send at scale</span></span>
<span data-ttu-id="56b8b-183">您也可以採用非同步方式將事件傳送到事件中樞。</span><span class="sxs-lookup"><span data-stu-id="56b8b-183">You can also send events to an event hub asynchronously.</span></span> <span data-ttu-id="56b8b-184">以非同步方式傳送可以增加用戶端傳送事件的速率。</span><span class="sxs-lookup"><span data-stu-id="56b8b-184">Sending asynchronously can increase the rate at which a client is able to send events.</span></span> <span data-ttu-id="56b8b-185">[Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) 和 [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) 這兩個方法都有會傳回 [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) 物件的非同步版本。</span><span class="sxs-lookup"><span data-stu-id="56b8b-185">Both the [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) and [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) methods are available in asynchronous versions that return a [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) object.</span></span> <span data-ttu-id="56b8b-186">雖然這項技術可以增加輸送量，不過如果實作不當，可能會造成用戶端在受到事件中樞服務節流的情況下繼續傳送事件，導致用戶端發生失敗或遺失訊息。</span><span class="sxs-lookup"><span data-stu-id="56b8b-186">While this technique can increase throughput, it can also cause the client to continue to send events even while it is being throttled by the Event Hubs service and can result in the client experiencing failures or lost messages if not properly implemented.</span></span> <span data-ttu-id="56b8b-187">此外，您還可以在用戶端上使用 [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) 屬性來控制用戶端重試選項。</span><span class="sxs-lookup"><span data-stu-id="56b8b-187">In addition, you can use the [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) property on the client to control client retry options.</span></span>

## <a name="create-a-partition-sender"></a><span data-ttu-id="56b8b-188">建立資料分割的傳送者</span><span class="sxs-lookup"><span data-stu-id="56b8b-188">Create a partition sender</span></span>
<span data-ttu-id="56b8b-189">雖然最常見的情況是不使用資料分割索引鍵就將事件傳送到事件中樞，不過在某些情況下，您可能會想要將事件直接傳送到指定的資料分割。</span><span class="sxs-lookup"><span data-stu-id="56b8b-189">Although it is most common to send events to an event hub without a partition key, in some cases you might want to send events directly to a given partition.</span></span> <span data-ttu-id="56b8b-190">例如：</span><span class="sxs-lookup"><span data-stu-id="56b8b-190">For example:</span></span>

```csharp
var partitionedSender = client.CreatePartitionedSender(description.PartitionIds[0]);
```

<span data-ttu-id="56b8b-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) 會傳回 [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) 物件，可供您用來將事件發佈到特定的事件中樞資料分割。</span><span class="sxs-lookup"><span data-stu-id="56b8b-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) returns an [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) object that you can use to publish events to a specific event hub partition.</span></span>

## <a name="event-consumers"></a><span data-ttu-id="56b8b-192">事件取用者</span><span class="sxs-lookup"><span data-stu-id="56b8b-192">Event consumers</span></span>
<span data-ttu-id="56b8b-193">事件中樞有兩個主要的事件取用模型：直接接收者和較高層級的抽象 (如 [EventProcessorHost][])。</span><span class="sxs-lookup"><span data-stu-id="56b8b-193">Event Hubs has two primary models for event consumption: direct receivers and higher-level abstractions, such as [EventProcessorHost][].</span></span> <span data-ttu-id="56b8b-194">直接接收者負責自行協調消費者群組內之資料分割的存取。</span><span class="sxs-lookup"><span data-stu-id="56b8b-194">Direct receivers are responsible for their own coordination of access to partitions within a consumer group.</span></span>

### <a name="direct-consumer"></a><span data-ttu-id="56b8b-195">直接消費者</span><span class="sxs-lookup"><span data-stu-id="56b8b-195">Direct consumer</span></span>
<span data-ttu-id="56b8b-196">要讀取消費者群組內的資料分割，最直接的方式是使用 [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) 類別。</span><span class="sxs-lookup"><span data-stu-id="56b8b-196">The most direct way to read from a partition within a consumer group is to use the [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) class.</span></span> <span data-ttu-id="56b8b-197">若要建立這個類別的執行個體，您必須使用 [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) 類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="56b8b-197">To create an instance of this class, you must use an instance of the [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) class.</span></span> <span data-ttu-id="56b8b-198">在以下範例中，您必須在建立消費者群組的接收者時指定資料分割識別碼。</span><span class="sxs-lookup"><span data-stu-id="56b8b-198">In the following example, the partition ID must be specified when creating the receiver for the consumer group.</span></span>

```csharp
EventHubConsumerGroup group = client.GetDefaultConsumerGroup();
var receiver = group.CreateReceiver(client.GetRuntimeInformation().PartitionIds[0]);
```

<span data-ttu-id="56b8b-199">[CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) 方法有幾個有助於控制所建立之讀取器的多載。</span><span class="sxs-lookup"><span data-stu-id="56b8b-199">The [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) method has several overloads that facilitate control over the reader being created.</span></span> <span data-ttu-id="56b8b-200">這些方法包括將位移指定為字串或時間戳記，以及讓您指定要在傳回的資料流中包括指定位移，或是在位移之後開始。</span><span class="sxs-lookup"><span data-stu-id="56b8b-200">These methods include specifying an offset as either a string or timestamp, and the ability to specify whether to include this specified offset in the returned stream, or start after it.</span></span> <span data-ttu-id="56b8b-201">建立接收者後，您可以開始接收有關傳回之物件的事件。</span><span class="sxs-lookup"><span data-stu-id="56b8b-201">After you create the receiver, you can start receiving events on the returned object.</span></span> <span data-ttu-id="56b8b-202">[Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) 方法有四個控制接收作業參數的多載，如批次大小和等待時間。</span><span class="sxs-lookup"><span data-stu-id="56b8b-202">The [Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) method has four overloads that control the receive operation parameters, such as batch size and wait time.</span></span> <span data-ttu-id="56b8b-203">若要增加消費者的輸送量，您可以使用這些方法的非同步版本。</span><span class="sxs-lookup"><span data-stu-id="56b8b-203">You can use the asynchronous versions of these methods to increase the throughput of a consumer.</span></span> <span data-ttu-id="56b8b-204">例如：</span><span class="sxs-lookup"><span data-stu-id="56b8b-204">For example:</span></span>

```csharp
bool receive = true;
string myOffset;
while(receive)
{
    var message = receiver.Receive();
    myOffset = message.Offset;
    string body = Encoding.UTF8.GetString(message.GetBytes());
    Console.WriteLine(String.Format("Received message offset: {0} \nbody: {1}", myOffset, body));
}
```

<span data-ttu-id="56b8b-205">對特定資料分割來說，訊息的接收順序與傳送到事件中樞時的順序相同。</span><span class="sxs-lookup"><span data-stu-id="56b8b-205">With respect to a specific partition, the messages are received in the order in which they were sent to the event hub.</span></span> <span data-ttu-id="56b8b-206">位移是一種字串權杖，它能用來識別資料分割中的訊息。</span><span class="sxs-lookup"><span data-stu-id="56b8b-206">The offset is a string token used to identify a message in a partition.</span></span>

<span data-ttu-id="56b8b-207">請注意，消費者群組內的單一資料分割一律不能擁有超過 5 個已連接的並行讀取器。</span><span class="sxs-lookup"><span data-stu-id="56b8b-207">Note that a single partition within a consumer group cannot have more than 5 concurrent readers connected at any time.</span></span> <span data-ttu-id="56b8b-208">當讀取器連接或中斷連線時，其工作階段可能會維持作用中狀態達數分鐘之久，服務才能辨識出它們已經中斷連線。</span><span class="sxs-lookup"><span data-stu-id="56b8b-208">As readers connect or become disconnected, their sessions might stay active for several minutes before the service recognizes that they have disconnected.</span></span> <span data-ttu-id="56b8b-209">在這段時間內，讀取器可能會無法重新連接資料分割。</span><span class="sxs-lookup"><span data-stu-id="56b8b-209">During this time, reconnecting to a partition may fail.</span></span> <span data-ttu-id="56b8b-210">如需撰寫事件中樞之直接接收者的完整範例，請參閱[事件中樞直接接收者](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6)範例。</span><span class="sxs-lookup"><span data-stu-id="56b8b-210">For a complete example of writing a direct receiver for Event Hubs, see the [Event Hubs Direct Receivers](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) sample.</span></span>

### <a name="event-processor-host"></a><span data-ttu-id="56b8b-211">事件處理器主機</span><span class="sxs-lookup"><span data-stu-id="56b8b-211">Event processor host</span></span>
<span data-ttu-id="56b8b-212">[EventProcessorHost][] 類別能處理來自事件中樞的資料。</span><span class="sxs-lookup"><span data-stu-id="56b8b-212">The [EventProcessorHost][] class processes data from Event Hubs.</span></span> <span data-ttu-id="56b8b-213">在 .NET 平台上建置事件讀取器時，您應該使用這項實作。</span><span class="sxs-lookup"><span data-stu-id="56b8b-213">You should use this implementation when building event readers on the .NET platform.</span></span> <span data-ttu-id="56b8b-214">[EventProcessorHost][] 能為事件處理器實作提供安全執行緒、多處理序、安全的執行階段環境，進而提供檢查點和資料分割租用管理。</span><span class="sxs-lookup"><span data-stu-id="56b8b-214">[EventProcessorHost][] provides a thread-safe, multi-process, safe runtime environment for event processor implementations that also provides checkpointing and partition lease management.</span></span>

<span data-ttu-id="56b8b-215">若要使用 [EventProcessorHost][] 類別，您可以實作 [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor)。</span><span class="sxs-lookup"><span data-stu-id="56b8b-215">To use the [EventProcessorHost][] class, you can implement [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor).</span></span> <span data-ttu-id="56b8b-216">這個介面包含三個方法：</span><span class="sxs-lookup"><span data-stu-id="56b8b-216">This interface contains three methods:</span></span>

* [<span data-ttu-id="56b8b-217">OpenAsync</span><span class="sxs-lookup"><span data-stu-id="56b8b-217">OpenAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_OpenAsync_Microsoft_ServiceBus_Messaging_PartitionContext_)
* [<span data-ttu-id="56b8b-218">CloseAsync</span><span class="sxs-lookup"><span data-stu-id="56b8b-218">CloseAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_CloseAsync_Microsoft_ServiceBus_Messaging_PartitionContext_Microsoft_ServiceBus_Messaging_CloseReason_)
* [<span data-ttu-id="56b8b-219">ProcessEventsAsync</span><span class="sxs-lookup"><span data-stu-id="56b8b-219">ProcessEventsAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_ProcessEventsAsync_Microsoft_ServiceBus_Messaging_PartitionContext_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__)

<span data-ttu-id="56b8b-220">若要啟動事件處理，請將 [EventProcessorHost][] 具現化，其中需為事件中樞提供適當的參數。</span><span class="sxs-lookup"><span data-stu-id="56b8b-220">To start event processing, instantiate [EventProcessorHost][], providing the appropriate parameters for your event hub.</span></span> <span data-ttu-id="56b8b-221">接著，呼叫 [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) 以向執行階段註冊 [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) 實作。</span><span class="sxs-lookup"><span data-stu-id="56b8b-221">Then, call [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) to register your [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) implementation with the runtime.</span></span> <span data-ttu-id="56b8b-222">此時，主機會嘗試使用「窮盡」演算法來取得事件中樞內每個磁碟分割的租用。</span><span class="sxs-lookup"><span data-stu-id="56b8b-222">At this point, the host will attempt to acquire a lease on every partition in the event hub using a "greedy" algorithm.</span></span> <span data-ttu-id="56b8b-223">這些租用將延續一段指定時間，然後必須更新。</span><span class="sxs-lookup"><span data-stu-id="56b8b-223">These leases will last for a given timeframe and must then be renewed.</span></span> <span data-ttu-id="56b8b-224">本案例中，當新節點上線時，背景工作執行個體會保留租用，而每當取得更多租用的嘗試發生時，負載會隨著在節點之間轉移。</span><span class="sxs-lookup"><span data-stu-id="56b8b-224">As new nodes, worker instances in this case, come online, they place lease reservations and over time the load shifts between nodes as each attempts to acquire more leases.</span></span>

![事件處理器主機](./media/event-hubs-programming-guide/IC759863.png)

<span data-ttu-id="56b8b-226">經過一段時間後，均衡的局面將會出現。</span><span class="sxs-lookup"><span data-stu-id="56b8b-226">Over time, an equilibrium is established.</span></span> <span data-ttu-id="56b8b-227">此動態功能可讓您將 CPU 架構自動調整套用至消費者，以便進行向上和向下調整。</span><span class="sxs-lookup"><span data-stu-id="56b8b-227">This dynamic capability enables CPU-based autoscaling to be applied to consumers for both scale-up and scale-down.</span></span> <span data-ttu-id="56b8b-228">由於事件中樞沒有直接的訊息計數概念，因此平均 CPU 使用率通常是測量後端或消費者規模最合適的機制。</span><span class="sxs-lookup"><span data-stu-id="56b8b-228">Because Event Hubs do not have a direct concept of message counts, average CPU utilization is often the best mechanism to measure back end or consumer scale.</span></span> <span data-ttu-id="56b8b-229">如果發佈者發佈的事件數量開始超出消費者的處理能力，消費者上增加的 CPU 可用來引發背景工作執行個體計數自動調整。</span><span class="sxs-lookup"><span data-stu-id="56b8b-229">If publishers begin to publish more events than consumers can process, the CPU increase on consumers can be used to cause an auto-scale on worker instance count.</span></span>

<span data-ttu-id="56b8b-230">[EventProcessorHost][] 類別還能實作以 Azure 儲存體為基礎的檢查點機制。</span><span class="sxs-lookup"><span data-stu-id="56b8b-230">The [EventProcessorHost][] class also implements an Azure storage-based checkpointing mechanism.</span></span> <span data-ttu-id="56b8b-231">這項機制能儲存每個磁碟分割的位移，方便各個消費者判斷前一個消費者的最後一個檢查點。</span><span class="sxs-lookup"><span data-stu-id="56b8b-231">This mechanism stores the offset on a per partition basis, so that each consumer can determine what the last checkpoint from the previous consumer was.</span></span> <span data-ttu-id="56b8b-232">由於資料分割會透過租用在節點之間轉換，因此這是能促進負載移位的同步處理機制。</span><span class="sxs-lookup"><span data-stu-id="56b8b-232">As partitions transition between nodes via leases, this is the synchronization mechanism that facilitates load shifting.</span></span>

## <a name="publisher-revocation"></a><span data-ttu-id="56b8b-233">發佈者撤銷</span><span class="sxs-lookup"><span data-stu-id="56b8b-233">Publisher revocation</span></span>
<span data-ttu-id="56b8b-234">除了 [EventProcessorHost][]的進階執行階段功能之外，「事件中樞」還能讓您撤銷發佈者，以防止特定發佈者將事件傳送到到事件中樞。</span><span class="sxs-lookup"><span data-stu-id="56b8b-234">In addition to the advanced run-time features of [EventProcessorHost][], Event Hubs enables publisher revocation in order to block specific publishers from sending event to an event hub.</span></span> <span data-ttu-id="56b8b-235">當發佈者權杖遭到洩露，或軟體更新造成發佈者出現不當行為時，這些功能特別有用。</span><span class="sxs-lookup"><span data-stu-id="56b8b-235">These features are particularly useful if a publisher token has been compromised, or a software update is causing them to behave inappropriately.</span></span> <span data-ttu-id="56b8b-236">在這些情況下，您可以封鎖發佈者 SAS 權杖中的發佈者身分識別，避免它們發佈事件。</span><span class="sxs-lookup"><span data-stu-id="56b8b-236">In these situations, the publisher's identity, which is part of their SAS token, can be blocked from publishing events.</span></span>

<span data-ttu-id="56b8b-237">如需有關發佈者撤銷，以及如何以發佈者身分傳送到事件中樞的詳細資訊，請參閱[事件中樞大規模安全發佈](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab)範例。</span><span class="sxs-lookup"><span data-stu-id="56b8b-237">For more information about publisher revocation and how to send to Event Hubs as a publisher, see the [Event Hubs Large Scale Secure Publishing](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) sample.</span></span>

## <a name="next-steps"></a><span data-ttu-id="56b8b-238">後續步驟</span><span class="sxs-lookup"><span data-stu-id="56b8b-238">Next steps</span></span>
<span data-ttu-id="56b8b-239">若要深入了解事件中樞案例，請造訪下列連結：</span><span class="sxs-lookup"><span data-stu-id="56b8b-239">To learn more about Event Hubs scenarios, visit these links:</span></span>

* [<span data-ttu-id="56b8b-240">事件中樞 API 概觀</span><span class="sxs-lookup"><span data-stu-id="56b8b-240">Event Hubs API overview</span></span>](event-hubs-api-overview.md)
* [<span data-ttu-id="56b8b-241">何謂事件中樞</span><span class="sxs-lookup"><span data-stu-id="56b8b-241">What is Event Hubs</span></span>](event-hubs-what-is-event-hubs.md)
* [<span data-ttu-id="56b8b-242">事件中樞的可用性和一致性</span><span class="sxs-lookup"><span data-stu-id="56b8b-242">Availability and consistency in Event Hubs</span></span>](event-hubs-availability-and-consistency.md)
* [<span data-ttu-id="56b8b-243">事件處理器主機 API 參考</span><span class="sxs-lookup"><span data-stu-id="56b8b-243">Event processor host API reference</span></span>](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost)

<span data-ttu-id="56b8b-244">[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager</span><span class="sxs-lookup"><span data-stu-id="56b8b-244">[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager</span></span>
<span data-ttu-id="56b8b-245">[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient</span><span class="sxs-lookup"><span data-stu-id="56b8b-245">[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient</span></span>
<span data-ttu-id="56b8b-246">[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata</span><span class="sxs-lookup"><span data-stu-id="56b8b-246">[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata</span></span>
<span data-ttu-id="56b8b-247">[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists</span><span class="sxs-lookup"><span data-stu-id="56b8b-247">[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists</span></span>
<span data-ttu-id="56b8b-248">[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey</span><span class="sxs-lookup"><span data-stu-id="56b8b-248">[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey</span></span>
<span data-ttu-id="56b8b-249">[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost</span><span class="sxs-lookup"><span data-stu-id="56b8b-249">[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost</span></span>
