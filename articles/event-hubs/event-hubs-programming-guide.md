---
title: "Azure 事件中心的 aaaProgramming 指南 |Microsoft 文件"
description: "使用 Azure.NET SDK hello Azure 事件中心撰寫的程式碼。"
services: event-hubs
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 64cbfd3d-4a0e-4455-a90a-7f3d4f080323
ms.service: event-hubs
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: tbd
ms.date: 08/17/2017
ms.author: sethm
ms.openlocfilehash: 43bebd126c2311af9e3daeb52324132b66cf0884
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="event-hubs-programming-guide"></a><span data-ttu-id="f2bf1-103">事件中樞程式設計指南</span><span class="sxs-lookup"><span data-stu-id="f2bf1-103">Event Hubs programming guide</span></span>

<span data-ttu-id="f2bf1-104">這篇文章會討論一些常見的案例中撰寫程式碼使用 Azure 事件中樞與 hello Azure.NET SDK。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-104">This article discusses some common scenarios in writing code using Azure Event Hubs and hello Azure .NET SDK.</span></span> <span data-ttu-id="f2bf1-105">它假設使用者對事件中樞已有初步了解。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-105">It assumes a preliminary understanding of Event Hubs.</span></span> <span data-ttu-id="f2bf1-106">事件中心概念的概觀，請參閱 hello[事件中心概觀](event-hubs-what-is-event-hubs.md)。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-106">For a conceptual overview of Event Hubs, see hello [Event Hubs overview](event-hubs-what-is-event-hubs.md).</span></span>

## <a name="event-publishers"></a><span data-ttu-id="f2bf1-107">事件發佈者</span><span class="sxs-lookup"><span data-stu-id="f2bf1-107">Event publishers</span></span>

<span data-ttu-id="f2bf1-108">您傳送事件 tooan 事件中心使用 HTTP POST 或透過 AMQP 1.0 連線。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-108">You send events tooan event hub either using HTTP POST or via an AMQP 1.0 connection.</span></span> <span data-ttu-id="f2bf1-109">hello 選擇的哪一個 toouse 和時機取決於要定址的 hello 特定案例。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-109">hello choice of which toouse and when depends on hello specific scenario being addressed.</span></span> <span data-ttu-id="f2bf1-110">AMQP 1.0 連線是以服務匯流排中的代理連線形式計量，其較適合經常出現大量訊息且需要低延遲的案例，因為它們可提供持續的傳訊通道。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-110">AMQP 1.0 connections are metered as brokered connections in Service Bus and are more appropriate in scenarios with frequent higher message volumes and lower latency requirements, as they provide a persistent messaging channel.</span></span>

<span data-ttu-id="f2bf1-111">您建立和管理事件中心使用 hello [NamespaceManager][]類別。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-111">You create and manage Event Hubs using hello [NamespaceManager][] class.</span></span> <span data-ttu-id="f2bf1-112">當使用 hello.NET managed Api 時，hello 主要會建構如發佈資料 tooEvent 集線器是 hello [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient)和[EventData][]類別。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-112">When using hello .NET managed APIs, hello primary constructs for publishing data tooEvent Hubs are hello [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) and [EventData][] classes.</span></span> <span data-ttu-id="f2bf1-113">[EventHubClient][]提供 hello 的事件傳送 toohello 事件中心的 AMQP 通訊通道。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-113">[EventHubClient][] provides hello AMQP communication channel over which events are sent toohello event hub.</span></span> <span data-ttu-id="f2bf1-114">hello [EventData][]類別代表事件，並為使用的 toopublish 訊息 tooan 事件中樞。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-114">hello [EventData][] class represents an event, and is used toopublish messages tooan event hub.</span></span> <span data-ttu-id="f2bf1-115">這個類別包含 hello 本文、 一些中繼資料及 hello 事件的標頭資訊。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-115">This class includes hello body, some metadata, and header information about hello event.</span></span> <span data-ttu-id="f2bf1-116">其他屬性會加入 toohello [EventData][]物件通過事件中心。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-116">Other properties are added toohello [EventData][] object as it passes through an event hub.</span></span>

## <a name="get-started"></a><span data-ttu-id="f2bf1-117">開始使用</span><span class="sxs-lookup"><span data-stu-id="f2bf1-117">Get started</span></span>

<span data-ttu-id="f2bf1-118">支援事件中樞的 hello.NET 類別被提供 hello Microsoft.ServiceBus.dll 組件中。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-118">hello .NET classes that support Event Hubs are provided in hello Microsoft.ServiceBus.dll assembly.</span></span> <span data-ttu-id="f2bf1-119">最簡單的方式 tooreference hello 服務匯流排 API 和 tooconfigure hello hello 服務匯流排相依性的所有應用程式都為 toodownload hello[服務匯流排 NuGet 封裝](https://www.nuget.org/packages/WindowsAzure.ServiceBus)。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-119">hello easiest way tooreference hello Service Bus API and tooconfigure your application with all of hello Service Bus dependencies is toodownload hello [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span></span> <span data-ttu-id="f2bf1-120">或者，您可以使用 hello [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) Visual Studio 中。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-120">Alternatively, you can use hello [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) in Visual Studio.</span></span> <span data-ttu-id="f2bf1-121">toodo 因此，發出下列命令在 hello hello [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console)視窗：</span><span class="sxs-lookup"><span data-stu-id="f2bf1-121">toodo so, issue hello following command in hello [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) window:</span></span>

```
Install-Package WindowsAzure.ServiceBus
```

## <a name="create-an-event-hub"></a><span data-ttu-id="f2bf1-122">建立事件中心</span><span class="sxs-lookup"><span data-stu-id="f2bf1-122">Create an event hub</span></span>
<span data-ttu-id="f2bf1-123">您可以使用 hello [NamespaceManager][]類別 toocreate 事件中心。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-123">You can use hello [NamespaceManager][] class toocreate Event Hubs.</span></span> <span data-ttu-id="f2bf1-124">例如：</span><span class="sxs-lookup"><span data-stu-id="f2bf1-124">For example:</span></span>

```csharp
var manager = new Microsoft.ServiceBus.NamespaceManager("mynamespace.servicebus.windows.net");
var description = manager.CreateEventHub("MyEventHub");
```

<span data-ttu-id="f2bf1-125">在大部分情況下，建議您使用 hello [CreateEventHubIfNotExists][]方法 tooavoid hello 服務重新啟動時產生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-125">In most cases, it is recommended that you use hello [CreateEventHubIfNotExists][] methods tooavoid generating exceptions if hello service restarts.</span></span> <span data-ttu-id="f2bf1-126">例如：</span><span class="sxs-lookup"><span data-stu-id="f2bf1-126">For example:</span></span>

```csharp
var description = manager.CreateEventHubIfNotExists("MyEventHub");
```

<span data-ttu-id="f2bf1-127">所有事件中心建立作業，包括[CreateEventHubIfNotExists][]，需要**管理**hello 相關的命名空間的權限。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-127">All Event Hubs creation operations, including [CreateEventHubIfNotExists][], require **Manage** permissions on hello namespace in question.</span></span> <span data-ttu-id="f2bf1-128">如果您想 toolimit hello 權限的發行者或取用者應用程式，您可以避免這些建立作業呼叫在實際執行程式碼中，當您使用有限權限的認證。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-128">If you want toolimit hello permissions of your publisher or consumer applications, you can avoid these create operation calls in production code when you use credentials with limited permissions.</span></span>

<span data-ttu-id="f2bf1-129">hello [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription)類別包含有關事件中心，包括 hello 授權規則、 hello 訊息保留間隔、 資料分割識別碼、 狀態和路徑的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-129">hello [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) class contains details about an event hub, including hello authorization rules, hello message retention interval, partition IDs, status, and path.</span></span> <span data-ttu-id="f2bf1-130">事件中心上，您可以使用此類別 tooupdate hello 中繼資料。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-130">You can use this class tooupdate hello metadata on an event hub.</span></span>

## <a name="create-an-event-hubs-client"></a><span data-ttu-id="f2bf1-131">建立事件中樞用戶端</span><span class="sxs-lookup"><span data-stu-id="f2bf1-131">Create an Event Hubs client</span></span>
<span data-ttu-id="f2bf1-132">hello 與事件中心互動的主要類別是[Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient]。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-132">hello primary class for interacting with Event Hubs is [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient].</span></span> <span data-ttu-id="f2bf1-133">這個類別提供傳送者和接收者功能。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-133">This class provides both sender and receiver capabilities.</span></span> <span data-ttu-id="f2bf1-134">您可以具現化這個類別使用 hello[建立](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create)方法 hello 下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-134">You can instantiate this class using hello [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) method, as shown in hello following example.</span></span>

```csharp
var client = EventHubClient.Create(description.Path);
```

<span data-ttu-id="f2bf1-135">這個方法會使用 hello 服務匯流排連接資訊在 hello App.config 檔案中，在 hello `appSettings` > 一節。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-135">This method uses hello Service Bus connection information in hello App.config file, in hello `appSettings` section.</span></span> <span data-ttu-id="f2bf1-136">如需範例的 hello `appSettings` XML 使用 toostore hello 服務匯流排連接資訊，請參閱 hello 文件以 hello [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_)方法。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-136">For an example of hello `appSettings` XML used toostore hello Service Bus connection information, see hello documentation for hello [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method.</span></span>

<span data-ttu-id="f2bf1-137">另一個選項是 toocreate hello 用戶端從連接字串。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-137">Another option is toocreate hello client from a connection string.</span></span> <span data-ttu-id="f2bf1-138">此選項可以使用 Azure 背景工作角色時，因為 hello 字串存放 hello hello 背景工作的組態屬性。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-138">This option works well when using Azure worker roles, because you can store hello string in hello configuration properties for hello worker.</span></span> <span data-ttu-id="f2bf1-139">例如：</span><span class="sxs-lookup"><span data-stu-id="f2bf1-139">For example:</span></span>

```csharp
EventHubClient.CreateFromConnectionString("your_connection_string");
```

<span data-ttu-id="f2bf1-140">hello 連接字串會在相同的格式出現在 hello 先前方法的 hello App.config 檔案中的 hello:</span><span class="sxs-lookup"><span data-stu-id="f2bf1-140">hello connection string will be in hello same format as it appears in hello App.config file for hello previous methods:</span></span>

```
Endpoint=sb://[namespace].servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=[key]
```

<span data-ttu-id="f2bf1-141">最後，它也是可能 toocreate [EventHubClient][]物件從[MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory)執行個體，如下列範例中的 hello 中所示。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-141">Finally, it is also possible toocreate an [EventHubClient][] object from a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance, as shown in hello following example.</span></span>

```csharp
var factory = MessagingFactory.CreateFromConnectionString("your_connection_string");
var client = factory.CreateEventHubClient("MyEventHub");
```

<span data-ttu-id="f2bf1-142">它是額外的重要 toonote [EventHubClient][]從傳訊 factory 執行個體建立的物件將會重複使用 hello 相同基礎 TCP 連線。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-142">It is important toonote that additional [EventHubClient][] objects created from a messaging factory instance will reuse hello same underlying TCP connection.</span></span> <span data-ttu-id="f2bf1-143">因此，這些物件對用戶端的輸送量將受到限制。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-143">Therefore, these objects have a client-side limit on throughput.</span></span> <span data-ttu-id="f2bf1-144">hello[建立](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_)方法重複使用單一傳訊 factory。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-144">hello [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method reuses a single messaging factory.</span></span> <span data-ttu-id="f2bf1-145">如果您與單一傳送者之間需要大量輸送量，可以建立多個訊息處理站，並從每個傳訊處理站建立一個 [EventHubClient][] 物件。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-145">If you need very high throughput from a single sender, then you can create multiple message factories and one [EventHubClient][] object from each messaging factory.</span></span>

## <a name="send-events-tooan-event-hub"></a><span data-ttu-id="f2bf1-146">傳送事件 tooan 事件中樞</span><span class="sxs-lookup"><span data-stu-id="f2bf1-146">Send events tooan event hub</span></span>
<span data-ttu-id="f2bf1-147">您藉由建立傳送事件 tooan 事件中心[EventData][]執行個體，並將它傳送嗨透過[傳送](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_)方法。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-147">You send events tooan event hub by creating an [EventData][] instance and sending it via hello [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) method.</span></span> <span data-ttu-id="f2bf1-148">這個方法會採用單一[EventData][]例項參數，並以同步方式傳送 tooan 事件中心。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-148">This method takes a single [EventData][] instance parameter and synchronously sends it tooan event hub.</span></span>

## <a name="event-serialization"></a><span data-ttu-id="f2bf1-149">事件序列化</span><span class="sxs-lookup"><span data-stu-id="f2bf1-149">Event serialization</span></span>
<span data-ttu-id="f2bf1-150">hello [EventData][]類別具有[四個多載建構函式](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_)可接受各種參數，例如物件和序列化程式、 位元組陣列或資料流。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-150">hello [EventData][] class has [four overloaded constructors](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_) that take a variety of parameters, such as an object and serializer, a byte array, or a stream.</span></span> <span data-ttu-id="f2bf1-151">它也是可能 tooinstantiate hello [EventData][]類別並之後設定 hello 內文資料流。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-151">It is also possible tooinstantiate hello [EventData][] class and set hello body stream afterwards.</span></span> <span data-ttu-id="f2bf1-152">當使用 JSON 與[EventData][]，您可以使用**Encoding.UTF8.GetBytes()** tooretrieve hello 位元組陣列的 JSON 編碼的字串。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-152">When using JSON with [EventData][], you can use **Encoding.UTF8.GetBytes()** tooretrieve hello byte array for a JSON-encoded string.</span></span>

## <a name="partition-key"></a><span data-ttu-id="f2bf1-153">資料分割索引鍵</span><span class="sxs-lookup"><span data-stu-id="f2bf1-153">Partition key</span></span>
<span data-ttu-id="f2bf1-154">hello [EventData][]類別具有[PartitionKey][]屬性，可讓 hello 寄件者 toospecify 的值是雜湊 tooproduce 資料分割指派。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-154">hello [EventData][] class has a [PartitionKey][] property that enables hello sender toospecify a value that is hashed tooproduce a partition assignment.</span></span> <span data-ttu-id="f2bf1-155">使用資料分割索引鍵，以確保所有以相同的金鑰會傳送的 hello hello 事件 toohello hello 事件中心在相同資料分割。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-155">Using a partition key ensures that all hello events with hello same key are sent toohello same partition in hello event hub.</span></span> <span data-ttu-id="f2bf1-156">常見的資料分割索引鍵包含使用者工作階段識別碼和唯一的傳送者識別碼。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-156">Common partition keys include user session IDs and unique sender IDs.</span></span> <span data-ttu-id="f2bf1-157">hello [PartitionKey][]是選擇性屬性，可供使用 hello 時[Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_)或[Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_)方法。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-157">hello [PartitionKey][] property is optional and can be provided when using hello [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) or [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) methods.</span></span> <span data-ttu-id="f2bf1-158">如果您未提供的值[PartitionKey][]，傳送事件是分散式的 toopartitions 使用循環配置資源模型。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-158">If you do not provide a value for [PartitionKey][], sent events are distributed toopartitions using a round-robin model.</span></span>

### <a name="availability-considerations"></a><span data-ttu-id="f2bf1-159">可用性考量</span><span class="sxs-lookup"><span data-stu-id="f2bf1-159">Availability considerations</span></span>

<span data-ttu-id="f2bf1-160">使用資料分割索引鍵為選擇性，而且您應該仔細考慮是否 toouse 其中一個。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-160">Using a partition key is optional, and you should consider carefully whether or not toouse one.</span></span> <span data-ttu-id="f2bf1-161">在許多情況下，如果事件的順序很重要，您最好選擇使用資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-161">In many cases, using a partition key is a good choice if event ordering is important.</span></span> <span data-ttu-id="f2bf1-162">當您使用資料分割索引鍵時，這些資料分割必須在單一節點上可供使用，但經過一段時間後，節點有可能會發生中斷，例如在計算節點重新開機及修補時。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-162">When you use a partition key, these partitions require availability on a single node, and outages can occur over time; for example, when compute nodes reboot and patch.</span></span> <span data-ttu-id="f2bf1-163">因此，如果設定分割區識別碼和因為某種原因，該資料分割變成無法使用，該分割中的嘗試 tooaccess hello 資料將會失敗。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-163">As such, if you set a partition ID and that partition becomes unavailable for some reason, an attempt tooaccess hello data in that partition will fail.</span></span> <span data-ttu-id="f2bf1-164">高可用性是最重要的如果未指定資料分割索引鍵，在此情況下的事件將會傳送 toopartitions 使用先前所述的 hello 循環配置資源模型。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-164">If high availability is most important, do not specify a partition key; in that case events will be sent toopartitions using hello round-robin model described previously.</span></span> <span data-ttu-id="f2bf1-165">在此案例中，您要進行的可用性 （沒有分割區識別碼） 與一致性 （釘選事件 tooa 分割區識別碼） 之間的明確選擇。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-165">In this scenario, you are making an explicit choice between availability (no partition ID) and consistency (pinning events tooa partition ID).</span></span>

<span data-ttu-id="f2bf1-166">另一項考量是對處理事件的延遲進行處理。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-166">Another consideration is handling delays in processing events.</span></span> <span data-ttu-id="f2bf1-167">在某些情況下可能會更好的 toodrop 資料比 tootry 重試和跟上處理，都可能會造成進一步的下游處理延遲。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-167">In some cases it might be better toodrop data and retry than tootry and keep up with processing, which can potentially cause further downstream processing delays.</span></span> <span data-ttu-id="f2bf1-168">例如，股票行情指示器很更好的 toowait 完成的最新資料，但在即時聊天或 VOIP 案例快，您想讓 hello 資料即使它不是完整。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-168">For example, with a stock ticker it's better toowait for complete up-to-date data, but in a live chat or VOIP scenario you'd rather have hello data quickly, even if it isn't complete.</span></span>

<span data-ttu-id="f2bf1-169">指定的這些可用性考量，在這些情況下您可能會選擇其中一個 hello 下列的錯誤處理策略：</span><span class="sxs-lookup"><span data-stu-id="f2bf1-169">Given these availability considerations, in these scenarios you might choose one of hello following error handling strategies:</span></span>

- <span data-ttu-id="f2bf1-170">停止 (停止讀取事件中樞，直到情況獲得修正)</span><span class="sxs-lookup"><span data-stu-id="f2bf1-170">Stop (stop reading from Event Hubs until things are fixed)</span></span>
- <span data-ttu-id="f2bf1-171">捨棄 (訊息並不重要，將其卸除)</span><span class="sxs-lookup"><span data-stu-id="f2bf1-171">Drop (messages aren’t important, drop them)</span></span>
- <span data-ttu-id="f2bf1-172">重試 (重試 hello 訊息，因為您會看到符合)</span><span class="sxs-lookup"><span data-stu-id="f2bf1-172">Retry (retry hello messages as you see fit)</span></span>
- <span data-ttu-id="f2bf1-173">[寄不出信件](../service-bus-messaging/service-bus-dead-letter-queues.md)（佇列或另一個事件中樞 toodead 字母 hello 訊息，您只使用無法處理）</span><span class="sxs-lookup"><span data-stu-id="f2bf1-173">[Dead letter](../service-bus-messaging/service-bus-dead-letter-queues.md) (use a queue or another event hub toodead letter only hello messages you couldn’t process)</span></span>

<span data-ttu-id="f2bf1-174">如需詳細資訊和討論 hello 之間的利弊得失可用性和一致性，請參閱[可用性和事件中心的一致性](event-hubs-availability-and-consistency.md)。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-174">For more information and a discussion about hello trade-offs between availability and consistency, see [Availability and consistency in Event Hubs](event-hubs-availability-and-consistency.md).</span></span> 

## <a name="batch-event-send-operations"></a><span data-ttu-id="f2bf1-175">批次事件傳送作業</span><span class="sxs-lookup"><span data-stu-id="f2bf1-175">Batch event send operations</span></span>
<span data-ttu-id="f2bf1-176">分批傳送事件能大幅增加輸送量。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-176">Sending events in batches can dramatically increase throughput.</span></span> <span data-ttu-id="f2bf1-177">hello [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__)方法會採用**IEnumerable**型別的參數[EventData][]和傳送 hello 與不可部分完成的作業 toohello 事件中心的整個批次。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-177">hello [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) method takes an **IEnumerable** parameter of type [EventData][] and sends hello entire batch as an atomic operation toohello event hub.</span></span>

```csharp
public void SendBatch(IEnumerable<EventData> eventDataList);
```

<span data-ttu-id="f2bf1-178">請注意，單一批次不能超過事件的 hello 256 KB 的限制。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-178">Note that a single batch must not exceed hello 256 KB limit of an event.</span></span> <span data-ttu-id="f2bf1-179">此外，在 hello 批次中的每個訊息會使用 hello 相同的發行者識別。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-179">Additionally, each message in hello batch uses hello same publisher identity.</span></span> <span data-ttu-id="f2bf1-180">它是 hello hello 批次的傳送者 tooensure hello 責任不超過 hello 事件大小上限。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-180">It is hello responsibility of hello sender tooensure that hello batch does not exceed hello maximum event size.</span></span> <span data-ttu-id="f2bf1-181">如果超過的話，系統會產生用戶端 **Send** 錯誤。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-181">If it does, a client **Send** error is generated.</span></span>

## <a name="send-asynchronously-and-send-at-scale"></a><span data-ttu-id="f2bf1-182">以非同步方式傳送和大規模傳送</span><span class="sxs-lookup"><span data-stu-id="f2bf1-182">Send asynchronously and send at scale</span></span>
<span data-ttu-id="f2bf1-183">您也可以以非同步方式傳送事件 tooan 事件中心。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-183">You can also send events tooan event hub asynchronously.</span></span> <span data-ttu-id="f2bf1-184">以非同步方式傳送可以提高用戶端之後無法 toosend 事件 hello 速率。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-184">Sending asynchronously can increase hello rate at which a client is able toosend events.</span></span> <span data-ttu-id="f2bf1-185">這兩個 hello[傳送](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_)和[SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__)方法都有非同步版本可傳回[工作](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx)物件。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-185">Both hello [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) and [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) methods are available in asynchronous versions that return a [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) object.</span></span> <span data-ttu-id="f2bf1-186">雖然這項技術可以增加輸送量，它也會造成 hello 用戶端 toocontinue toosend 事件即使它已實施節流 hello 事件中心服務，並可能會導致 hello 用戶端發生失敗或遺失的訊息時如果未正確實作。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-186">While this technique can increase throughput, it can also cause hello client toocontinue toosend events even while it is being throttled by hello Event Hubs service and can result in hello client experiencing failures or lost messages if not properly implemented.</span></span> <span data-ttu-id="f2bf1-187">此外，您可以使用 hello [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) hello 用戶端 toocontrol 用戶端重試選項上的屬性。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-187">In addition, you can use hello [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) property on hello client toocontrol client retry options.</span></span>

## <a name="create-a-partition-sender"></a><span data-ttu-id="f2bf1-188">建立資料分割的傳送者</span><span class="sxs-lookup"><span data-stu-id="f2bf1-188">Create a partition sender</span></span>
<span data-ttu-id="f2bf1-189">雖然它是最常見 toosend 事件 tooan 事件中樞沒有資料分割索引鍵，在某些情況下您可能想 toosend 事件直接 tooa 給定資料分割。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-189">Although it is most common toosend events tooan event hub without a partition key, in some cases you might want toosend events directly tooa given partition.</span></span> <span data-ttu-id="f2bf1-190">例如：</span><span class="sxs-lookup"><span data-stu-id="f2bf1-190">For example:</span></span>

```csharp
var partitionedSender = client.CreatePartitionedSender(description.PartitionIds[0]);
```

<span data-ttu-id="f2bf1-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_)傳回[EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender)物件，您可以使用 toopublish 事件 tooa 特定事件中心資料分割。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) returns an [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) object that you can use toopublish events tooa specific event hub partition.</span></span>

## <a name="event-consumers"></a><span data-ttu-id="f2bf1-192">事件取用者</span><span class="sxs-lookup"><span data-stu-id="f2bf1-192">Event consumers</span></span>
<span data-ttu-id="f2bf1-193">事件中樞有兩個主要的事件取用模型：直接接收者和較高層級的抽象 (如 [EventProcessorHost][])。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-193">Event Hubs has two primary models for event consumption: direct receivers and higher-level abstractions, such as [EventProcessorHost][].</span></span> <span data-ttu-id="f2bf1-194">直接接收者負責自行協調取用者群組內存取 toopartitions。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-194">Direct receivers are responsible for their own coordination of access toopartitions within a consumer group.</span></span>

### <a name="direct-consumer"></a><span data-ttu-id="f2bf1-195">直接消費者</span><span class="sxs-lookup"><span data-stu-id="f2bf1-195">Direct consumer</span></span>
<span data-ttu-id="f2bf1-196">hello 最直接的方式 tooread 取用者群組內的資料分割為 toouse hello [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver)類別。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-196">hello most direct way tooread from a partition within a consumer group is toouse hello [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) class.</span></span> <span data-ttu-id="f2bf1-197">這個類別的執行個體 toocreate，您必須使用 hello 的執行個體[EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup)類別。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-197">toocreate an instance of this class, you must use an instance of hello [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) class.</span></span> <span data-ttu-id="f2bf1-198">在下列範例的 hello，hello 分割區識別碼時，必須指定建立 hello 接收器 hello 取用者群組。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-198">In hello following example, hello partition ID must be specified when creating hello receiver for hello consumer group.</span></span>

```csharp
EventHubConsumerGroup group = client.GetDefaultConsumerGroup();
var receiver = group.CreateReceiver(client.GetRuntimeInformation().PartitionIds[0]);
```

<span data-ttu-id="f2bf1-199">hello [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary)方法有數個多載可加強控制所建立的 hello 讀取器。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-199">hello [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) method has several overloads that facilitate control over hello reader being created.</span></span> <span data-ttu-id="f2bf1-200">這些方法包括位移指定為字串或時間戳記，而且 hello 能力 toospecify 是否 tooinclude hello 在此指定的位移傳回串流處理，還是它之後啟動。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-200">These methods include specifying an offset as either a string or timestamp, and hello ability toospecify whether tooinclude this specified offset in hello returned stream, or start after it.</span></span> <span data-ttu-id="f2bf1-201">建立 hello 接收者之後，您可以開始接收 hello 傳回物件上的事件。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-201">After you create hello receiver, you can start receiving events on hello returned object.</span></span> <span data-ttu-id="f2bf1-202">hello[接收](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary)方法有四個多載，該控制項 hello 接收操作參數，例如批次大小和等待時間。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-202">hello [Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) method has four overloads that control hello receive operation parameters, such as batch size and wait time.</span></span> <span data-ttu-id="f2bf1-203">您可以使用取用者的這些方法 tooincrease hello 輸送量 hello 非同步版本。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-203">You can use hello asynchronous versions of these methods tooincrease hello throughput of a consumer.</span></span> <span data-ttu-id="f2bf1-204">例如：</span><span class="sxs-lookup"><span data-stu-id="f2bf1-204">For example:</span></span>

```csharp
bool receive = true;
string myOffset;
while(receive)
{
    var message = receiver.Receive();
    myOffset = message.Offset;
    string body = Encoding.UTF8.GetString(message.GetBytes());
    Console.WriteLine(String.Format("Received message offset: {0} \nbody: {1}", myOffset, body));
}
```

<span data-ttu-id="f2bf1-205">尊重 tooa 特定分割區，以在其中傳送 toohello 事件中心的 hello 順序來接收 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-205">With respect tooa specific partition, hello messages are received in hello order in which they were sent toohello event hub.</span></span> <span data-ttu-id="f2bf1-206">hello 位移是字串語彙基元使用的 tooidentify 資料分割中的訊息。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-206">hello offset is a string token used tooidentify a message in a partition.</span></span>

<span data-ttu-id="f2bf1-207">請注意，消費者群組內的單一資料分割一律不能擁有超過 5 個已連接的並行讀取器。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-207">Note that a single partition within a consumer group cannot have more than 5 concurrent readers connected at any time.</span></span> <span data-ttu-id="f2bf1-208">當讀取器連接或中斷時，他們的工作階段可能會持續作用數分鐘才能 hello 服務辨識它們已中斷連線。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-208">As readers connect or become disconnected, their sessions might stay active for several minutes before hello service recognizes that they have disconnected.</span></span> <span data-ttu-id="f2bf1-209">在此期間，重新連接 tooa 磁碟分割可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-209">During this time, reconnecting tooa partition may fail.</span></span> <span data-ttu-id="f2bf1-210">撰寫直接接收者建立事件中樞的完整範例，請參閱 hello[事件中心直接接收者](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6)範例。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-210">For a complete example of writing a direct receiver for Event Hubs, see hello [Event Hubs Direct Receivers](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) sample.</span></span>

### <a name="event-processor-host"></a><span data-ttu-id="f2bf1-211">事件處理器主機</span><span class="sxs-lookup"><span data-stu-id="f2bf1-211">Event processor host</span></span>
<span data-ttu-id="f2bf1-212">hello [EventProcessorHost][]類別處理來自事件中心資料。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-212">hello [EventProcessorHost][] class processes data from Event Hubs.</span></span> <span data-ttu-id="f2bf1-213">Hello.NET 平台上建置事件讀取器時，您應該使用這項實作。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-213">You should use this implementation when building event readers on hello .NET platform.</span></span> <span data-ttu-id="f2bf1-214">[EventProcessorHost][] 能為事件處理器實作提供安全執行緒、多處理序、安全的執行階段環境，進而提供檢查點和資料分割租用管理。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-214">[EventProcessorHost][] provides a thread-safe, multi-process, safe runtime environment for event processor implementations that also provides checkpointing and partition lease management.</span></span>

<span data-ttu-id="f2bf1-215">toouse hello [EventProcessorHost][]類別時，您可以實作[IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor)。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-215">toouse hello [EventProcessorHost][] class, you can implement [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor).</span></span> <span data-ttu-id="f2bf1-216">這個介面包含三個方法：</span><span class="sxs-lookup"><span data-stu-id="f2bf1-216">This interface contains three methods:</span></span>

* [<span data-ttu-id="f2bf1-217">OpenAsync</span><span class="sxs-lookup"><span data-stu-id="f2bf1-217">OpenAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_OpenAsync_Microsoft_ServiceBus_Messaging_PartitionContext_)
* [<span data-ttu-id="f2bf1-218">CloseAsync</span><span class="sxs-lookup"><span data-stu-id="f2bf1-218">CloseAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_CloseAsync_Microsoft_ServiceBus_Messaging_PartitionContext_Microsoft_ServiceBus_Messaging_CloseReason_)
* [<span data-ttu-id="f2bf1-219">ProcessEventsAsync</span><span class="sxs-lookup"><span data-stu-id="f2bf1-219">ProcessEventsAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_ProcessEventsAsync_Microsoft_ServiceBus_Messaging_PartitionContext_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__)

<span data-ttu-id="f2bf1-220">toostart 事件處理，具現化[EventProcessorHost][]，事件中心提供 hello 適當的參數。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-220">toostart event processing, instantiate [EventProcessorHost][], providing hello appropriate parameters for your event hub.</span></span> <span data-ttu-id="f2bf1-221">然後，呼叫[RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) tooregister 您[IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) hello 執行階段實作。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-221">Then, call [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) tooregister your [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) implementation with hello runtime.</span></span> <span data-ttu-id="f2bf1-222">此時，hello 主機將會嘗試 tooacquire hello 事件中心採用 「 窮盡 」 演算法中的每個資料分割上的租用。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-222">At this point, hello host will attempt tooacquire a lease on every partition in hello event hub using a "greedy" algorithm.</span></span> <span data-ttu-id="f2bf1-223">這些租用將延續一段指定時間，然後必須更新。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-223">These leases will last for a given timeframe and must then be renewed.</span></span> <span data-ttu-id="f2bf1-224">為新的節點，背景工作執行個體在此情況下，上線，它們會預訂租約，並且經過一段時間 hello 負載會轉移節點之間為每個嘗試次數 tooacquire 更多租用。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-224">As new nodes, worker instances in this case, come online, they place lease reservations and over time hello load shifts between nodes as each attempts tooacquire more leases.</span></span>

![事件處理器主機](./media/event-hubs-programming-guide/IC759863.png)

<span data-ttu-id="f2bf1-226">經過一段時間後，均衡的局面將會出現。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-226">Over time, an equilibrium is established.</span></span> <span data-ttu-id="f2bf1-227">此動態功能可讓 CPU 型自動調整套用 toobe tooconsumers 向上延展和向下調整。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-227">This dynamic capability enables CPU-based autoscaling toobe applied tooconsumers for both scale-up and scale-down.</span></span> <span data-ttu-id="f2bf1-228">因為事件中心之間沒有直接的訊息計數概念，平均 CPU 使用率通常是 hello 最佳機制 toomeasure 後端或取用者小數位數。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-228">Because Event Hubs do not have a direct concept of message counts, average CPU utilization is often hello best mechanism toomeasure back end or consumer scale.</span></span> <span data-ttu-id="f2bf1-229">如果發行者開始的 toopublish 可以處理更多的事件取用者比，取用者上的 hello CPU 增加可以使用的 toocause 自動調整規模上背景工作執行個體計數。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-229">If publishers begin toopublish more events than consumers can process, hello CPU increase on consumers can be used toocause an auto-scale on worker instance count.</span></span>

<span data-ttu-id="f2bf1-230">hello [EventProcessorHost][]類別也實作 Azure 儲存體為基礎的檢查點機制。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-230">hello [EventProcessorHost][] class also implements an Azure storage-based checkpointing mechanism.</span></span> <span data-ttu-id="f2bf1-231">已使每一個取用者可以判斷先前取用者 hello 哪些 hello 最後一個檢查點位移針對每個資料分割，此機制存放區 hello。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-231">This mechanism stores hello offset on a per partition basis, so that each consumer can determine what hello last checkpoint from hello previous consumer was.</span></span> <span data-ttu-id="f2bf1-232">由於資料分割轉換之間透過租約在節點，這是 hello 加速負載移轉的同步處理機制。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-232">As partitions transition between nodes via leases, this is hello synchronization mechanism that facilitates load shifting.</span></span>

## <a name="publisher-revocation"></a><span data-ttu-id="f2bf1-233">發佈者撤銷</span><span class="sxs-lookup"><span data-stu-id="f2bf1-233">Publisher revocation</span></span>
<span data-ttu-id="f2bf1-234">此外 toohello 進階執行階段功能的[EventProcessorHost][]，事件中心也啟用發行者撤銷中順序 tooblock 特定發行者傳送事件 tooan 事件中心。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-234">In addition toohello advanced run-time features of [EventProcessorHost][], Event Hubs enables publisher revocation in order tooblock specific publishers from sending event tooan event hub.</span></span> <span data-ttu-id="f2bf1-235">如果發行者權杖已遭洩漏，或軟體更新造成 toobehave 不當，這些功能會特別有用。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-235">These features are particularly useful if a publisher token has been compromised, or a software update is causing them toobehave inappropriately.</span></span> <span data-ttu-id="f2bf1-236">在這些情況下，hello 發行者的身分識別，是其 SAS 權杖的一部分，可能會封鎖從發行事件。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-236">In these situations, hello publisher's identity, which is part of their SAS token, can be blocked from publishing events.</span></span>

<span data-ttu-id="f2bf1-237">如需有關發行者撤銷及如何 toosend tooEvent 中心為發行者，請參閱 hello[事件中心大規模安全發行](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab)範例。</span><span class="sxs-lookup"><span data-stu-id="f2bf1-237">For more information about publisher revocation and how toosend tooEvent Hubs as a publisher, see hello [Event Hubs Large Scale Secure Publishing](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) sample.</span></span>

## <a name="next-steps"></a><span data-ttu-id="f2bf1-238">後續步驟</span><span class="sxs-lookup"><span data-stu-id="f2bf1-238">Next steps</span></span>
<span data-ttu-id="f2bf1-239">toolearn 有關事件中心案例的詳細資訊，請前往下列連結：</span><span class="sxs-lookup"><span data-stu-id="f2bf1-239">toolearn more about Event Hubs scenarios, visit these links:</span></span>

* [<span data-ttu-id="f2bf1-240">事件中樞 API 概觀</span><span class="sxs-lookup"><span data-stu-id="f2bf1-240">Event Hubs API overview</span></span>](event-hubs-api-overview.md)
* [<span data-ttu-id="f2bf1-241">何謂事件中樞</span><span class="sxs-lookup"><span data-stu-id="f2bf1-241">What is Event Hubs</span></span>](event-hubs-what-is-event-hubs.md)
* [<span data-ttu-id="f2bf1-242">事件中樞的可用性和一致性</span><span class="sxs-lookup"><span data-stu-id="f2bf1-242">Availability and consistency in Event Hubs</span></span>](event-hubs-availability-and-consistency.md)
* [<span data-ttu-id="f2bf1-243">事件處理器主機 API 參考</span><span class="sxs-lookup"><span data-stu-id="f2bf1-243">Event processor host API reference</span></span>](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost)

[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager
[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient
[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata
[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists
[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey
[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost
