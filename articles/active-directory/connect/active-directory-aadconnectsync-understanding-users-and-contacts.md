---
title: "Azure AD Connect 同步：了解使用者和連絡人 | Microsoft Docs"
description: "說明 Azure AD Connect 同步處理中的使用者和連絡人。"
services: active-directory
documentationcenter: 
author: MarkusVi
manager: femila
ms.assetid: 8d204647-213a-4519-bd62-49563c421602
ms.service: active-directory
ms.workload: identity
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 07/12/2017
ms.author: markvi;andkjell
ms.openlocfilehash: 495e926a1975128707212ba571d47cfc7c9507b3
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/03/2017
---
# <a name="azure-ad-connect-sync-understanding-users-and-contacts"></a><span data-ttu-id="94ba4-103">Azure AD Connect 同步處理：了解使用者和連絡人</span><span class="sxs-lookup"><span data-stu-id="94ba4-103">Azure AD Connect sync: Understanding Users and Contacts</span></span>
<span data-ttu-id="94ba4-104">您可能有幾種不同的原因，而擁有多個 Active Directory 樹系並且具有幾種不同的部署拓撲。</span><span class="sxs-lookup"><span data-stu-id="94ba4-104">There are several different reasons why you would have multiple Active Directory forests and there are several different deployment topologies.</span></span> <span data-ttu-id="94ba4-105">常見的模型包括合併與收購之後的帳戶-資源部署與 GAL 同步處理的樹系。</span><span class="sxs-lookup"><span data-stu-id="94ba4-105">Common models include an account-resource deployment and GAL sync’ed forests after a merger & acquisition.</span></span> <span data-ttu-id="94ba4-106">雖然有單純的模型，但混合模型也同樣常見。</span><span class="sxs-lookup"><span data-stu-id="94ba4-106">But even if there are pure models, hybrid models are common as well.</span></span> <span data-ttu-id="94ba4-107">Azure AD Connect 同步處理中的預設組態不會採用任何特定的模型，但是根據在安裝指南中選取使用者比對的方式，可以觀察到不同的行為。</span><span class="sxs-lookup"><span data-stu-id="94ba4-107">The default configuration in Azure AD Connect sync does not assume any particular model but depending on how user matching was selected in the installation guide, different behaviors can be observed.</span></span>

<span data-ttu-id="94ba4-108">在本主題中，我們將詳細解說預設組態在某些拓撲中的運作方式。</span><span class="sxs-lookup"><span data-stu-id="94ba4-108">In this topic, we will go through how the default configuration behaves in certain topologies.</span></span> <span data-ttu-id="94ba4-109">我們將詳細解說組態，以及可用來查看組態的同步處理規則編輯器。</span><span class="sxs-lookup"><span data-stu-id="94ba4-109">We will go through the configuration and the Synchronization Rules Editor can be used to look at the configuration.</span></span>

<span data-ttu-id="94ba4-110">組態假設幾個一般規則：</span><span class="sxs-lookup"><span data-stu-id="94ba4-110">There are a few general rules the configuration assumes:</span></span>

* <span data-ttu-id="94ba4-111">無論我們以何種順序從來源 Active Directory 匯入，最後的結果應一律相同。</span><span class="sxs-lookup"><span data-stu-id="94ba4-111">Regardless of which order we import from the source Active Directories, the end result should always be the same.</span></span>
* <span data-ttu-id="94ba4-112">使用中的帳戶一律會提供登入資訊，包括 **userPrincipalName** 和 **sourceAnchor**。</span><span class="sxs-lookup"><span data-stu-id="94ba4-112">An active account will always contribute sign-in information, including **userPrincipalName** and **sourceAnchor**.</span></span>
* <span data-ttu-id="94ba4-113">如果找不到使用中的帳戶，除非帳戶是連結的信箱，否則停用的帳戶將會提供 userPrincipalName 和 sourceAnchor。</span><span class="sxs-lookup"><span data-stu-id="94ba4-113">A disabled account will contribute userPrincipalName and sourceAnchor, unless it is a linked mailbox, if there is no active account to be found.</span></span>
* <span data-ttu-id="94ba4-114">具有連結信箱的帳戶永遠不會用於 userPrincipalName 和 sourceAnchor。</span><span class="sxs-lookup"><span data-stu-id="94ba4-114">An account with a linked mailbox will never be used for userPrincipalName and sourceAnchor.</span></span> <span data-ttu-id="94ba4-115">它假設稍後就會找到使用中的帳戶。</span><span class="sxs-lookup"><span data-stu-id="94ba4-115">It is assumed that an active account will be found later.</span></span>
* <span data-ttu-id="94ba4-116">連絡人物件可能會佈建到 Azure AD 成為連絡人或使用者。</span><span class="sxs-lookup"><span data-stu-id="94ba4-116">A contact object might be provisioned to Azure AD as a contact or as a user.</span></span> <span data-ttu-id="94ba4-117">一直要到處理了所有來源 Active Directory 樹系之後，您才會知道物件成為何者。</span><span class="sxs-lookup"><span data-stu-id="94ba4-117">You don’t really know until all source Active Directory forests have been processed.</span></span>

## <a name="contacts"></a><span data-ttu-id="94ba4-118">連絡人</span><span class="sxs-lookup"><span data-stu-id="94ba4-118">Contacts</span></span>
<span data-ttu-id="94ba4-119">在合併與收購時使用 GALSync 解決方案橋接兩個或多個 Exchange 樹系之後，常會有多個連絡人代表不同樹系中的某個使用者。</span><span class="sxs-lookup"><span data-stu-id="94ba4-119">Having contacts representing a user in a different forest is common after a merger & acquisition where a GALSync solution is bridging two or more Exchange forests.</span></span> <span data-ttu-id="94ba4-120">連絡人物件一律從連接器空間使用 mail 屬性加入 Metaverse。</span><span class="sxs-lookup"><span data-stu-id="94ba4-120">The contact object is always joining from the connector space to the metaverse using the mail attribute.</span></span> <span data-ttu-id="94ba4-121">如果已經有具相同郵件地址的連絡人物件或使用者物件，則物件會一起加入。</span><span class="sxs-lookup"><span data-stu-id="94ba4-121">If there is already a contact object or user object with the same mail address, the objects are joined together.</span></span> <span data-ttu-id="94ba4-122">這設定在規則 **In from AD – Contact Join**中。</span><span class="sxs-lookup"><span data-stu-id="94ba4-122">This is configured in the rule **In from AD – Contact Join**.</span></span> <span data-ttu-id="94ba4-123">另外還有一個名為 **In from AD - Contact Common** 的規則，其屬性流程是使用常數 **Contact** 提供給 Metaverse 屬性 **sourceObjectType**。</span><span class="sxs-lookup"><span data-stu-id="94ba4-123">There is also a rule named **In from AD – Contact Common** with an attribute flow to the metaverse attribute **sourceObjectType** with the constant **Contact**.</span></span> <span data-ttu-id="94ba4-124">此規則的優先順序非常低，因此，如果已將任何使用者物件聯結到同一個 Metaverse 物件，則規則 **In from AD – User Common** 會提供 User 值給這個屬性。</span><span class="sxs-lookup"><span data-stu-id="94ba4-124">This rule has very low precedence so if any user object is joined to the same metaverse object, then the rule **In from AD – User Common** will contribute the value User to this attribute.</span></span> <span data-ttu-id="94ba4-125">有了這項規則，如果沒有使用者加入，此屬性的值就會是 Contact，如果至少找到了一個使用者，則屬性的值就會是 User。</span><span class="sxs-lookup"><span data-stu-id="94ba4-125">With this rule, this attribute will have the value Contact if no user has been joined and the value User if at least one user has been found.</span></span>

<span data-ttu-id="94ba4-126">當佈建物件到 Azure AD 時，如果 Metaverse 屬性 **sourceObjectType** 設為 **Contact**，輸出規則 **Out to AAD - Contact Join** 就會建立連絡人物件。</span><span class="sxs-lookup"><span data-stu-id="94ba4-126">For provisioning an object to Azure AD, the outbound rule **Out to AAD – Contact Join** will create a contact object if the metaverse attribute **sourceObjectType** is set to **Contact**.</span></span> <span data-ttu-id="94ba4-127">如果將此屬性設定為 **User**，則規則 **Out to AAD - User Join** 將改為建立使用者物件。</span><span class="sxs-lookup"><span data-stu-id="94ba4-127">If this attribute is set to **User**, then the rule **Out to AAD – User Join** will create a user object instead.</span></span>
<span data-ttu-id="94ba4-128">當有多個來源 Active Directory 匯入並同步處理時，可以將物件從 Contact 升級為 User。</span><span class="sxs-lookup"><span data-stu-id="94ba4-128">It is possible that an object is promoted from Contact to User when more source Active Directories are imported and synchronized.</span></span>

<span data-ttu-id="94ba4-129">例如，在 GALSync 拓撲中，當我們匯入第一個樹系時，我們會在第二個樹系中找到每個人的連絡人物件。</span><span class="sxs-lookup"><span data-stu-id="94ba4-129">For example, in a GALSync topology we will find contact objects for everyone in the second forest when we import the first forest.</span></span> <span data-ttu-id="94ba4-130">這會在 AAD 連接器中暫存新的連絡人物件。</span><span class="sxs-lookup"><span data-stu-id="94ba4-130">This will stage new contact objects in the AAD Connector.</span></span> <span data-ttu-id="94ba4-131">當我們之後匯入和同步處理第二個樹系時，我們會找到真正的使用者，並將他們加入現有的 Metaverse 物件。</span><span class="sxs-lookup"><span data-stu-id="94ba4-131">When we later import and synchronize the second forest, we will find the real users and join them to the existing metaverse objects.</span></span> <span data-ttu-id="94ba4-132">然後我們就可以刪除 AAD 中的連絡人物件，然後改為建立新的使用者物件。</span><span class="sxs-lookup"><span data-stu-id="94ba4-132">We will then delete the contact object in AAD and create a new user object instead.</span></span>

<span data-ttu-id="94ba4-133">如果您有一個拓撲，其中使用者以連絡人代表，請確定您在安裝指南中選取根據 mail 屬性比對使用者。</span><span class="sxs-lookup"><span data-stu-id="94ba4-133">If you have a topology where users are represented as contacts, make sure you select to match users on the mail attribute in the installation guide.</span></span> <span data-ttu-id="94ba4-134">如果您選取另一個選項，則您的組態就會與順序有關。</span><span class="sxs-lookup"><span data-stu-id="94ba4-134">If you select another option, then you will have an order dependent configuration.</span></span> <span data-ttu-id="94ba4-135">連絡人物件永遠會跟隨著 mail 屬性，但如果在安裝指南中選取了此選項，使用者物件就只會跟隨著 mail 屬性。</span><span class="sxs-lookup"><span data-stu-id="94ba4-135">Contact objects will always join on the mail attribute, but user objects will only join on the mail attribute if this option was selected in the installation guide.</span></span> <span data-ttu-id="94ba4-136">如果在匯入使用者物件之前先匯入連絡人物件，您在 Metaverse 中就會得到具有相同 mail 屬性的兩種不同物件。</span><span class="sxs-lookup"><span data-stu-id="94ba4-136">You could then end up with two different objects in the metaverse with the same mail attribute if the contact object was imported before the user object.</span></span> <span data-ttu-id="94ba4-137">在匯出到 Azure AD 期間，將會擲回錯誤。</span><span class="sxs-lookup"><span data-stu-id="94ba4-137">During export to Azure AD, an error will be thrown.</span></span> <span data-ttu-id="94ba4-138">此行為是刻意設計，這樣會指出資料有錯誤，或者在安裝期間未正確識別拓撲。</span><span class="sxs-lookup"><span data-stu-id="94ba4-138">This behavior is by design and would indicate bad data or that the topology was not correctly identified during the installation.</span></span>

## <a name="disabled-accounts"></a><span data-ttu-id="94ba4-139">停用的帳戶</span><span class="sxs-lookup"><span data-stu-id="94ba4-139">Disabled accounts</span></span>
<span data-ttu-id="94ba4-140">停用的帳戶也同樣會同步處理到 Azure AD。</span><span class="sxs-lookup"><span data-stu-id="94ba4-140">Disabled accounts are synchronized as well to Azure AD.</span></span> <span data-ttu-id="94ba4-141">停用的帳戶在 Exchange 中通常代表資源，例如會議室。</span><span class="sxs-lookup"><span data-stu-id="94ba4-141">Disabled accounts are common to represent resources in Exchange, for example conference rooms.</span></span> <span data-ttu-id="94ba4-142">例外狀況是具有連結信箱的使用者。如先前所述，這些使用者將永遠不會佈建帳戶到 Azure AD。</span><span class="sxs-lookup"><span data-stu-id="94ba4-142">The exception is users with a linked mailbox; as previously mentioned, these will never provision an account to Azure AD.</span></span>

<span data-ttu-id="94ba4-143">這個假設是，如果找到停用的使用者帳戶，我們之後就不會找到另一個使用中的帳戶，而物件會使用找到的 userPrincipalName 和 sourceAnchor 佈建到 Azure AD。</span><span class="sxs-lookup"><span data-stu-id="94ba4-143">The assumption is that if a disabled user account is found, then we will not find another active account later and the object is provisioned to Azure AD with the userPrincipalName and sourceAnchor found.</span></span> <span data-ttu-id="94ba4-144">如果有另一個使用中的帳戶加入相同的 Metaverse 物件，則會使用其 userPrincipalName 和 sourceAnchor。</span><span class="sxs-lookup"><span data-stu-id="94ba4-144">In case another active account will join to the same metaverse object, then its userPrincipalName and sourceAnchor will be used.</span></span>

## <a name="changing-sourceanchor"></a><span data-ttu-id="94ba4-145">變更 sourceAnchor</span><span class="sxs-lookup"><span data-stu-id="94ba4-145">Changing sourceAnchor</span></span>
<span data-ttu-id="94ba4-146">當物件匯出到 Azure AD 之後，則不允許再變更 sourceAnchor。</span><span class="sxs-lookup"><span data-stu-id="94ba4-146">When an object has been exported to Azure AD then it is not allowed to change the sourceAnchor anymore.</span></span> <span data-ttu-id="94ba4-147">當物件匯出之後，Metaverse 屬性 **cloudSourceAnchor** 就會設為 Azure AD 所接受的 **sourceAnchor** 值。</span><span class="sxs-lookup"><span data-stu-id="94ba4-147">When the object has been exported the metaverse attribute **cloudSourceAnchor** is set with the **sourceAnchor** value accepted by Azure AD.</span></span> <span data-ttu-id="94ba4-148">如果 **sourceAnchor** 已變更且不符合 **cloudSourceAnchor**，規則 **Out to AAD - User Join** 將會擲回 **sourceAnchor 屬性已經變更**的錯誤。</span><span class="sxs-lookup"><span data-stu-id="94ba4-148">If **sourceAnchor** is changed and not match **cloudSourceAnchor**, the rule **Out to AAD – User Join** will throw the error **sourceAnchor attribute has changed**.</span></span> <span data-ttu-id="94ba4-149">在此情況下，必須先更正組態或資料，讓 Metaverse 中再度具有相同的 sourceAnchor，才能再次同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="94ba4-149">In this case, the configuration or data must be corrected so the same sourceAnchor is present in the metaverse again before the object can be synchronized again.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="94ba4-150">其他資源</span><span class="sxs-lookup"><span data-stu-id="94ba4-150">Additional Resources</span></span>
* [<span data-ttu-id="94ba4-151">Azure AD Connect 同步處理：自訂同步處理選項</span><span class="sxs-lookup"><span data-stu-id="94ba4-151">Azure AD Connect Sync: Customizing Synchronization options</span></span>](active-directory-aadconnectsync-whatis.md)
* [<span data-ttu-id="94ba4-152">整合內部部署身分識別與 Azure Active Directory</span><span class="sxs-lookup"><span data-stu-id="94ba4-152">Integrating your on-premises identities with Azure Active Directory</span></span>](active-directory-aadconnect.md)

