---
title: "改善效能，使用 Azure Service Bus aaaBest 作法 |Microsoft 文件"
description: "描述如何 toouse 交換時，服務匯流排 toooptimize 效能代理訊息。"
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: e756c15d-31fc-45c0-8df4-0bca0da10bb2
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 05/10/2017
ms.author: sethm
ms.openlocfilehash: 52764d227757cbb11246675878933f21685817f1
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="best-practices-for-performance-improvements-using-service-bus-messaging"></a><span data-ttu-id="18c84-103">使用服務匯流排傳訊的效能改進最佳作法</span><span class="sxs-lookup"><span data-stu-id="18c84-103">Best Practices for performance improvements using Service Bus Messaging</span></span>

<span data-ttu-id="18c84-104">本文說明如何 toouse [Azure 服務匯流排傳訊](https://azure.microsoft.com/services/service-bus/)toooptimize 效能時交換代理訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-104">This article describes how toouse [Azure Service Bus messaging](https://azure.microsoft.com/services/service-bus/) toooptimize performance when exchanging brokered messages.</span></span> <span data-ttu-id="18c84-105">hello 本主題的第一個部分說明 hello 不同的機制，提供 toohelp 增加效能。</span><span class="sxs-lookup"><span data-stu-id="18c84-105">hello first part of this topic describes hello different mechanisms that are offered toohelp increase performance.</span></span> <span data-ttu-id="18c84-106">hello 第二個部分提供指引 toouse Service Bus 可以提供的方式如何 hello 在指定案例最佳效能。</span><span class="sxs-lookup"><span data-stu-id="18c84-106">hello second part provides guidance on how toouse Service Bus in a way that can offer hello best performance in a given scenario.</span></span>

<span data-ttu-id="18c84-107">本主題中，整個 hello 詞彙 「 用戶端 」 是指 tooany 實體存取服務匯流排。</span><span class="sxs-lookup"><span data-stu-id="18c84-107">Throughout this topic, hello term "client" refers tooany entity that accesses Service Bus.</span></span> <span data-ttu-id="18c84-108">用戶端可以擔任傳送者或接收者的 hello 角色。</span><span class="sxs-lookup"><span data-stu-id="18c84-108">A client can take hello role of a sender or a receiver.</span></span> <span data-ttu-id="18c84-109">hello 詞彙 「 寄件者 」 用於服務匯流排佇列或主題用戶端傳送的郵件 tooa 服務匯流排佇列或主題。</span><span class="sxs-lookup"><span data-stu-id="18c84-109">hello term "sender" is used for a Service Bus queue or topic client that sends messages tooa Service Bus queue or topic.</span></span> <span data-ttu-id="18c84-110">hello 詞彙 「 接收者 」 是指 tooa 服務匯流排佇列或訂閱用戶端會接收來自服務匯流排佇列或訂閱訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-110">hello term "receiver" refers tooa Service Bus queue or subscription client that receives messages from a Service Bus queue or subscription.</span></span>

<span data-ttu-id="18c84-111">下列各節介紹數個服務匯流排使用 toohelp 提升效能的概念。</span><span class="sxs-lookup"><span data-stu-id="18c84-111">These sections introduce several concepts that Service Bus uses toohelp boost performance.</span></span>

## <a name="protocols"></a><span data-ttu-id="18c84-112">通訊協定</span><span class="sxs-lookup"><span data-stu-id="18c84-112">Protocols</span></span>
<span data-ttu-id="18c84-113">服務匯流排可讓用戶端 toosend 和接收訊息，透過三種通訊協定之一：</span><span class="sxs-lookup"><span data-stu-id="18c84-113">Service Bus enables clients toosend and receive messages via one of three protocols:</span></span>

1. <span data-ttu-id="18c84-114">進階訊息佇列通訊協定 (AMQP)</span><span class="sxs-lookup"><span data-stu-id="18c84-114">Advanced Message Queuing Protocol (AMQP)</span></span>
2. <span data-ttu-id="18c84-115">服務匯流排傳訊通訊協定 (SBMP)</span><span class="sxs-lookup"><span data-stu-id="18c84-115">Service Bus Messaging Protocol (SBMP)</span></span>
3. <span data-ttu-id="18c84-116">HTTP</span><span class="sxs-lookup"><span data-stu-id="18c84-116">HTTP</span></span>

<span data-ttu-id="18c84-117">AMQP 和 SBMP 會更有效率，因為它們會維護 hello 連接 tooService 匯流排，只要存在 hello 訊息 factory。</span><span class="sxs-lookup"><span data-stu-id="18c84-117">AMQP and SBMP are more efficient, because they maintain hello connection tooService Bus as long as hello messaging factory exists.</span></span> <span data-ttu-id="18c84-118">它也會實作批次處理和預先擷取作業。</span><span class="sxs-lookup"><span data-stu-id="18c84-118">It also implements batching and prefetching.</span></span> <span data-ttu-id="18c84-119">除非明確所述，本主題中的所有內容會都假設 hello 使用 AMQP 或 SBMP。</span><span class="sxs-lookup"><span data-stu-id="18c84-119">Unless explicitly mentioned, all content in this topic assumes hello use of AMQP or SBMP.</span></span>

## <a name="reusing-factories-and-clients"></a><span data-ttu-id="18c84-120">重複使用處理站和用戶端</span><span class="sxs-lookup"><span data-stu-id="18c84-120">Reusing factories and clients</span></span>
<span data-ttu-id="18c84-121">服務匯流排用戶端物件，例如 [QueueClient][QueueClient] 或 [MessageSender][MessageSender]，會透過也提供內部連接管理的 [MessagingFactory][MessagingFactory] 物件來建立。</span><span class="sxs-lookup"><span data-stu-id="18c84-121">Service Bus client objects, such as [QueueClient][QueueClient] or [MessageSender][MessageSender], are created through a [MessagingFactory][MessagingFactory] object, which also provides internal management of connections.</span></span> <span data-ttu-id="18c84-122">您應該關閉訊息中心或佇列、 主題及訂閱用戶端傳送訊息，並再重新建立它們時傳送嗨下一個訊息之後。</span><span class="sxs-lookup"><span data-stu-id="18c84-122">You should not close messaging factories or queue, topic, and subscription clients after you send a message, and then re-create them when you send hello next message.</span></span> <span data-ttu-id="18c84-123">關閉訊息中心刪除 hello 連接 toohello 服務匯流排服務，並重新建立 hello 處理站時，建立新的連接。</span><span class="sxs-lookup"><span data-stu-id="18c84-123">Closing a messaging factory deletes hello connection toohello Service Bus service, and a new connection is established when recreating hello factory.</span></span> <span data-ttu-id="18c84-124">建立連接，您可以避免重複使用昂貴的作業 hello 相同的處理站和用戶端物件的多個作業。</span><span class="sxs-lookup"><span data-stu-id="18c84-124">Establishing a connection is an expensive operation that you can avoid by re-using hello same factory and client objects for multiple operations.</span></span> <span data-ttu-id="18c84-125">您可以安全地使用 hello [QueueClient] [ QueueClient]物件以傳送訊息，從並行的非同步作業和多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="18c84-125">You can safely use hello [QueueClient][QueueClient] object for sending messages from concurrent asynchronous operations and multiple threads.</span></span> 

## <a name="concurrent-operations"></a><span data-ttu-id="18c84-126">並行作業</span><span class="sxs-lookup"><span data-stu-id="18c84-126">Concurrent operations</span></span>
<span data-ttu-id="18c84-127">執行作業 (傳送、接收、刪除等等) 需要一點時間。</span><span class="sxs-lookup"><span data-stu-id="18c84-127">Performing an operation (send, receive, delete, etc.) takes some time.</span></span> <span data-ttu-id="18c84-128">此時根據 hello 服務匯流排服務包括 hello 處理 hello 作業的加法 toohello 延遲 hello 要求與 hello 回覆中。</span><span class="sxs-lookup"><span data-stu-id="18c84-128">This time includes hello processing of hello operation by hello Service Bus service in addition toohello latency of hello request and hello reply.</span></span> <span data-ttu-id="18c84-129">tooincrease hello 數字，每次的作業，必須同時執行作業。</span><span class="sxs-lookup"><span data-stu-id="18c84-129">tooincrease hello number of operations per time, operations must execute concurrently.</span></span> <span data-ttu-id="18c84-130">您可以利用數個不同方式執行這項操作：</span><span class="sxs-lookup"><span data-stu-id="18c84-130">You can do this in several different ways:</span></span>

* <span data-ttu-id="18c84-131">**非同步作業**: hello 用戶端所執行的非同步作業排程的作業。</span><span class="sxs-lookup"><span data-stu-id="18c84-131">**Asynchronous operations**: hello client schedules operations by performing asynchronous operations.</span></span> <span data-ttu-id="18c84-132">hello 前一個要求完成之前，會發出 hello 下一個要求。</span><span class="sxs-lookup"><span data-stu-id="18c84-132">hello next request is started before hello previous request is completed.</span></span> <span data-ttu-id="18c84-133">hello 下列是非同步傳送作業的範例：</span><span class="sxs-lookup"><span data-stu-id="18c84-133">hello following is an example of an asynchronous send operation:</span></span>
  
 ```csharp
  BrokeredMessage m1 = new BrokeredMessage(body);
  BrokeredMessage m2 = new BrokeredMessage(body);
  
  Task send1 = queueClient.SendAsync(m1).ContinueWith((t) => 
    {
      Console.WriteLine("Sent message #1");
    });
  Task send2 = queueClient.SendAsync(m2).ContinueWith((t) => 
    {
      Console.WriteLine("Sent message #2");
    });
  Task.WaitAll(send1, send2);
  Console.WriteLine("All messages sent");
  ```
  
  <span data-ttu-id="18c84-134">非同步接收作業的範例如下：</span><span class="sxs-lookup"><span data-stu-id="18c84-134">This is an example of an asynchronous receive operation:</span></span>
  
  ```csharp
  Task receive1 = queueClient.ReceiveAsync().ContinueWith(ProcessReceivedMessage);
  Task receive2 = queueClient.ReceiveAsync().ContinueWith(ProcessReceivedMessage);
  
  Task.WaitAll(receive1, receive2);
  Console.WriteLine("All messages received");
  
  async void ProcessReceivedMessage(Task<BrokeredMessage> t)
  {
    BrokeredMessage m = t.Result;
    Console.WriteLine("{0} received", m.Label);
    await m.CompleteAsync();
    Console.WriteLine("{0} complete", m.Label);
  }
  ```
* <span data-ttu-id="18c84-135">**多個中心**： 所有用戶端 （傳送者在加法 tooreceivers） 所建立的 hello 相同 factory 共用一個 TCP 連線。</span><span class="sxs-lookup"><span data-stu-id="18c84-135">**Multiple factories**: all clients (senders in addition tooreceivers) that are created by hello same factory share one TCP connection.</span></span> <span data-ttu-id="18c84-136">hello 最大訊息輸送量受限於 hello 可以透過此 TCP 連線的作業數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-136">hello maximum message throughput is limited by hello number of operations that can go through this TCP connection.</span></span> <span data-ttu-id="18c84-137">可以透過單一中心取得的 hello 輸送量與 TCP 來回行程時間和訊息大小的極大的不同。</span><span class="sxs-lookup"><span data-stu-id="18c84-137">hello throughput that can be obtained with a single factory varies greatly with TCP round-trip times and message size.</span></span> <span data-ttu-id="18c84-138">tooobtain 更高的輸送量速率，您應該使用多個訊息中心。</span><span class="sxs-lookup"><span data-stu-id="18c84-138">tooobtain higher throughput rates, you should use multiple messaging factories.</span></span>

## <a name="receive-mode"></a><span data-ttu-id="18c84-139">接收模式</span><span class="sxs-lookup"><span data-stu-id="18c84-139">Receive mode</span></span>
<span data-ttu-id="18c84-140">建立佇列或訂用帳戶用戶端時，您可以指定接收模式：「查看鎖定」或「接收與刪除」。</span><span class="sxs-lookup"><span data-stu-id="18c84-140">When creating a queue or subscription client, you can specify a receive mode: *Peek-lock* or *Receive and Delete*.</span></span> <span data-ttu-id="18c84-141">hello 預設接收模式是[PeekLock][PeekLock]。</span><span class="sxs-lookup"><span data-stu-id="18c84-141">hello default receive mode is [PeekLock][PeekLock].</span></span> <span data-ttu-id="18c84-142">以這種模式操作時，hello 用戶端傳送要求 tooreceive 訊息從服務匯流排。</span><span class="sxs-lookup"><span data-stu-id="18c84-142">When operating in this mode, hello client sends a request tooreceive a message from Service Bus.</span></span> <span data-ttu-id="18c84-143">Hello 用戶端收到 hello 訊息後，它會傳送要求 toocomplete hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-143">After hello client has received hello message, it sends a request toocomplete hello message.</span></span>

<span data-ttu-id="18c84-144">當太設定 hello 接收模式[ReceiveAndDelete][ReceiveAndDelete]，這兩個步驟會結合在單一要求中。</span><span class="sxs-lookup"><span data-stu-id="18c84-144">When setting hello receive mode too[ReceiveAndDelete][ReceiveAndDelete], both steps are combined in a single request.</span></span> <span data-ttu-id="18c84-145">這可減少 hello 總次數的作業，並可改善 hello 整體訊息輸送量。</span><span class="sxs-lookup"><span data-stu-id="18c84-145">This reduces hello overall number of operations, and can improve hello overall message throughput.</span></span> <span data-ttu-id="18c84-146">此效能提升伴隨 hello 風險的遺失訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-146">This performance gain comes at hello risk of losing messages.</span></span>

<span data-ttu-id="18c84-147">服務匯流排不支援接收和刪除作業的交易。</span><span class="sxs-lookup"><span data-stu-id="18c84-147">Service Bus does not support transactions for receive-and-delete operations.</span></span> <span data-ttu-id="18c84-148">此外，查看並鎖定語意的案例所需的任何在哪一個 hello 用戶端想要 toodefer 或[寄不出信件](service-bus-dead-letter-queues.md)訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-148">In addition, peek-lock semantics are required for any scenarios in which hello client wants toodefer or [dead-letter](service-bus-dead-letter-queues.md) a message.</span></span>

## <a name="client-side-batching"></a><span data-ttu-id="18c84-149">用戶端批次處理</span><span class="sxs-lookup"><span data-stu-id="18c84-149">Client-side batching</span></span>
<span data-ttu-id="18c84-150">用戶端批次處理可讓佇列或主題用戶端 toodelay hello 訊息傳送的一段時間的時間。</span><span class="sxs-lookup"><span data-stu-id="18c84-150">Client-side batching enables a queue or topic client toodelay hello sending of a message for a certain period of time.</span></span> <span data-ttu-id="18c84-151">如果 hello 用戶端會傳送其他訊息，此期間內，它將以單一批次的 hello 訊息傳輸。</span><span class="sxs-lookup"><span data-stu-id="18c84-151">If hello client sends additional messages during this time period, it transmits hello messages in a single batch.</span></span> <span data-ttu-id="18c84-152">用戶端批次處理也會導致佇列或訂閱的用戶端 toobatch 多個**完成**結合為單一要求的要求。</span><span class="sxs-lookup"><span data-stu-id="18c84-152">Client-side batching also causes a queue or subscription client toobatch multiple **Complete** requests into a single request.</span></span> <span data-ttu-id="18c84-153">批次處理僅適用於非同步**傳送**及**完成**作業。</span><span class="sxs-lookup"><span data-stu-id="18c84-153">Batching is only available for asynchronous **Send** and **Complete** operations.</span></span> <span data-ttu-id="18c84-154">同步作業會立即傳送 toohello 服務匯流排服務。</span><span class="sxs-lookup"><span data-stu-id="18c84-154">Synchronous operations are immediately sent toohello Service Bus service.</span></span> <span data-ttu-id="18c84-155">查看或接收作業不會進行批次處理，也不會跨用戶端進行。</span><span class="sxs-lookup"><span data-stu-id="18c84-155">Batching does not occur for peek or receive operations, nor does batching occur across clients.</span></span>

<span data-ttu-id="18c84-156">根據預設，用戶端使用的批次間隔為 20 毫秒。</span><span class="sxs-lookup"><span data-stu-id="18c84-156">By default, a client uses a batch interval of 20ms.</span></span> <span data-ttu-id="18c84-157">您可以變更設定 hello hello 批次間隔[BatchFlushInterval] [ BatchFlushInterval]屬性，才能建立 hello 訊息 factory。</span><span class="sxs-lookup"><span data-stu-id="18c84-157">You can change hello batch interval by setting hello [BatchFlushInterval][BatchFlushInterval] property before creating hello messaging factory.</span></span> <span data-ttu-id="18c84-158">這個設定會影響此處理站所建立的所有用戶端。</span><span class="sxs-lookup"><span data-stu-id="18c84-158">This setting affects all clients that are created by this factory.</span></span>

<span data-ttu-id="18c84-159">toodisable 批次處理，設定 hello [BatchFlushInterval] [ BatchFlushInterval]屬性太**TimeSpan.Zero**。</span><span class="sxs-lookup"><span data-stu-id="18c84-159">toodisable batching, set hello [BatchFlushInterval][BatchFlushInterval] property too**TimeSpan.Zero**.</span></span> <span data-ttu-id="18c84-160">例如：</span><span class="sxs-lookup"><span data-stu-id="18c84-160">For example:</span></span>

```csharp
MessagingFactorySettings mfs = new MessagingFactorySettings();
mfs.TokenProvider = tokenProvider;
mfs.NetMessagingTransportSettings.BatchFlushInterval = TimeSpan.FromSeconds(0.05);
MessagingFactory messagingFactory = MessagingFactory.Create(namespaceUri, mfs);
```

<span data-ttu-id="18c84-161">批次處理不會影響 hello 可計費訊息作業數目，並僅供 hello 服務匯流排用戶端通訊協定。</span><span class="sxs-lookup"><span data-stu-id="18c84-161">Batching does not affect hello number of billable messaging operations, and is available only for hello Service Bus client protocol.</span></span> <span data-ttu-id="18c84-162">hello HTTP 通訊協定不支援批次處理。</span><span class="sxs-lookup"><span data-stu-id="18c84-162">hello HTTP protocol does not support batching.</span></span>

## <a name="batching-store-access"></a><span data-ttu-id="18c84-163">批次處理存放區存取</span><span class="sxs-lookup"><span data-stu-id="18c84-163">Batching store access</span></span>
<span data-ttu-id="18c84-164">tooincrease hello 輸送量佇列、 主題或訂用帳戶的服務匯流排批次多個訊息時就會將寫入 tooits 內部存放區。</span><span class="sxs-lookup"><span data-stu-id="18c84-164">tooincrease hello throughput of a queue, topic, or subscription, Service Bus batches multiple messages when it writes tooits internal store.</span></span> <span data-ttu-id="18c84-165">如果啟用佇列或主題，會進行批次處理訊息寫入到 hello 存放區。</span><span class="sxs-lookup"><span data-stu-id="18c84-165">If enabled on a queue or topic, writing messages into hello store will be batched.</span></span> <span data-ttu-id="18c84-166">如果啟用佇列或訂閱，會進行批次處理從 hello 存放區刪除訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-166">If enabled on a queue or subscription, deleting messages from hello store will be batched.</span></span> <span data-ttu-id="18c84-167">如果實體啟用批次存放區存取時，服務匯流排會延遲對於向上 too20ms 所實體存放區寫入作業。</span><span class="sxs-lookup"><span data-stu-id="18c84-167">If batched store access is enabled for an entity, Service Bus delays a store write operation regarding that entity by up too20ms.</span></span> <span data-ttu-id="18c84-168">此間隔期間發生的其他存放區作業會加入 toohello 批次。</span><span class="sxs-lookup"><span data-stu-id="18c84-168">Additional store operations that occur during this interval are added toohello batch.</span></span> <span data-ttu-id="18c84-169">批次處理的存放區存取只會影響**傳送**和**完成**作業；接收作業不會受到影響。</span><span class="sxs-lookup"><span data-stu-id="18c84-169">Batched store access only affects **Send** and **Complete** operations; receive operations are not affected.</span></span> <span data-ttu-id="18c84-170">批次處理的存放區存取是實體上的屬性。</span><span class="sxs-lookup"><span data-stu-id="18c84-170">Batched store access is a property on an entity.</span></span> <span data-ttu-id="18c84-171">批次處理會在啟用批次處理存放區存取的所有實體進行。</span><span class="sxs-lookup"><span data-stu-id="18c84-171">Batching occurs across all entities that enable batched store access.</span></span>

<span data-ttu-id="18c84-172">建立新佇列、主題或訂用帳戶時，預設會啟用批次處理的存放區存取。</span><span class="sxs-lookup"><span data-stu-id="18c84-172">When creating a new queue, topic or subscription, batched store access is enabled by default.</span></span> <span data-ttu-id="18c84-173">toodisable 批次存放區存取，集合 hello [EnableBatchedOperations] [ EnableBatchedOperations]屬性太**false**之前建立 hello 的實體。</span><span class="sxs-lookup"><span data-stu-id="18c84-173">toodisable batched store access, set hello [EnableBatchedOperations][EnableBatchedOperations] property too**false** before creating hello entity.</span></span> <span data-ttu-id="18c84-174">例如：</span><span class="sxs-lookup"><span data-stu-id="18c84-174">For example:</span></span>

```csharp
QueueDescription qd = new QueueDescription();
qd.EnableBatchedOperations = false;
Queue q = namespaceManager.CreateQueue(qd);
```

<span data-ttu-id="18c84-175">批次存放區存取並不會影響 hello 可計費訊息作業數目，而且是佇列、 主題或訂用帳戶的屬性。</span><span class="sxs-lookup"><span data-stu-id="18c84-175">Batched store access does not affect hello number of billable messaging operations, and is a property of a queue, topic, or subscription.</span></span> <span data-ttu-id="18c84-176">它是獨立的 hello 接收模式和 hello 使用用戶端與 hello 服務匯流排服務之間的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="18c84-176">It is independent of hello receive mode and hello protocol that is used between a client and hello Service Bus service.</span></span>

## <a name="prefetching"></a><span data-ttu-id="18c84-177">預先擷取</span><span class="sxs-lookup"><span data-stu-id="18c84-177">Prefetching</span></span>
<span data-ttu-id="18c84-178">執行接收作業時，預先擷取可讓 hello 佇列或訂閱用戶端 tooload 額外的訊息從 hello 服務。</span><span class="sxs-lookup"><span data-stu-id="18c84-178">Prefetching enables hello queue or subscription client tooload additional messages from hello service when it performs a receive operation.</span></span> <span data-ttu-id="18c84-179">hello 用戶端會將這些訊息儲存在本機快取。</span><span class="sxs-lookup"><span data-stu-id="18c84-179">hello client stores these messages in a local cache.</span></span> <span data-ttu-id="18c84-180">hello hello 快取大小由 hello [QueueClient.PrefetchCount] [ QueueClient.PrefetchCount]或[SubscriptionClient.PrefetchCount] [ SubscriptionClient.PrefetchCount]屬性。</span><span class="sxs-lookup"><span data-stu-id="18c84-180">hello size of hello cache is determined by hello [QueueClient.PrefetchCount][QueueClient.PrefetchCount] or [SubscriptionClient.PrefetchCount][SubscriptionClient.PrefetchCount] properties.</span></span> <span data-ttu-id="18c84-181">啟用預先擷取的每個用戶端會維護自己的快取。</span><span class="sxs-lookup"><span data-stu-id="18c84-181">Each client that enables prefetching maintains its own cache.</span></span> <span data-ttu-id="18c84-182">快取不會跨用戶端共用。</span><span class="sxs-lookup"><span data-stu-id="18c84-182">A cache is not shared across clients.</span></span> <span data-ttu-id="18c84-183">如果 hello 用戶端起始接收作業，而且其快取是空的 hello 服務會傳輸一批訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-183">If hello client initiates a receive operation and its cache is empty, hello service transmits a batch of messages.</span></span> <span data-ttu-id="18c84-184">hello hello 批次大小等於 hello hello 快取或 256 KB 的大小，以較小。</span><span class="sxs-lookup"><span data-stu-id="18c84-184">hello size of hello batch equals hello size of hello cache or 256 KB, whichever is smaller.</span></span> <span data-ttu-id="18c84-185">如果 hello 用戶端起始接收作業 hello 快取包含一則訊息，hello 訊息是來自 hello 快取中。</span><span class="sxs-lookup"><span data-stu-id="18c84-185">If hello client initiates a receive operation and hello cache contains a message, hello message is taken from hello cache.</span></span>

<span data-ttu-id="18c84-186">當訊息預先提取，hello 服務鎖定 hello 預先擷取的訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-186">When a message is prefetched, hello service locks hello prefetched message.</span></span> <span data-ttu-id="18c84-187">如此一來，hello 預先擷取的訊息無法接收不同的接收者。</span><span class="sxs-lookup"><span data-stu-id="18c84-187">By doing this, hello prefetched message cannot be received by a different receiver.</span></span> <span data-ttu-id="18c84-188">如果 hello 接收者 hello 鎖定到期之前，無法完成 hello 訊息，hello 訊息會變成可用 tooother 接收者。</span><span class="sxs-lookup"><span data-stu-id="18c84-188">If hello receiver cannot complete hello message before hello lock expires, hello message becomes available tooother receivers.</span></span> <span data-ttu-id="18c84-189">預先提取的 hello hello 訊息副本會保留在 hello 快取。</span><span class="sxs-lookup"><span data-stu-id="18c84-189">hello prefetched copy of hello message remains in hello cache.</span></span> <span data-ttu-id="18c84-190">hello 接收器，以便取用 hello 過期快取嘗試 toocomplete 該訊息時，複製將會收到例外狀況。</span><span class="sxs-lookup"><span data-stu-id="18c84-190">hello receiver that consumes hello expired cached copy will receive an exception when it tries toocomplete that message.</span></span> <span data-ttu-id="18c84-191">根據預設，hello 訊息鎖定 60 秒之後到期。</span><span class="sxs-lookup"><span data-stu-id="18c84-191">By default, hello message lock expires after 60 seconds.</span></span> <span data-ttu-id="18c84-192">這個值可以是擴充的 too5 分鐘。</span><span class="sxs-lookup"><span data-stu-id="18c84-192">This value can be extended too5 minutes.</span></span> <span data-ttu-id="18c84-193">過期的訊息 tooprevent hello 耗用量，hello 快取大小一律應小於 hello 可供用戶端 hello 鎖定逾時間隔內的訊息數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-193">tooprevent hello consumption of expired messages, hello cache size should always be smaller than hello number of messages that can be consumed by a client within hello lock time-out interval.</span></span>

<span data-ttu-id="18c84-194">使用 60 秒的 hello 預設鎖定到期時，理想值[SubscriptionClient.PrefetchCount] [ SubscriptionClient.PrefetchCount]上限的 20 倍 hello 會處理所有接收者 hello factory 的速度。</span><span class="sxs-lookup"><span data-stu-id="18c84-194">When using hello default lock expiration of 60 seconds, a good value for [SubscriptionClient.PrefetchCount][SubscriptionClient.PrefetchCount] is 20 times hello maximum processing rates of all receivers of hello factory.</span></span> <span data-ttu-id="18c84-195">例如，中心建立 3 個接收者，而且每個接收者可以處理 too10 每秒的訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-195">For example, a factory creates 3 receivers, and each receiver can process up too10 messages per second.</span></span> <span data-ttu-id="18c84-196">hello 預先擷取計數不應該超過 20 X 3 X 10 = 600。</span><span class="sxs-lookup"><span data-stu-id="18c84-196">hello prefetch count should not exceed 20 X 3 X 10 = 600.</span></span> <span data-ttu-id="18c84-197">根據預設， [QueueClient.PrefetchCount] [ QueueClient.PrefetchCount]是集 too0，表示從 hello 服務擷取任何額外的訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-197">By default, [QueueClient.PrefetchCount][QueueClient.PrefetchCount] is set too0, which means that no additional messages are fetched from hello service.</span></span>

<span data-ttu-id="18c84-198">預先擷取訊息會增加 hello 的佇列或訂閱的整體輸送量，因為它可以減少 hello 訊息作業或來回行程的整體數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-198">Prefetching messages increases hello overall throughput for a queue or subscription because it reduces hello overall number of message operations, or round trips.</span></span> <span data-ttu-id="18c84-199">擷取 hello 第一則訊息，不過，將會延長 （因為 toohello 增加訊息大小）。</span><span class="sxs-lookup"><span data-stu-id="18c84-199">Fetching hello first message, however, will take longer (due toohello increased message size).</span></span> <span data-ttu-id="18c84-200">接收預先擷取的訊息將會比較快，因為 hello 用戶端已下載這些訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-200">Receiving prefetched messages will be faster because these messages have already been downloaded by hello client.</span></span>

<span data-ttu-id="18c84-201">hello 伺服器會檢查訊息的 hello 存留時間 (TTL) 屬性，在 hello 伺服器會傳送 hello 訊息 toohello 用戶端 hello 階段。</span><span class="sxs-lookup"><span data-stu-id="18c84-201">hello time-to-live (TTL) property of a message is checked by hello server at hello time hello server sends hello message toohello client.</span></span> <span data-ttu-id="18c84-202">hello 用戶端收到 hello 訊息時，不會檢查 hello 訊息的 TTL 屬性。</span><span class="sxs-lookup"><span data-stu-id="18c84-202">hello client does not check hello message’s TTL property when hello message is received.</span></span> <span data-ttu-id="18c84-203">相反地，即使 hello 訊息 TTL 已通過由 hello 用戶端快取的 hello 訊息時，可以收到 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-203">Instead, hello message can be received even if hello message’s TTL has passed while hello message was cached by hello client.</span></span>

<span data-ttu-id="18c84-204">預先擷取不會影響 hello 可計費訊息作業數目，並僅供 hello 服務匯流排用戶端通訊協定。</span><span class="sxs-lookup"><span data-stu-id="18c84-204">Prefetching does not affect hello number of billable messaging operations, and is available only for hello Service Bus client protocol.</span></span> <span data-ttu-id="18c84-205">hello HTTP 通訊協定不支援預先擷取。</span><span class="sxs-lookup"><span data-stu-id="18c84-205">hello HTTP protocol does not support prefetching.</span></span> <span data-ttu-id="18c84-206">同步和非同步接收作業皆可使用預先擷取。</span><span class="sxs-lookup"><span data-stu-id="18c84-206">Prefetching is available for both synchronous and asynchronous receive operations.</span></span>

## <a name="express-queues-and-topics"></a><span data-ttu-id="18c84-207">快速佇列和主題</span><span class="sxs-lookup"><span data-stu-id="18c84-207">Express queues and topics</span></span>

<span data-ttu-id="18c84-208">快速實體啟用高輸送量和低的延遲案例，而且只支援 hello 標準通訊層。</span><span class="sxs-lookup"><span data-stu-id="18c84-208">Express entities enable high throughput and reduced latency scenarios, and are supported only in hello Standard messaging tier.</span></span> <span data-ttu-id="18c84-209">所建立的實體[Premium 命名空間](service-bus-premium-messaging.md)不支援 hello express 的選項。</span><span class="sxs-lookup"><span data-stu-id="18c84-209">Entities created in [Premium namespaces](service-bus-premium-messaging.md) do not support hello express option.</span></span> <span data-ttu-id="18c84-210">使用快速實體時，如果 tooa 佇列或主題時，會將訊息傳送 hello 訊息不立即會儲存在 hello 訊息存放區。</span><span class="sxs-lookup"><span data-stu-id="18c84-210">With express entities, if a message is sent tooa queue or topic, hello message is not immediately stored in hello messaging store.</span></span> <span data-ttu-id="18c84-211">相反地，它會快取在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="18c84-211">Instead, it is cached in memory.</span></span> <span data-ttu-id="18c84-212">如果訊息保留在佇列中的 hello 超過幾秒鐘，它會自動寫入 toostable 存放裝置，藉此保護到期 tooan 中斷不會遺失。</span><span class="sxs-lookup"><span data-stu-id="18c84-212">If a message remains in hello queue for more than a few seconds, it is automatically written toostable storage, thus protecting it against loss due tooan outage.</span></span> <span data-ttu-id="18c84-213">寫入記憶體快取的 hello 訊息會增加輸送量並降低延遲，因為沒有存取 toostable 傳送的 hello 時間 hello 訊息儲存。</span><span class="sxs-lookup"><span data-stu-id="18c84-213">Writing hello message into a memory cache increases throughput and reduces latency because there is no access toostable storage at hello time hello message is sent.</span></span> <span data-ttu-id="18c84-214">在幾秒鐘內耗用的訊息不會寫入 toohello 訊息存放區。</span><span class="sxs-lookup"><span data-stu-id="18c84-214">Messages that are consumed within a few seconds are not written toohello messaging store.</span></span> <span data-ttu-id="18c84-215">hello 下列範例會建立快速主題。</span><span class="sxs-lookup"><span data-stu-id="18c84-215">hello following example creates an express topic.</span></span>

```csharp
TopicDescription td = new TopicDescription(TopicName);
td.EnableExpress = true;
namespaceManager.CreateTopic(td);
```

<span data-ttu-id="18c84-216">如果包含不可遺失的重要資訊的訊息傳送 tooan 快速實體，hello 寄件者可以強制執行服務匯流排 tooimmediately 保存 hello 訊息 toostable 存放裝置設定 hello [ForcePersistence] [ForcePersistence]屬性太**true**。</span><span class="sxs-lookup"><span data-stu-id="18c84-216">If a message containing critical information that must not be lost is sent tooan express entity, hello sender can force Service Bus tooimmediately persist hello message toostable storage by setting hello [ForcePersistence][ForcePersistence] property too**true**.</span></span>

> [!NOTE]
> <span data-ttu-id="18c84-217">快速實體並不支援交易。</span><span class="sxs-lookup"><span data-stu-id="18c84-217">Express entities do not support transactions.</span></span>

## <a name="use-of-partitioned-queues-or-topics"></a><span data-ttu-id="18c84-218">使用分割的佇列或主題</span><span class="sxs-lookup"><span data-stu-id="18c84-218">Use of partitioned queues or topics</span></span>
<span data-ttu-id="18c84-219">就內部而言，Service Bus 使用相同的節點和訊息存放區 tooprocess hello 和儲存訊息實體 （佇列或主題） 的所有訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-219">Internally, Service Bus uses hello same node and messaging store tooprocess and store all messages for a messaging entity (queue or topic).</span></span> <span data-ttu-id="18c84-220">磁碟分割的佇列或主題上 hello，換句話說，都會分散到多個節點和訊息存放區。</span><span class="sxs-lookup"><span data-stu-id="18c84-220">A partitioned queue or topic, on hello other hand, is distributed across multiple nodes and messaging stores.</span></span> <span data-ttu-id="18c84-221">分割的佇列和主題不僅會產生比一般佇列和主題更高的輸送量，也會展現較優異的可用性。</span><span class="sxs-lookup"><span data-stu-id="18c84-221">Partitioned queues and topics not only yield a higher throughput than regular queues and topics, they also exhibit superior availability.</span></span> <span data-ttu-id="18c84-222">toocreate 的資料分割的實體集 hello [EnablePartitioning] [ EnablePartitioning]屬性太**true**hello 下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="18c84-222">toocreate a partitioned entity, set hello [EnablePartitioning][EnablePartitioning] property too**true**, as shown in hello following example.</span></span> <span data-ttu-id="18c84-223">如需分割實體的詳細資訊，請參閱[分割的傳訊實體][Partitioned messaging entities]。</span><span class="sxs-lookup"><span data-stu-id="18c84-223">For more information about partitioned entities, see [Partitioned messaging entities][Partitioned messaging entities].</span></span>

```csharp
// Create partitioned queue.
QueueDescription qd = new QueueDescription(QueueName);
qd.EnablePartitioning = true;
namespaceManager.CreateQueue(qd);
```

## <a name="use-of-multiple-queues"></a><span data-ttu-id="18c84-224">使用多個佇列</span><span class="sxs-lookup"><span data-stu-id="18c84-224">Use of multiple queues</span></span>

<span data-ttu-id="18c84-225">如果不可能 toouse 分割的佇列或主題或 hello 預期負載無法處理的單一磁碟分割的佇列或主題，您必須使用多個訊息實體。</span><span class="sxs-lookup"><span data-stu-id="18c84-225">If it is not possible toouse a partitioned queue or topic, or hello expected load cannot be handled by a single partitioned queue or topic, you must use multiple messaging entities.</span></span> <span data-ttu-id="18c84-226">當使用多個實體，建立專用的用戶端，每個實體，而不是使用 hello 相同用戶端的所有實體。</span><span class="sxs-lookup"><span data-stu-id="18c84-226">When using multiple entities, create a dedicated client for each entity, instead of using hello same client for all entities.</span></span>

## <a name="development-and-testing-features"></a><span data-ttu-id="18c84-227">開發與測試功能</span><span class="sxs-lookup"><span data-stu-id="18c84-227">Development and testing features</span></span>

<span data-ttu-id="18c84-228">服務匯流排有一項專門用於開發的功能，此功能**永遠不應該用在生產組態**：[TopicDescription.EnableFilteringMessagesBeforePublishing][]。</span><span class="sxs-lookup"><span data-stu-id="18c84-228">Service Bus has one feature that is used specifically for development which **should never be used in production configurations**: [TopicDescription.EnableFilteringMessagesBeforePublishing][].</span></span>

<span data-ttu-id="18c84-229">當新的規則或篩選器加入 toohello 主題時，您可以使用[TopicDescription.EnableFilteringMessagesBeforePublishing][] hello 新的篩選條件運算式的 tooverify 是否正常運作。</span><span class="sxs-lookup"><span data-stu-id="18c84-229">When new rules or filters are added toohello topic, you can use [TopicDescription.EnableFilteringMessagesBeforePublishing][] tooverify that hello new filter expression is working as expected.</span></span>

## <a name="scenarios"></a><span data-ttu-id="18c84-230">案例</span><span class="sxs-lookup"><span data-stu-id="18c84-230">Scenarios</span></span>
<span data-ttu-id="18c84-231">hello 下列各節描述一般傳訊案例，並簡述慣用的 hello 服務匯流排設定。</span><span class="sxs-lookup"><span data-stu-id="18c84-231">hello following sections describe typical messaging scenarios and outline hello preferred Service Bus settings.</span></span> <span data-ttu-id="18c84-232">輸送量速率會分類為小型 (小於 1 則訊息/秒)、中型 (1 則訊息/秒或更多但小於 100 則訊息/秒) 和高型 (100 則訊息/秒或更多)。</span><span class="sxs-lookup"><span data-stu-id="18c84-232">Throughput rates are classified as small (less than 1 message/second), moderate (1 message/second or greater but less than 100 messages/second) and high (100 messages/second or greater).</span></span> <span data-ttu-id="18c84-233">hello 的用戶端數目可分為小 （5 或更少），「 中 」 (5 個以上但小於或等於 too20)，和大 （超過 20）。</span><span class="sxs-lookup"><span data-stu-id="18c84-233">hello number of clients are classified as small (5 or fewer), moderate (more than 5 but less than or equal too20), and large (more than 20).</span></span>

### <a name="high-throughput-queue"></a><span data-ttu-id="18c84-234">高輸送量佇列</span><span class="sxs-lookup"><span data-stu-id="18c84-234">High-throughput queue</span></span>
<span data-ttu-id="18c84-235">目標： 在單一佇列的 hello 輸送量最大化。</span><span class="sxs-lookup"><span data-stu-id="18c84-235">Goal: Maximize hello throughput of a single queue.</span></span> <span data-ttu-id="18c84-236">hello 傳送者和接收者數目很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-236">hello number of senders and receivers is small.</span></span>

* <span data-ttu-id="18c84-237">使用分割的佇列以改善效能和可用性。</span><span class="sxs-lookup"><span data-stu-id="18c84-237">Use a partitioned queue for improved performance and availability.</span></span>
* <span data-ttu-id="18c84-238">tooincrease hello 整體傳送速率，到 hello 佇列，請使用多個訊息 factory toocreate 寄件者。</span><span class="sxs-lookup"><span data-stu-id="18c84-238">tooincrease hello overall send rate into hello queue, use multiple message factories toocreate senders.</span></span> <span data-ttu-id="18c84-239">對每個傳送者使用非同步作業或多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="18c84-239">For each sender, use asynchronous operations or multiple threads.</span></span>
* <span data-ttu-id="18c84-240">整體 tooincrease hello 從 hello 佇列接收速率，請使用多個訊息 factory toocreate 接收者。</span><span class="sxs-lookup"><span data-stu-id="18c84-240">tooincrease hello overall receive rate from hello queue, use multiple message factories toocreate receivers.</span></span>
* <span data-ttu-id="18c84-241">使用非同步作業 tootake 利用用戶端批次處理。</span><span class="sxs-lookup"><span data-stu-id="18c84-241">Use asynchronous operations tootake advantage of client-side batching.</span></span>
* <span data-ttu-id="18c84-242">設定批次處理間隔 too50ms tooreduce hello 數量的服務匯流排用戶端通訊協定傳送 hello。</span><span class="sxs-lookup"><span data-stu-id="18c84-242">Set hello batching interval too50ms tooreduce hello number of Service Bus client protocol transmissions.</span></span> <span data-ttu-id="18c84-243">如果使用多個傳送者，請增加批次處理間隔 too100ms hello。</span><span class="sxs-lookup"><span data-stu-id="18c84-243">If multiple senders are used, increase hello batching interval too100ms.</span></span>
* <span data-ttu-id="18c84-244">讓批次處理的存放區存取保持啟用。</span><span class="sxs-lookup"><span data-stu-id="18c84-244">Leave batched store access enabled.</span></span> <span data-ttu-id="18c84-245">這會增加整體的 hello 訊息可以寫入 hello 佇列的速率。</span><span class="sxs-lookup"><span data-stu-id="18c84-245">This increases hello overall rate at which messages can be written into hello queue.</span></span>
* <span data-ttu-id="18c84-246">設定 hello 預先擷取計數 too20 時間 hello 處理速率上限的所有接收者處理站。</span><span class="sxs-lookup"><span data-stu-id="18c84-246">Set hello prefetch count too20 times hello maximum processing rates of all receivers of a factory.</span></span> <span data-ttu-id="18c84-247">這會減少 hello 服務匯流排用戶端通訊協定傳輸數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-247">This reduces hello number of Service Bus client protocol transmissions.</span></span>

### <a name="multiple-high-throughput-queues"></a><span data-ttu-id="18c84-248">多個高輸送量佇列</span><span class="sxs-lookup"><span data-stu-id="18c84-248">Multiple high-throughput queues</span></span>
<span data-ttu-id="18c84-249">目標：最大化多個佇列的整體輸送量。</span><span class="sxs-lookup"><span data-stu-id="18c84-249">Goal: Maximize overall throughput of multiple queues.</span></span> <span data-ttu-id="18c84-250">個別佇列的 hello 輸送量為中或大。</span><span class="sxs-lookup"><span data-stu-id="18c84-250">hello throughput of an individual queue is moderate or high.</span></span>

<span data-ttu-id="18c84-251">tooobtain 橫跨多個佇列的最大輸送量，使用 hello 設定概述 toomaximize hello 單一佇列輸送量。</span><span class="sxs-lookup"><span data-stu-id="18c84-251">tooobtain maximum throughput across multiple queues, use hello settings outlined toomaximize hello throughput of a single queue.</span></span> <span data-ttu-id="18c84-252">此外，使用不同的處理站 toocreate 的用戶端傳送或接收來自不同的佇列。</span><span class="sxs-lookup"><span data-stu-id="18c84-252">In addition, use different factories toocreate clients that send or receive from different queues.</span></span>

### <a name="low-latency-queue"></a><span data-ttu-id="18c84-253">低延遲性佇列</span><span class="sxs-lookup"><span data-stu-id="18c84-253">Low latency queue</span></span>
<span data-ttu-id="18c84-254">目標：最小化佇列或主題的端對端延遲。</span><span class="sxs-lookup"><span data-stu-id="18c84-254">Goal: Minimize end-to-end latency of a queue or topic.</span></span> <span data-ttu-id="18c84-255">hello 傳送者和接收者數目很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-255">hello number of senders and receivers is small.</span></span> <span data-ttu-id="18c84-256">hello 佇列的 hello 輸送量為小或中度。</span><span class="sxs-lookup"><span data-stu-id="18c84-256">hello throughput of hello queue is small or moderate.</span></span>

* <span data-ttu-id="18c84-257">使用分割的佇列以改善可用性。</span><span class="sxs-lookup"><span data-stu-id="18c84-257">Use a partitioned queue for improved availability.</span></span>
* <span data-ttu-id="18c84-258">停用用戶端批次處理。</span><span class="sxs-lookup"><span data-stu-id="18c84-258">Disable client-side batching.</span></span> <span data-ttu-id="18c84-259">hello 用戶端會立即傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-259">hello client immediately sends a message.</span></span>
* <span data-ttu-id="18c84-260">停用批次處理的存放區存取。</span><span class="sxs-lookup"><span data-stu-id="18c84-260">Disable batched store access.</span></span> <span data-ttu-id="18c84-261">hello 服務會立即寫入 hello 訊息 toohello 存放區。</span><span class="sxs-lookup"><span data-stu-id="18c84-261">hello service immediately writes hello message toohello store.</span></span>
* <span data-ttu-id="18c84-262">如果使用單一用戶端，設定 hello 預先擷取計數 too20 時間 hello 處理速度的 hello 接收器。</span><span class="sxs-lookup"><span data-stu-id="18c84-262">If using a single client, set hello prefetch count too20 times hello processing rate of hello receiver.</span></span> <span data-ttu-id="18c84-263">如果多個訊息到達 hello 佇列 hello 在相同時間，hello 服務匯流排用戶端通訊協定傳送 hello 的所有項目相同的時間。</span><span class="sxs-lookup"><span data-stu-id="18c84-263">If multiple messages arrive at hello queue at hello same time, hello Service Bus client protocol transmits them all at hello same time.</span></span> <span data-ttu-id="18c84-264">Hello 用戶端收到 hello 下一個訊息時，該訊息會已經在 hello 本機快取。</span><span class="sxs-lookup"><span data-stu-id="18c84-264">When hello client receives hello next message, that message is already in hello local cache.</span></span> <span data-ttu-id="18c84-265">hello 快取應該很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-265">hello cache should be small.</span></span>
* <span data-ttu-id="18c84-266">如果使用多個用戶端，設定 hello 預先擷取計數 too0。</span><span class="sxs-lookup"><span data-stu-id="18c84-266">If using multiple clients, set hello prefetch count too0.</span></span> <span data-ttu-id="18c84-267">如此一來，hello 第二個用戶端可以接收 hello 第二個訊息時 hello 第一個用戶端仍在處理 hello 第一則訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-267">By doing this, hello second client can receive hello second message while hello first client is still processing hello first message.</span></span>

### <a name="queue-with-a-large-number-of-senders"></a><span data-ttu-id="18c84-268">具有大量傳送者的佇列</span><span class="sxs-lookup"><span data-stu-id="18c84-268">Queue with a large number of senders</span></span>
<span data-ttu-id="18c84-269">目標：最大化具有大量傳送者之佇列或主題的輸送量。</span><span class="sxs-lookup"><span data-stu-id="18c84-269">Goal: Maximize throughput of a queue or topic with a large number of senders.</span></span> <span data-ttu-id="18c84-270">每個傳送者都會以中等速率傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-270">Each sender sends messages with a moderate rate.</span></span> <span data-ttu-id="18c84-271">hello 接收者數目很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-271">hello number of receivers is small.</span></span>

<span data-ttu-id="18c84-272">服務匯流排可讓向上 too1000 並行連線 tooa 訊息實體 (5000 個使用 AMQP)。</span><span class="sxs-lookup"><span data-stu-id="18c84-272">Service Bus enables up too1000 concurrent connections tooa messaging entity (or 5000 using AMQP).</span></span> <span data-ttu-id="18c84-273">在 hello 命名空間層級，會強制執行這項限制，佇列/主題/訂閱會受限於 hello 每個命名空間的並行連線限制。</span><span class="sxs-lookup"><span data-stu-id="18c84-273">This limit is enforced at hello namespace level, and queues/topics/subscriptions are capped by hello limit of concurrent connections per namespace.</span></span> <span data-ttu-id="18c84-274">對佇列而言，這個數目是在傳送者和接收者之間共用的。</span><span class="sxs-lookup"><span data-stu-id="18c84-274">For queues, this number is shared between senders and receivers.</span></span> <span data-ttu-id="18c84-275">如果所有的 1000 個連接所需的寄件者，您應該以主題和單一訂閱取代 hello 佇列。</span><span class="sxs-lookup"><span data-stu-id="18c84-275">If all 1000 connections are required for senders, you should replace hello queue with a topic and a single subscription.</span></span> <span data-ttu-id="18c84-276">主題會接受 too1000 寄件者，並行連線，而 hello 訂用帳戶接受接收者其他 1000 個並行連接。</span><span class="sxs-lookup"><span data-stu-id="18c84-276">A topic accepts up too1000 concurrent connections from senders, whereas hello subscription accepts an additional 1000 concurrent connections from receivers.</span></span> <span data-ttu-id="18c84-277">如果需要超過 1000 個並行的寄件者，hello 寄件者應該傳送訊息 toohello 透過 HTTP 的服務匯流排通訊協定。</span><span class="sxs-lookup"><span data-stu-id="18c84-277">If more than 1000 concurrent senders are required, hello senders should send messages toohello Service Bus protocol via HTTP.</span></span>

<span data-ttu-id="18c84-278">toomaximize 輸送量，請勿遵循 hello:</span><span class="sxs-lookup"><span data-stu-id="18c84-278">toomaximize throughput, do hello following:</span></span>

* <span data-ttu-id="18c84-279">使用分割的佇列以改善效能和可用性。</span><span class="sxs-lookup"><span data-stu-id="18c84-279">Use a partitioned queue for improved performance and availability.</span></span>
* <span data-ttu-id="18c84-280">如果每個傳送者都位於不同的處理序中，每個處理序僅使用單一處理站。</span><span class="sxs-lookup"><span data-stu-id="18c84-280">If each sender resides in a different process, use only a single factory per process.</span></span>
* <span data-ttu-id="18c84-281">使用非同步作業 tootake 利用用戶端批次處理。</span><span class="sxs-lookup"><span data-stu-id="18c84-281">Use asynchronous operations tootake advantage of client-side batching.</span></span>
* <span data-ttu-id="18c84-282">使用 hello 毫秒預設批次處理間隔的 20 毫秒 tooreduce hello 服務匯流排用戶端通訊協定傳輸數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-282">Use hello default batching interval of 20ms tooreduce hello number of Service Bus client protocol transmissions.</span></span>
* <span data-ttu-id="18c84-283">讓批次處理的存放區存取保持啟用。</span><span class="sxs-lookup"><span data-stu-id="18c84-283">Leave batched store access enabled.</span></span> <span data-ttu-id="18c84-284">這會增加整體的 hello 的訊息可以寫入的速率 hello 佇列或主題。</span><span class="sxs-lookup"><span data-stu-id="18c84-284">This increases hello overall rate at which messages can be written into hello queue or topic.</span></span>
* <span data-ttu-id="18c84-285">設定 hello 預先擷取計數 too20 時間 hello 處理速率上限的所有接收者處理站。</span><span class="sxs-lookup"><span data-stu-id="18c84-285">Set hello prefetch count too20 times hello maximum processing rates of all receivers of a factory.</span></span> <span data-ttu-id="18c84-286">這會減少 hello 服務匯流排用戶端通訊協定傳輸數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-286">This reduces hello number of Service Bus client protocol transmissions.</span></span>

### <a name="queue-with-a-large-number-of-receivers"></a><span data-ttu-id="18c84-287">具有大量接收者的佇列</span><span class="sxs-lookup"><span data-stu-id="18c84-287">Queue with a large number of receivers</span></span>
<span data-ttu-id="18c84-288">目標： 最大化 hello 接收的佇列或訂閱具有大量接收者的速率。</span><span class="sxs-lookup"><span data-stu-id="18c84-288">Goal: Maximize hello receive rate of a queue or subscription with a large number of receivers.</span></span> <span data-ttu-id="18c84-289">每個接收者皆以中等速率接收訊息。</span><span class="sxs-lookup"><span data-stu-id="18c84-289">Each receiver receives messages at a moderate rate.</span></span> <span data-ttu-id="18c84-290">hello 寄件者數目很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-290">hello number of senders is small.</span></span>

<span data-ttu-id="18c84-291">服務匯流排可讓向上 too1000 並行連線 tooan 實體。</span><span class="sxs-lookup"><span data-stu-id="18c84-291">Service Bus enables up too1000 concurrent connections tooan entity.</span></span> <span data-ttu-id="18c84-292">如果佇列需要超過 1000 個接收者，您應該以主題和多個訂閱取代 hello 佇列。</span><span class="sxs-lookup"><span data-stu-id="18c84-292">If a queue requires more than 1000 receivers, you should replace hello queue with a topic and multiple subscriptions.</span></span> <span data-ttu-id="18c84-293">每個訂用帳戶可以支援 too1000 並行連線。</span><span class="sxs-lookup"><span data-stu-id="18c84-293">Each subscription can support up too1000 concurrent connections.</span></span> <span data-ttu-id="18c84-294">或者，接收者可以存取透過 HTTP 通訊協定 hello hello 佇列。</span><span class="sxs-lookup"><span data-stu-id="18c84-294">Alternatively, receivers can access hello queue via hello HTTP protocol.</span></span>

<span data-ttu-id="18c84-295">toomaximize 輸送量，請勿遵循 hello:</span><span class="sxs-lookup"><span data-stu-id="18c84-295">toomaximize throughput, do hello following:</span></span>

* <span data-ttu-id="18c84-296">使用分割的佇列以改善效能和可用性。</span><span class="sxs-lookup"><span data-stu-id="18c84-296">Use a partitioned queue for improved performance and availability.</span></span>
* <span data-ttu-id="18c84-297">如果每個接收者都位於不同的處理序中，每個處理序僅使用單一處理站。</span><span class="sxs-lookup"><span data-stu-id="18c84-297">If each receiver resides in a different process, use only a single factory per process.</span></span>
* <span data-ttu-id="18c84-298">接收者可以使用同步或非同步作業。</span><span class="sxs-lookup"><span data-stu-id="18c84-298">Receivers can use synchronous or asynchronous operations.</span></span> <span data-ttu-id="18c84-299">指定的 hello 中度的接收設定個別接收者的速率，用戶端批次處理完成的要求不會影響接收者輸送量。</span><span class="sxs-lookup"><span data-stu-id="18c84-299">Given hello moderate receive rate of an individual receiver, client-side batching of a Complete request does not affect receiver throughput.</span></span>
* <span data-ttu-id="18c84-300">讓批次處理的存放區存取保持啟用。</span><span class="sxs-lookup"><span data-stu-id="18c84-300">Leave batched store access enabled.</span></span> <span data-ttu-id="18c84-301">這會減少 hello hello 實體的整體負載。</span><span class="sxs-lookup"><span data-stu-id="18c84-301">This reduces hello overall load of hello entity.</span></span> <span data-ttu-id="18c84-302">它也會減少 hello，可以將訊息寫入 hello 佇列或主題的整體速率。</span><span class="sxs-lookup"><span data-stu-id="18c84-302">It also reduces hello overall rate at which messages can be written into hello queue or topic.</span></span>
* <span data-ttu-id="18c84-303">設定 hello 預先擷取計數 tooa 小的值 (例如，PrefetchCount = 10)。</span><span class="sxs-lookup"><span data-stu-id="18c84-303">Set hello prefetch count tooa small value (for example, PrefetchCount = 10).</span></span> <span data-ttu-id="18c84-304">這樣可以避免接收者在其他接收者具有大量快取的訊息時閒置。</span><span class="sxs-lookup"><span data-stu-id="18c84-304">This prevents receivers from being idle while other receivers have large numbers of messages cached.</span></span>

### <a name="topic-with-a-small-number-of-subscriptions"></a><span data-ttu-id="18c84-305">具有少量訂用帳戶的主題</span><span class="sxs-lookup"><span data-stu-id="18c84-305">Topic with a small number of subscriptions</span></span>
<span data-ttu-id="18c84-306">目標： 具有少量訂閱的主題的 hello 輸送量最大化。</span><span class="sxs-lookup"><span data-stu-id="18c84-306">Goal: Maximize hello throughput of a topic with a small number of subscriptions.</span></span> <span data-ttu-id="18c84-307">收到的訊息是許多訂閱，這表示 hello 結合接收所有訂閱的速度大於 hello 傳送速率。</span><span class="sxs-lookup"><span data-stu-id="18c84-307">A message is received by many subscriptions, which means hello combined receive rate over all subscriptions is larger than hello send rate.</span></span> <span data-ttu-id="18c84-308">hello 寄件者數目很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-308">hello number of senders is small.</span></span> <span data-ttu-id="18c84-309">每個訂閱接收者的 hello 數目很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-309">hello number of receivers per subscription is small.</span></span>

<span data-ttu-id="18c84-310">toomaximize 輸送量，請勿遵循 hello:</span><span class="sxs-lookup"><span data-stu-id="18c84-310">toomaximize throughput, do hello following:</span></span>

* <span data-ttu-id="18c84-311">使用分割的主題以改善效能和可用性。</span><span class="sxs-lookup"><span data-stu-id="18c84-311">Use a partitioned topic for improved performance and availability.</span></span>
* <span data-ttu-id="18c84-312">tooincrease hello 整體傳送速率，到 hello 主題，請使用多個訊息 factory toocreate 寄件者。</span><span class="sxs-lookup"><span data-stu-id="18c84-312">tooincrease hello overall send rate into hello topic, use multiple message factories toocreate senders.</span></span> <span data-ttu-id="18c84-313">對每個傳送者使用非同步作業或多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="18c84-313">For each sender, use asynchronous operations or multiple threads.</span></span>
* <span data-ttu-id="18c84-314">整體 tooincrease hello 從訂閱接收速率，請使用多個訊息 factory toocreate 接收者。</span><span class="sxs-lookup"><span data-stu-id="18c84-314">tooincrease hello overall receive rate from a subscription, use multiple message factories toocreate receivers.</span></span> <span data-ttu-id="18c84-315">對每個接收者使用非同步作業或多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="18c84-315">For each receiver, use asynchronous operations or multiple threads.</span></span>
* <span data-ttu-id="18c84-316">使用非同步作業 tootake 利用用戶端批次處理。</span><span class="sxs-lookup"><span data-stu-id="18c84-316">Use asynchronous operations tootake advantage of client-side batching.</span></span>
* <span data-ttu-id="18c84-317">使用 hello 毫秒預設批次處理間隔的 20 毫秒 tooreduce hello 服務匯流排用戶端通訊協定傳輸數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-317">Use hello default batching interval of 20ms tooreduce hello number of Service Bus client protocol transmissions.</span></span>
* <span data-ttu-id="18c84-318">讓批次處理的存放區存取保持啟用。</span><span class="sxs-lookup"><span data-stu-id="18c84-318">Leave batched store access enabled.</span></span> <span data-ttu-id="18c84-319">這會增加整體的 hello 訊息可以寫入 hello 主題速率。</span><span class="sxs-lookup"><span data-stu-id="18c84-319">This increases hello overall rate at which messages can be written into hello topic.</span></span>
* <span data-ttu-id="18c84-320">設定 hello 預先擷取計數 too20 時間 hello 處理速率上限的所有接收者處理站。</span><span class="sxs-lookup"><span data-stu-id="18c84-320">Set hello prefetch count too20 times hello maximum processing rates of all receivers of a factory.</span></span> <span data-ttu-id="18c84-321">這會減少 hello 服務匯流排用戶端通訊協定傳輸數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-321">This reduces hello number of Service Bus client protocol transmissions.</span></span>

### <a name="topic-with-a-large-number-of-subscriptions"></a><span data-ttu-id="18c84-322">具有大量訂用帳戶的主題</span><span class="sxs-lookup"><span data-stu-id="18c84-322">Topic with a large number of subscriptions</span></span>
<span data-ttu-id="18c84-323">目標： 具有大量訂閱的主題的 hello 輸送量最大化。</span><span class="sxs-lookup"><span data-stu-id="18c84-323">Goal: Maximize hello throughput of a topic with a large number of subscriptions.</span></span> <span data-ttu-id="18c84-324">收到的訊息是許多訂閱，這表示 hello 結合接收所有訂閱的速度會遠大於 hello 傳送速率。</span><span class="sxs-lookup"><span data-stu-id="18c84-324">A message is received by many subscriptions, which means hello combined receive rate over all subscriptions is much larger than hello send rate.</span></span> <span data-ttu-id="18c84-325">hello 寄件者數目很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-325">hello number of senders is small.</span></span> <span data-ttu-id="18c84-326">每個訂閱接收者的 hello 數目很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-326">hello number of receivers per subscription is small.</span></span>

<span data-ttu-id="18c84-327">如果所有的訊息路由的 tooall 訂用帳戶具有大量訂閱的主題通常會呈現低的整體輸送量。</span><span class="sxs-lookup"><span data-stu-id="18c84-327">Topics with a large number of subscriptions typically expose a low overall throughput if all messages are routed tooall subscriptions.</span></span> <span data-ttu-id="18c84-328">這被因為 hello 事實收到許多次，每個訊息，並包含在主題中的所有訊息，以及所有其訂用帳戶會儲存在 hello 相同存放區。</span><span class="sxs-lookup"><span data-stu-id="18c84-328">This is caused by hello fact that each message is received many times, and all messages that are contained in a topic and all its subscriptions are stored in hello same store.</span></span> <span data-ttu-id="18c84-329">它會假設 hello 寄件者數目和每個訂閱的接收者數目很小。</span><span class="sxs-lookup"><span data-stu-id="18c84-329">It is assumed that hello number of senders and number of receivers per subscription is small.</span></span> <span data-ttu-id="18c84-330">服務匯流排支援向上 too2，每個主題 000 訂用帳戶。</span><span class="sxs-lookup"><span data-stu-id="18c84-330">Service Bus supports up too2,000 subscriptions per topic.</span></span>

<span data-ttu-id="18c84-331">toomaximize 輸送量，請勿遵循 hello:</span><span class="sxs-lookup"><span data-stu-id="18c84-331">toomaximize throughput, do hello following:</span></span>

* <span data-ttu-id="18c84-332">使用分割的主題以改善效能和可用性。</span><span class="sxs-lookup"><span data-stu-id="18c84-332">Use a partitioned topic for improved performance and availability.</span></span>
* <span data-ttu-id="18c84-333">使用非同步作業 tootake 利用用戶端批次處理。</span><span class="sxs-lookup"><span data-stu-id="18c84-333">Use asynchronous operations tootake advantage of client-side batching.</span></span>
* <span data-ttu-id="18c84-334">使用 hello 毫秒預設批次處理間隔的 20 毫秒 tooreduce hello 服務匯流排用戶端通訊協定傳輸數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-334">Use hello default batching interval of 20ms tooreduce hello number of Service Bus client protocol transmissions.</span></span>
* <span data-ttu-id="18c84-335">讓批次處理的存放區存取保持啟用。</span><span class="sxs-lookup"><span data-stu-id="18c84-335">Leave batched store access enabled.</span></span> <span data-ttu-id="18c84-336">這會增加整體的 hello 訊息可以寫入 hello 主題速率。</span><span class="sxs-lookup"><span data-stu-id="18c84-336">This increases hello overall rate at which messages can be written into hello topic.</span></span>
* <span data-ttu-id="18c84-337">設定速率 hello 預期收到 hello 預先擷取計數 too20 時間，以秒為單位。</span><span class="sxs-lookup"><span data-stu-id="18c84-337">Set hello prefetch count too20 times hello expected receive rate in seconds.</span></span> <span data-ttu-id="18c84-338">這會減少 hello 服務匯流排用戶端通訊協定傳輸數目。</span><span class="sxs-lookup"><span data-stu-id="18c84-338">This reduces hello number of Service Bus client protocol transmissions.</span></span>

## <a name="next-steps"></a><span data-ttu-id="18c84-339">後續步驟</span><span class="sxs-lookup"><span data-stu-id="18c84-339">Next steps</span></span>
<span data-ttu-id="18c84-340">toolearn 有關 Service Bus 效能最佳化的詳細資訊請參閱[分割訊息實體][Partitioned messaging entities]。</span><span class="sxs-lookup"><span data-stu-id="18c84-340">toolearn more about optimizing Service Bus performance, see [Partitioned messaging entities][Partitioned messaging entities].</span></span>

[QueueClient]: /dotnet/api/microsoft.servicebus.messaging.queueclient
[MessageSender]: /dotnet/api/microsoft.servicebus.messaging.messagesender
[MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[PeekLock]: /dotnet/api/microsoft.servicebus.messaging.receivemode
[ReceiveAndDelete]: /dotnet/api/microsoft.servicebus.messaging.receivemode
[BatchFlushInterval]: /dotnet/api/microsoft.servicebus.messaging.netmessagingtransportsettings.batchflushinterval#Microsoft_ServiceBus_Messaging_NetMessagingTransportSettings_BatchFlushInterval
[EnableBatchedOperations]: /dotnet/api/microsoft.servicebus.messaging.queuedescription.enablebatchedoperations#Microsoft_ServiceBus_Messaging_QueueDescription_EnableBatchedOperations
[QueueClient.PrefetchCount]: /dotnet/api/microsoft.servicebus.messaging.queueclient.prefetchcount#Microsoft_ServiceBus_Messaging_QueueClient_PrefetchCount
[SubscriptionClient.PrefetchCount]: /dotnet/api/microsoft.servicebus.messaging.subscriptionclient.prefetchcount#Microsoft_ServiceBus_Messaging_SubscriptionClient_PrefetchCount
[ForcePersistence]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage.forcepersistence#Microsoft_ServiceBus_Messaging_BrokeredMessage_ForcePersistence
[EnablePartitioning]: /dotnet/api/microsoft.servicebus.messaging.queuedescription.enablepartitioning#Microsoft_ServiceBus_Messaging_QueueDescription_EnablePartitioning
[Partitioned messaging entities]: service-bus-partitioning.md
[TopicDescription.EnableFilteringMessagesBeforePublishing]: /dotnet/api/microsoft.servicebus.messaging.topicdescription.enablefilteringmessagesbeforepublishing#Microsoft_ServiceBus_Messaging_TopicDescription_EnableFilteringMessagesBeforePublishing
