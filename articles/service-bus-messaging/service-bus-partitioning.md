---
title: "aaaCreate 分割 Azure 服務匯流排佇列和主題 |Microsoft 文件"
description: "描述如何 toopartition Service Bus 佇列和主題，使用多個訊息仲介。"
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: a0c7d5a2-4876-42cb-8344-a1fc988746e7
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm;hillaryc
ms.openlocfilehash: 6d42556a0714d6a012dc319f662521c8b0bb958b
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="partitioned-queues-and-topics"></a><span data-ttu-id="a7008-103">分割的佇列和主題</span><span class="sxs-lookup"><span data-stu-id="a7008-103">Partitioned queues and topics</span></span>
<span data-ttu-id="a7008-104">Azure 的服務匯流排會運用多個訊息代理人 tooprocess 訊息和多個訊息存放 toostore 訊息。</span><span class="sxs-lookup"><span data-stu-id="a7008-104">Azure Service Bus employs multiple message brokers tooprocess messages and multiple messaging stores toostore messages.</span></span> <span data-ttu-id="a7008-105">傳統的佇列或主題由單一訊息代理程式處理並儲存在一個訊息存放區中。</span><span class="sxs-lookup"><span data-stu-id="a7008-105">A conventional queue or topic is handled by a single message broker and stored in one messaging store.</span></span> <span data-ttu-id="a7008-106">服務匯流排*分割*啟用佇列和主題，或*傳訊實體*，toobe 分割到多個訊息代理程式和訊息存放區。</span><span class="sxs-lookup"><span data-stu-id="a7008-106">Service Bus *partitions* enable queues and topics, or *messaging entities*, toobe partitioned across multiple message brokers and messaging stores.</span></span> <span data-ttu-id="a7008-107">Hello 磁碟分割實體的整體輸送量這表示不再受限於單一訊息代理程式或訊息存放區的 hello 效能。</span><span class="sxs-lookup"><span data-stu-id="a7008-107">This means that hello overall throughput of a partitioned entity is no longer limited by hello performance of a single message broker or messaging store.</span></span> <span data-ttu-id="a7008-108">此外，即使訊息存放區暫時中斷也不會讓分割的佇列或主題無法使用。</span><span class="sxs-lookup"><span data-stu-id="a7008-108">In addition, a temporary outage of a messaging store does not render a partitioned queue or topic unavailable.</span></span> <span data-ttu-id="a7008-109">分割的佇列和主題可以包含所有進階的服務匯流排功能，例如支援交易和工作階段。</span><span class="sxs-lookup"><span data-stu-id="a7008-109">Partitioned queues and topics can contain all advanced Service Bus features, such as support for transactions and sessions.</span></span>

<span data-ttu-id="a7008-110">如需服務匯流排內部項目資訊，請參閱 hello [Service Bus 架構][ Service Bus architecture]發行項。</span><span class="sxs-lookup"><span data-stu-id="a7008-110">For information about Service Bus internals, see hello [Service Bus architecture][Service Bus architecture] article.</span></span>

<span data-ttu-id="a7008-111">在標準和進階傳訊中，依預設，在所有佇列和主題上建立實體時會啟用分割。</span><span class="sxs-lookup"><span data-stu-id="a7008-111">Partitioning is enabled by default at entity creation on all queues and topics in both Standard and Premium messaging.</span></span> <span data-ttu-id="a7008-112">您可以建立標準傳訊層實體而不要分割，但進階命名空間中的佇列和主題永遠會分割。無法停用此選項。</span><span class="sxs-lookup"><span data-stu-id="a7008-112">You can create Standard messaging tier entities without partitioning, but queues and topics in a Premium namespace are always partitioned; this option cannot be disabled.</span></span> 

<span data-ttu-id="a7008-113">不可能 toochange hello 資料分割上現有的佇列或主題 Standard 或 Premium 層中的選項，您可以只 hello 時設定選項建立 hello 實體。</span><span class="sxs-lookup"><span data-stu-id="a7008-113">It is not possible toochange hello partitioning option on an existing queue or topic in either Standard or Premium tiers, you can only set hello option when you create hello entity.</span></span>

## <a name="how-it-works"></a><span data-ttu-id="a7008-114">運作方式</span><span class="sxs-lookup"><span data-stu-id="a7008-114">How it works</span></span>

<span data-ttu-id="a7008-115">每個分割的佇列或主題都包含多個片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-115">Each partitioned queue or topic consists of multiple fragments.</span></span> <span data-ttu-id="a7008-116">每個片段儲存在不同的訊息存放區中，並由不同的訊息代理人處理。</span><span class="sxs-lookup"><span data-stu-id="a7008-116">Each fragment is stored in a different messaging store and handled by a different message broker.</span></span> <span data-ttu-id="a7008-117">當訊息傳送 tooa 分割的佇列或主題時，服務匯流排會指派 hello 訊息 tooone 的 hello 片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-117">When a message is sent tooa partitioned queue or topic, Service Bus assigns hello message tooone of hello fragments.</span></span> <span data-ttu-id="a7008-118">hello 選取項目由隨機服務匯流排，或者可以指定使用 hello 寄件者資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-118">hello selection is done randomly by Service Bus or by using a partition key that hello sender can specify.</span></span>

<span data-ttu-id="a7008-119">當用戶端想 tooreceive 將訊息從資料分割的佇列或訂閱 tooa 分割主題，從服務匯流排查詢訊息的所有片段時，然後傳回 hello 取自任何 hello 訊息存放區 toohello 收件者的第一個訊息。</span><span class="sxs-lookup"><span data-stu-id="a7008-119">When a client wants tooreceive a message from a partitioned queue, or from a subscription tooa partitioned topic, Service Bus queries all fragments for messages, then returns hello first message that is obtained from any of hello messaging stores toohello receiver.</span></span> <span data-ttu-id="a7008-120">服務匯流排快取 hello 其他的訊息並傳回它們收到其他時接收要求。</span><span class="sxs-lookup"><span data-stu-id="a7008-120">Service Bus caches hello other messages and returns them when it receives additional receive requests.</span></span> <span data-ttu-id="a7008-121">接收用戶端並不知道 hello 資料分割;hello 面對用戶端行為的分割的佇列或主題 (例如 read、 complete、 defer、 deadletter、 預先提取) 是相同的 toohello 行為的一般實體。</span><span class="sxs-lookup"><span data-stu-id="a7008-121">A receiving client is not aware of hello partitioning; hello client-facing behavior of a partitioned queue or topic (for example, read, complete, defer, deadletter, prefetching) is identical toohello behavior of a regular entity.</span></span>

<span data-ttu-id="a7008-122">傳送訊息給分割的佇列或主題，或從該處接收訊息時，不需要額外成本。</span><span class="sxs-lookup"><span data-stu-id="a7008-122">There is no additional cost when sending a message to, or receiving a message from, a partitioned queue or topic.</span></span>

## <a name="enable-partitioning"></a><span data-ttu-id="a7008-123">啟用分割</span><span class="sxs-lookup"><span data-stu-id="a7008-123">Enable partitioning</span></span>

<span data-ttu-id="a7008-124">toouse 分割佇列和主題與 Azure 服務匯流排，使用 hello Azure SDK 版本 2.2 或更新版本，或指定`api-version=2013-10`在您的 HTTP 要求。</span><span class="sxs-lookup"><span data-stu-id="a7008-124">toouse partitioned queues and topics with Azure Service Bus, use hello Azure SDK version 2.2 or later, or specify `api-version=2013-10` in your HTTP requests.</span></span>

### <a name="standard"></a><span data-ttu-id="a7008-125">標準</span><span class="sxs-lookup"><span data-stu-id="a7008-125">Standard</span></span>

<span data-ttu-id="a7008-126">在 hello 標準通訊層，您可以建立服務匯流排佇列和主題 1、 2、 3、 4 或 5 GB 大小 （hello 預設為 1 GB）。</span><span class="sxs-lookup"><span data-stu-id="a7008-126">In hello Standard messaging tier, you can create Service Bus queues and topics in 1, 2, 3, 4, or 5 GB sizes (hello default is 1 GB).</span></span> <span data-ttu-id="a7008-127">啟用分割，服務匯流排會建立您指定每個 GB 的 hello 實體 16 的複本 （16 個磁碟分割）。</span><span class="sxs-lookup"><span data-stu-id="a7008-127">With partitioning enabled, Service Bus creates 16 copies (16 partitions) of hello entity for each GB you specify.</span></span> <span data-ttu-id="a7008-128">因此，如果您建立大小為 5 GB 的佇列時，16 個磁碟分割與 hello 佇列大小上限會變成 (5 \* 16) = 80 GB。</span><span class="sxs-lookup"><span data-stu-id="a7008-128">As such, if you create a queue that's 5 GB in size, with 16 partitions hello maximum queue size becomes (5 \* 16) = 80 GB.</span></span> <span data-ttu-id="a7008-129">您可以看到 hello 磁碟分割的佇列或主題的大小上限藉由查看其項目上 hello [Azure 入口網站][Azure portal]，在 hello**概觀**刀鋒視窗，該實體。</span><span class="sxs-lookup"><span data-stu-id="a7008-129">You can see hello maximum size of your partitioned queue or topic by looking at its entry on hello [Azure portal][Azure portal], in hello **Overview** blade for that entity.</span></span>

### <a name="premium"></a><span data-ttu-id="a7008-130">進階</span><span class="sxs-lookup"><span data-stu-id="a7008-130">Premium</span></span>

<span data-ttu-id="a7008-131">在 Premium 層命名空間中，您可以建立服務匯流排佇列和主題 1、 2、 3、 4、 5、 10、 20、 40、 80 GB 的大小 （hello 預設為 1 GB）。</span><span class="sxs-lookup"><span data-stu-id="a7008-131">In a Premium tier namespace, you can create Service Bus queues and topics in 1, 2, 3, 4, 5, 10, 20, 40, or 80 GB sizes (hello default is 1 GB).</span></span> <span data-ttu-id="a7008-132">由於依預設會啟用分割，服務匯流排會為每個實體建立兩個資料分割。</span><span class="sxs-lookup"><span data-stu-id="a7008-132">With partitioning enabled by default, Service Bus creates two partitions per entity.</span></span> <span data-ttu-id="a7008-133">您可以看到 hello 磁碟分割的佇列或主題的大小上限藉由查看其項目上 hello [Azure 入口網站][Azure portal]，在 hello**概觀**刀鋒視窗，該實體。</span><span class="sxs-lookup"><span data-stu-id="a7008-133">You can see hello maximum size of your partitioned queue or topic by looking at its entry on hello [Azure portal][Azure portal], in hello **Overview** blade for that entity.</span></span>

<span data-ttu-id="a7008-134">如需 hello Premium 傳訊層的資料分割的詳細資訊，請參閱[服務匯流排 Premium 和 Standard 傳訊層](service-bus-premium-messaging.md)。</span><span class="sxs-lookup"><span data-stu-id="a7008-134">For more information about partitioning in hello Premium messaging tier, see [Service Bus Premium and Standard messaging tiers](service-bus-premium-messaging.md).</span></span> 

### <a name="create-a-partitioned-entity"></a><span data-ttu-id="a7008-135">建立分割實體</span><span class="sxs-lookup"><span data-stu-id="a7008-135">Create a partitioned entity</span></span>

<span data-ttu-id="a7008-136">有數種方式 toocreate 磁碟分割佇列或主題。</span><span class="sxs-lookup"><span data-stu-id="a7008-136">There are several ways toocreate a partitioned queue or topic.</span></span> <span data-ttu-id="a7008-137">當您從應用程式建立 hello 佇列或主題時，您可以啟用依分別設定 hello hello 佇列或主題分割[QueueDescription.EnablePartitioning] [ QueueDescription.EnablePartitioning]或[TopicDescription.EnablePartitioning] [ TopicDescription.EnablePartitioning]屬性太**true**。</span><span class="sxs-lookup"><span data-stu-id="a7008-137">When you create hello queue or topic from your application, you can enable partitioning for hello queue or topic by respectively setting hello [QueueDescription.EnablePartitioning][QueueDescription.EnablePartitioning] or [TopicDescription.EnablePartitioning][TopicDescription.EnablePartitioning] property too**true**.</span></span> <span data-ttu-id="a7008-138">這些屬性必須設定在 hello hello 佇列的時間，或建立主題。</span><span class="sxs-lookup"><span data-stu-id="a7008-138">These properties must be set at hello time hello queue or topic is created.</span></span> <span data-ttu-id="a7008-139">如先前所述，它是不可能 toochange 這些屬性上的現有的佇列或主題。</span><span class="sxs-lookup"><span data-stu-id="a7008-139">As stated previously, it is not possible toochange these properties on an existing queue or topic.</span></span> <span data-ttu-id="a7008-140">例如：</span><span class="sxs-lookup"><span data-stu-id="a7008-140">For example:</span></span>

```csharp
// Create partitioned topic
NamespaceManager ns = NamespaceManager.CreateFromConnectionString(myConnectionString);
TopicDescription td = new TopicDescription(TopicName);
td.EnablePartitioning = true;
ns.CreateTopic(td);
```

<span data-ttu-id="a7008-141">或者，您可以建立磁碟分割的佇列或主題在 hello [Azure 入口網站][ Azure portal]或 Visual Studio 中。</span><span class="sxs-lookup"><span data-stu-id="a7008-141">Alternatively, you can create a partitioned queue or topic in hello [Azure portal][Azure portal] or in Visual Studio.</span></span> <span data-ttu-id="a7008-142">當您在 hello 入口網站中建立的佇列或主題時，hello**啟用資料分割**hello 佇列或主題中的選項**建立**預設會核取刀鋒視窗。</span><span class="sxs-lookup"><span data-stu-id="a7008-142">When you create a queue or topic in hello portal, hello **Enable partitioning** option in hello queue or topic **Create** blade is checked by default.</span></span> <span data-ttu-id="a7008-143">您可以只停用的標準層實體; 中的這個選項在 hello 永遠啟用 Premium 層資料分割。</span><span class="sxs-lookup"><span data-stu-id="a7008-143">You can only disable this option in a Standard tier entity; in hello Premium tier partitioning is always enabled.</span></span> <span data-ttu-id="a7008-144">在 Visual Studio 中，按一下 [hello**啟用分割**核取方塊在 hello**新佇列**或**新主題**] 對話方塊。</span><span class="sxs-lookup"><span data-stu-id="a7008-144">In Visual Studio, click hello **Enable Partitioning** checkbox in hello **New Queue** or **New Topic** dialog box.</span></span>

## <a name="use-of-partition-keys"></a><span data-ttu-id="a7008-145">分割索引鍵的用途</span><span class="sxs-lookup"><span data-stu-id="a7008-145">Use of partition keys</span></span>
<span data-ttu-id="a7008-146">當訊息列入分割的佇列或主題時，會檢查服務匯流排 hello 存在資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-146">When a message is enqueued into a partitioned queue or topic, Service Bus checks for hello presence of a partition key.</span></span> <span data-ttu-id="a7008-147">如果找到，就會選取該索引鍵為基礎的 hello 片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-147">If it finds one, it selects hello fragment based on that key.</span></span> <span data-ttu-id="a7008-148">如果找不到資料分割索引鍵，就會選取內部演算法為基礎的 hello 片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-148">If it does not find a partition key, it selects hello fragment based on an internal algorithm.</span></span>

### <a name="using-a-partition-key"></a><span data-ttu-id="a7008-149">使用分割區索引鍵</span><span class="sxs-lookup"><span data-stu-id="a7008-149">Using a partition key</span></span>
<span data-ttu-id="a7008-150">某些情況下，例如工作階段或交易，需要訊息 toobe 儲存在特定的片段中。</span><span class="sxs-lookup"><span data-stu-id="a7008-150">Some scenarios, such as sessions or transactions, require messages toobe stored in a specific fragment.</span></span> <span data-ttu-id="a7008-151">所有這些情況下需要 hello 使用資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-151">All these scenarios require hello use of a partition key.</span></span> <span data-ttu-id="a7008-152">所有訊息相同的資料分割索引鍵會指派該使用 hello toohello 相同片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-152">All messages that use hello same partition key are assigned toohello same fragment.</span></span> <span data-ttu-id="a7008-153">如果 hello 片段暫時無法使用時，服務匯流排會傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="a7008-153">If hello fragment is temporarily unavailable, Service Bus returns an error.</span></span>

<span data-ttu-id="a7008-154">根據 hello 的案例，不同的訊息屬性會用做資料分割索引鍵：</span><span class="sxs-lookup"><span data-stu-id="a7008-154">Depending on hello scenario, different message properties are used as a partition key:</span></span>

<span data-ttu-id="a7008-155">**SessionId**： 若訊息已 hello [BrokeredMessage.SessionId] [ BrokeredMessage.SessionId]設定屬性，則服務匯流排會使用這個屬性為 hello 資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-155">**SessionId**: If a message has hello [BrokeredMessage.SessionId][BrokeredMessage.SessionId] property set, then Service Bus uses this property as hello partition key.</span></span> <span data-ttu-id="a7008-156">如此一來，所有的訊息，toohello 屬於相同的工作階段由處理 hello 相同訊息代理程式。</span><span class="sxs-lookup"><span data-stu-id="a7008-156">This way, all messages that belong toohello same session are handled by hello same message broker.</span></span> <span data-ttu-id="a7008-157">這可讓服務匯流排 tooguarantee 訊息排序以及 hello 的工作階段狀態的一致性。</span><span class="sxs-lookup"><span data-stu-id="a7008-157">This enables Service Bus tooguarantee message ordering as well as hello consistency of session states.</span></span>

<span data-ttu-id="a7008-158">**PartitionKey**： 若訊息已 hello [BrokeredMessage.PartitionKey] [ BrokeredMessage.PartitionKey]屬性，但不是 hello [BrokeredMessage.SessionId] [BrokeredMessage.SessionId]設定屬性，則服務匯流排也使用 hello [PartitionKey] [ PartitionKey] hello 資料分割索引鍵屬性。</span><span class="sxs-lookup"><span data-stu-id="a7008-158">**PartitionKey**: If a message has hello [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] property but not hello [BrokeredMessage.SessionId][BrokeredMessage.SessionId] property set, then Service Bus uses hello [PartitionKey][PartitionKey] property as hello partition key.</span></span> <span data-ttu-id="a7008-159">如果 hello 訊息有兩個 hello [SessionId] [ SessionId]和 hello [PartitionKey] [ PartitionKey]屬性集，這兩個屬性必須相同。</span><span class="sxs-lookup"><span data-stu-id="a7008-159">If hello message has both hello [SessionId][SessionId] and hello [PartitionKey][PartitionKey] properties set, both properties must be identical.</span></span> <span data-ttu-id="a7008-160">如果 hello [PartitionKey] [ PartitionKey]屬性設定為比 hello tooa 不同值[SessionId] [ SessionId]屬性，服務匯流排會傳回不正確作業的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a7008-160">If hello [PartitionKey][PartitionKey] property is set tooa different value than hello [SessionId][SessionId] property, Service Bus returns an invalid operation exception.</span></span> <span data-ttu-id="a7008-161">hello [PartitionKey] [ PartitionKey]應該使用屬性，如果傳送端傳送非工作階段感知的交易訊息。</span><span class="sxs-lookup"><span data-stu-id="a7008-161">hello [PartitionKey][PartitionKey] property should be used if a sender sends non-session aware transactional messages.</span></span> <span data-ttu-id="a7008-162">hello 分割金鑰可確保，在交易內傳送的所有訊息都由 hello 相同訊息代理人。</span><span class="sxs-lookup"><span data-stu-id="a7008-162">hello partition key ensures that all messages that are sent within a transaction are handled by hello same messaging broker.</span></span>

<span data-ttu-id="a7008-163">**MessageId**： 如果 hello 佇列或主題有 hello [QueueDescription.RequiresDuplicateDetection] [ QueueDescription.RequiresDuplicateDetection]屬性設定太**true**和 hello [BrokeredMessage.SessionId] [ BrokeredMessage.SessionId]或[BrokeredMessage.PartitionKey] [ BrokeredMessage.PartitionKey]屬性未設定，則 hello [BrokeredMessage.MessageId] [ BrokeredMessage.MessageId]屬性做為 hello 資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-163">**MessageId**: If hello queue or topic has hello [QueueDescription.RequiresDuplicateDetection][QueueDescription.RequiresDuplicateDetection] property set too**true** and hello [BrokeredMessage.SessionId][BrokeredMessage.SessionId] or [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] properties are not set, then hello [BrokeredMessage.MessageId][BrokeredMessage.MessageId] property serves as hello partition key.</span></span> <span data-ttu-id="a7008-164">（請注意，hello Microsoft.NET 和 AMQP 程式庫自動指派訊息識別碼 hello 傳送應用程式並不會）。在此情況下，所有副本都由相同訊息的都 hello 都 hello 相同訊息代理程式。</span><span class="sxs-lookup"><span data-stu-id="a7008-164">(Note that hello Microsoft .NET and AMQP libraries automatically assign a message ID if hello sending application does not.) In this case, all copies of hello same message are handled by hello same message broker.</span></span> <span data-ttu-id="a7008-165">這可讓服務匯流排 toodetect，並排除重覆的訊息。</span><span class="sxs-lookup"><span data-stu-id="a7008-165">This enables Service Bus toodetect and eliminate duplicate messages.</span></span> <span data-ttu-id="a7008-166">如果 hello [QueueDescription.RequiresDuplicateDetection] [ QueueDescription.RequiresDuplicateDetection]屬性未設定太**true**，Service Bus 不會考慮 hello [MessageId][ MessageId]做為資料分割索引鍵的屬性。</span><span class="sxs-lookup"><span data-stu-id="a7008-166">If hello [QueueDescription.RequiresDuplicateDetection][QueueDescription.RequiresDuplicateDetection] property is not set too**true**, Service Bus does not consider hello [MessageId][MessageId] property as a partition key.</span></span>

### <a name="not-using-a-partition-key"></a><span data-ttu-id="a7008-167">不使用分割索引鍵</span><span class="sxs-lookup"><span data-stu-id="a7008-167">Not using a partition key</span></span>
<span data-ttu-id="a7008-168">Hello 沒有資料分割索引鍵，在服務匯流排將發佈中的 hello 分割的佇列或主題的循環配置資源方式 tooall hello 片段的訊息。</span><span class="sxs-lookup"><span data-stu-id="a7008-168">In hello absence of a partition key, Service Bus distributes messages in a round-robin fashion tooall hello fragments of hello partitioned queue or topic.</span></span> <span data-ttu-id="a7008-169">如果選擇的 hello 片段無法使用，服務匯流排指派 hello 訊息 tooa 不同的片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-169">If hello chosen fragment is not available, Service Bus assigns hello message tooa different fragment.</span></span> <span data-ttu-id="a7008-170">如此一來，hello 訊息存放區暫時無法使用儘管成功 hello 傳送作業。</span><span class="sxs-lookup"><span data-stu-id="a7008-170">This way, hello send operation succeeds despite hello temporary unavailability of a messaging store.</span></span> <span data-ttu-id="a7008-171">不過，您不會封存 hello 保證順序，會提供資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-171">However, you will not achieve hello guaranteed ordering that a partition key provides.</span></span>

<span data-ttu-id="a7008-172">Hello 可用性 （沒有資料分割索引鍵） 與一致性 （使用資料分割索引鍵） 之間的權衡取捨的更深入討論，請參閱[本文](../event-hubs/event-hubs-availability-and-consistency.md)。</span><span class="sxs-lookup"><span data-stu-id="a7008-172">For a more in-depth discussion of hello tradeoff between availability (no partition key) and consistency (using a partition key), see [this article](../event-hubs/event-hubs-availability-and-consistency.md).</span></span> <span data-ttu-id="a7008-173">這項資訊同樣適用於 toopartitioned 服務匯流排實體和事件中心資料分割。</span><span class="sxs-lookup"><span data-stu-id="a7008-173">This information applies equally toopartitioned Service Bus entities and Event Hubs partitions.</span></span>

<span data-ttu-id="a7008-174">toogive 服務匯流排足夠時間 tooenqueue hello 訊息至不同的片段，hello [MessagingFactorySettings.OperationTimeout] [ MessagingFactorySettings.OperationTimeout] hello 用戶端傳送 hello 訊息所指定的值必須大於 15 秒。</span><span class="sxs-lookup"><span data-stu-id="a7008-174">toogive Service Bus enough time tooenqueue hello message into a different fragment, hello [MessagingFactorySettings.OperationTimeout][MessagingFactorySettings.OperationTimeout] value specified by hello client that sends hello message must be greater than 15 seconds.</span></span> <span data-ttu-id="a7008-175">我們建議您設定 hello [OperationTimeout] [ OperationTimeout]屬性 toohello 預設值為 60 秒。</span><span class="sxs-lookup"><span data-stu-id="a7008-175">It is recommended that you set hello [OperationTimeout][OperationTimeout] property toohello default value of 60 seconds.</span></span>

<span data-ttu-id="a7008-176">請注意，資料分割索引鍵"pin"訊息 tooa 特定片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-176">Note that a partition key "pins" a message tooa specific fragment.</span></span> <span data-ttu-id="a7008-177">如果保留此片段的 hello 訊息存放區無法使用時，服務匯流排會傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="a7008-177">If hello messaging store that holds this fragment is unavailable, Service Bus returns an error.</span></span> <span data-ttu-id="a7008-178">在資料分割索引鍵 hello 不存在，服務匯流排可以選擇不同的片段，hello 作業成功。</span><span class="sxs-lookup"><span data-stu-id="a7008-178">In hello absence of a partition key, Service Bus can choose a different fragment and hello operation succeeds.</span></span> <span data-ttu-id="a7008-179">因此，建議您若非必要請勿提供分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-179">Therefore, it is recommended that you do not supply a partition key unless it is required.</span></span>

## <a name="advanced-topics-use-transactions-with-partitioned-entities"></a><span data-ttu-id="a7008-180">進階主題：搭配交易使用分割的實體</span><span class="sxs-lookup"><span data-stu-id="a7008-180">Advanced topics: use transactions with partitioned entities</span></span>
<span data-ttu-id="a7008-181">傳送做為交易一部分的訊息必須指定資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-181">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="a7008-182">這可以是其中一個 hello 下列屬性： [BrokeredMessage.SessionId][BrokeredMessage.SessionId]， [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey]，或[BrokeredMessage.MessageId][BrokeredMessage.MessageId]。</span><span class="sxs-lookup"><span data-stu-id="a7008-182">This can be one of hello following properties: [BrokeredMessage.SessionId][BrokeredMessage.SessionId], [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey], or [BrokeredMessage.MessageId][BrokeredMessage.MessageId].</span></span> <span data-ttu-id="a7008-183">Hello 必須指定相同的交易中傳送的所有訊息都 hello 相同的資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-183">All messages that are sent as part of hello same transaction must specify hello same partition key.</span></span> <span data-ttu-id="a7008-184">如果您嘗試 toosend 訊息，但在交易內的資料分割索引鍵，服務匯流排傳回無效的作業例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a7008-184">If you attempt toosend a message without a partition key within a transaction, Service Bus returns an invalid operation exception.</span></span> <span data-ttu-id="a7008-185">如果您嘗試的 toosend 內的多個訊息 hello 相同的交易具有不同的資料分割索引鍵，服務匯流排傳回無效的作業例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a7008-185">If you attempt toosend multiple messages within hello same transaction that have different partition keys, Service Bus returns an invalid operation exception.</span></span> <span data-ttu-id="a7008-186">例如：</span><span class="sxs-lookup"><span data-stu-id="a7008-186">For example:</span></span>

```csharp
CommittableTransaction committableTransaction = new CommittableTransaction();
using (TransactionScope ts = new TransactionScope(committableTransaction))
{
    BrokeredMessage msg = new BrokeredMessage("This is a message");
    msg.PartitionKey = "myPartitionKey";
    messageSender.Send(msg); 
    ts.Complete();
}
committableTransaction.Commit();
```

<span data-ttu-id="a7008-187">如果設定了任何 hello 屬性做為資料分割索引鍵，服務匯流排 pin hello 訊息 tooa 特定片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-187">If any of hello properties that serve as a partition key are set, Service Bus pins hello message tooa specific fragment.</span></span> <span data-ttu-id="a7008-188">無論是否使用交易，都會發生這個行為。</span><span class="sxs-lookup"><span data-stu-id="a7008-188">This behavior occurs whether or not a transaction is used.</span></span> <span data-ttu-id="a7008-189">建議您若非必要請勿指定分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a7008-189">It is recommended that you do not specify a partition key if it is not necessary.</span></span>

## <a name="using-sessions-with-partitioned-entities"></a><span data-ttu-id="a7008-190">搭配工作階段使用分割的實體</span><span class="sxs-lookup"><span data-stu-id="a7008-190">Using sessions with partitioned entities</span></span>
<span data-ttu-id="a7008-191">hello 訊息 toosend 異動式訊息 tooa 工作階段感知主題或佇列，必須有 hello [BrokeredMessage.SessionId] [ BrokeredMessage.SessionId]屬性集。</span><span class="sxs-lookup"><span data-stu-id="a7008-191">toosend a transactional message tooa session-aware topic or queue, hello message must have hello [BrokeredMessage.SessionId][BrokeredMessage.SessionId] property set.</span></span> <span data-ttu-id="a7008-192">如果 hello [BrokeredMessage.PartitionKey] [ BrokeredMessage.PartitionKey]也指定屬性，它必須是相同的 toohello [SessionId] [ SessionId]屬性。</span><span class="sxs-lookup"><span data-stu-id="a7008-192">If hello [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] property is specified as well, it must be identical toohello [SessionId][SessionId] property.</span></span> <span data-ttu-id="a7008-193">如果兩者不同，服務匯流排會傳回無效作業例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a7008-193">If they differ, Service Bus returns an invalid operation exception.</span></span>

<span data-ttu-id="a7008-194">不同於一般 （非資料分割） 的佇列或主題，它不可能 toouse 單一交易 toosend 多個訊息 toodifferent 工作階段。</span><span class="sxs-lookup"><span data-stu-id="a7008-194">Unlike regular (non-partitioned) queues or topics, it is not possible toouse a single transaction toosend multiple messages toodifferent sessions.</span></span> <span data-ttu-id="a7008-195">如果嘗試這樣做，服務匯流排會傳回無效作業例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a7008-195">If attempted, Service Bus returns an invalid operation exception.</span></span> <span data-ttu-id="a7008-196">例如：</span><span class="sxs-lookup"><span data-stu-id="a7008-196">For example:</span></span>

```csharp
CommittableTransaction committableTransaction = new CommittableTransaction();
using (TransactionScope ts = new TransactionScope(committableTransaction))
{
    BrokeredMessage msg = new BrokeredMessage("This is a message");
    msg.SessionId = "mySession";
    messageSender.Send(msg); 
    ts.Complete();
}
committableTransaction.Commit();
```

## <a name="automatic-message-forwarding-with-partitioned-entities"></a><span data-ttu-id="a7008-197">使用分割實體的自動訊息轉送</span><span class="sxs-lookup"><span data-stu-id="a7008-197">Automatic message forwarding with partitioned entities</span></span>
<span data-ttu-id="a7008-198">服務匯流排支援往返於分割實體或在它們之間自動轉送訊息。</span><span class="sxs-lookup"><span data-stu-id="a7008-198">Service Bus supports automatic message forwarding from, to, or between partitioned entities.</span></span> <span data-ttu-id="a7008-199">tooenable 自動訊息轉送、 設定 hello [QueueDescription.ForwardTo] [ QueueDescription.ForwardTo] hello 來源佇列或訂閱的屬性。</span><span class="sxs-lookup"><span data-stu-id="a7008-199">tooenable automatic message forwarding, set hello [QueueDescription.ForwardTo][QueueDescription.ForwardTo] property on hello source queue or subscription.</span></span> <span data-ttu-id="a7008-200">如果 hello 訊息指定資料分割索引鍵 ([SessionId][SessionId]， [PartitionKey][PartitionKey]，或[MessageId] [ MessageId])，該資料分割索引鍵用於 hello 目的地實體。</span><span class="sxs-lookup"><span data-stu-id="a7008-200">If hello message specifies a partition key ([SessionId][SessionId], [PartitionKey][PartitionKey], or [MessageId][MessageId]), that partition key is used for hello destination entity.</span></span>

## <a name="considerations-and-guidelines"></a><span data-ttu-id="a7008-201">考量和指導方針</span><span class="sxs-lookup"><span data-stu-id="a7008-201">Considerations and guidelines</span></span>
* <span data-ttu-id="a7008-202">**高一致性功能**： 如果實體使用的功能，例如工作階段、 重複偵測或明確控制資料分割索引鍵，則 hello 訊息作業永遠是路由的 toospecific 片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-202">**High consistency features**: If an entity uses features such as sessions, duplicate detection, or explicit control of partitioning key, then hello messaging operations are always routed toospecific fragments.</span></span> <span data-ttu-id="a7008-203">如果任何 hello 片段遇到高流量或 hello 基礎存放區的狀況不良，這些作業失敗，且可用性會減少。</span><span class="sxs-lookup"><span data-stu-id="a7008-203">If any of hello fragments experience high traffic or hello underlying store is unhealthy, those operations fail and availability is reduced.</span></span> <span data-ttu-id="a7008-204">整體來說，hello 一致性高於仍然很多非資料分割的實體。相對於的 tooall hello 流量為發生問題，流量的子集合。</span><span class="sxs-lookup"><span data-stu-id="a7008-204">Overall, hello consistency is still much higher than non-partitioned entities; only a subset of traffic is experiencing issues, as opposed tooall hello traffic.</span></span> <span data-ttu-id="a7008-205">如需詳細資訊，請參閱這篇[針對可用性和一致性的討論](../event-hubs/event-hubs-availability-and-consistency.md)。</span><span class="sxs-lookup"><span data-stu-id="a7008-205">For more information, see this [discussion of availability and consistency](../event-hubs/event-hubs-availability-and-consistency.md).</span></span>
* <span data-ttu-id="a7008-206">**管理**： 必須 hello 實體的所有 hello 片段上執行作業，例如 Create、 Update 和 Delete。</span><span class="sxs-lookup"><span data-stu-id="a7008-206">**Management**: Operations such as Create, Update and Delete must be performed on all hello fragments of hello entity.</span></span> <span data-ttu-id="a7008-207">如果任何片段的狀況不良，可能會造成這些作業失敗。</span><span class="sxs-lookup"><span data-stu-id="a7008-207">If any fragment is unhealthy it could result in failures for these operations.</span></span> <span data-ttu-id="a7008-208">Hello Get 作業，例如訊息計數必須彙總資訊來自所有片段。</span><span class="sxs-lookup"><span data-stu-id="a7008-208">For hello Get operation, information such as message counts must be aggregated from all fragments.</span></span> <span data-ttu-id="a7008-209">如果任何片段會處於狀況不良，則會將 hello 實體可用性狀態報告為有限。</span><span class="sxs-lookup"><span data-stu-id="a7008-209">If any fragment is unhealthy, hello entity availability status is reported as limited.</span></span>
* <span data-ttu-id="a7008-210">**低的大量訊息案例，**： 對於這類情況，尤其是使用 hello HTTP 通訊協定，您可能必須 tooperform 多個接收作業順序 tooobtain 中所有的 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="a7008-210">**Low volume message scenarios**: For such scenarios, especially when using hello HTTP protocol, you may have tooperform multiple receive operations in order tooobtain all hello messages.</span></span> <span data-ttu-id="a7008-211">接收要求，hello 前端會接收對所有 hello 片段，並快取所有收到的 hello 回應。</span><span class="sxs-lookup"><span data-stu-id="a7008-211">For receive requests, hello front end performs a receive on all hello fragments and caches all hello responses received.</span></span> <span data-ttu-id="a7008-212">在相同的連接會從這個快取中獲益並收到延遲的 hello 後續接收要求會比較低。</span><span class="sxs-lookup"><span data-stu-id="a7008-212">A subsequent receive request on hello same connection would benefit from this caching and receive latencies will be lower.</span></span> <span data-ttu-id="a7008-213">不過，如果您有多個連線或使用 HTTP，則會針對每個要求建立新的連接。</span><span class="sxs-lookup"><span data-stu-id="a7008-213">However, if you have multiple connections or use HTTP, that establishes a new connection for each request.</span></span> <span data-ttu-id="a7008-214">在這種情況，則它會登陸 hello 無法確保相同的節點。</span><span class="sxs-lookup"><span data-stu-id="a7008-214">As such, there is no guarantee that it would land on hello same node.</span></span> <span data-ttu-id="a7008-215">如果所有現有的訊息會鎖定，快取中另一個前端 hello 接收作業會傳回**null**。</span><span class="sxs-lookup"><span data-stu-id="a7008-215">If all existing messages are locked and cached in another front end, hello receive operation returns **null**.</span></span> <span data-ttu-id="a7008-216">訊息最後會到期，您可以再次接收它們。</span><span class="sxs-lookup"><span data-stu-id="a7008-216">Messages eventually expire and you can receive them again.</span></span> <span data-ttu-id="a7008-217">建議使用 HTTP 持續作用。</span><span class="sxs-lookup"><span data-stu-id="a7008-217">HTTP keep-alive is recommended.</span></span>
* <span data-ttu-id="a7008-218">**瀏覽窺視訊息**: [PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_)不一定會傳回所指定的 hello 訊息的 hello 數目[MessageCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MessageCount)屬性。</span><span class="sxs-lookup"><span data-stu-id="a7008-218">**Browse/Peek messages**: [PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_) does not always return hello number of messages specified in hello [MessageCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MessageCount) property.</span></span> <span data-ttu-id="a7008-219">這有兩個常見的原因。</span><span class="sxs-lookup"><span data-stu-id="a7008-219">There are two common reasons for this.</span></span> <span data-ttu-id="a7008-220">其中一個原因是該 hello hello 訊息的集合彙總的大小超過 hello 256 KB 的大小上限。</span><span class="sxs-lookup"><span data-stu-id="a7008-220">One reason is that hello aggregated size of hello collection of messages exceeds hello maximum size of 256KB.</span></span> <span data-ttu-id="a7008-221">另一個原因是如果 hello 佇列或主題有 hello [EnablePartitioning 屬性](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_EnablePartitioning)設定得**true**，資料分割可能沒有足夠的訊息 toocomplete hello 要求的訊息數目。</span><span class="sxs-lookup"><span data-stu-id="a7008-221">Another reason is that if hello queue or topic has hello [EnablePartitioning property](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_EnablePartitioning) set too**true**, a partition may not have enough messages toocomplete hello requested number of messages.</span></span> <span data-ttu-id="a7008-222">一般情況下，如果應用程式想 tooreceive 特定數目的訊息，它應該呼叫[PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_)重複直到到達該數目的訊息，或有沒有更多的訊息 toopeek。</span><span class="sxs-lookup"><span data-stu-id="a7008-222">In general, if an application wants tooreceive a specific number of messages, it should call [PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_) repeatedly until it gets that number of messages, or there are no more messages toopeek.</span></span> <span data-ttu-id="a7008-223">如需詳細資訊，包括程式碼範例，請參閱 [QueueClient.PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_) 或 [SubscriptionClient.PeekBatch](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient#Microsoft_ServiceBus_Messaging_SubscriptionClient_PeekBatch_System_Int32_)。</span><span class="sxs-lookup"><span data-stu-id="a7008-223">For more information, including code samples, see [QueueClient.PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_) or [SubscriptionClient.PeekBatch](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient#Microsoft_ServiceBus_Messaging_SubscriptionClient_PeekBatch_System_Int32_).</span></span>

## <a name="latest-added-features"></a><span data-ttu-id="a7008-224">最新加入的功能</span><span class="sxs-lookup"><span data-stu-id="a7008-224">Latest added features</span></span>
* <span data-ttu-id="a7008-225">分割實體現在支援新增或移除規則。</span><span class="sxs-lookup"><span data-stu-id="a7008-225">Add or remove rule is now supported with partitioned entities.</span></span> <span data-ttu-id="a7008-226">不同於非分割實體，交易情況下不支援這些作業。</span><span class="sxs-lookup"><span data-stu-id="a7008-226">Different from non-partitioned entities, these operations are not supported under transactions.</span></span> 
* <span data-ttu-id="a7008-227">AMQP 現在支援傳送和接收訊息 tooand 從資料分割的實體。</span><span class="sxs-lookup"><span data-stu-id="a7008-227">AMQP is now supported for sending and receiving messages tooand from a partitioned entity.</span></span>
* <span data-ttu-id="a7008-228">AMQP 現在支援下列作業的 hello:[批次傳送](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_BrokeredMessage__)，[批次接收](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_ReceiveBatch_System_Int32_)，[接收由序號](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_Receive_System_Int64_)，[查看](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_Peek)， [更新鎖定](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_RenewMessageLock_System_Guid_)，[排程訊息](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_ScheduleMessageAsync_Microsoft_ServiceBus_Messaging_BrokeredMessage_System_DateTimeOffset_)，[取消已排程的訊息](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_CancelScheduledMessageAsync_System_Int64_)，[新增規則](/dotnet/api/microsoft.servicebus.messaging.ruledescription)，[移除規則](/dotnet/api/microsoft.servicebus.messaging.ruledescription)，[工作階段更新鎖定](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_RenewLock)，[設定工作階段狀態](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_)，[取得工作階段狀態](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_GetState)，和[列舉工作階段](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessionsAsync)。</span><span class="sxs-lookup"><span data-stu-id="a7008-228">AMQP is now supported for hello following operations: [Batch Send](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_BrokeredMessage__), [Batch Receive](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_ReceiveBatch_System_Int32_), [Receive by Sequence Number](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_Receive_System_Int64_), [Peek](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_Peek), [Renew Lock](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_RenewMessageLock_System_Guid_), [Schedule Message](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_ScheduleMessageAsync_Microsoft_ServiceBus_Messaging_BrokeredMessage_System_DateTimeOffset_), [Cancel Scheduled Message](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_CancelScheduledMessageAsync_System_Int64_), [Add Rule](/dotnet/api/microsoft.servicebus.messaging.ruledescription), [Remove Rule](/dotnet/api/microsoft.servicebus.messaging.ruledescription), [Session Renew Lock](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_RenewLock), [Set Session State](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_), [Get Session State](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_GetState), and [Enumerate Sessions](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessionsAsync).</span></span>

## <a name="partitioned-entities-limitations"></a><span data-ttu-id="a7008-229">分割實體限制</span><span class="sxs-lookup"><span data-stu-id="a7008-229">Partitioned entities limitations</span></span>
<span data-ttu-id="a7008-230">目前服務匯流排會加諸下列限制分割的佇列和主題的 hello:</span><span class="sxs-lookup"><span data-stu-id="a7008-230">Currently Service Bus imposes hello following limitations on partitioned queues and topics:</span></span>

* <span data-ttu-id="a7008-231">資料分割的佇列和主題不支援所傳送的訊息屬於 toodifferent 在單一交易中的工作階段。</span><span class="sxs-lookup"><span data-stu-id="a7008-231">Partitioned queues and topics do not support sending messages that belong toodifferent sessions in a single transaction.</span></span>
* <span data-ttu-id="a7008-232">服務匯流排目前允許 too100 分割佇列或主題，每個命名空間。</span><span class="sxs-lookup"><span data-stu-id="a7008-232">Service Bus currently allows up too100 partitioned queues or topics per namespace.</span></span> <span data-ttu-id="a7008-233">每個磁碟分割的佇列或主題會計入 hello 配額的 10,000 個實體，每個命名空間 （不適用 tooPremium 層）。</span><span class="sxs-lookup"><span data-stu-id="a7008-233">Each partitioned queue or topic counts towards hello quota of 10,000 entities per namespace (does not apply tooPremium tier).</span></span>

## <a name="next-steps"></a><span data-ttu-id="a7008-234">後續步驟</span><span class="sxs-lookup"><span data-stu-id="a7008-234">Next steps</span></span>
<span data-ttu-id="a7008-235">請參閱 hello 討論[服務匯流排 AMQP 1.0 支援分割佇列和主題][ AMQP 1.0 support for Service Bus partitioned queues and topics] toolearn 更多關於資料分割訊息實體。</span><span class="sxs-lookup"><span data-stu-id="a7008-235">See hello discussion of [AMQP 1.0 support for Service Bus partitioned queues and topics][AMQP 1.0 support for Service Bus partitioned queues and topics] toolearn more about partitioning messaging entities.</span></span> 

[Service Bus architecture]: service-bus-architecture.md
[Azure portal]: https://portal.azure.com
[QueueDescription.EnablePartitioning]: /dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_EnablePartitioning
[TopicDescription.EnablePartitioning]: /dotnet/api/microsoft.servicebus.messaging.topicdescription#Microsoft_ServiceBus_Messaging_TopicDescription_EnablePartitioning
[BrokeredMessage.SessionId]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_SessionId
[BrokeredMessage.PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_PartitionKey
[SessionId]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_SessionId
[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_PartitionKey
[QueueDescription.RequiresDuplicateDetection]: /dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_RequiresDuplicateDetection
[BrokeredMessage.MessageId]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId
[MessageId]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId
[MessagingFactorySettings.OperationTimeout]: /dotnet/api/microsoft.servicebus.messaging.messagingfactorysettings#Microsoft_ServiceBus_Messaging_MessagingFactorySettings_OperationTimeout
[OperationTimeout]: /dotnet/api/microsoft.servicebus.messaging.messagingfactorysettings#Microsoft_ServiceBus_Messaging_MessagingFactorySettings_OperationTimeout
[QueueDescription.ForwardTo]: /dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_ForwardTo
[AMQP 1.0 support for Service Bus partitioned queues and topics]: service-bus-partitioned-queues-and-topics-amqp-overview.md
