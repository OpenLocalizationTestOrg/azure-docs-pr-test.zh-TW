---
title: "Azure 服務匯流排配對的命名空間 |Microsoft Docs"
description: "配對的命名空間實作詳細資料和成本"
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 2440c8d3-ed2e-47e0-93cf-ab7fbb855d2e
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 05/25/2017
ms.author: sethm
ms.openlocfilehash: a200ea7937b9f5296c743928a9408897adfba428
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="paired-namespace-implementation-details-and-cost-implications"></a><span data-ttu-id="54ca2-103">配對命名空間實作詳細資料和成本影響</span><span class="sxs-lookup"><span data-stu-id="54ca2-103">Paired namespace implementation details and cost implications</span></span>
<span data-ttu-id="54ca2-104">使用 [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] 執行個體的 [PairNamespaceAsync][PairNamespaceAsync] 方法會代表您執行可見的工作。</span><span class="sxs-lookup"><span data-stu-id="54ca2-104">The [PairNamespaceAsync][PairNamespaceAsync] method, using a [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance, performs visible tasks on your behalf.</span></span> <span data-ttu-id="54ca2-105">因為使用此功能時有一些成本考量，了解這些工作會有所幫助，以便預期發生時的行為。</span><span class="sxs-lookup"><span data-stu-id="54ca2-105">Because there are cost considerations when using the feature, it is useful to understand those tasks so that you expect the behavior when it happens.</span></span> <span data-ttu-id="54ca2-106">API 會代表您下列從事下列自動行為：</span><span class="sxs-lookup"><span data-stu-id="54ca2-106">The API engages the following automatic behavior on your behalf:</span></span>

* <span data-ttu-id="54ca2-107">建立待處理項目佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-107">Creation of backlog queues.</span></span>
* <span data-ttu-id="54ca2-108">建立可與佇列或主題交談的 [MessageSender][MessageSender] 物件。</span><span class="sxs-lookup"><span data-stu-id="54ca2-108">Creation of a [MessageSender][MessageSender] object that talks to queues or topics.</span></span>
* <span data-ttu-id="54ca2-109">當傳訊實體變成無法使用時，在嘗試偵測該實體何時可再度使用時傳送 ping 訊息到實體。</span><span class="sxs-lookup"><span data-stu-id="54ca2-109">When a messaging entity becomes unavailable, sends ping messages to the entity in an attempt to detect when that entity becomes available again.</span></span>
* <span data-ttu-id="54ca2-110">選擇性建立一組可將訊息從待處理項目佇列移到主要佇列的「訊息幫浦」。</span><span class="sxs-lookup"><span data-stu-id="54ca2-110">Optionally creates of a set of “message pumps” that move messages from the backlog queues to the primary queues.</span></span>
* <span data-ttu-id="54ca2-111">協調主要和次要 [MessagingFactory][MessagingFactory] 執行個體的關閉/失敗。</span><span class="sxs-lookup"><span data-stu-id="54ca2-111">Coordinates closing/faulting of the primary and secondary [MessagingFactory][MessagingFactory] instances.</span></span>

<span data-ttu-id="54ca2-112">概括而言，此功能的運作方式如下：當主要實體的狀況良好時，不會發生任何行為變更。</span><span class="sxs-lookup"><span data-stu-id="54ca2-112">At a high level, the feature works as follows: when the primary entity is healthy, no behavior changes occur.</span></span> <span data-ttu-id="54ca2-113">當 [FailoverInterval][FailoverInterval] 期間過後，而且主要實體未看到非暫時性 [MessagingException][MessagingException] 或 [TimeoutException][TimeoutException] 之後有任何成功傳送，則會發生下列行為：</span><span class="sxs-lookup"><span data-stu-id="54ca2-113">When the [FailoverInterval][FailoverInterval] duration elapses, and the primary entity sees no successful sends after a non-transient [MessagingException][MessagingException] or a [TimeoutException][TimeoutException], the following behavior occurs:</span></span>

1. <span data-ttu-id="54ca2-114">傳送至主要實體的作業會停用，而系統會 ping 主要實體，直到可以成功傳送 ping 為止。</span><span class="sxs-lookup"><span data-stu-id="54ca2-114">Send operations to the primary entity are disabled and the system pings the primary entity until pings can be successfully delivered.</span></span>
2. <span data-ttu-id="54ca2-115">已選取隨機待處理項目佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-115">A random backlog queue is selected.</span></span>
3. <span data-ttu-id="54ca2-116">[BrokeredMessage][BrokeredMessage] 物件會路由傳送至所選的積存佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-116">[BrokeredMessage][BrokeredMessage] objects are routed to the chosen backlog queue.</span></span>
4. <span data-ttu-id="54ca2-117">如果傳送至所選待處理項目佇列的作業失敗，則會從輪替提取該佇列並選取新的佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-117">If a send operation to the chosen backlog queue fails, that queue is pulled from the rotation and a new queue is selected.</span></span> <span data-ttu-id="54ca2-118">[MessagingFactory][MessagingFactory] 執行個體上的所有傳送端都會得知失敗。</span><span class="sxs-lookup"><span data-stu-id="54ca2-118">All senders on the [MessagingFactory][MessagingFactory] instance learn of the failure.</span></span>

<span data-ttu-id="54ca2-119">下圖描繪順序。</span><span class="sxs-lookup"><span data-stu-id="54ca2-119">The following figures depict the sequence.</span></span> <span data-ttu-id="54ca2-120">首先，傳送端會傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="54ca2-120">First, the sender sends messages.</span></span>

![配對的命名空間][0]

<span data-ttu-id="54ca2-122">無法傳送到主要佇列時，傳送端會開始傳送訊息到隨機選擇的待處理項目佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-122">Upon failure to send to the primary queue, the sender begins sending messages to a randomly chosen backlog queue.</span></span> <span data-ttu-id="54ca2-123">同時，它會開始進行 ping 工作。</span><span class="sxs-lookup"><span data-stu-id="54ca2-123">Simultaneously, it starts a ping task.</span></span>

![配對的命名空間][1]

<span data-ttu-id="54ca2-125">此時訊息仍在次要佇列中，而尚未傳遞到主要佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-125">At this point the messages are still in the secondary queue and have not been delivered to the primary queue.</span></span> <span data-ttu-id="54ca2-126">一旦主要佇列再度恢復良好狀況，至少有一個程序應該執行 Syphon。</span><span class="sxs-lookup"><span data-stu-id="54ca2-126">Once the primary queue is healthy again, at least one process should be running the syphon.</span></span> <span data-ttu-id="54ca2-127">Syphon 會將各種待處理項目佇列中的訊息傳遞至適當的目的地實體 (佇列和主題)。</span><span class="sxs-lookup"><span data-stu-id="54ca2-127">The syphon delivers the messages from all the various backlog queues to the proper destination entities (queues and topics).</span></span>

![配對的命名空間][2]

<span data-ttu-id="54ca2-129">本主題的其餘部分將討論這些片段運作方式的具體詳細資料。</span><span class="sxs-lookup"><span data-stu-id="54ca2-129">The remainder of this topic discusses the specific details of how these pieces work.</span></span>

## <a name="creation-of-backlog-queues"></a><span data-ttu-id="54ca2-130">建立待處理項目佇列</span><span class="sxs-lookup"><span data-stu-id="54ca2-130">Creation of backlog queues</span></span>
<span data-ttu-id="54ca2-131">傳遞至 [PairNamespaceAsync][PairNamespaceAsync] 方法的 [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] 物件會指出您要使用的積存佇列數目。</span><span class="sxs-lookup"><span data-stu-id="54ca2-131">The [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] object passed to the [PairNamespaceAsync][PairNamespaceAsync] method indicates the number of backlog queues you want to use.</span></span> <span data-ttu-id="54ca2-132">然後建立已明確設定下列屬性的每個積存佇列 (所有其他值都會設為 [QueueDescription][QueueDescription] 預設值)：</span><span class="sxs-lookup"><span data-stu-id="54ca2-132">Each backlog queue is then created with the following properties explicitly set (all other values are set to the [QueueDescription][QueueDescription] defaults):</span></span>

| <span data-ttu-id="54ca2-133">Path</span><span class="sxs-lookup"><span data-stu-id="54ca2-133">Path</span></span> | <span data-ttu-id="54ca2-134">[primary namespace]/x-servicebus-transfer/[index]，其中 [index] 是 [0, BacklogQueueCount) 中的值</span><span class="sxs-lookup"><span data-stu-id="54ca2-134">[primary namespace]/x-servicebus-transfer/[index] where [index] is a value in [0, BacklogQueueCount)</span></span> |
| --- | --- |
| <span data-ttu-id="54ca2-135">MaxSizeInMegabytes</span><span class="sxs-lookup"><span data-stu-id="54ca2-135">MaxSizeInMegabytes</span></span> |<span data-ttu-id="54ca2-136">5120</span><span class="sxs-lookup"><span data-stu-id="54ca2-136">5120</span></span> |
| <span data-ttu-id="54ca2-137">MaxDeliveryCount</span><span class="sxs-lookup"><span data-stu-id="54ca2-137">MaxDeliveryCount</span></span> |<span data-ttu-id="54ca2-138">int.MaxValue</span><span class="sxs-lookup"><span data-stu-id="54ca2-138">int.MaxValue</span></span> |
| <span data-ttu-id="54ca2-139">DefaultMessageTimeToLive</span><span class="sxs-lookup"><span data-stu-id="54ca2-139">DefaultMessageTimeToLive</span></span> |<span data-ttu-id="54ca2-140">TimeSpan.MaxValue</span><span class="sxs-lookup"><span data-stu-id="54ca2-140">TimeSpan.MaxValue</span></span> |
| <span data-ttu-id="54ca2-141">AutoDeleteOnIdle</span><span class="sxs-lookup"><span data-stu-id="54ca2-141">AutoDeleteOnIdle</span></span> |<span data-ttu-id="54ca2-142">TimeSpan.MaxValue</span><span class="sxs-lookup"><span data-stu-id="54ca2-142">TimeSpan.MaxValue</span></span> |
| <span data-ttu-id="54ca2-143">LockDuration</span><span class="sxs-lookup"><span data-stu-id="54ca2-143">LockDuration</span></span> |<span data-ttu-id="54ca2-144">1 分鐘</span><span class="sxs-lookup"><span data-stu-id="54ca2-144">1 minute</span></span> |
| <span data-ttu-id="54ca2-145">EnableDeadLetteringOnMessageExpiration</span><span class="sxs-lookup"><span data-stu-id="54ca2-145">EnableDeadLetteringOnMessageExpiration</span></span> |<span data-ttu-id="54ca2-146">true</span><span class="sxs-lookup"><span data-stu-id="54ca2-146">true</span></span> |
| <span data-ttu-id="54ca2-147">EnableBatchedOperations</span><span class="sxs-lookup"><span data-stu-id="54ca2-147">EnableBatchedOperations</span></span> |<span data-ttu-id="54ca2-148">true</span><span class="sxs-lookup"><span data-stu-id="54ca2-148">true</span></span> |

<span data-ttu-id="54ca2-149">例如，針對命名空間 **contoso`contoso/x-servicebus-transfer/0` 建立的第一個積存佇列名為** 。</span><span class="sxs-lookup"><span data-stu-id="54ca2-149">For example, the first backlog queue created for namespace **contoso** is named `contoso/x-servicebus-transfer/0`.</span></span>

<span data-ttu-id="54ca2-150">建立佇列時，程式碼會先查看是否有此佇列存在。</span><span class="sxs-lookup"><span data-stu-id="54ca2-150">When creating the queues, the code first checks to see if such a queue exists.</span></span> <span data-ttu-id="54ca2-151">如果此佇列不存在，則會建立佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-151">If the queue does not exist, then the queue is created.</span></span> <span data-ttu-id="54ca2-152">程式碼不會清除「額外的」待處理項目佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-152">The code does not clean up "extra" backlog queues.</span></span> <span data-ttu-id="54ca2-153">具體而言，如果具有主要命名空間 **contoso** 的應用程式要求 5 個積存佇列，但有一個具有路徑 `contoso/x-servicebus-transfer/7` 的積存佇列存在，則該額外的積存佇列仍然存在，但不會使用。</span><span class="sxs-lookup"><span data-stu-id="54ca2-153">Specifically, if the application with the primary namespace **contoso** requests five backlog queues but a backlog queue with the path `contoso/x-servicebus-transfer/7` exists, that extra backlog queue is still present but is not used.</span></span> <span data-ttu-id="54ca2-154">系統明確允許額外的待處理項目佇列存在但不會使用。</span><span class="sxs-lookup"><span data-stu-id="54ca2-154">The system explicitly allows extra backlog queues to exist that would not be used.</span></span> <span data-ttu-id="54ca2-155">身為命名空間擁有者，您必須負責清除任何未使用/不需要的待處理項目佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-155">As the namespace owner, you are responsible for cleaning up any unused/unwanted backlog queues.</span></span> <span data-ttu-id="54ca2-156">此決策的原因是服務匯流排無法得知您的命名空間中所有佇列的目的為何。</span><span class="sxs-lookup"><span data-stu-id="54ca2-156">The reason for this decision is that Service Bus cannot know what purposes exist for all the queues in your namespace.</span></span> <span data-ttu-id="54ca2-157">此外，如果佇列具有指定的名稱但不符合所假設的 [QueueDescription][QueueDescription]，則您的理由是您自己要變更預設行為。</span><span class="sxs-lookup"><span data-stu-id="54ca2-157">Furthermore, if a queue exists with the given name but does not meet the assumed [QueueDescription][QueueDescription], then your reasons are your own for changing the default behavior.</span></span> <span data-ttu-id="54ca2-158">不保證您的程式碼會修改待處理項目佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-158">No guarantees are made for modifications to the backlog queues by your code.</span></span> <span data-ttu-id="54ca2-159">請務必徹底測試您的變更。</span><span class="sxs-lookup"><span data-stu-id="54ca2-159">Make sure to test your changes thoroughly.</span></span>

## <a name="custom-messagesender"></a><span data-ttu-id="54ca2-160">自訂 MessageSender</span><span class="sxs-lookup"><span data-stu-id="54ca2-160">Custom MessageSender</span></span>
<span data-ttu-id="54ca2-161">傳送時，所有訊息都會經過內部 [MessageSender][MessageSender] 物件，該物件在一切可行時會正常表現，但在出現問題時會重新導向至積存佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-161">When sending, all messages go through an internal [MessageSender][MessageSender] object that behaves normally when everything works, and redirects to the backlog queues when things "break."</span></span> <span data-ttu-id="54ca2-162">收到非暫時性失敗時，會啟動計時器。</span><span class="sxs-lookup"><span data-stu-id="54ca2-162">Upon receiving a non-transient failure, a timer starts.</span></span> <span data-ttu-id="54ca2-163">在由 [FailoverInterval][FailoverInterval] 屬性值組成的 [TimeSpan][TimeSpan] 期間 (其間並未傳送任何成功訊息) 過後，會進行容錯移轉。</span><span class="sxs-lookup"><span data-stu-id="54ca2-163">After a [TimeSpan][TimeSpan] period consisting of the [FailoverInterval][FailoverInterval] property value during which no successful messages are sent, the failover is engaged.</span></span> <span data-ttu-id="54ca2-164">此時，每個實體會發生下列情況︰</span><span class="sxs-lookup"><span data-stu-id="54ca2-164">At this point, the following things happen for each entity:</span></span>

* <span data-ttu-id="54ca2-165">每隔 [PingPrimaryInterval][PingPrimaryInterval] 就會執行一次 Ping 工作來檢查實體是否可用。</span><span class="sxs-lookup"><span data-stu-id="54ca2-165">A ping task executes every [PingPrimaryInterval][PingPrimaryInterval] to check if the entity is available.</span></span> <span data-ttu-id="54ca2-166">此工作一旦成功，使用該實體的所有用戶端程式碼會立即開始將新訊息傳送到主要命名空間。</span><span class="sxs-lookup"><span data-stu-id="54ca2-166">Once this task succeeds, all client code that uses the entity immediately starts sending new messages to the primary namespace.</span></span>
* <span data-ttu-id="54ca2-167">未來要從任何其他傳送端傳送到該相同實體的要求，將導致所傳送的[BrokeredMessage][BrokeredMessage] 遭到修改以放入積存佇列中。</span><span class="sxs-lookup"><span data-stu-id="54ca2-167">Future requests to send to that same entity from any other senders will result in the [BrokeredMessage][BrokeredMessage] being sent to be modified to sit in the backlog queue.</span></span> <span data-ttu-id="54ca2-168">修改作業會從 [BrokeredMessage][BrokeredMessage] 物件移除某些屬性，並將它們儲存在其他地方。</span><span class="sxs-lookup"><span data-stu-id="54ca2-168">The modification removes some properties from the [BrokeredMessage][BrokeredMessage] object and stores them elsewhere.</span></span> <span data-ttu-id="54ca2-169">下列屬性已被清除並新增於新別名之下，可讓服務匯流排和 SDK 以一致的方式處理訊息︰</span><span class="sxs-lookup"><span data-stu-id="54ca2-169">The following properties are cleared and added under a new alias, allowing Service Bus and the SDK to process messages uniformly:</span></span>

| <span data-ttu-id="54ca2-170">舊屬性名稱</span><span class="sxs-lookup"><span data-stu-id="54ca2-170">Old Property Name</span></span> | <span data-ttu-id="54ca2-171">新屬性名稱</span><span class="sxs-lookup"><span data-stu-id="54ca2-171">New Property Name</span></span> |
| --- | --- |
| <span data-ttu-id="54ca2-172">SessionId</span><span class="sxs-lookup"><span data-stu-id="54ca2-172">SessionId</span></span> |<span data-ttu-id="54ca2-173">x-ms-sessionid</span><span class="sxs-lookup"><span data-stu-id="54ca2-173">x-ms-sessionid</span></span> |
| <span data-ttu-id="54ca2-174">TimeToLive</span><span class="sxs-lookup"><span data-stu-id="54ca2-174">TimeToLive</span></span> |<span data-ttu-id="54ca2-175">x-ms-timetolive</span><span class="sxs-lookup"><span data-stu-id="54ca2-175">x-ms-timetolive</span></span> |
| <span data-ttu-id="54ca2-176">ScheduledEnqueueTimeUtc</span><span class="sxs-lookup"><span data-stu-id="54ca2-176">ScheduledEnqueueTimeUtc</span></span> |<span data-ttu-id="54ca2-177">x-ms-path</span><span class="sxs-lookup"><span data-stu-id="54ca2-177">x-ms-path</span></span> |

<span data-ttu-id="54ca2-178">原始目的地路徑也會以名為 x-ms-path 的屬性形式儲存在訊息內。</span><span class="sxs-lookup"><span data-stu-id="54ca2-178">The original destination path is also stored within the message as a property named x-ms-path.</span></span> <span data-ttu-id="54ca2-179">這種設計可讓多個實體的訊息共存於單一待處理項目佇列中。</span><span class="sxs-lookup"><span data-stu-id="54ca2-179">This design allows messages for many entities to coexist in a single backlog queue.</span></span> <span data-ttu-id="54ca2-180">這些屬性會由 Syphon 轉譯回來。</span><span class="sxs-lookup"><span data-stu-id="54ca2-180">The properties are translated back by the syphon.</span></span>

<span data-ttu-id="54ca2-181">自訂的 [MessageSender][MessageSender] 物件可能會在訊息接近 256 KB 限制並進行容錯移轉時遇到問題。</span><span class="sxs-lookup"><span data-stu-id="54ca2-181">The custom [MessageSender][MessageSender] object can encounter issues when messages approach the 256-KB limit and failover is engaged.</span></span> <span data-ttu-id="54ca2-182">自訂的 [MessageSender][MessageSender] 物件會將所有佇列和主題的訊息一起存放在積存佇列中。</span><span class="sxs-lookup"><span data-stu-id="54ca2-182">The custom [MessageSender][MessageSender] object stores messages for all queues and topics together in the backlog queues.</span></span> <span data-ttu-id="54ca2-183">此物件會將待處理項目佇列中許多主要項目的訊息混合在一起。</span><span class="sxs-lookup"><span data-stu-id="54ca2-183">This object mixes messages from many primaries together within the backlog queues.</span></span> <span data-ttu-id="54ca2-184">為了處理許多不知道彼此存在之用戶端間的負載平衡，SDK 會為您在程式碼中建立的每個 [QueueClient][QueueClient] 或 [TopicClient][TopicClient] 隨機挑選一個積存佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-184">To handle load balancing among many clients that do not know each other, the SDK randomly picks one backlog queue for each [QueueClient][QueueClient] or [TopicClient][TopicClient] you create in code.</span></span>

## <a name="pings"></a><span data-ttu-id="54ca2-185">Ping</span><span class="sxs-lookup"><span data-stu-id="54ca2-185">Pings</span></span>
<span data-ttu-id="54ca2-186">Ping 訊息是空的 [BrokeredMessage][BrokeredMessage]，它的 [ContentType][ContentType] 屬性設定為 application/vnd.ms-servicebus-ping 且 [TimeToLive][TimeToLive] 值為 1 秒。</span><span class="sxs-lookup"><span data-stu-id="54ca2-186">A ping message is an empty [BrokeredMessage][BrokeredMessage] with its [ContentType][ContentType] property set to application/vnd.ms-servicebus-ping and a [TimeToLive][TimeToLive] value of 1 second.</span></span> <span data-ttu-id="54ca2-187">此 ping 在服務匯流排中有一個特性︰當任何呼叫端要求 [BrokeredMessage][BrokeredMessage] 時，伺服器絕不會傳遞 ping。</span><span class="sxs-lookup"><span data-stu-id="54ca2-187">This ping has one special characteristic in Service Bus: the server never delivers a ping when any caller requests a [BrokeredMessage][BrokeredMessage].</span></span> <span data-ttu-id="54ca2-188">因此，您永遠都不必了解如何接收並忽略這些訊息。</span><span class="sxs-lookup"><span data-stu-id="54ca2-188">Thus, you never have to learn how to receive and ignore these messages.</span></span> <span data-ttu-id="54ca2-189">當每個用戶端的每個 [MessagingFactory][MessagingFactory] 執行個體的每個實體 (唯一佇列或主題) 被視為無法使用時，將會進行 ping。</span><span class="sxs-lookup"><span data-stu-id="54ca2-189">Each entity (unique queue or topic) per [MessagingFactory][MessagingFactory] instance per client will be pinged when they are considered to be unavailable.</span></span> <span data-ttu-id="54ca2-190">根據預設，這會每分鐘發生一次。</span><span class="sxs-lookup"><span data-stu-id="54ca2-190">By default, this happens once per minute.</span></span> <span data-ttu-id="54ca2-191">Ping 訊息會被視為一般的服務匯流排訊息，可能會導致頻寬和訊息的費用。</span><span class="sxs-lookup"><span data-stu-id="54ca2-191">Ping messages are considered to be regular Service Bus messages, and can result in charges for bandwidth and messages.</span></span> <span data-ttu-id="54ca2-192">只要用戶端偵測到系統可以使用，訊息就會停止。</span><span class="sxs-lookup"><span data-stu-id="54ca2-192">As soon as the clients detect that the system is available, the messages stop.</span></span>

## <a name="the-syphon"></a><span data-ttu-id="54ca2-193">Syphon</span><span class="sxs-lookup"><span data-stu-id="54ca2-193">The syphon</span></span>
<span data-ttu-id="54ca2-194">應用程式中至少有一個可執行程式應該主動執行 Syphon。</span><span class="sxs-lookup"><span data-stu-id="54ca2-194">At least one executable program in the application should be actively running the syphon.</span></span> <span data-ttu-id="54ca2-195">Syphon 會執行持續 15 分鐘的長時間輪詢接收。</span><span class="sxs-lookup"><span data-stu-id="54ca2-195">The syphon performs a long poll receive that lasts 15 minutes.</span></span> <span data-ttu-id="54ca2-196">當所有實體都可使用且有 10 個待處理項目佇列時，裝載 Syphon 的應用程式會呼叫接收作業︰每小時 40 次、每天 960 次和 30 天內 28800 次。</span><span class="sxs-lookup"><span data-stu-id="54ca2-196">When all entities are available and you have 10 backlog queues, the application that hosts the syphon calls the receive operation 40 times per hour, 960 times per day, and 28800 times in 30 days.</span></span> <span data-ttu-id="54ca2-197">當 Syphon 主動將訊息從待處理項目移到主要佇列時，每則訊息會發生下列收費 (訊息大小和頻寬的標準收費適用於所有階段)︰</span><span class="sxs-lookup"><span data-stu-id="54ca2-197">When the syphon is actively moving messages from the backlog to the primary queue, each message experiences the following charges (standard charges for message size and bandwidth apply in all stages):</span></span>

1. <span data-ttu-id="54ca2-198">傳送至待處理項目佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-198">Send to the backlog.</span></span>
2. <span data-ttu-id="54ca2-199">從待處理項目佇列接收。</span><span class="sxs-lookup"><span data-stu-id="54ca2-199">Receive from the backlog.</span></span>
3. <span data-ttu-id="54ca2-200">傳送至主要佇列。</span><span class="sxs-lookup"><span data-stu-id="54ca2-200">Send to the primary.</span></span>
4. <span data-ttu-id="54ca2-201">從主要佇列接收。</span><span class="sxs-lookup"><span data-stu-id="54ca2-201">Receive from the primary.</span></span>

## <a name="closefault-behavior"></a><span data-ttu-id="54ca2-202">關閉/錯誤行為</span><span class="sxs-lookup"><span data-stu-id="54ca2-202">Close/fault behavior</span></span>
<span data-ttu-id="54ca2-203">在裝載 Syphon 的應用程式內，一旦主要或次要 [MessagingFactory][MessagingFactory] 發生錯誤或已關閉，但其夥伴並未同時發生錯誤/關閉且 Syphon 偵測到此狀態之後，Syphon 就會採取行動。</span><span class="sxs-lookup"><span data-stu-id="54ca2-203">Within an application that hosts the syphon, once the primary or secondary [MessagingFactory][MessagingFactory] faults or is closed without its partner also being faulted/closed and the syphon detects this state, the syphon acts.</span></span> <span data-ttu-id="54ca2-204">如果其他 [MessagingFactory][MessagingFactory] 未在 5 秒內關閉，則 Syphon 會發生錯誤但仍開啟 [MessagingFactory][MessagingFactory]。</span><span class="sxs-lookup"><span data-stu-id="54ca2-204">If the other [MessagingFactory][MessagingFactory] is not closed within 5 seconds, the syphon will fault the still open [MessagingFactory][MessagingFactory].</span></span>

## <a name="next-steps"></a><span data-ttu-id="54ca2-205">後續步驟</span><span class="sxs-lookup"><span data-stu-id="54ca2-205">Next steps</span></span>
<span data-ttu-id="54ca2-206">如需服務匯流排非同步通訊的詳細討論，請參閱[非同步通訊模式和高可用性][Asynchronous messaging patterns and high availability]。</span><span class="sxs-lookup"><span data-stu-id="54ca2-206">See [Asynchronous messaging patterns and high availability][Asynchronous messaging patterns and high availability] for a detailed discussion of Service Bus asynchronous messaging.</span></span> 

[PairNamespaceAsync]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_PairNamespaceAsync_Microsoft_ServiceBus_Messaging_PairedNamespaceOptions_
[SendAvailabilityPairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions
[MessageSender]: /dotnet/api/microsoft.servicebus.messaging.messagesender
[MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[FailoverInterval]: /dotnet/api/microsoft.servicebus.messaging.pairednamespaceoptions#Microsoft_ServiceBus_Messaging_PairedNamespaceOptions_FailoverInterval
[MessagingException]: /dotnet/api/microsoft.servicebus.messaging.messagingexception
[TimeoutException]: https://msdn.microsoft.com/library/azure/system.timeoutexception.aspx
[BrokeredMessage]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage
[QueueDescription]: /dotnet/api/microsoft.servicebus.messaging.queuedescription
[TimeSpan]: https://msdn.microsoft.com/library/azure/system.timespan.aspx
[PingPrimaryInterval]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_PingPrimaryInterval
[QueueClient]: /dotnet/api/microsoft.servicebus.messaging.queueclient
[TopicClient]: /dotnet/api/microsoft.servicebus.messaging.topicclient
[ContentType]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_ContentType
[TimeToLive]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive
[Asynchronous messaging patterns and high availability]: service-bus-async-messaging.md
[0]: ./media/service-bus-paired-namespaces/IC673405.png
[1]: ./media/service-bus-paired-namespaces/IC673406.png
[2]: ./media/service-bus-paired-namespaces/IC673407.png
