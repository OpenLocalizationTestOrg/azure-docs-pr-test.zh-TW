---
title: "aaaService 匯流排寄不出信件佇列 |Microsoft 文件"
description: "Azure 服務匯流排寄不出的信件佇列的概觀"
services: service-bus-messaging
documentationcenter: .net
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 68b2aa38-dba7-491a-9c26-0289bc15d397
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 05/17/2017
ms.author: clemensv;sethm
ms.openlocfilehash: 1638272085b8a3a59e8814f6f943caee35a2bfdc
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="overview-of-service-bus-dead-letter-queues"></a><span data-ttu-id="53272-103">服務匯流排寄不出的信件佇列的概觀</span><span class="sxs-lookup"><span data-stu-id="53272-103">Overview of Service Bus dead-letter queues</span></span>

<span data-ttu-id="53272-104">服務匯流排佇列和主題訂用帳戶提供次要的子佇列，稱為*無效信件佇列* (DLQ)。</span><span class="sxs-lookup"><span data-stu-id="53272-104">Service Bus queues and topic subscriptions provide a secondary sub-queue, called a *dead-letter queue* (DLQ).</span></span> <span data-ttu-id="53272-105">hello 寄不出的信件佇列不需要明確建立 toobe，而且不能刪除或其他 managed 的無關的 hello 主要實體。</span><span class="sxs-lookup"><span data-stu-id="53272-105">hello dead-letter queue does not need toobe explicitly created and cannot be deleted or otherwise managed independent of hello main entity.</span></span>

<span data-ttu-id="53272-106">本文討論 Azure 服務匯流排中的無效信件佇列。</span><span class="sxs-lookup"><span data-stu-id="53272-106">This article discusses dead-letter queues in Azure Service Bus.</span></span> <span data-ttu-id="53272-107">大部分的 hello 討論說明 hello[寄不出的信件佇列範例](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/DeadletterQueue)GitHub 上。</span><span class="sxs-lookup"><span data-stu-id="53272-107">Much of hello discussion is illustrated by hello [Dead-Letter Queues sample](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/DeadletterQueue) on GitHub.</span></span>
 
## <a name="hello-dead-letter-queue"></a><span data-ttu-id="53272-108">hello 寄不出的信件佇列</span><span class="sxs-lookup"><span data-stu-id="53272-108">hello dead-letter queue</span></span>

<span data-ttu-id="53272-109">hello 的目的 hello 寄不出的信件佇列是 toohold 訊息無法傳遞 tooany 收件者或無法處理的訊息。</span><span class="sxs-lookup"><span data-stu-id="53272-109">hello purpose of hello dead-letter queue is toohold messages that cannot be delivered tooany receiver, or messages that could not be processed.</span></span> <span data-ttu-id="53272-110">可以從 hello DLQ 移除訊息，然後檢查。</span><span class="sxs-lookup"><span data-stu-id="53272-110">Messages can then be removed from hello DLQ and inspected.</span></span> <span data-ttu-id="53272-111">應用程式可能會與運算子的說明，請更正問題並再重新送出 hello 訊息、 記錄時發生錯誤，hello 事實和採取更正動作。</span><span class="sxs-lookup"><span data-stu-id="53272-111">An application might, with help of an operator, correct issues and resubmit hello message, log hello fact that there was an error, and take corrective action.</span></span> 

<span data-ttu-id="53272-112">從應用程式開發介面和通訊協定的觀點而言，hello DLQ 是大部分類似 tooany 其他佇列中，不同之處在於只能透過 hello 寄不出信件筆勢 hello 父實體的提交訊息。</span><span class="sxs-lookup"><span data-stu-id="53272-112">From an API and protocol perspective, hello DLQ is mostly similar tooany other queue, except that messages can only be submitted via hello dead-letter gesture of hello parent entity.</span></span> <span data-ttu-id="53272-113">此外，存留時間並未遵守，而且您無法從 DLQ 讓訊息寄不出去。</span><span class="sxs-lookup"><span data-stu-id="53272-113">In addition, time-to-live is not observed, and you can't dead-letter a message from a DLQ.</span></span> <span data-ttu-id="53272-114">hello 寄不出的信件佇列完全支援查看並鎖定傳遞和交易式作業。</span><span class="sxs-lookup"><span data-stu-id="53272-114">hello dead-letter queue fully supports peek-lock delivery and transactional operations.</span></span>

<span data-ttu-id="53272-115">請注意，不會自動清除的 hello DLQ。</span><span class="sxs-lookup"><span data-stu-id="53272-115">Note that there is no automatic cleanup of hello DLQ.</span></span> <span data-ttu-id="53272-116">訊息保留在 hello DLQ，直到您明確地從 hello DLQ 和呼叫擷取[complete （)](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_CompleteAsync) hello 寄不出的信件訊息上。</span><span class="sxs-lookup"><span data-stu-id="53272-116">Messages remain in hello DLQ until you explicitly retrieve them from hello DLQ and call [Complete()](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_CompleteAsync) on hello dead-letter message.</span></span>

## <a name="moving-messages-toohello-dlq"></a><span data-ttu-id="53272-117">移動訊息 toohello DLQ</span><span class="sxs-lookup"><span data-stu-id="53272-117">Moving messages toohello DLQ</span></span>

<span data-ttu-id="53272-118">沒有服務匯流排中數個會造成訊息 tooget 推入 toohello 從 DLQ hello 傳訊引擎本身內的活動。</span><span class="sxs-lookup"><span data-stu-id="53272-118">There are several activities in Service Bus that cause messages tooget pushed toohello DLQ from within hello messaging engine itself.</span></span> <span data-ttu-id="53272-119">應用程式可以同時明確地移動訊息 toohello DLQ。</span><span class="sxs-lookup"><span data-stu-id="53272-119">An application can also explicitly move messages toohello DLQ.</span></span> 

<span data-ttu-id="53272-120">因為 hello broker 會呼叫其內部版的 hello hello broker 取得移動 hello 訊息，當兩個屬性就會加入 toohello 訊息[DeadLetter](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_DeadLetter_System_String_System_String_) hello 訊息上的方法：`DeadLetterReason`和`DeadLetterErrorDescription`。</span><span class="sxs-lookup"><span data-stu-id="53272-120">As hello message gets moved by hello broker, two properties are added toohello message as hello broker calls its internal version of hello [DeadLetter](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_DeadLetter_System_String_System_String_) method on hello message: `DeadLetterReason` and `DeadLetterErrorDescription`.</span></span>

<span data-ttu-id="53272-121">應用程式可以定義自己的程式碼的 hello`DeadLetterReason`屬性，但是 hello 系統集 hello 下列值。</span><span class="sxs-lookup"><span data-stu-id="53272-121">Applications can define their own codes for hello `DeadLetterReason` property, but hello system sets hello following values.</span></span>

| <span data-ttu-id="53272-122">條件</span><span class="sxs-lookup"><span data-stu-id="53272-122">Condition</span></span> | <span data-ttu-id="53272-123">DeadLetterReason</span><span class="sxs-lookup"><span data-stu-id="53272-123">DeadLetterReason</span></span> | <span data-ttu-id="53272-124">DeadLetterErrorDescription</span><span class="sxs-lookup"><span data-stu-id="53272-124">DeadLetterErrorDescription</span></span> |
| --- | --- | --- |
| <span data-ttu-id="53272-125">一律</span><span class="sxs-lookup"><span data-stu-id="53272-125">Always</span></span> |<span data-ttu-id="53272-126">HeaderSizeExceeded</span><span class="sxs-lookup"><span data-stu-id="53272-126">HeaderSizeExceeded</span></span> |<span data-ttu-id="53272-127">已經超過這個資料流的 hello 大小配額。</span><span class="sxs-lookup"><span data-stu-id="53272-127">hello size quota for this stream has been exceeded.</span></span> |
| <span data-ttu-id="53272-128">!TopicDescription.</span><span class="sxs-lookup"><span data-stu-id="53272-128">!TopicDescription.</span></span><br /><span data-ttu-id="53272-129">EnableFilteringMessagesBeforePublishing 和 SubscriptionDescription.</span><span class="sxs-lookup"><span data-stu-id="53272-129">EnableFilteringMessagesBeforePublishing and SubscriptionDescription.</span></span><br /><span data-ttu-id="53272-130">EnableDeadLetteringOnFilterEvaluationExceptions</span><span class="sxs-lookup"><span data-stu-id="53272-130">EnableDeadLetteringOnFilterEvaluationExceptions</span></span> |<span data-ttu-id="53272-131">exception.GetType().Name</span><span class="sxs-lookup"><span data-stu-id="53272-131">exception.GetType().Name</span></span> |<span data-ttu-id="53272-132">exception.Message</span><span class="sxs-lookup"><span data-stu-id="53272-132">exception.Message</span></span> |
| <span data-ttu-id="53272-133">EnableDeadLetteringOnMessageExpiration</span><span class="sxs-lookup"><span data-stu-id="53272-133">EnableDeadLetteringOnMessageExpiration</span></span> |<span data-ttu-id="53272-134">TTLExpiredException</span><span class="sxs-lookup"><span data-stu-id="53272-134">TTLExpiredException</span></span> |<span data-ttu-id="53272-135">hello 訊息過期，而且已無作用信件。</span><span class="sxs-lookup"><span data-stu-id="53272-135">hello message expired and was dead lettered.</span></span> |
| <span data-ttu-id="53272-136">SubscriptionDescription.RequiresSession</span><span class="sxs-lookup"><span data-stu-id="53272-136">SubscriptionDescription.RequiresSession</span></span> |<span data-ttu-id="53272-137">工作階段識別碼為 null。</span><span class="sxs-lookup"><span data-stu-id="53272-137">Session id is null.</span></span> |<span data-ttu-id="53272-138">啟用工作階段的實體不允許工作階段識別項為 null 的訊息。</span><span class="sxs-lookup"><span data-stu-id="53272-138">Session enabled entity doesn't allow a message whose session identifier is null.</span></span> |
| <span data-ttu-id="53272-139">！寄不出的信件佇列</span><span class="sxs-lookup"><span data-stu-id="53272-139">!dead letter queue</span></span> |<span data-ttu-id="53272-140">MaxTransferHopCountExceeded</span><span class="sxs-lookup"><span data-stu-id="53272-140">MaxTransferHopCountExceeded</span></span> |<span data-ttu-id="53272-141">Null</span><span class="sxs-lookup"><span data-stu-id="53272-141">Null</span></span> |
| <span data-ttu-id="53272-142">應用程式明確停止傳送</span><span class="sxs-lookup"><span data-stu-id="53272-142">Application explicit dead lettering</span></span> |<span data-ttu-id="53272-143">應用程式所指定</span><span class="sxs-lookup"><span data-stu-id="53272-143">Specified by application</span></span> |<span data-ttu-id="53272-144">應用程式所指定</span><span class="sxs-lookup"><span data-stu-id="53272-144">Specified by application</span></span> |

## <a name="exceeding-maxdeliverycount"></a><span data-ttu-id="53272-145">超過 MaxDeliveryCount</span><span class="sxs-lookup"><span data-stu-id="53272-145">Exceeding MaxDeliveryCount</span></span>
<span data-ttu-id="53272-146">佇列與訂用帳戶各有[QueueDescription.MaxDeliveryCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MaxDeliveryCount)和[SubscriptionDescription.MaxDeliveryCount](/dotnet/api/microsoft.servicebus.messaging.subscriptiondescription#Microsoft_ServiceBus_Messaging_SubscriptionDescription_MaxDeliveryCount)屬性分別; hello 預設值為 10。</span><span class="sxs-lookup"><span data-stu-id="53272-146">Queues and subscriptions each have a [QueueDescription.MaxDeliveryCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MaxDeliveryCount) and [SubscriptionDescription.MaxDeliveryCount](/dotnet/api/microsoft.servicebus.messaging.subscriptiondescription#Microsoft_ServiceBus_Messaging_SubscriptionDescription_MaxDeliveryCount) property respectively; hello default value is 10.</span></span> <span data-ttu-id="53272-147">每當在鎖定下傳遞的訊息 ([ReceiveMode.PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode))，但是已經是明確放棄或 hello 鎖定已過期，hello 訊息[BrokeredMessage.DeliveryCount](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_DeliveryCount)是遞增。</span><span class="sxs-lookup"><span data-stu-id="53272-147">Whenever a message has been delivered under a lock ([ReceiveMode.PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode)), but has been either explicitly abandoned or hello lock has expired, hello message's [BrokeredMessage.DeliveryCount](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_DeliveryCount) is incremented.</span></span> <span data-ttu-id="53272-148">當[DeliveryCount](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_DeliveryCount)超過[MaxDeliveryCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MaxDeliveryCount)，hello 訊息是移動的 toohello DLQ，指定 hello`MaxDeliveryCountExceeded`原因碼。</span><span class="sxs-lookup"><span data-stu-id="53272-148">When [DeliveryCount](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_DeliveryCount) exceeds [MaxDeliveryCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MaxDeliveryCount), hello message is moved toohello DLQ, specifying hello `MaxDeliveryCountExceeded` reason code.</span></span>

<span data-ttu-id="53272-149">無法停用此行為，但是您可以設定[MaxDeliveryCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MaxDeliveryCount) tooa 數量非常龐大。</span><span class="sxs-lookup"><span data-stu-id="53272-149">This behavior cannot be disabled, but you can set [MaxDeliveryCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MaxDeliveryCount) tooa very large number.</span></span>

## <a name="exceeding-timetolive"></a><span data-ttu-id="53272-150">超過 TimeToLive</span><span class="sxs-lookup"><span data-stu-id="53272-150">Exceeding TimeToLive</span></span>
<span data-ttu-id="53272-151">當 hello [QueueDescription.EnableDeadLetteringOnMessageExpiration](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_EnableDeadLetteringOnMessageExpiration)或[SubscriptionDescription.EnableDeadLetteringOnMessageExpiration](/dotnet/api/microsoft.servicebus.messaging.subscriptiondescription#Microsoft_ServiceBus_Messaging_SubscriptionDescription_EnableDeadLetteringOnMessageExpiration)屬性設定太**true**(hello 預設值是**false**)，所有的過期訊息會移動的 toohello DLQ，指定 hello`TTLExpiredException`原因碼。</span><span class="sxs-lookup"><span data-stu-id="53272-151">When hello [QueueDescription.EnableDeadLetteringOnMessageExpiration](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_EnableDeadLetteringOnMessageExpiration) or [SubscriptionDescription.EnableDeadLetteringOnMessageExpiration](/dotnet/api/microsoft.servicebus.messaging.subscriptiondescription#Microsoft_ServiceBus_Messaging_SubscriptionDescription_EnableDeadLetteringOnMessageExpiration) property is set too**true** (hello default is **false**), all expiring messages are moved toohello DLQ, specifying hello  `TTLExpiredException` reason code.</span></span>

<span data-ttu-id="53272-152">請注意，過期的訊息只會被清除，而且至少一個作用中的接收者 hello 主要佇列或訂閱; 提取時，因此移動 toohello DLQ該行為是預設行為。</span><span class="sxs-lookup"><span data-stu-id="53272-152">Note that expired messages are only purged and therefore moved toohello DLQ when there is at least one active receiver pulling on hello main queue or subscription; that behavior is by design.</span></span>

## <a name="errors-while-processing-subscription-rules"></a><span data-ttu-id="53272-153">在處理訂用帳戶規則時發生錯誤</span><span class="sxs-lookup"><span data-stu-id="53272-153">Errors while processing subscription rules</span></span>
<span data-ttu-id="53272-154">當 hello [SubscriptionDescription.EnableDeadLetteringOnFilterEvaluationExceptions](/dotnet/api/microsoft.servicebus.messaging.subscriptiondescription#Microsoft_ServiceBus_Messaging_SubscriptionDescription_EnableDeadLetteringOnFilterEvaluationExceptions)屬性已啟用訂用帳戶、 訂用帳戶的 SQL 篩選規則執行時所發生的任何錯誤所擷取的 hello DLQ以及 hello 違規的訊息。</span><span class="sxs-lookup"><span data-stu-id="53272-154">When hello [SubscriptionDescription.EnableDeadLetteringOnFilterEvaluationExceptions](/dotnet/api/microsoft.servicebus.messaging.subscriptiondescription#Microsoft_ServiceBus_Messaging_SubscriptionDescription_EnableDeadLetteringOnFilterEvaluationExceptions) property is enabled for a subscription, any errors that occur while a subscription's SQL filter rule executes are captured in hello DLQ along with hello offending message.</span></span>

## <a name="application-level-dead-lettering"></a><span data-ttu-id="53272-155">應用程式層級無效信件處理</span><span class="sxs-lookup"><span data-stu-id="53272-155">Application-level dead-lettering</span></span>
<span data-ttu-id="53272-156">在加法 toohello 系統提供信件功能，應用程式可以使用 hello DLQ tooexplicitly 拒絕無法接受訊息。</span><span class="sxs-lookup"><span data-stu-id="53272-156">In addition toohello system-provided dead-lettering features, applications can use hello DLQ tooexplicitly reject unacceptable messages.</span></span> <span data-ttu-id="53272-157">這可能包括無法正確處理系統問題、 保存格式不正確的裝載的訊息或訊息的驗證失敗時則會使用某些訊息層級安全性配置 tooany 排序到期的訊息。</span><span class="sxs-lookup"><span data-stu-id="53272-157">This may include messages that cannot be properly processed due tooany sort of system issue, messages that hold malformed payloads, or messages that fail authentication when some message-level security scheme is used.</span></span>

## <a name="dead-lettering-in-forwardto-or-sendvia-scenarios"></a><span data-ttu-id="53272-158">ForwardTo 或 SendVia 案例中寄不出的信件處理</span><span class="sxs-lookup"><span data-stu-id="53272-158">Dead-lettering in ForwardTo or SendVia scenarios</span></span>

<span data-ttu-id="53272-159">訊息會傳送的 toohello 傳送寄不出信件佇列 hello 下列條件下：</span><span class="sxs-lookup"><span data-stu-id="53272-159">Messages will be sent toohello transfer dead-letter queue under hello following conditions:</span></span>

- <span data-ttu-id="53272-160">訊息會通過 3 個以上[鏈結在一起](service-bus-auto-forwarding.md)的佇列或主題。</span><span class="sxs-lookup"><span data-stu-id="53272-160">A message passes through more than 3 queues or topics that are [chained together](service-bus-auto-forwarding.md).</span></span>
- <span data-ttu-id="53272-161">hello 目的地佇列或主題已停用或刪除。</span><span class="sxs-lookup"><span data-stu-id="53272-161">hello destination queue or topic is disabled or deleted.</span></span>
- <span data-ttu-id="53272-162">hello 目的地佇列或主題超過 hello 最大實體大小。</span><span class="sxs-lookup"><span data-stu-id="53272-162">hello destination queue or topic exceeds hello maximum entity size.</span></span>

<span data-ttu-id="53272-163">tooretrieve 這些信件訊息中，您可以建立使用 hello 接收者[FormatTransferDeadletterPath](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_FormatTransferDeadLetterPath_System_String_)公用程式方法。</span><span class="sxs-lookup"><span data-stu-id="53272-163">tooretrieve these dead-lettered messages, you can create a receiver using hello [FormatTransferDeadletterPath](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_FormatTransferDeadLetterPath_System_String_) utility method.</span></span>

## <a name="example"></a><span data-ttu-id="53272-164">範例</span><span class="sxs-lookup"><span data-stu-id="53272-164">Example</span></span>
<span data-ttu-id="53272-165">下列程式碼片段的 hello 建立訊息接收者。</span><span class="sxs-lookup"><span data-stu-id="53272-165">hello following code snippet creates a message receiver.</span></span> <span data-ttu-id="53272-166">在 hello 收到 hello 主要佇列的迴圈、 hello 程式碼會擷取與 hello 訊息[Receive(TimeSpan.Zero)](/dotnet/api/microsoft.servicebus.messaging.messagereceiver#Microsoft_ServiceBus_Messaging_MessageReceiver_Receive_System_TimeSpan_)，詢問 hello broker tooinstantly 傳回任何訊息取用，或沒有結果 tooreturn。</span><span class="sxs-lookup"><span data-stu-id="53272-166">In hello receive loop for hello main queue, hello code retrieves hello message with [Receive(TimeSpan.Zero)](/dotnet/api/microsoft.servicebus.messaging.messagereceiver#Microsoft_ServiceBus_Messaging_MessageReceiver_Receive_System_TimeSpan_), which asks hello broker tooinstantly return any message readily available, or tooreturn with no result.</span></span> <span data-ttu-id="53272-167">如果 hello 程式碼會收到訊息時，它立即放棄，即可遞增 hello `DeliveryCount`。</span><span class="sxs-lookup"><span data-stu-id="53272-167">If hello code receives a message, it immediately abandons it, which increments hello  `DeliveryCount`.</span></span> <span data-ttu-id="53272-168">一旦 hello 系統移 hello 訊息 toohello DLQ，hello 主要佇列是空的做為 hello 迴圈結束[ReceiveAsync](/dotnet/api/microsoft.servicebus.messaging.messagereceiver#Microsoft_ServiceBus_Messaging_MessageReceiver_ReceiveAsync_System_TimeSpan_)傳回**null**。</span><span class="sxs-lookup"><span data-stu-id="53272-168">Once hello system moves hello message toohello DLQ, hello main queue is empty and hello loop exits, as [ReceiveAsync](/dotnet/api/microsoft.servicebus.messaging.messagereceiver#Microsoft_ServiceBus_Messaging_MessageReceiver_ReceiveAsync_System_TimeSpan_) returns **null**.</span></span>

```csharp
var receiver = await receiverFactory.CreateMessageReceiverAsync(queueName, ReceiveMode.PeekLock);
while(true)
{
    var msg = await receiver.ReceiveAsync(TimeSpan.Zero);
    if (msg != null)
    {
        Console.WriteLine("Picked up message; DeliveryCount {0}", msg.DeliveryCount);
        await msg.AbandonAsync();
    }
    else
    {
        break;
    }
}
```

## <a name="next-steps"></a><span data-ttu-id="53272-169">後續步驟</span><span class="sxs-lookup"><span data-stu-id="53272-169">Next steps</span></span>
<span data-ttu-id="53272-170">請參閱下列文章中的服務匯流排佇列的詳細資訊的 hello:</span><span class="sxs-lookup"><span data-stu-id="53272-170">See hello following articles for more information about Service Bus queues:</span></span>

* [<span data-ttu-id="53272-171">開始使用服務匯流排佇列</span><span class="sxs-lookup"><span data-stu-id="53272-171">Get started with Service Bus queues</span></span>](service-bus-dotnet-get-started-with-queues.md)
* [<span data-ttu-id="53272-172">比較 Azure 佇列和服務匯流排佇列</span><span class="sxs-lookup"><span data-stu-id="53272-172">Azure Queues and Service Bus queues compared</span></span>](service-bus-azure-and-service-bus-queues-compared-contrasted.md)

