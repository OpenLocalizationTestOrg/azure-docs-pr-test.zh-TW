---
title: "Azure 服務匯流排的基本概念的 aaaOverview |Microsoft 文件"
description: "簡介 toousing Service Bus tooconnect Azure 應用程式 tooother 軟體。"
services: service-bus-messaging
documentationcenter: .net
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 12654cdd-82ab-4b95-b56f-08a5a8bbc6f9
ms.service: service-bus-messaging
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: get-started-article
ms.date: 06/15/2017
ms.author: sethm
ms.openlocfilehash: 1abd5cf310ef06ba35e1e2489a7c0a07e1797736
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="azure-service-bus"></a><span data-ttu-id="19c8c-103">Azure 服務匯流排</span><span class="sxs-lookup"><span data-stu-id="19c8c-103">Azure Service Bus</span></span>

<span data-ttu-id="19c8c-104">是否要應用程式或服務執行 hello 雲端或內部部署上，它通常需要 toointeract 與其他應用程式或服務。</span><span class="sxs-lookup"><span data-stu-id="19c8c-104">Whether an application or service runs in hello cloud or on premises, it often needs toointeract with other applications or services.</span></span> <span data-ttu-id="19c8c-105">tooprovide 廣泛實用的方式 toodo 此，Microsoft Azure 提供服務匯流排。</span><span class="sxs-lookup"><span data-stu-id="19c8c-105">tooprovide a broadly useful way toodo this, Microsoft Azure offers Service Bus.</span></span> <span data-ttu-id="19c8c-106">這篇文章探討這項技術，而且您可能會想 toouse 的原因描述它。</span><span class="sxs-lookup"><span data-stu-id="19c8c-106">This article looks at this technology, describing what it is and why you might want toouse it.</span></span>

## <a name="service-bus-fundamentals"></a><span data-ttu-id="19c8c-107">服務匯流排基本概念</span><span class="sxs-lookup"><span data-stu-id="19c8c-107">Service Bus fundamentals</span></span>

<span data-ttu-id="19c8c-108">不同的情況需要不同的通訊方式。</span><span class="sxs-lookup"><span data-stu-id="19c8c-108">Different situations call for different styles of communication.</span></span> <span data-ttu-id="19c8c-109">某些情況下，讓應用程式傳送和接收訊息，透過簡單的佇列是 hello 最佳解決方案。</span><span class="sxs-lookup"><span data-stu-id="19c8c-109">Sometimes, letting applications send and receive messages through a simple queue is hello best solution.</span></span> <span data-ttu-id="19c8c-110">在其他情況下，普通的佇列仍嫌不足，具有發佈與訂閱機制的佇列會更好。</span><span class="sxs-lookup"><span data-stu-id="19c8c-110">In other situations, an ordinary queue isn't enough; a queue with a publish-and-subscribe mechanism is better.</span></span> <span data-ttu-id="19c8c-111">在某些情況下，就只需要應用程式之間的連線，而不需要佇列。</span><span class="sxs-lookup"><span data-stu-id="19c8c-111">In some cases, all that's needed is a connection between applications, and queues are not required.</span></span> <span data-ttu-id="19c8c-112">服務匯流排提供這三個選項，啟用您的應用程式 toointeract 數種不同方式。</span><span class="sxs-lookup"><span data-stu-id="19c8c-112">Service Bus provides all three options, enabling your applications toointeract in several different ways.</span></span>

<span data-ttu-id="19c8c-113">Service Bus 是多租用戶雲端服務，這表示 hello 服務由多位使用者共用。</span><span class="sxs-lookup"><span data-stu-id="19c8c-113">Service Bus is a multi-tenant cloud service, which means that hello service is shared by multiple users.</span></span> <span data-ttu-id="19c8c-114">每個使用者，例如應用程式開發人員建立*命名空間*，然後定義需要該命名空間中的 hello 通訊機制。</span><span class="sxs-lookup"><span data-stu-id="19c8c-114">Each user, such as an application developer, creates a *namespace*, then defines hello communication mechanisms needed within that namespace.</span></span> <span data-ttu-id="19c8c-115">圖 1 顯示此架構的外觀。</span><span class="sxs-lookup"><span data-stu-id="19c8c-115">Figure 1 shows how this architecture looks.</span></span>

![][1]

<span data-ttu-id="19c8c-116">**圖 1： 服務匯流排提供連接透過 hello 雲端應用程式的多租用戶服務。**</span><span class="sxs-lookup"><span data-stu-id="19c8c-116">**Figure 1: Service Bus provides a multi-tenant service for connecting applications through hello cloud.**</span></span>

<span data-ttu-id="19c8c-117">在一個命名空間內，您可以使用三種不同通訊機制的一或多個執行個體，這些機制各以不同的方式連接應用程式。</span><span class="sxs-lookup"><span data-stu-id="19c8c-117">Within a namespace, you can use one or more instances of three different communication mechanisms, each of which connects applications in a different way.</span></span> <span data-ttu-id="19c8c-118">hello 選項有：</span><span class="sxs-lookup"><span data-stu-id="19c8c-118">hello choices are:</span></span>

* <span data-ttu-id="19c8c-119">佇列，允許單向通訊。</span><span class="sxs-lookup"><span data-stu-id="19c8c-119">*Queues*, which allow one-directional communication.</span></span> <span data-ttu-id="19c8c-120">每個佇列扮演中繼角色 (有時稱為代理人 )，儲存已傳送但尚未接收的訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-120">Each queue acts as an intermediary (sometimes called a *broker*) that stores sent messages until they are received.</span></span> <span data-ttu-id="19c8c-121">每個訊息會由單一收件者接收。</span><span class="sxs-lookup"><span data-stu-id="19c8c-121">Each message is received by a single recipient.</span></span>
* <span data-ttu-id="19c8c-122">「主題」提供使用「訂用帳戶」的單向通訊，而單一主題可以有多個訂用帳戶。</span><span class="sxs-lookup"><span data-stu-id="19c8c-122">*Topics*, which provide one-directional communication using *subscriptions*-a single topic can have multiple subscriptions.</span></span> <span data-ttu-id="19c8c-123">類似佇列，主題會做為 broker，但每個訂用帳戶可以選擇性地使用篩選 tooreceive 唯一訊息符合特定準則。</span><span class="sxs-lookup"><span data-stu-id="19c8c-123">Like a queue, a topic acts as a broker, but each subscription can optionally use a filter tooreceive only messages that match specific criteria.</span></span>
* <span data-ttu-id="19c8c-124">轉送，提供雙向通訊。</span><span class="sxs-lookup"><span data-stu-id="19c8c-124">*Relays*, which provide bi-directional communication.</span></span> <span data-ttu-id="19c8c-125">與佇列和主題不同，轉送不是訊息代理程式，不會儲存途中訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-125">Unlike queues and topics, a relay doesn't store in-flight messages; it's not a broker.</span></span> <span data-ttu-id="19c8c-126">相反地，它只傳送它們的 toohello 目的端應用程式。</span><span class="sxs-lookup"><span data-stu-id="19c8c-126">Instead, it just passes them on toohello destination application.</span></span>

<span data-ttu-id="19c8c-127">您在建立佇列、主題或轉送時會提供名稱。</span><span class="sxs-lookup"><span data-stu-id="19c8c-127">When you create a queue, topic, or relay, you give it a name.</span></span> <span data-ttu-id="19c8c-128">這個名稱與任何您呼叫您的命名空間結合，建立 hello 物件的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="19c8c-128">Combined with whatever you called your namespace, this name creates a unique identifier for hello object.</span></span> <span data-ttu-id="19c8c-129">應用程式可以提供此名稱 tooService 匯流排，然後使用該佇列、 主題或轉送 toocommunicate 彼此。</span><span class="sxs-lookup"><span data-stu-id="19c8c-129">Applications can provide this name tooService Bus, then use that queue, topic, or relay toocommunicate with one another.</span></span> 

<span data-ttu-id="19c8c-130">toouse 其中任何物件在 hello 轉送案例中，Windows 應用程式可以使用 Windows Communication Foundation (WCF)。</span><span class="sxs-lookup"><span data-stu-id="19c8c-130">toouse any of these objects in hello relay scenario, Windows applications can use Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="19c8c-131">此服務也稱為 [WCF 轉送](../service-bus-relay/relay-what-is-it.md)。</span><span class="sxs-lookup"><span data-stu-id="19c8c-131">This service is known as [WCF Relay](../service-bus-relay/relay-what-is-it.md).</span></span> <span data-ttu-id="19c8c-132">對於佇列和主題，Windows 應用程式可以使用服務匯流排定義的訊息 API。</span><span class="sxs-lookup"><span data-stu-id="19c8c-132">For queues and topics, Windows applications can use Service Bus-defined messaging APIs.</span></span> <span data-ttu-id="19c8c-133">toomake 這些物件更容易 toouse 從非 Windows 應用程式，Microsoft 提供 Java、 Node.js 和其他語言的 Sdk。</span><span class="sxs-lookup"><span data-stu-id="19c8c-133">toomake these objects easier toouse from non-Windows applications, Microsoft provides SDKs for Java, Node.js, and other languages.</span></span> <span data-ttu-id="19c8c-134">您也可以透過 HTTP 使用 [REST API](/rest/api/servicebus/)，存取佇列和主題。</span><span class="sxs-lookup"><span data-stu-id="19c8c-134">You can also access queues and topics using [REST APIs](/rest/api/servicebus/) over HTTP(s).</span></span> 

<span data-ttu-id="19c8c-135">請務必在 hello 雲端中執行，即使服務匯流排本身 toounderstand (也就是在 Microsoft Azure 資料中心)，使用它的應用程式可以執行任何位置。</span><span class="sxs-lookup"><span data-stu-id="19c8c-135">It's important toounderstand that even though Service Bus itself runs in hello cloud (that is, in Microsoft's Azure datacenters), applications that use it can run anywhere.</span></span> <span data-ttu-id="19c8c-136">您可以使用 Azure，比方說或您自己的資料中心內執行的應用程式上執行的服務匯流排 tooconnect 應用程式。</span><span class="sxs-lookup"><span data-stu-id="19c8c-136">You can use Service Bus tooconnect applications running on Azure, for example, or applications running inside your own datacenter.</span></span> <span data-ttu-id="19c8c-137">您也可以使用它 tooconnect 在 Azure 或另一個執行的應用程式與內部部署應用程式或平板電腦和電話的雲端平台。</span><span class="sxs-lookup"><span data-stu-id="19c8c-137">You can also use it tooconnect an application running on Azure or another cloud platform with an on-premises application or with tablets and phones.</span></span> <span data-ttu-id="19c8c-138">它是甚至可能 tooconnect 家庭應用裝置、 感應器和其他裝置 tooa 管理中心應用程式或其他 tooone。</span><span class="sxs-lookup"><span data-stu-id="19c8c-138">It's even possible tooconnect household appliances, sensors, and other devices tooa central application or tooone other.</span></span> <span data-ttu-id="19c8c-139">Service Bus 是通訊機制，可從幾乎任何地方存取 hello 雲端中。</span><span class="sxs-lookup"><span data-stu-id="19c8c-139">Service Bus is a communication mechanism in hello cloud that's accessible from pretty much anywhere.</span></span> <span data-ttu-id="19c8c-140">如何使用它相依於您應用程式需要 toodo。</span><span class="sxs-lookup"><span data-stu-id="19c8c-140">How you use it depends on what your applications need toodo.</span></span>

## <a name="queues"></a><span data-ttu-id="19c8c-141">佇列</span><span class="sxs-lookup"><span data-stu-id="19c8c-141">Queues</span></span>

<span data-ttu-id="19c8c-142">假設您決定使用服務匯流排佇列 tooconnect 兩個應用程式。</span><span class="sxs-lookup"><span data-stu-id="19c8c-142">Suppose you decide tooconnect two applications using a Service Bus queue.</span></span> <span data-ttu-id="19c8c-143">圖 2 顯示此情形。</span><span class="sxs-lookup"><span data-stu-id="19c8c-143">Figure 2 illustrates this situation.</span></span>

![][2]

<span data-ttu-id="19c8c-144">**圖 2：服務匯流排佇列提供單向非同步的佇列作業。**</span><span class="sxs-lookup"><span data-stu-id="19c8c-144">**Figure 2: Service Bus queues provide one-way asynchronous queuing.**</span></span>

<span data-ttu-id="19c8c-145">hello 程序很簡單： 寄件者傳送訊息 tooa Service Bus 佇列，以及接收者在稍後收取該訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-145">hello process is simple: A sender sends a message tooa Service Bus queue, and a receiver picks up that message at some later time.</span></span> <span data-ttu-id="19c8c-146">一個佇列只可以有一個接收者 (如圖 2 所示)。</span><span class="sxs-lookup"><span data-stu-id="19c8c-146">A queue can have just a single receiver, as Figure 2 shows.</span></span> <span data-ttu-id="19c8c-147">或多個應用程式可以從 hello 讀取相同的佇列。</span><span class="sxs-lookup"><span data-stu-id="19c8c-147">Or, multiple applications can read from hello same queue.</span></span> <span data-ttu-id="19c8c-148">在 hello 後者的情況下，只有一個收件者讀取每個訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-148">In hello latter situation, each message is read by just one receiver.</span></span> <span data-ttu-id="19c8c-149">對於多點傳送服務，您應改用主題。</span><span class="sxs-lookup"><span data-stu-id="19c8c-149">For a multi-cast service, you should use a topic instead.</span></span>

<span data-ttu-id="19c8c-150">每一個訊息分成兩個部分：一組屬性 (各為機碼/值組) 和訊息承載。</span><span class="sxs-lookup"><span data-stu-id="19c8c-150">Each message has two parts: a set of properties, each a key/value pair, and a message payload.</span></span> <span data-ttu-id="19c8c-151">hello 裝載可以是二進位、 文字或甚至是 XML。</span><span class="sxs-lookup"><span data-stu-id="19c8c-151">hello payload can be binary, text, or even XML.</span></span> <span data-ttu-id="19c8c-152">使用方式，取決於哪些應用程式正在 toodo。</span><span class="sxs-lookup"><span data-stu-id="19c8c-152">How they're used depends on what an application is trying toodo.</span></span> <span data-ttu-id="19c8c-153">例如，應用程式傳送新的銷售資料的相關訊息可能會包含 hello 屬性**賣方 ="Ava"**和**量 = 10000**。</span><span class="sxs-lookup"><span data-stu-id="19c8c-153">For example, an application sending a message about a recent sale might include hello properties **Seller="Ava"** and **Amount=10000**.</span></span> <span data-ttu-id="19c8c-154">hello 訊息本文可能包含 hello 銷售帶正負號合約掃描的影像或者，如果沒有，保持空白。</span><span class="sxs-lookup"><span data-stu-id="19c8c-154">hello message body might contain a scanned image of hello sale's signed contract or, if there isn't one, remain empty.</span></span>

<span data-ttu-id="19c8c-155">接收者以兩種不同的方法從服務匯流排佇列讀取訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-155">A receiver can read a message from a Service Bus queue in two different ways.</span></span> <span data-ttu-id="19c8c-156">hello 第一個選項，稱為 *[ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode)*、 從 hello 佇列移除訊息和立即將它刪除。</span><span class="sxs-lookup"><span data-stu-id="19c8c-156">hello first option, called *[ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode)*, removes a message from hello queue and immediately deletes it.</span></span> <span data-ttu-id="19c8c-157">這個選項很簡單，但是如果 hello 接收者損毀它完成處理 hello 訊息之前，hello 訊息就會遺失。</span><span class="sxs-lookup"><span data-stu-id="19c8c-157">This option is simple, but if hello receiver crashes before it finishes processing hello message, hello message is lost.</span></span> <span data-ttu-id="19c8c-158">它從 hello 佇列中已移除，因為沒有其他收件者可以存取它。</span><span class="sxs-lookup"><span data-stu-id="19c8c-158">Because it's been removed from hello queue, no other receiver can access it.</span></span> 

<span data-ttu-id="19c8c-159">hello 第二個選項，  *[PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode)*，目的在於 toohelp 與此問題。</span><span class="sxs-lookup"><span data-stu-id="19c8c-159">hello second option, *[PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode)*, is meant toohelp with this problem.</span></span> <span data-ttu-id="19c8c-160">像**ReceiveAndDelete**、 **PeekLock**讀取從 hello 佇列移除訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-160">Like **ReceiveAndDelete**, a **PeekLock** read removes a message from hello queue.</span></span> <span data-ttu-id="19c8c-161">不過它不會刪除 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-161">It doesn't delete hello message, however.</span></span> <span data-ttu-id="19c8c-162">相反地，它會鎖定 hello 訊息，因此看不見 tooother 接收者，然後等待三個事件的其中一個：</span><span class="sxs-lookup"><span data-stu-id="19c8c-162">Instead, it locks hello message, making it invisible tooother receivers, then waits for one of three events:</span></span>

* <span data-ttu-id="19c8c-163">如果 hello 接收者處理程序成功 hello 訊息，則會呼叫[complete （)](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)，並 hello 佇列刪除 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-163">If hello receiver processes hello message successfully, it calls [Complete()](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), and hello queue deletes hello message.</span></span> 
* <span data-ttu-id="19c8c-164">如果 hello 接收者決定時，無法成功處理 hello 訊息，則會呼叫[Abandon()](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon)。</span><span class="sxs-lookup"><span data-stu-id="19c8c-164">If hello receiver decides that it can't process hello message successfully, it calls [Abandon()](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon).</span></span> <span data-ttu-id="19c8c-165">hello 佇列然後 hello 鎖定移除 hello 訊息，並讓您可以使用 tooother 接收者。</span><span class="sxs-lookup"><span data-stu-id="19c8c-165">hello queue then removes hello lock from hello message and makes it available tooother receivers.</span></span>
* <span data-ttu-id="19c8c-166">如果 hello 接收者 （依預設為 60 秒） 呼叫這些方法都可設定的一段時間內，hello 佇列會假設失敗 hello 收件者。</span><span class="sxs-lookup"><span data-stu-id="19c8c-166">If hello receiver calls neither of these methods within a configurable period of time (by default, 60 seconds), hello queue assumes hello receiver has failed.</span></span> <span data-ttu-id="19c8c-167">在此情況下，其行為就如同已經呼叫 hello 接收者**放棄**，進行 hello 訊息可用 tooother 接收者。</span><span class="sxs-lookup"><span data-stu-id="19c8c-167">In this case, it behaves as if hello receiver had called **Abandon**, making hello message available tooother receivers.</span></span>

<span data-ttu-id="19c8c-168">請注意，這裡會發生什麼情況： hello 相同訊息可能會傳送兩次，可能是 tootwo 不同的接收者。</span><span class="sxs-lookup"><span data-stu-id="19c8c-168">Notice what can happen here: hello same message might be delivered twice, perhaps tootwo different receivers.</span></span> <span data-ttu-id="19c8c-169">使用服務匯流排佇列的應用程式對此事件必須有因應之道。</span><span class="sxs-lookup"><span data-stu-id="19c8c-169">Applications using Service Bus queues must be prepared for this event.</span></span> <span data-ttu-id="19c8c-170">toomake 重複偵測更容易，每個訊息都有唯一[MessageID](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId)屬性，預設會保持 hello 相同無論多少次 hello 訊息從佇列讀取。</span><span class="sxs-lookup"><span data-stu-id="19c8c-170">toomake duplicate detection easier, each message has a unique [MessageID](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property that by default stays hello same no matter how many times hello message is read from a queue.</span></span> 

<span data-ttu-id="19c8c-171">佇列在許多情況下都很有用。</span><span class="sxs-lookup"><span data-stu-id="19c8c-171">Queues are useful in quite a few situations.</span></span> <span data-ttu-id="19c8c-172">它們可讓應用程式 toocommunicate 即使兩者都不在 hello 執行相同的時間，項目與批次和行動應用程式特別有用。</span><span class="sxs-lookup"><span data-stu-id="19c8c-172">They enable applications toocommunicate even when both aren't running at hello same time, something that's especially handy with batch and mobile applications.</span></span> <span data-ttu-id="19c8c-173">如果佇列有多個接收者，由於傳送的訊息會襲捲這些接收者，此佇列也提供自動的負載平衡。</span><span class="sxs-lookup"><span data-stu-id="19c8c-173">A queue with multiple receivers also provides automatic load balancing, since sent messages are spread across these receivers.</span></span>

## <a name="topics"></a><span data-ttu-id="19c8c-174">主題</span><span class="sxs-lookup"><span data-stu-id="19c8c-174">Topics</span></span>

<span data-ttu-id="19c8c-175">因為它們是很有用，佇列不一定 hello 絕佳的解決方案。</span><span class="sxs-lookup"><span data-stu-id="19c8c-175">Useful as they are, queues aren't always hello right solution.</span></span> <span data-ttu-id="19c8c-176">有時，服務匯流排主題更適合。</span><span class="sxs-lookup"><span data-stu-id="19c8c-176">Sometimes, Service Bus topics are better.</span></span> <span data-ttu-id="19c8c-177">圖 3 闡明此概念。</span><span class="sxs-lookup"><span data-stu-id="19c8c-177">Figure 3 illustrates this idea.</span></span>

![][3]

<span data-ttu-id="19c8c-178">**圖 3： 根據 hello 訂閱應用程式指定的篩選器，它可以接收部分或所有的 hello 訊息傳送 tooa Service Bus 主題。**</span><span class="sxs-lookup"><span data-stu-id="19c8c-178">**Figure 3: Based on hello filter a subscribing application specifies, it can receive some or all hello messages sent tooa Service Bus topic.**</span></span>

<span data-ttu-id="19c8c-179">A*主題*類似許多方式 tooa 佇列中。</span><span class="sxs-lookup"><span data-stu-id="19c8c-179">A *topic* is similar in many ways tooa queue.</span></span> <span data-ttu-id="19c8c-180">寄件者送出 hello 訊息 tooa 主題，送出的郵件 tooa 佇列，而且這些訊息的外觀 hello 與佇列相同的方式。</span><span class="sxs-lookup"><span data-stu-id="19c8c-180">Senders submit messages tooa topic in hello same way that they submit messages tooa queue, and those messages look hello same as with queues.</span></span> <span data-ttu-id="19c8c-181">hello 差異是，各個主題可讓每個接收應用程式 toocreate 自己*訂用帳戶*藉由定義*篩選*。</span><span class="sxs-lookup"><span data-stu-id="19c8c-181">hello difference is that topics enable each receiving application toocreate its own *subscription* by defining a *filter*.</span></span> <span data-ttu-id="19c8c-182">訂閱者接著會看到符合該篩選條件 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-182">A subscriber then sees only hello messages that match that filter.</span></span> <span data-ttu-id="19c8c-183">例如，圖 3 顯示一個傳送者、一個主題及三個訂閱者，而訂閱者各有其本身的篩選：</span><span class="sxs-lookup"><span data-stu-id="19c8c-183">For example, Figure 3 shows a sender and a topic with three subscribers, each with its own filter:</span></span>

* <span data-ttu-id="19c8c-184">訂閱者 」 1 收到包含 hello 屬性的訊息*賣方 ="Ava"*。</span><span class="sxs-lookup"><span data-stu-id="19c8c-184">Subscriber 1 receives only messages that contain hello property *Seller="Ava"*.</span></span>
* <span data-ttu-id="19c8c-185">訂閱者 2 收到的訊息包含 hello 屬性*賣方 ="Ruby"*和 （或) 包含*量*其值大於 100000 的屬性。</span><span class="sxs-lookup"><span data-stu-id="19c8c-185">Subscriber 2 receives messages that contain hello property *Seller="Ruby"* and/or contain an *Amount* property whose value is greater than 100,000.</span></span> <span data-ttu-id="19c8c-186">可能是 Ruby 是 hello 銷售經理，因此她想 toosee 她自己的銷售和所有大型的銷售，無論誰可讓它們。</span><span class="sxs-lookup"><span data-stu-id="19c8c-186">Perhaps Ruby is hello sales manager, so she wants toosee both her own sales and all large sales regardless of who makes them.</span></span>
* <span data-ttu-id="19c8c-187">訂閱者 3 已經過設定其篩選器*True*，這表示它會接收所有訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-187">Subscriber 3 has set its filter too*True*, which means that it receives all messages.</span></span> <span data-ttu-id="19c8c-188">例如，此應用程式可能會負責維護稽核記錄，因此需要 toosee 所有 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-188">For example, this application might be responsible for maintaining an audit trail and therefore it needs toosee all hello messages.</span></span>

<span data-ttu-id="19c8c-189">訂閱者 tooa 主題可與佇列讀取訊息使用[ReceiveAndDelete 或 PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode)。</span><span class="sxs-lookup"><span data-stu-id="19c8c-189">As with queues, subscribers tooa topic can read messages using either [ReceiveAndDelete or PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode).</span></span> <span data-ttu-id="19c8c-190">不同於佇列，不過，單一訊息傳送 tooa 主題可以接收多個訂用帳戶。</span><span class="sxs-lookup"><span data-stu-id="19c8c-190">Unlike queues, however, a single message sent tooa topic can be received by multiple subscriptions.</span></span> <span data-ttu-id="19c8c-191">這個方法時，通常稱為*發佈和訂閱*(或*pub/sub*)，是很有用，每當有多個應用程式有興趣 hello 相同的訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-191">This approach, commonly called *publish and subscribe* (or *pub/sub*), is useful whenever multiple applications are interested in hello same messages.</span></span> <span data-ttu-id="19c8c-192">藉由定義 hello 右篩選，每個訂閱者可以點選入只需要 toosee hello 訊息資料流 hello 部分。</span><span class="sxs-lookup"><span data-stu-id="19c8c-192">By defining hello right filter, each subscriber can tap into just hello part of hello message stream that it needs toosee.</span></span>

## <a name="relays"></a><span data-ttu-id="19c8c-193">轉送</span><span class="sxs-lookup"><span data-stu-id="19c8c-193">Relays</span></span>

<span data-ttu-id="19c8c-194">佇列和主題都是透過訊息代理程式來提供單向非同步通訊。</span><span class="sxs-lookup"><span data-stu-id="19c8c-194">Both queues and topics provide one-way asynchronous communication through a broker.</span></span> <span data-ttu-id="19c8c-195">流量只往一個方向流動，傳送者和接收者之間並未直接連接。</span><span class="sxs-lookup"><span data-stu-id="19c8c-195">Traffic flows in just one direction, and there's no direct connection between senders and receivers.</span></span> <span data-ttu-id="19c8c-196">但如果不想要這種連線又該如何？</span><span class="sxs-lookup"><span data-stu-id="19c8c-196">But what if you don't want this connection?</span></span> <span data-ttu-id="19c8c-197">假設您的應用程式需要 tooboth 傳送和接收訊息，或可能是您想要它們之間的直接連結，也不需要 broker toostore 訊息。</span><span class="sxs-lookup"><span data-stu-id="19c8c-197">Suppose your applications need tooboth send and receive messages, or perhaps you want a direct link between them and you don't need a broker toostore messages.</span></span> <span data-ttu-id="19c8c-198">這類 tooaddress 情況下，服務匯流排提供*轉送*，如圖 4 所示。</span><span class="sxs-lookup"><span data-stu-id="19c8c-198">tooaddress scenarios such as this, Service Bus provides *relays*, as Figure 4 shows.</span></span>

![][4]

<span data-ttu-id="19c8c-199">**圖 4：服務匯流排轉送在應用程式之間提供同步、雙向的通訊。**</span><span class="sxs-lookup"><span data-stu-id="19c8c-199">**Figure 4: Service Bus relay provides synchronous, two-way communication between applications.**</span></span>

<span data-ttu-id="19c8c-200">hello 有關轉送的問題 tooask 如下： 為何要使用它？</span><span class="sxs-lookup"><span data-stu-id="19c8c-200">hello obvious question tooask about relays is this: why would I use one?</span></span> <span data-ttu-id="19c8c-201">即使我不需要的佇列，為什麼會讓通訊透過雲端服務而不只是直接互動的應用程式嗎？hello 回應是指直接可以比您想像更困難。</span><span class="sxs-lookup"><span data-stu-id="19c8c-201">Even if I don't need queues, why make applications communicate via a cloud service rather than just interact directly? hello answer is that talking directly can be harder than you might think.</span></span>

<span data-ttu-id="19c8c-202">假設您想 tooconnect 兩個內部部署應用程式，同時公司的資料中心內執行。</span><span class="sxs-lookup"><span data-stu-id="19c8c-202">Suppose you want tooconnect two on-premises applications, both running inside corporate datacenters.</span></span> <span data-ttu-id="19c8c-203">每個應用程式都位於防火牆後面，且每個資料中心可能使用網路位址轉譯 (NAT)。</span><span class="sxs-lookup"><span data-stu-id="19c8c-203">Each of these applications sits behind a firewall, and each datacenter probably uses network address translation (NAT).</span></span> <span data-ttu-id="19c8c-204">hello 防火牆會封鎖所有但少數的連接埠和 NAT 上的內送資料表示 hello 電腦執行每個應用程式沒有您可以直接從外部 hello 資料中心達到的固定的 IP 位址。</span><span class="sxs-lookup"><span data-stu-id="19c8c-204">hello firewall blocks incoming data on all but a few ports, and NAT implies that hello machine each application is running on doesn't have a fixed IP address that you can reach directly from outside hello datacenter.</span></span> <span data-ttu-id="19c8c-205">而不需一些額外的協助，這些應用程式透過連接 hello 公用網際網路是有問題。</span><span class="sxs-lookup"><span data-stu-id="19c8c-205">Without some extra help, connecting these applications over hello public internet is problematic.</span></span>

<span data-ttu-id="19c8c-206">服務匯流排轉送有所幫助。</span><span class="sxs-lookup"><span data-stu-id="19c8c-206">A Service Bus relay can help.</span></span> <span data-ttu-id="19c8c-207">toocommunicate 雙向透過轉送，每個應用程式建立與服務匯流排的輸出 TCP 連線，則會保持開啟。</span><span class="sxs-lookup"><span data-stu-id="19c8c-207">toocommunicate bi-directionally through a relay, each application establishes an outbound TCP connection with Service Bus, then keeps it open.</span></span> <span data-ttu-id="19c8c-208">Hello 兩個應用程式之間的所有通訊都都透過這些連接。</span><span class="sxs-lookup"><span data-stu-id="19c8c-208">All communication between hello two applications travels over these connections.</span></span> <span data-ttu-id="19c8c-209">因為每個連線已建立從內部 hello datacenter hello 防火牆允許連入流量 tooeach 應用程式而不需要開啟新的連接埠。</span><span class="sxs-lookup"><span data-stu-id="19c8c-209">Because each connection was established from inside hello datacenter, hello firewall allows incoming traffic tooeach application without opening new ports.</span></span> <span data-ttu-id="19c8c-210">這個方法也會取得 hello NAT 問題，因為每個應用程式在整個 hello 通訊 hello 雲端存有一致的端點。</span><span class="sxs-lookup"><span data-stu-id="19c8c-210">This approach also gets around hello NAT problem, because each application has a consistent endpoint in hello cloud throughout hello communication.</span></span> <span data-ttu-id="19c8c-211">藉由交換 hello 轉送的資料，hello 應用程式可以避免 hello 問題會否則讓通訊更加困難。</span><span class="sxs-lookup"><span data-stu-id="19c8c-211">By exchanging data through hello relay, hello applications can avoid hello problems that would otherwise make communication difficult.</span></span> 

<span data-ttu-id="19c8c-212">toouse 服務匯流排轉送，應用程式依賴 hello Windows Communication Foundation (WCF)。</span><span class="sxs-lookup"><span data-stu-id="19c8c-212">toouse Service Bus relays, applications rely on hello Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="19c8c-213">服務匯流排提供，可讓您可以直接透過轉送的 Windows 應用程式 toointeract WCF 繫結。</span><span class="sxs-lookup"><span data-stu-id="19c8c-213">Service Bus provides WCF bindings that make it straightforward for Windows applications toointeract via relays.</span></span> <span data-ttu-id="19c8c-214">已使用 WCF 應用程式通常可以指定其中一個繫結，然後溝通 tooeach 其他透過轉送。</span><span class="sxs-lookup"><span data-stu-id="19c8c-214">Applications that already use WCF can typically specify one of these bindings, then talk tooeach other through a relay.</span></span> <span data-ttu-id="19c8c-215">然而，與佇列和主題不同，雖然可能從非 Windows 應用程式中使用轉送，但需要投入一些程式設計工作。沒有標準的程式庫可用。</span><span class="sxs-lookup"><span data-stu-id="19c8c-215">Unlike queues and topics, however, using relays from non-Windows applications, while possible, requires some programming effort; no standard libraries are provided.</span></span>

<span data-ttu-id="19c8c-216">與佇列和主題不同，應用程式不會明確建立轉送。</span><span class="sxs-lookup"><span data-stu-id="19c8c-216">Unlike queues and topics, applications don't explicitly create relays.</span></span> <span data-ttu-id="19c8c-217">相反地，希望 tooreceive 訊息應用程式會建立 TCP 連線的服務匯流排，轉送時自動建立。</span><span class="sxs-lookup"><span data-stu-id="19c8c-217">Instead, when an application that wishes tooreceive messages establishes a TCP connection with Service Bus, a relay is created automatically.</span></span> <span data-ttu-id="19c8c-218">Hello 連線中斷，就會刪除 hello 轉送。</span><span class="sxs-lookup"><span data-stu-id="19c8c-218">When hello connection is dropped, hello relay is deleted.</span></span> <span data-ttu-id="19c8c-219">tooenable 的應用程式 toofind hello 轉送伺服器建立特定的接聽程式，服務匯流排所提供的登錄，可讓應用程式 toolocate 特定轉送依名稱。</span><span class="sxs-lookup"><span data-stu-id="19c8c-219">tooenable an application toofind hello relay created by a specific listener, Service Bus provides a registry that enables applications toolocate a specific relay by name.</span></span>

<span data-ttu-id="19c8c-220">轉送是 hello 絕佳的解決方案，當您需要應用程式之間的直接通訊。</span><span class="sxs-lookup"><span data-stu-id="19c8c-220">Relays are hello right solution when you need direct communication between applications.</span></span> <span data-ttu-id="19c8c-221">舉例來說，假設有一個在內部部署資料中心執行的飛機訂票系統，且必須從自助登機亭、行動裝置和其他電腦來存取此系統。</span><span class="sxs-lookup"><span data-stu-id="19c8c-221">For example, consider an airline reservation system running in an on-premises datacenter that must be accessed from check-in kiosks, mobile devices, and other computers.</span></span> <span data-ttu-id="19c8c-222">在所有這些系統上執行的應用程式無法依賴 hello 雲端 toocommunicate 中的服務匯流排轉送，只要它們可能會執行。</span><span class="sxs-lookup"><span data-stu-id="19c8c-222">Applications running on all these systems could rely on Service Bus relays in hello cloud toocommunicate, wherever they might be running.</span></span>

## <a name="summary"></a><span data-ttu-id="19c8c-223">摘要</span><span class="sxs-lookup"><span data-stu-id="19c8c-223">Summary</span></span>

<span data-ttu-id="19c8c-224">應用程式連接一律已建置完整的解決方案的一部分，而且 hello 範圍的情況需要使用應用程式和服務 toocommunicate 彼此設定 tooincrease 還有更多的應用程式與裝置連線的 toohello 網際網路。</span><span class="sxs-lookup"><span data-stu-id="19c8c-224">Connecting applications has always been part of building complete solutions, and hello range of scenarios that require applications and services toocommunicate with each other is set tooincrease as more applications and devices are connected toohello internet.</span></span> <span data-ttu-id="19c8c-225">藉由提供以雲端為基礎的技術達成透過佇列、 主題和轉送的通訊，Service Bus 以外的工具 toomake 這個必要的函式更容易 tooimplement 和更廣泛。</span><span class="sxs-lookup"><span data-stu-id="19c8c-225">By providing cloud-based technologies for achieving communication through queues, topics, and relays, Service Bus aims toomake this essential function easier tooimplement and more broadly available.</span></span>

## <a name="next-steps"></a><span data-ttu-id="19c8c-226">後續步驟</span><span class="sxs-lookup"><span data-stu-id="19c8c-226">Next steps</span></span>

<span data-ttu-id="19c8c-227">現在，您學到的 Azure 服務匯流排的 hello 基本概念，請遵循這些連結 toolearn 更多。</span><span class="sxs-lookup"><span data-stu-id="19c8c-227">Now that you've learned hello fundamentals of Azure Service Bus, follow these links toolearn more.</span></span>

* <span data-ttu-id="19c8c-228">如何 toouse[服務匯流排佇列](service-bus-dotnet-get-started-with-queues.md)</span><span class="sxs-lookup"><span data-stu-id="19c8c-228">How toouse [Service Bus queues](service-bus-dotnet-get-started-with-queues.md)</span></span>
* <span data-ttu-id="19c8c-229">如何 toouse[服務匯流排主題](service-bus-dotnet-how-to-use-topics-subscriptions.md)</span><span class="sxs-lookup"><span data-stu-id="19c8c-229">How toouse [Service Bus topics](service-bus-dotnet-how-to-use-topics-subscriptions.md)</span></span>
* <span data-ttu-id="19c8c-230">如何 toouse[服務匯流排轉送](../service-bus-relay/service-bus-dotnet-how-to-use-relay.md)</span><span class="sxs-lookup"><span data-stu-id="19c8c-230">How toouse [Service Bus relay](../service-bus-relay/service-bus-dotnet-how-to-use-relay.md)</span></span>
* [<span data-ttu-id="19c8c-231">服務匯流排範例</span><span class="sxs-lookup"><span data-stu-id="19c8c-231">Service Bus samples</span></span>](service-bus-samples.md)

[1]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_01_architecture.png
[2]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_02_queues.png
[3]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_03_topicsandsubscriptions.png
[4]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_04_relay.png
