---
title: "使用 Azure Service Bus 佇列的 aaaWrite 應用程式 |Microsoft 文件"
description: "如何 toowrite 簡單佇列為基礎的應用程式使用 Azure 服務匯流排。"
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 93b75902a06becd6e33e05298e09f5669d0e2aef
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="2c1c8-103">建立使用服務匯流排佇列的應用程式</span><span class="sxs-lookup"><span data-stu-id="2c1c8-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="2c1c8-104">本主題描述服務匯流排佇列，並顯示如何 toowrite 的簡單佇列架構應用程式會使用服務匯流排。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-104">This topic describes Service Bus queues and shows how toowrite a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="2c1c8-105">請考慮下列案例： hello world 的零售銷售資料從個別 Point-of-Sale (POS) 終端機必須路由傳送 tooan 庫存管理系統時，所用 hello 資料 toodetermine toobe 補充存貨。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-105">Consider a scenario from hello world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed tooan inventory management system that uses hello data toodetermine when stock has toobe replenished.</span></span> <span data-ttu-id="2c1c8-106">此解決方案會使用服務匯流排訊息 hello 之間的通訊 hello 終端機和 hello 庫存管理系統，hello 遵循圖所示：</span><span class="sxs-lookup"><span data-stu-id="2c1c8-106">This solution uses Service Bus messaging for hello communication between hello terminals and hello inventory management system, as illustrated in hello following figure:</span></span>

![服務匯流排佇列影像 1](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="2c1c8-108">每個 POS 終端機報告其銷售資料，藉由傳送訊息 toohello **DataCollectionQueue**。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-108">Each POS terminal reports its sales data by sending messages toohello **DataCollectionQueue**.</span></span> <span data-ttu-id="2c1c8-109">這些訊息會維持此佇列，直到擷取 hello 庫存管理系統。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-109">These messages remain in this queue until they are retrieved by hello inventory management system.</span></span> <span data-ttu-id="2c1c8-110">此模式通常稱為*非同步傳訊*，因為 hello POS 終端機無須 toowait hello 庫存管理系統 toocontinue 處理的回覆。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-110">This pattern is often termed *asynchronous messaging*, because hello POS terminal does not have toowait for a reply from hello inventory management system toocontinue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="2c1c8-111">為何使用佇列？</span><span class="sxs-lookup"><span data-stu-id="2c1c8-111">Why queuing?</span></span>
<span data-ttu-id="2c1c8-112">我們會審視此應用程式的必要的 tooset hello 程式碼之前，請考慮在此案例中而不需 hello POS 終端機使用佇列的 hello 優點溝通直接 （同步） toohello 庫存管理系統。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-112">Before we look at hello code that is required tooset up this application, consider hello advantages of using a queue in this scenario instead of having hello POS terminals talk directly (synchronously) toohello inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="2c1c8-113">暫時分離</span><span class="sxs-lookup"><span data-stu-id="2c1c8-113">Temporal decoupling</span></span>
<span data-ttu-id="2c1c8-114">使用 hello 非同步訊息模式中，產生者和消費者不需要線上 toobe hello 在相同的時間。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-114">With hello asynchronous messaging pattern, producers and consumers do not have toobe online at hello same time.</span></span> <span data-ttu-id="2c1c8-115">hello 訊息基礎結構會可靠地儲存訊息直到 hello 取用方準備 tooreceive 它們。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-115">hello messaging infrastructure reliably stores messages until hello consuming party is ready tooreceive them.</span></span> <span data-ttu-id="2c1c8-116">這表示 hello hello 分散式應用程式元件可以被中斷連線，或是主動;例如，為了進行維護，或因為 tooa 元件損毀，而不會影響 hello 整個系統。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-116">This means hello components of hello distributed application can be disconnected, either voluntarily; for example, for maintenance, or due tooa component crash, without affecting hello whole system.</span></span> <span data-ttu-id="2c1c8-117">此外，hello 取用應用程式可能只有線上 toobe hello 一天的特定時間。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-117">Furthermore, hello consuming application may only have toobe online during certain times of hello day.</span></span> <span data-ttu-id="2c1c8-118">例如，在此零售案例中，hello 庫存管理系統可能只有 toocome 線上 hello hello 營業日結束後。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-118">For example, in this retail scenario, hello inventory management system may only have toocome online after hello end of hello business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="2c1c8-119">負載調節</span><span class="sxs-lookup"><span data-stu-id="2c1c8-119">Load leveling</span></span>
<span data-ttu-id="2c1c8-120">在許多應用程式系統負載會隨著時間改變，而每一單位的工作所需的 hello 處理時間則通常不變。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-120">In many applications system load varies over time, whereas hello processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="2c1c8-121">調解訊息產生者和具有佇列表示 hello 消費性應用程式 （hello 背景工作角色） 的消費者只有 toobe 佈建的 tooservice 平均負載而不是高峰負載。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-121">Intermediating message producers and consumers with a queue means that hello consuming application (hello worker) only has toobe provisioned tooservice an average load rather than a peak load.</span></span> <span data-ttu-id="2c1c8-122">hello hello 佇列深度會成長，而且合約為 hello 連入負載而有所不同。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-122">hello depth of hello queue will grow and contract as hello incoming load varies.</span></span> <span data-ttu-id="2c1c8-123">這與基礎結構需要的 tooservice hello 應用程式負載而考慮 toohello 數量可直接節省金錢。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-123">This directly saves money with regard toohello amount of infrastructure required tooservice hello application load.</span></span>

![服務匯流排佇列影像 2](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="2c1c8-125">負載平衡</span><span class="sxs-lookup"><span data-stu-id="2c1c8-125">Load balancing</span></span>
<span data-ttu-id="2c1c8-126">為 hello 負載增加，多個背景工作處理序可以是加入的 tooread hello 背景工作佇列中。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-126">As hello load increases, more worker processes can be added tooread from hello worker queue.</span></span> <span data-ttu-id="2c1c8-127">只有其中一個 hello 背景工作處理序處理每個訊息。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-127">Each message is processed by only one of hello worker processes.</span></span> <span data-ttu-id="2c1c8-128">此外，此提取為基礎的負載平衡能充分利用 hello 背景工作電腦即使 hello 背景工作電腦不同而考慮 tooprocessing 電源，因為它們會在他們自己的最大速率提取訊息。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-128">Furthermore, this pull-based load balancing allows for optimum usage of hello worker computers even if hello worker computers differ with regard tooprocessing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="2c1c8-129">此模式通常稱為 hello 競爭取用者模式。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-129">This pattern is often termed hello competing consumer pattern.</span></span>

![服務匯流排佇列影像 3](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="2c1c8-131">鬆散結合</span><span class="sxs-lookup"><span data-stu-id="2c1c8-131">Loose coupling</span></span>
<span data-ttu-id="2c1c8-132">使用訊息佇列 toointermediate 訊息產生者和消費者提供 hello 元件之間的內建鬆散結合。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-132">Using message queuing toointermediate between message producers and consumers provides an intrinsic loose coupling between hello components.</span></span> <span data-ttu-id="2c1c8-133">因為產生者和消費者不知道彼此的存在，取用者可以在 hello 生產者影響的情況下升級。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on hello producer.</span></span> <span data-ttu-id="2c1c8-134">此外，而不會影響 hello 現有端點的 hello 訊息拓撲能持續改進。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-134">Furthermore, hello messaging topology can evolve without affecting hello existing endpoints.</span></span> <span data-ttu-id="2c1c8-135">當我們談到發佈/訂閱時，會討論更多這部分的內容。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-hello-code"></a><span data-ttu-id="2c1c8-136">我想 hello 程式碼</span><span class="sxs-lookup"><span data-stu-id="2c1c8-136">Show me hello code</span></span>
<span data-ttu-id="2c1c8-137">hello 之後 > 一節顯示如何 toouse Service Bus toobuild 此應用程式。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-137">hello following section shows how toouse Service Bus toobuild this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="2c1c8-138">註冊 Azure 帳戶</span><span class="sxs-lookup"><span data-stu-id="2c1c8-138">Sign up for an Azure account</span></span>
<span data-ttu-id="2c1c8-139">您需要使用服務匯流排的順序 toostart 中的 Azure 帳戶。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-139">You’ll need an Azure account in order toostart working with Service Bus.</span></span> <span data-ttu-id="2c1c8-140">如果您沒有此帳戶，可以在[這裡](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF)註冊免費帳戶。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="2c1c8-141">建立命名空間</span><span class="sxs-lookup"><span data-stu-id="2c1c8-141">Create a namespace</span></span>
<span data-ttu-id="2c1c8-142">當您有訂用帳戶後，便可[建立服務命名空間](service-bus-create-namespace-portal.md)。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="2c1c8-143">每個命名空間會作為一組服務匯流排實體的範圍容器。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="2c1c8-144">請為所有服務匯流排帳戶的新命名空間指定唯一名稱。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-hello-nuget-package"></a><span data-ttu-id="2c1c8-145">安裝 hello NuGet 封裝</span><span class="sxs-lookup"><span data-stu-id="2c1c8-145">Install hello NuGet package</span></span>
<span data-ttu-id="2c1c8-146">toouse hello 服務匯流排命名空間，應用程式必須參考 hello 服務匯流排組件，也就是 Microsoft.ServiceBus.dll。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-146">toouse hello Service Bus namespace, an application must reference hello Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="2c1c8-147">您可以找到此組件的 hello Microsoft Azure SDK，且可在 hello hello 下載[Azure SDK 下載頁面](https://azure.microsoft.com/downloads/)。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-147">You can find this assembly as part of hello Microsoft Azure SDK, and hello download is available at hello [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="2c1c8-148">不過，hello[服務匯流排 NuGet 封裝](https://www.nuget.org/packages/WindowsAzure.ServiceBus)是最簡單方式 tooget hello hello 服務匯流排 API 和 tooconfigure hello 服務匯流排相依性的所有應用程式。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-148">However, hello [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is hello easiest way tooget hello Service Bus API and tooconfigure your application with all of hello Service Bus dependencies.</span></span>

### <a name="create-hello-queue"></a><span data-ttu-id="2c1c8-149">建立 hello 佇列</span><span class="sxs-lookup"><span data-stu-id="2c1c8-149">Create hello queue</span></span>
<span data-ttu-id="2c1c8-150">管理 Service Bus 訊息實體 （佇列和發佈/訂閱主題） 都是透過 hello 作業[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager)類別。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="2c1c8-151">服務匯流排會使用以[共用存取簽章 (SAS)](service-bus-sas.md) 為基礎的安全性模型。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="2c1c8-152">hello [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider)類別代表與內建的 factory 方法傳回某些已知權杖提供者的安全性權杖提供者。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-152">hello [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="2c1c8-153">我們將使用[CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_)方法 toohold hello SAS 認證。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method toohold hello SAS credentials.</span></span> <span data-ttu-id="2c1c8-154">hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) hello hello 服務匯流排命名空間和 hello 權杖提供者的基底地址，然後建構執行個體。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-154">hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with hello base address of hello Service Bus namespace and hello token provider.</span></span>

<span data-ttu-id="2c1c8-155">hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager)類別會提供方法 toocreate、 列舉和刪除訊息實體。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-155">hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods toocreate, enumerate and delete messaging entities.</span></span> <span data-ttu-id="2c1c8-156">hello 程式碼，如下所示顯示如何 hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager)執行個體是已建立並使用 toocreate hello **DataCollectionQueue**佇列。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-156">hello code that is shown here shows how hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used toocreate hello **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="2c1c8-157">請注意，有多載的 hello [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_)啟用內容的 hello 佇列 toobe 微調的方法。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-157">Note that there are overloads of hello [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of hello queue toobe tuned.</span></span> <span data-ttu-id="2c1c8-158">例如，您可以設定 hello 預設存留時間 (TTL) 值傳送 toohello 佇列的訊息。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-158">For example, you can set hello default time-to-live (TTL) value for messages sent toohello queue.</span></span>

### <a name="send-messages-toohello-queue"></a><span data-ttu-id="2c1c8-159">傳送訊息 toohello 佇列</span><span class="sxs-lookup"><span data-stu-id="2c1c8-159">Send messages toohello queue</span></span>
<span data-ttu-id="2c1c8-160">對於服務匯流排實體上的執行階段作業 (例如，傳送和接收訊息)，應用程式必須先建立 [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) 物件。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="2c1c8-161">類似 toohello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager)類別，hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory)從 hello hello 服務命名空間和 hello 權杖提供者的基底地址建立執行個體。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-161">Similar toohello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from hello base address of hello service namespace and hello token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="2c1c8-162">訊息傳送至，並收到來自服務匯流排佇列都是執行個體的 hello [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage)類別。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-162">Messages sent to, and received from Service Bus queues are instances of hello [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="2c1c8-163">這個類別所組成的一組標準屬性 (例如[標籤](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label)和[TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)) 的字典，其中使用的 toohold 應用程式屬性，和任意應用程式資料的主體。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used toohold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="2c1c8-164">應用程式可以藉由傳遞任何可序列化的物件設定 hello 主體 (hello 下列範例會傳入**SalesData**表示 hello POS 終端機 hello 銷售資料物件)，就會使用 hello [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) tooserialize hello 物件。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-164">An application can set hello body by passing in any serializable object (hello following example passes in a **SalesData** object that represents hello sales data from hello POS terminal), which will use hello [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) tooserialize hello object.</span></span> <span data-ttu-id="2c1c8-165">或者，也可以提供 [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) 物件。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="2c1c8-166">hello 我們的案例 hello 中指定佇列中，最簡單的方式 toosend 訊息 tooa **DataCollectionQueue**，是 toouse [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) toocreate [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender)物件直接從 hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory)執行個體。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-166">hello easiest way toosend messages tooa given queue, in our case hello **DataCollectionQueue**, is toouse [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) toocreate a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-hello-queue"></a><span data-ttu-id="2c1c8-167">從 hello 佇列接收訊息</span><span class="sxs-lookup"><span data-stu-id="2c1c8-167">Receiving messages from hello queue</span></span>
<span data-ttu-id="2c1c8-168">tooreceive 從 hello 佇列的訊息，您可以使用[MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver)您直接從 hello 建立物件[MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory)使用[CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_)。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-168">tooreceive messages from hello queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="2c1c8-169">訊息接收者可在兩種不同的模式下運作：**ReceiveAndDelete** 和 **PeekLock**。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="2c1c8-170">hello [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode)建立 hello 訊息接收者時，做為參數 toohello 設定[CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_)呼叫。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-170">hello [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when hello message receiver is created, as a parameter toohello [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="2c1c8-171">當使用 hello **ReceiveAndDelete**模式中，會收到 hello 是單發式作業; 也就是服務匯流排收到 hello 要求時，它會標示為正在使用的 hello 訊息，並傳回它 toohello 應用程式。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-171">When using hello **ReceiveAndDelete** mode, hello receive is a single-shot operation; that is, when Service Bus receives hello request, it marks hello message as being consumed and returns it toohello application.</span></span> <span data-ttu-id="2c1c8-172">**ReceiveAndDelete**模式是 hello 簡單的模式，最適合用於中的 hello 應用程式可以容許 toooccur 失敗時，不處理訊息的案例。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-172">**ReceiveAndDelete** mode is hello simplest model and works best for scenarios in which hello application can tolerate not processing a message if a failure were toooccur.</span></span> <span data-ttu-id="2c1c8-173">toounderstand，假設在哪一個 hello 取用者問題 hello 接收要求，而後再處理它。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-173">toounderstand this, consider a scenario in which hello consumer issues hello receive request and then crashes before processing it.</span></span> <span data-ttu-id="2c1c8-174">服務匯流排會標示為正在使用的 hello 訊息，因為當 hello 應用程式重新啟動並開始取用訊息，將會遺失 hello 損毀之前所耗用的 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-174">Since Service Bus marked hello message as being consumed, when hello application restarts and starts consuming messages again, it will have missed hello message that was consumed before hello crash.</span></span>

<span data-ttu-id="2c1c8-175">在**PeekLock**模式，hello 接收會變成兩階段作業，使其不容許遺失訊息的可能 toosupport 應用程式。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-175">In **PeekLock** mode, hello receive becomes a two-stage operation, which makes it possible toosupport applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="2c1c8-176">服務匯流排收到 hello 要求時，它會尋找下一個訊息 toobe hello 耗用鎖定，tooprevent 其他消費者接收該，然後再將它傳 toohello 應用程式。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-176">When Service Bus receives hello request, it finds hello next message toobe consumed, locks it tooprevent other consumers receiving it, and then returns it toohello application.</span></span> <span data-ttu-id="2c1c8-177">Hello 應用程式完成處理 hello 訊息 （或可靠地儲存以供未來處理後），它就會完成 hello hello 第二個階段藉由呼叫接收處理序[完成](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)上收到 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-177">After hello application finishes processing hello message (or stores it reliably for future processing), it completes hello second stage of hello receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on hello received message.</span></span> <span data-ttu-id="2c1c8-178">當服務匯流排會看見 hello[完成](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)呼叫時，它會將標示為正在使用的 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-178">When Service Bus sees hello [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks hello message as being consumed.</span></span>

<span data-ttu-id="2c1c8-179">可能會有兩種不同的結果。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-179">Two other outcomes are possible.</span></span> <span data-ttu-id="2c1c8-180">首先，如果 hello 應用程式無法 tooprocess hello 訊息，因為某些原因，它可以呼叫[放棄](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon)上收到 hello 訊息 (而不是[完成](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete))。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-180">First, if hello application is unable tooprocess hello message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on hello received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="2c1c8-181">這會使服務匯流排 toounlock hello 訊息，並讓它再次接收可用 toobe、 由 hello 相同的消費者或其他競爭消費者。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-181">This causes Service Bus toounlock hello message and make it available toobe received again, either by hello same consumer or by another completing consumer.</span></span> <span data-ttu-id="2c1c8-182">第二，沒有逾時與 hello 鎖定相關聯，而且如果 hello 應用程式無法處理 hello 訊息 hello 鎖定逾時過期之前 （例如，如果 hello 應用程式當機），然後將會解除鎖定 Service Bus hello 訊息，並將其可用 toobe接收一次 (基本上執行[放棄](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon)作業依預設)。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-182">Second, there is a time-out associated with hello lock and if hello application cannot process hello message before hello lock time-out expires (for example, if hello application crashes), then Service Bus will unlock hello message and make it available toobe received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="2c1c8-183">請注意，如果 hello 應用程式損毀它處理 hello 訊息之後但在 hello 之前[完成](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)發出要求，hello 訊息將已重新傳遞的 toohello 應用程式，重新啟動時。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-183">Note that if hello application crashes after it processes hello message but before hello [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, hello message will be redelivered toohello application when it restarts.</span></span> <span data-ttu-id="2c1c8-184">這通常稱為 * At Least Once * 處理。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="2c1c8-185">這表示每則訊息會至少一次處理，但可能在某些情況下 hello 傳遞相同的訊息。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-185">This means that each message will be processed at least once but in certain situations hello same message may be redelivered.</span></span> <span data-ttu-id="2c1c8-186">如果 hello 案例無法容許重複處理 hello 應用程式 toodetect 重複的情況需要額外的邏輯。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-186">If hello scenario cannot tolerate duplicate processing, then additional logic is required in hello application toodetect duplicates.</span></span> <span data-ttu-id="2c1c8-187">這可以根據 hello [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) hello 訊息屬性。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-187">This can be achieved based on hello [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of hello message.</span></span> <span data-ttu-id="2c1c8-188">這個屬性的 hello 值傳遞嘗試都維持不變。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-188">hello value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="2c1c8-189">這便稱為「剛好一次」處理。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="2c1c8-190">hello 如下所示的程式碼接收和處理訊息，使用 hello **PeekLock**模式中，這是 hello 預設值，如果沒有[ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode)明確提供值。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-190">hello code that is shown here receives and processes a message using hello **PeekLock** mode, which is hello default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-hello-queue-client"></a><span data-ttu-id="2c1c8-191">使用 hello 佇列用戶端</span><span class="sxs-lookup"><span data-stu-id="2c1c8-191">Use hello queue client</span></span>
<span data-ttu-id="2c1c8-192">hello 本節稍早建立的範例[MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender)和[MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver)物件直接從 hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) toosend 和接收訊息從 hello 佇列分別。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-192">hello examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) toosend and receive messages from hello queue, respectively.</span></span> <span data-ttu-id="2c1c8-193">另一個方法是 toouse [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient)物件，其支援同時傳送和接收作業中加入 toomore 進階功能，例如工作階段。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-193">An alternative approach is toouse a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition toomore advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="2c1c8-194">後續步驟</span><span class="sxs-lookup"><span data-stu-id="2c1c8-194">Next steps</span></span>
<span data-ttu-id="2c1c8-195">既然您已經學會 hello 的佇列的基本概念，請參閱[建立使用服務匯流排主題和訂用帳戶的應用程式](service-bus-create-topics-subscriptions.md)toocontinue 使用 hello 發佈/訂閱功能的 Service Bus 主題討論和訂用帳戶。</span><span class="sxs-lookup"><span data-stu-id="2c1c8-195">Now that you've learned hello basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) toocontinue this discussion using hello publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>

