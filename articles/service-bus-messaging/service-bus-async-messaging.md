---
title: "aaaService 匯流排非同步傳訊 |Microsoft 文件"
description: "「Azure 服務匯流排」非同步傳訊說明。"
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: f1435549-e1f2-40cb-a280-64ea07b39fc7
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 04/19/2017
ms.author: sethm
ms.openlocfilehash: 5ab6ddf052155a9dd975b413cfaf393119c1999d
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="asynchronous-messaging-patterns-and-high-availability"></a><span data-ttu-id="ea7e7-103">非同步傳訊模式和高可用性</span><span class="sxs-lookup"><span data-stu-id="ea7e7-103">Asynchronous messaging patterns and high availability</span></span>

<span data-ttu-id="ea7e7-104">有各種不同的方式可以實作非同步傳訊。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-104">Asynchronous messaging can be implemented in a variety of different ways.</span></span> <span data-ttu-id="ea7e7-105">「Azure 服務匯流排」利用佇列、主題及訂用帳戶來支援透過儲存和轉送機制進行的非同步處理。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-105">With queues, topics, and subscriptions, Azure Service Bus supports asynchronism via a store and forward mechanism.</span></span> <span data-ttu-id="ea7e7-106">在正常 （同步） 作業中，您可以傳送訊息 tooqueues 和主題，並從佇列和訂閱接收訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-106">In normal (synchronous) operation, you send messages tooqueues and topics, and receive messages from queues and subscriptions.</span></span> <span data-ttu-id="ea7e7-107">您撰寫的應用程式依存於這些實體永遠可用。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-107">Applications you write depend on these entities always being available.</span></span> <span data-ttu-id="ea7e7-108">Hello 實體健全狀況變更時，由於 tooa 各種不同的情況下，您需要的方式 tooprovide 能夠滿足大多數需求的容量減少的實體。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-108">When hello entity health changes, due tooa variety of circumstances, you need a way tooprovide a reduced capability entity that can satisfy most needs.</span></span>

<span data-ttu-id="ea7e7-109">應用程式通常使用非同步傳訊模式 tooenable 一些通訊案例。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-109">Applications typically use asynchronous messaging patterns tooenable a number of communication scenarios.</span></span> <span data-ttu-id="ea7e7-110">您可以建置應用程式即使 hello 服務未執行用戶端可以傳送訊息 tooservices。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-110">You can build applications in which clients can send messages tooservices, even when hello service is not running.</span></span> <span data-ttu-id="ea7e7-111">對於遇到大量通訊的應用程式，佇列可協助提供位置 toobuffer 通訊載入層級 hello。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-111">For applications that experience bursts of communications, a queue can help level hello load by providing a place toobuffer communications.</span></span> <span data-ttu-id="ea7e7-112">最後，您可以取得簡單但有效率的負載平衡器 toodistribute 訊息在多部電腦。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-112">Finally, you can get a simple but effective load balancer toodistribute messages across multiple machines.</span></span>

<span data-ttu-id="ea7e7-113">在這些實體的任何順序 toomaintain 可用性，請考慮不同的方法，這些實體可以出現在長期訊息系統無法使用的數字。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-113">In order toomaintain availability of any of these entities, consider a number of different ways in which these entities can appear unavailable for a durable messaging system.</span></span> <span data-ttu-id="ea7e7-114">一般而言，我們看到 hello 實體會變成無法使用 tooapplications hello 遵循不同的方式在我們寫入：</span><span class="sxs-lookup"><span data-stu-id="ea7e7-114">Generally speaking, we see hello entity become unavailable tooapplications we write in hello following different ways:</span></span>

* <span data-ttu-id="ea7e7-115">無法 toosend 訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-115">Unable toosend messages.</span></span>
* <span data-ttu-id="ea7e7-116">無法 tooreceive 訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-116">Unable tooreceive messages.</span></span>
* <span data-ttu-id="ea7e7-117">無法 toomanage 實體 （建立、 擷取、 更新或刪除實體）。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-117">Unable toomanage entities (create, retrieve, update, or delete entities).</span></span>
* <span data-ttu-id="ea7e7-118">無法 toocontact hello 服務。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-118">Unable toocontact hello service.</span></span>

<span data-ttu-id="ea7e7-119">針對每個這些失敗情況，不同的失敗模式會讓某個層級的容量減少應用程式 toocontinue tooperform 工作。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-119">For each of these failures, different failure modes exist that enable an application toocontinue tooperform work at some level of reduced capability.</span></span> <span data-ttu-id="ea7e7-120">例如，可傳送訊息但不會收到訊息的系統仍可以接收來自客戶的訂單，但無法處理這些訂單。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-120">For example, a system that can send messages but not receive them can still receive orders from customers but cannot process those orders.</span></span> <span data-ttu-id="ea7e7-121">本主題討論可能發生的潛在問題，以及如何減輕這些問題。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-121">This topic discusses potential issues that can occur, and how those issues are mitigated.</span></span> <span data-ttu-id="ea7e7-122">服務匯流排已導入了一些您必須選擇加入，這與本主題也討論的 hello 規則 hello 控管使用這些選擇加入防護功能。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-122">Service Bus has introduced a number of mitigations which you must opt into, and this topic also discusses hello rules governing hello use of those opt-in mitigations.</span></span>

## <a name="reliability-in-service-bus"></a><span data-ttu-id="ea7e7-123">服務匯流排的可靠性</span><span class="sxs-lookup"><span data-stu-id="ea7e7-123">Reliability in Service Bus</span></span>
<span data-ttu-id="ea7e7-124">有數種方式 toohandle 訊息和實體問題，而且都有控管 hello 適當使用這些防護功能的指導方針。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-124">There are several ways toohandle message and entity issues, and there are guidelines governing hello appropriate use of those mitigations.</span></span> <span data-ttu-id="ea7e7-125">toounderstand hello 指導方針，您必須先了解什麼可以在服務匯流排失敗。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-125">toounderstand hello guidelines, you must first understand what can fail in Service Bus.</span></span> <span data-ttu-id="ea7e7-126">Toohello 設計 Azure 的系統，因為所有的這些問題通常 toobe 存留較短。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-126">Due toohello design of Azure systems, all of these issues tend toobe short-lived.</span></span> <span data-ttu-id="ea7e7-127">在高層級，hello 的不可用不同的原因如下：</span><span class="sxs-lookup"><span data-stu-id="ea7e7-127">At a high level, hello different causes of unavailability appear as follows:</span></span>

* <span data-ttu-id="ea7e7-128">從服務匯流排所依賴的外部系統節流。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-128">Throttling from an external system on which Service Bus depends.</span></span> <span data-ttu-id="ea7e7-129">從與儲存體和運算資源的互動進行節流。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-129">Throttling occurs from interactions with storage and compute resources.</span></span>
* <span data-ttu-id="ea7e7-130">服務匯流排所依賴系統的問題。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-130">Issue for a system on which Service Bus depends.</span></span> <span data-ttu-id="ea7e7-131">例如，指定的儲存體部份可能會發生問題。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-131">For example, a given part of storage can encounter issues.</span></span>
* <span data-ttu-id="ea7e7-132">單一子系統上的服務匯流排失敗。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-132">Failure of Service Bus on single subsystem.</span></span> <span data-ttu-id="ea7e7-133">在此情況下，計算節點可以進入不一致的狀態，且必須重新啟動本身，造成所有的實體做 tooload 平衡 tooother 節點。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-133">In this situation, a compute node can get into an inconsistent state and must restart itself, causing all entities it serves tooload balance tooother nodes.</span></span> <span data-ttu-id="ea7e7-134">這又會導致短期內的訊息處理速度緩慢。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-134">This in turn can cause a short period of slow message processing.</span></span>
* <span data-ttu-id="ea7e7-135">Azure 資料中心內的服務匯流排失敗。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-135">Failure of Service Bus within an Azure datacenter.</span></span> <span data-ttu-id="ea7e7-136">這是在 hello 系統是無法連線到數分鐘或幾個小時的 「 災難性失敗 」。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-136">This is a "catastrophic failure" during which hello system is unreachable for many minutes or a few hours.</span></span>

> [!NOTE]
> <span data-ttu-id="ea7e7-137">hello 詞彙**儲存體**可代表 Azure 儲存體和 SQL Azure。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-137">hello term **storage** can mean both Azure Storage and SQL Azure.</span></span>
> 
> 

<span data-ttu-id="ea7e7-138">對於這些問題，服務匯流排有數種緩和措施。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-138">Service Bus contains a number of mitigations for these issues.</span></span> <span data-ttu-id="ea7e7-139">hello 下列各節會討論每個問題，以及其各別的防護功能。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-139">hello following sections discuss each issue and their respective mitigations.</span></span>

### <a name="throttling"></a><span data-ttu-id="ea7e7-140">節流</span><span class="sxs-lookup"><span data-stu-id="ea7e7-140">Throttling</span></span>
<span data-ttu-id="ea7e7-141">使用服務匯流排，節流可達到協同合作的訊息速率管理。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-141">With Service Bus, throttling enables cooperative message rate management.</span></span> <span data-ttu-id="ea7e7-142">每個個別的服務匯流排節點都容納許多實體。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-142">Each individual Service Bus node houses many entities.</span></span> <span data-ttu-id="ea7e7-143">每個實體 CPU、 記憶體、 存放裝置，和其他方面的 hello 系統提出需求。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-143">Each of those entities makes demands on hello system in terms of CPU, memory, storage, and other facets.</span></span> <span data-ttu-id="ea7e7-144">當上述任何面向偵測到超出所定義臨界值的使用量時，服務匯流排可以拒絕指定的要求。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-144">When any of these facets detects usage that exceeds defined thresholds, Service Bus can deny a given request.</span></span> <span data-ttu-id="ea7e7-145">hello 呼叫端會收到[ServerBusyException] [ ServerBusyException]和 10 秒後的重試。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-145">hello caller receives a [ServerBusyException][ServerBusyException] and retries after 10 seconds.</span></span>

<span data-ttu-id="ea7e7-146">做為防護功能，hello 程式碼必須讀取 hello 錯誤並停止 hello 訊息的任何重試至少 10 秒。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-146">As a mitigation, hello code must read hello error and halt any retries of hello message for at least 10 seconds.</span></span> <span data-ttu-id="ea7e7-147">Hello 錯誤可能會發生跨 hello 客戶應用程式項目，因為它預期每個都能獨立執行 hello 重試邏輯。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-147">Since hello error can happen across pieces of hello customer application, it is expected that each piece independently executes hello retry logic.</span></span> <span data-ttu-id="ea7e7-148">hello 程式碼可以降低啟用佇列或主題上的分割區會進行節流處理 hello 機率。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-148">hello code can reduce hello probability of being throttled by enabling partitioning on a queue or topic.</span></span>

### <a name="issue-for-an-azure-dependency"></a><span data-ttu-id="ea7e7-149">Azure 相依性問題</span><span class="sxs-lookup"><span data-stu-id="ea7e7-149">Issue for an Azure dependency</span></span>
<span data-ttu-id="ea7e7-150">Azure 中的其他元件可能會不時出現服務問題。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-150">Other components within Azure can occasionally have service issues.</span></span> <span data-ttu-id="ea7e7-151">例如，當服務匯流排使用的系統正在升級時，該系統可能會暫時經歷降低的功能。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-151">For example, when a system that Service Bus uses is being upgraded, that system can temporarily experience reduced capabilities.</span></span> <span data-ttu-id="ea7e7-152">這些類型的問題，服務匯流排定期 toowork 調查並實作防護功能。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-152">toowork around these types of issues, Service Bus regularly investigates and implements mitigations.</span></span> <span data-ttu-id="ea7e7-153">這些緩和措施的確會出現副作用。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-153">Side effects of these mitigations do appear.</span></span> <span data-ttu-id="ea7e7-154">例如，toohandle 暫時性問題的儲存體、 服務匯流排實作系統，可讓訊息傳送作業 toowork 一致的方式。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-154">For example, toohandle transient issues with storage, Service Bus implements a system that allows message send operations toowork consistently.</span></span> <span data-ttu-id="ea7e7-155">Hello 緩和 toohello 本質，因為傳送的訊息可以佔用 too15 分鐘 tooappear hello 受影響的佇列或訂閱中，並準備好可供接收作業。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-155">Due toohello nature of hello mitigation, a sent message can take up too15 minutes tooappear in hello affected queue or subscription and be ready for a receive operation.</span></span> <span data-ttu-id="ea7e7-156">一般而言，大部分實體不會發生這個問題。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-156">Generally speaking, most entities will not experience this issue.</span></span> <span data-ttu-id="ea7e7-157">不過，在 Azure 中的服務匯流排中給定實體的 hello 數目，此防護功能有時需要的服務匯流排客戶的小型子集。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-157">However, given hello number of entities in Service Bus within Azure, this mitigation is sometimes needed for a small subset of Service Bus customers.</span></span>

### <a name="service-bus-failure-on-a-single-subsystem"></a><span data-ttu-id="ea7e7-158">單一子系統上的服務匯流排失敗</span><span class="sxs-lookup"><span data-stu-id="ea7e7-158">Service Bus failure on a single subsystem</span></span>
<span data-ttu-id="ea7e7-159">任何應用程式，情況可能會造成不一致的服務匯流排 toobecome 的內部元件。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-159">With any application, circumstances can cause an internal component of Service Bus toobecome inconsistent.</span></span> <span data-ttu-id="ea7e7-160">當服務匯流排偵測到此時，它會收集資料 hello 應用程式 tooaid 診斷發生了什麼事。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-160">When Service Bus detects this, it collects data from hello application tooaid in diagnosing what happened.</span></span> <span data-ttu-id="ea7e7-161">一旦 hello 資料收集，hello 應用程式是在重新啟動嘗試 tooreturn 它 tooa 一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-161">Once hello data is collected, hello application is restarted in an attempt tooreturn it tooa consistent state.</span></span> <span data-ttu-id="ea7e7-162">此程序會相當快速，而結果中實體無法向上 tooa toobe 幾分鐘的時間，但一般停機時間較短。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-162">This process happens fairly quickly, and results in an entity appearing toobe unavailable for up tooa few minutes, though typical down times are much shorter.</span></span>

<span data-ttu-id="ea7e7-163">在這些情況下，hello 用戶端應用程式會產生[System.TimeoutException] [ System.TimeoutException]或[MessagingException] [ MessagingException]例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-163">In these cases, hello client application generates a [System.TimeoutException][System.TimeoutException] or [MessagingException][MessagingException] exception.</span></span> <span data-ttu-id="ea7e7-164">服務匯流排包含自動化用戶端重試邏輯的 hello 形式問題防護功能。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-164">Service Bus contains a mitigation for this issue in hello form of automated client retry logic.</span></span> <span data-ttu-id="ea7e7-165">一旦 hello 重試期間已用完，且不會傳送 hello 訊息，您可以瀏覽使用其他功能，例如[配對命名空間][paired namespaces]。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-165">Once hello retry period is exhausted and hello message is not delivered, you can explore using other features such as [paired namespaces][paired namespaces].</span></span> <span data-ttu-id="ea7e7-166">配對的命名空間有其他需要的注意事項 (請見該文章中的討論)。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-166">Paired namespaces have other caveats that are discussed in that article.</span></span>

### <a name="failure-of-service-bus-within-an-azure-datacenter"></a><span data-ttu-id="ea7e7-167">Azure 資料中心內的服務匯流排失敗</span><span class="sxs-lookup"><span data-stu-id="ea7e7-167">Failure of Service Bus within an Azure datacenter</span></span>
<span data-ttu-id="ea7e7-168">hello Azure 資料中心失敗的最可能的原因是服務匯流排或相依系統的升級部署失敗。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-168">hello most probable reason for a failure in an Azure datacenter is a failed upgrade deployment of Service Bus or a dependent system.</span></span> <span data-ttu-id="ea7e7-169">因為 hello 平台日趨成熟，已大幅降低 hello 可能性，這種類型的失敗。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-169">As hello platform has matured, hello likelihood of this type of failure has diminished.</span></span> <span data-ttu-id="ea7e7-170">資料中心失敗的可能發生的原因包括下列 hello:</span><span class="sxs-lookup"><span data-stu-id="ea7e7-170">A datacenter failure can also happen for reasons that include hello following:</span></span>

* <span data-ttu-id="ea7e7-171">電力中斷 (電源和供電失效)。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-171">Electrical outage (power supply and generating power disappear).</span></span>
* <span data-ttu-id="ea7e7-172">連線 (用戶端與 Azure 之間的網際網路中斷)。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-172">Connectivity (internet break between your clients and Azure).</span></span>

<span data-ttu-id="ea7e7-173">在這兩種情況下，自然或二災害 hello 問題原因。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-173">In both cases, a natural or man-made disaster caused hello issue.</span></span> <span data-ttu-id="ea7e7-174">toowork 解決這個問題，請確定您仍然可以傳送訊息，您可以使用[配對命名空間][ paired namespaces] tooenable 時 hello 主要位置運作正常之後，訊息傳送的 toobe tooa 第二個位置。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-174">toowork around this and make sure that you can still send messages, you can use [paired namespaces][paired namespaces] tooenable messages toobe sent tooa second location while hello primary location is made healthy again.</span></span> <span data-ttu-id="ea7e7-175">如需詳細資訊，請參閱[將應用程式與服務匯流排中斷和災難隔絕的最佳做法 (英文)][Best practices for insulating applications against Service Bus outages and disasters]。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-175">For more information, see [Best practices for insulating applications against Service Bus outages and disasters][Best practices for insulating applications against Service Bus outages and disasters].</span></span>

## <a name="paired-namespaces"></a><span data-ttu-id="ea7e7-176">配對的命名空間</span><span class="sxs-lookup"><span data-stu-id="ea7e7-176">Paired namespaces</span></span>
<span data-ttu-id="ea7e7-177">hello[配對命名空間][ paired namespaces]功能支援案例中無法使用服務匯流排實體或資料中心內的部署。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-177">hello [paired namespaces][paired namespaces] feature supports scenarios in which a Service Bus entity or deployment within a data center becomes unavailable.</span></span> <span data-ttu-id="ea7e7-178">雖然這個事件不常發生，分散式的系統仍然必須準備 toohandle 最糟的情況。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-178">While this event occurs infrequently, distributed systems still must be prepared toohandle worst case scenarios.</span></span> <span data-ttu-id="ea7e7-179">通常會因為服務匯流排所依賴的某個元素遇到短期問題而發生此事件。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-179">Typically, this event happens because some element on which Service Bus depends is experiencing a short-term issue.</span></span> <span data-ttu-id="ea7e7-180">toomaintain 應用程式可用性中斷，在服務匯流排使用者可以使用兩個不同的命名空間，最好是在不同的資料中心，toohost 其訊息實體。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-180">toomaintain application availability during an outage, Service Bus users can use two separate namespaces, preferably in separate data centers, toohost their messaging entities.</span></span> <span data-ttu-id="ea7e7-181">hello 本節其餘部分會使用下列詞彙的 hello:</span><span class="sxs-lookup"><span data-stu-id="ea7e7-181">hello remainder of this section uses hello following terminology:</span></span>

* <span data-ttu-id="ea7e7-182">主要命名空間： hello 命名空間與您的應用程式互動，傳送和接收作業。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-182">Primary namespace: hello namespace with which your application interacts, for send and receive operations.</span></span>
* <span data-ttu-id="ea7e7-183">次要命名空間： hello 做為備份 toohello 主要命名空間的命名空間。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-183">Secondary namespace: hello namespace that acts as a backup toohello primary namespace.</span></span> <span data-ttu-id="ea7e7-184">應用程式邏輯不會與此命名空間互動。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-184">Application logic does not interact with this namespace.</span></span>
* <span data-ttu-id="ea7e7-185">容錯移轉間隔： hello 數量時間 tooaccept 正常失敗之前 hello 應用程式切換 hello 主要命名空間 toohello 次要命名空間中。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-185">Failover interval: hello amount of time tooaccept normal failures before hello application switches from hello primary namespace toohello secondary namespace.</span></span>

<span data-ttu-id="ea7e7-186">配對的命名空間支援「傳送可用性」。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-186">Paired namespaces support *send availability*.</span></span> <span data-ttu-id="ea7e7-187">傳送可用性會保留 hello 能力 toosend 訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-187">Send availability preserves hello ability toosend messages.</span></span> <span data-ttu-id="ea7e7-188">toouse 傳送可用性，您的應用程式必須符合下列需求的 hello:</span><span class="sxs-lookup"><span data-stu-id="ea7e7-188">toouse send availability, your application must meet hello following requirements:</span></span>

1. <span data-ttu-id="ea7e7-189">訊息只會收到 hello 主要命名空間。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-189">Messages are only received from hello primary namespace.</span></span>
2. <span data-ttu-id="ea7e7-190">給定的佇列或主題傳送的訊息 tooa 可能到達順序。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-190">Messages sent tooa given queue or topic might arrive out of order.</span></span>
3. <span data-ttu-id="ea7e7-191">工作階段內的訊息可能不會按順序抵達。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-191">Messages within a session might arrive out of order.</span></span> <span data-ttu-id="ea7e7-192">這是工作階段的正常功能毀損。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-192">This is a break from normal functionality of sessions.</span></span> <span data-ttu-id="ea7e7-193">這表示您的應用程式會使用訊息工作階段 toologically 分組。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-193">This means that your application uses sessions toologically group messages.</span></span>
4. <span data-ttu-id="ea7e7-194">Hello 主要命名空間只會保留工作階段狀態。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-194">Session state is only maintained on hello primary namespace.</span></span>
5. <span data-ttu-id="ea7e7-195">hello 主要佇列可以上線，而 hello 次要佇列傳遞所有訊息到 hello 主要佇列之前開始接受訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-195">hello primary queue can come online and start accepting messages before hello secondary queue delivers all messages into hello primary queue.</span></span>

<span data-ttu-id="ea7e7-196">hello 下列各節討論 hello Api、 hello 應用程式開發介面中實作方式，以及顯示範例程式碼使用 hello 功能。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-196">hello following sections discuss hello APIs, how hello APIs are implemented, and shows sample code that uses hello feature.</span></span> <span data-ttu-id="ea7e7-197">請注意，這項功能有相關聯的計費暗示。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-197">Note that there are billing implications associated with this feature.</span></span>

### <a name="hello-messagingfactorypairnamespaceasync-api"></a><span data-ttu-id="ea7e7-198">hello MessagingFactory.PairNamespaceAsync API</span><span class="sxs-lookup"><span data-stu-id="ea7e7-198">hello MessagingFactory.PairNamespaceAsync API</span></span>
<span data-ttu-id="ea7e7-199">hello 配對的命名空間功能包括 hello [PairNamespaceAsync] [ PairNamespaceAsync]方法上 hello [Microsoft.ServiceBus.Messaging.MessagingFactory] [Microsoft.ServiceBus.Messaging.MessagingFactory]類別：</span><span class="sxs-lookup"><span data-stu-id="ea7e7-199">hello paired namespaces feature includes hello [PairNamespaceAsync][PairNamespaceAsync] method on hello [Microsoft.ServiceBus.Messaging.MessagingFactory][Microsoft.ServiceBus.Messaging.MessagingFactory] class:</span></span>

```csharp
public Task PairNamespaceAsync(PairedNamespaceOptions options);
```

<span data-ttu-id="ea7e7-200">Hello 工作完成時，hello 命名空間配對也是完成並準備 tooact 時任何[MessageReceiver][MessageReceiver]， [QueueClient] [ QueueClient]，或[TopicClient] [ TopicClient]建立以 hello [MessagingFactory] [ MessagingFactory]執行個體。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-200">When hello task completes, hello namespace pairing is also complete and ready tooact upon for any [MessageReceiver][MessageReceiver], [QueueClient][QueueClient], or [TopicClient][TopicClient] created with hello [MessagingFactory][MessagingFactory] instance.</span></span> <span data-ttu-id="ea7e7-201">[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions] [ Microsoft.ServiceBus.Messaging.PairedNamespaceOptions]是 hello hello 基底類別不同型別的配對，可用之[MessagingFactory] [MessagingFactory]物件。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-201">[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions][Microsoft.ServiceBus.Messaging.PairedNamespaceOptions] is hello base class for hello different types of pairing that are available with a [MessagingFactory][MessagingFactory] object.</span></span> <span data-ttu-id="ea7e7-202">目前，hello 衍生類別只是一個名為[SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions]，它會實作 hello 傳送可用性需求。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-202">Currently, hello only derived class is one named [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions], which implements hello send availability requirements.</span></span> <span data-ttu-id="ea7e7-203">[SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] 有一組建立在彼此之上的建構函式。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-203">[SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] has a set of constructors that build on each other.</span></span> <span data-ttu-id="ea7e7-204">查看 hello 建構函式以 hello 大部分的參數，您可以了解 hello 行為 hello 其他建構函式。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-204">Looking at hello constructor with hello most parameters, you can understand hello behavior of hello other constructors.</span></span>

```csharp
public SendAvailabilityPairedNamespaceOptions(
    NamespaceManager secondaryNamespaceManager,
    MessagingFactory messagingFactory,
    int backlogQueueCount,
    TimeSpan failoverInterval,
    bool enableSyphon)
```

<span data-ttu-id="ea7e7-205">這些參數具有下列意義 hello:</span><span class="sxs-lookup"><span data-stu-id="ea7e7-205">These parameters have hello following meanings:</span></span>

* <span data-ttu-id="ea7e7-206">*secondaryNamespaceManager*： 初始化[NamespaceManager] [ NamespaceManager]例項而言 hello 次要命名空間的 hello [PairNamespaceAsync][ PairNamespaceAsync]方法可以使用 tooset hello 次要命名空間。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-206">*secondaryNamespaceManager*: An initialized [NamespaceManager][NamespaceManager] instance for hello secondary namespace that hello [PairNamespaceAsync][PairNamespaceAsync] method can use tooset up hello secondary namespace.</span></span> <span data-ttu-id="ea7e7-207">hello 命名空間管理員是使用的 tooobtain hello hello 命名空間和 toomake 確定存在所需的 hello 待處理項目佇列中的佇列清單。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-207">hello namespace manager is used tooobtain hello list of queues in hello namespace and toomake sure that hello required backlog queues exist.</span></span> <span data-ttu-id="ea7e7-208">如果這些佇列不存在，則會加以建立。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-208">If those queues do not exist, they are created.</span></span> <span data-ttu-id="ea7e7-209">[NamespaceManager] [ NamespaceManager]需要 hello 能力 toocreate hello 的語彙基元**管理**宣告。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-209">[NamespaceManager][NamespaceManager] requires hello ability toocreate a token with hello **Manage** claim.</span></span>
* <span data-ttu-id="ea7e7-210">*messagingFactory*: hello [MessagingFactory] [ MessagingFactory] hello 次要命名空間的執行個體。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-210">*messagingFactory*: hello [MessagingFactory][MessagingFactory] instance for hello secondary namespace.</span></span> <span data-ttu-id="ea7e7-211">hello [MessagingFactory] [ MessagingFactory]物件是使用的 toosend，而如果 hello [EnableSyphon] [ EnableSyphon]屬性設定太**，則為 true**，從 hello 待處理項目佇列接收訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-211">hello [MessagingFactory][MessagingFactory] object is used toosend and, if hello [EnableSyphon][EnableSyphon] property is set too**true**, receive messages from hello backlog queues.</span></span>
* <span data-ttu-id="ea7e7-212">*backlogQueueCount*： 排入佇列，toocreate hello 待處理項目數目。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-212">*backlogQueueCount*: hello number of backlog queues toocreate.</span></span> <span data-ttu-id="ea7e7-213">此值必須至少為 1。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-213">This value must be at least 1.</span></span> <span data-ttu-id="ea7e7-214">當傳送訊息 toohello 待處理項目，會隨機選擇其中一個佇列。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-214">When sending messages toohello backlog, one of these queues is randomly chosen.</span></span> <span data-ttu-id="ea7e7-215">如果您設定 hello 值 too1，只有一個佇列可以曾經使用。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-215">If you set hello value too1, then only one queue can ever be used.</span></span> <span data-ttu-id="ea7e7-216">當發生這種情況，hello 積存佇列產生錯誤時 hello 用戶端不能 tootry 不同的積存佇列，並可能會失敗 toosend 您的訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-216">When this happens and hello one backlog queue generates errors, hello client is not able tootry a different backlog queue and may fail toosend your message.</span></span> <span data-ttu-id="ea7e7-217">我們建議您設定此值 toosome 較大值和預設 hello 值 too10。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-217">We recommend setting this value toosome larger value and default hello value too10.</span></span> <span data-ttu-id="ea7e7-218">您可以變更此 tooa 較高或較低的值，視資料量而定每天傳送您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-218">You can change this tooa higher or lower value depending on how much data your application sends per day.</span></span> <span data-ttu-id="ea7e7-219">每個積存佇列可以阻擋 too5 GB 的訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-219">Each backlog queue can hold up too5 GB of messages.</span></span>
* <span data-ttu-id="ea7e7-220">*failoverInterval*: hello 一段期間將會接受 hello 主要命名空間上的失敗之前切換 toohello 次要命名空間中的任何單一實體的時間。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-220">*failoverInterval*: hello amount of time during which you will accept failures on hello primary namespace before switching any single entity over toohello secondary namespace.</span></span> <span data-ttu-id="ea7e7-221">容錯移轉會以逐一實體的方式進行。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-221">Failovers occur on an entity-by-entity basis.</span></span> <span data-ttu-id="ea7e7-222">單一命名空間中的實體經常留存在服務匯流排中的不同節點。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-222">Entities in a single namespace frequently live in different nodes within Service Bus.</span></span> <span data-ttu-id="ea7e7-223">某一個實體失敗不表示另一個實體也失敗。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-223">A failure in one entity does not imply a failure in another.</span></span> <span data-ttu-id="ea7e7-224">您可以將此值太[System.TimeSpan.Zero] [ System.TimeSpan.Zero] toofailover toohello 您第一次、 非暫時性失敗後立即次要。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-224">You can set this value too[System.TimeSpan.Zero][System.TimeSpan.Zero] toofailover toohello secondary immediately after your first, non-transient failure.</span></span> <span data-ttu-id="ea7e7-225">Hello 容錯移轉計時器觸發程序的失敗是否有任何[MessagingException] [ MessagingException]中的 hello [IsTransient] [ IsTransient]屬性為 false，或[System.TimeoutException][System.TimeoutException]。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-225">Failures that trigger hello failover timer are any [MessagingException][MessagingException] in which hello [IsTransient][IsTransient] property is false, or a [System.TimeoutException][System.TimeoutException].</span></span> <span data-ttu-id="ea7e7-226">其他例外狀況，例如[UnauthorizedAccessException] [ UnauthorizedAccessException]並不會造成容錯移轉，因為它們表示該 hello 用戶端設定不正確。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-226">Other exceptions, such as [UnauthorizedAccessException][UnauthorizedAccessException] do not cause failover, because they indicate that hello client is configured incorrectly.</span></span> <span data-ttu-id="ea7e7-227">A [ServerBusyException] [ ServerBusyException]不會致使容錯移轉由於 hello 正確模式為 toowait 10 秒，然後傳送 hello 訊息一次。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-227">A [ServerBusyException][ServerBusyException] does not cause failover because hello correct pattern is toowait 10 seconds, then send hello message again.</span></span>
* <span data-ttu-id="ea7e7-228">*enableSyphon*： 表示此特殊的配對應該也會虹吸 hello 次要命名空間後 toohello 主要命名空間中的訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-228">*enableSyphon*: Indicates that this particular pairing should also syphon messages from hello secondary namespace back toohello primary namespace.</span></span> <span data-ttu-id="ea7e7-229">一般情況下，傳送訊息的應用程式應該將此值太**false**; 接收訊息的應用程式應將此值設定太**true**。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-229">In general, applications that send messages should set this value too**false**; applications that receive messages should set this value too**true**.</span></span> <span data-ttu-id="ea7e7-230">hello 原因是，經常有較少的訊息接收端可比傳送的訊息。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-230">hello reason for this is that frequently, there are fewer message receivers than message senders.</span></span> <span data-ttu-id="ea7e7-231">根據 hello 接收者數目，您可以選擇 toohave 單一應用程式執行個體控制代碼 hello 虹吸工作。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-231">Depending on hello number of receivers, you can choose toohave a single application instance handle hello syphon duties.</span></span> <span data-ttu-id="ea7e7-232">使用許多接收端會牽涉到每個待處理項目佇列的計費。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-232">Using many receivers has billing implications for each backlog queue.</span></span>

<span data-ttu-id="ea7e7-233">toouse hello 程式碼，請建立主要[MessagingFactory] [ MessagingFactory]執行個體，次要[MessagingFactory] [ MessagingFactory]執行個體，次要資料庫[NamespaceManager] [ NamespaceManager]執行個體，和[SendAvailabilityPairedNamespaceOptions] [ SendAvailabilityPairedNamespaceOptions]執行個體。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-233">toouse hello code, create a primary [MessagingFactory][MessagingFactory] instance, a secondary [MessagingFactory][MessagingFactory] instance, a secondary [NamespaceManager][NamespaceManager] instance, and a [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance.</span></span> <span data-ttu-id="ea7e7-234">hello 呼叫很簡單，如下所示 hello:</span><span class="sxs-lookup"><span data-stu-id="ea7e7-234">hello call can be as simple as hello following:</span></span>

```csharp
SendAvailabilityPairedNamespaceOptions sendAvailabilityOptions = new SendAvailabilityPairedNamespaceOptions(secondaryNamespaceManager, secondary);
primary.PairNamespaceAsync(sendAvailabilityOptions).Wait();
```

<span data-ttu-id="ea7e7-235">當 hello hello 所傳回工作[PairNamespaceAsync] [ PairNamespaceAsync]方法完成、 設定和準備 toouse 的所有內容。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-235">When hello task returned by hello [PairNamespaceAsync][PairNamespaceAsync] method completes, everything is set up and ready toouse.</span></span> <span data-ttu-id="ea7e7-236">Hello 工作傳回前，您可能尚未完成所有 hello 背景工作所需的 hello 配對 toowork 權限。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-236">Before hello task is returned, you may not have completed all of hello background work necessary for hello pairing toowork right.</span></span> <span data-ttu-id="ea7e7-237">如此一來，您不應開始傳送訊息，直到 hello 工作傳回。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-237">As a result, you should not start sending messages until hello task returns.</span></span> <span data-ttu-id="ea7e7-238">如果發生任何失敗，例如認證錯誤或失敗 toocreate hello 待處理項目佇列 hello 工作完成之後將會擲回這些例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-238">If any failures occurred, such as bad credentials, or failure toocreate hello backlog queues, those exceptions will be thrown once hello task completes.</span></span> <span data-ttu-id="ea7e7-239">一旦傳回 hello 工作，確認已找到 hello 佇列，或藉由檢查 hello 建立[BacklogQueueCount] [ BacklogQueueCount]屬性您[SendAvailabilityPairedNamespaceOptions][ SendAvailabilityPairedNamespaceOptions]執行個體。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-239">Once hello task returns, verify that hello queues were found or created by examining hello [BacklogQueueCount][BacklogQueueCount] property on your [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance.</span></span> <span data-ttu-id="ea7e7-240">Hello 前面程式碼，該作業會出現，如下所示：</span><span class="sxs-lookup"><span data-stu-id="ea7e7-240">For hello preceding code, that operation appears as follows:</span></span>

```csharp
if (sendAvailabilityOptions.BacklogQueueCount < 1)
{
    // Handle case where no queues were created.
}
```

## <a name="next-steps"></a><span data-ttu-id="ea7e7-241">後續步驟</span><span class="sxs-lookup"><span data-stu-id="ea7e7-241">Next steps</span></span>
<span data-ttu-id="ea7e7-242">現在，您學到的非同步傳訊服務匯流排中的 hello 基本概念，閱讀更多詳細資料[配對命名空間][paired namespaces]。</span><span class="sxs-lookup"><span data-stu-id="ea7e7-242">Now that you've learned hello basics of asynchronous messaging in Service Bus, read more details about [paired namespaces][paired namespaces].</span></span>

[ServerBusyException]: /dotnet/api/microsoft.servicebus.messaging.serverbusyexception
[System.TimeoutException]: https://msdn.microsoft.com/library/system.timeoutexception.aspx
[MessagingException]: /dotnet/api/microsoft.servicebus.messaging.messagingexception
[Best practices for insulating applications against Service Bus outages and disasters]: service-bus-outages-disasters.md
[Microsoft.ServiceBus.Messaging.MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[MessageReceiver]: /dotnet/api/microsoft.servicebus.messaging.messagereceiver
[QueueClient]: /dotnet/api/microsoft.servicebus.messaging.queueclient
[TopicClient]: /dotnet/api/microsoft.servicebus.messaging.topicclient
[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.pairednamespaceoptions
[MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[SendAvailabilityPairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions
[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager
[PairNamespaceAsync]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_PairNamespaceAsync_Microsoft_ServiceBus_Messaging_PairedNamespaceOptions_
[EnableSyphon]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_EnableSyphon
[System.TimeSpan.Zero]: https://msdn.microsoft.com/library/system.timespan.zero.aspx
[IsTransient]: /dotnet/api/microsoft.servicebus.messaging.messagingexception#Microsoft_ServiceBus_Messaging_MessagingException_IsTransient
[UnauthorizedAccessException]: https://msdn.microsoft.com/library/system.unauthorizedaccessexception.aspx
[BacklogQueueCount]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_BacklogQueueCount
[paired namespaces]: service-bus-paired-namespaces.md
