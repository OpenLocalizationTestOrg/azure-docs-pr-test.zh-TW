---
title: "服務匯流排非同步傳訊 |Microsoft Docs"
description: "「Azure 服務匯流排」非同步傳訊說明。"
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: f1435549-e1f2-40cb-a280-64ea07b39fc7
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 04/19/2017
ms.author: sethm
ms.openlocfilehash: 95d6f295ba145a55fe4ed3fc7c6f627c9d419a3c
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="asynchronous-messaging-patterns-and-high-availability"></a><span data-ttu-id="98a98-103">非同步傳訊模式和高可用性</span><span class="sxs-lookup"><span data-stu-id="98a98-103">Asynchronous messaging patterns and high availability</span></span>

<span data-ttu-id="98a98-104">有各種不同的方式可以實作非同步傳訊。</span><span class="sxs-lookup"><span data-stu-id="98a98-104">Asynchronous messaging can be implemented in a variety of different ways.</span></span> <span data-ttu-id="98a98-105">「Azure 服務匯流排」利用佇列、主題及訂用帳戶來支援透過儲存和轉送機制進行的非同步處理。</span><span class="sxs-lookup"><span data-stu-id="98a98-105">With queues, topics, and subscriptions, Azure Service Bus supports asynchronism via a store and forward mechanism.</span></span> <span data-ttu-id="98a98-106">在正常 (同步) 作業中，您可將訊息傳送至佇列和主題，並接收來自佇列和訂用帳戶的訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-106">In normal (synchronous) operation, you send messages to queues and topics, and receive messages from queues and subscriptions.</span></span> <span data-ttu-id="98a98-107">您撰寫的應用程式依存於這些實體永遠可用。</span><span class="sxs-lookup"><span data-stu-id="98a98-107">Applications you write depend on these entities always being available.</span></span> <span data-ttu-id="98a98-108">當實體健康狀態變更時，因為有許多不同的情況，您必須有辦法提供能滿足大多數需求的容量減少實體。</span><span class="sxs-lookup"><span data-stu-id="98a98-108">When the entity health changes, due to a variety of circumstances, you need a way to provide a reduced capability entity that can satisfy most needs.</span></span>

<span data-ttu-id="98a98-109">應用程式通常會使用非同步傳訊模式來啟用一些通訊案例。</span><span class="sxs-lookup"><span data-stu-id="98a98-109">Applications typically use asynchronous messaging patterns to enable a number of communication scenarios.</span></span> <span data-ttu-id="98a98-110">您可以建置一個應用程式，讓用戶端可以傳送訊息至服務 (即使服務並未執行)。</span><span class="sxs-lookup"><span data-stu-id="98a98-110">You can build applications in which clients can send messages to services, even when the service is not running.</span></span> <span data-ttu-id="98a98-111">對於經歷通訊暴增的應用程式，佇列可提供一個緩衝通訊的地方，協助平穩負載。</span><span class="sxs-lookup"><span data-stu-id="98a98-111">For applications that experience bursts of communications, a queue can help level the load by providing a place to buffer communications.</span></span> <span data-ttu-id="98a98-112">最後，您可取得簡單但有效率的負載平衡器，將訊息分散於多部電腦上。</span><span class="sxs-lookup"><span data-stu-id="98a98-112">Finally, you can get a simple but effective load balancer to distribute messages across multiple machines.</span></span>

<span data-ttu-id="98a98-113">為了維護這些實體的可用性，請考慮讓這些實體對持久的傳訊系統呈現無法使用的各種不同方式。</span><span class="sxs-lookup"><span data-stu-id="98a98-113">In order to maintain availability of any of these entities, consider a number of different ways in which these entities can appear unavailable for a durable messaging system.</span></span> <span data-ttu-id="98a98-114">一般而言，我們會看到我們所撰寫的應用程式因下列情況而無法使用實體：</span><span class="sxs-lookup"><span data-stu-id="98a98-114">Generally speaking, we see the entity become unavailable to applications we write in the following different ways:</span></span>

* <span data-ttu-id="98a98-115">無法傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-115">Unable to send messages.</span></span>
* <span data-ttu-id="98a98-116">無法接收訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-116">Unable to receive messages.</span></span>
* <span data-ttu-id="98a98-117">無法管理實體 (建立、擷取、更新或刪除實體)。</span><span class="sxs-lookup"><span data-stu-id="98a98-117">Unable to manage entities (create, retrieve, update, or delete entities).</span></span>
* <span data-ttu-id="98a98-118">無法連絡服務。</span><span class="sxs-lookup"><span data-stu-id="98a98-118">Unable to contact the service.</span></span>

<span data-ttu-id="98a98-119">上述每個失敗有不同的失敗模式存在，可讓應用程式以降低某些能力的方式繼續執行工作。</span><span class="sxs-lookup"><span data-stu-id="98a98-119">For each of these failures, different failure modes exist that enable an application to continue to perform work at some level of reduced capability.</span></span> <span data-ttu-id="98a98-120">例如，可傳送訊息但不會收到訊息的系統仍可以接收來自客戶的訂單，但無法處理這些訂單。</span><span class="sxs-lookup"><span data-stu-id="98a98-120">For example, a system that can send messages but not receive them can still receive orders from customers but cannot process those orders.</span></span> <span data-ttu-id="98a98-121">本主題討論可能發生的潛在問題，以及如何減輕這些問題。</span><span class="sxs-lookup"><span data-stu-id="98a98-121">This topic discusses potential issues that can occur, and how those issues are mitigated.</span></span> <span data-ttu-id="98a98-122">服務匯流排已引進數個您必須選擇加入的緩和措施，而本主題也會討論以規則來控管使用這些選擇加入的緩和措施。</span><span class="sxs-lookup"><span data-stu-id="98a98-122">Service Bus has introduced a number of mitigations which you must opt into, and this topic also discusses the rules governing the use of those opt-in mitigations.</span></span>

## <a name="reliability-in-service-bus"></a><span data-ttu-id="98a98-123">服務匯流排的可靠性</span><span class="sxs-lookup"><span data-stu-id="98a98-123">Reliability in Service Bus</span></span>
<span data-ttu-id="98a98-124">有數種方法可以處理訊息和實體問題，而且有用來控管適當使用這些緩和措施的指導方針。</span><span class="sxs-lookup"><span data-stu-id="98a98-124">There are several ways to handle message and entity issues, and there are guidelines governing the appropriate use of those mitigations.</span></span> <span data-ttu-id="98a98-125">若要了解這些指導方針，您必須先了解服務匯流排中可能發生何種失敗。</span><span class="sxs-lookup"><span data-stu-id="98a98-125">To understand the guidelines, you must first understand what can fail in Service Bus.</span></span> <span data-ttu-id="98a98-126">由於 Azure 系統的設計，所有這些問題通常都很短暫。</span><span class="sxs-lookup"><span data-stu-id="98a98-126">Due to the design of Azure systems, all of these issues tend to be short-lived.</span></span> <span data-ttu-id="98a98-127">概括而言，無法使用的各種原因如下︰</span><span class="sxs-lookup"><span data-stu-id="98a98-127">At a high level, the different causes of unavailability appear as follows:</span></span>

* <span data-ttu-id="98a98-128">從服務匯流排所依賴的外部系統節流。</span><span class="sxs-lookup"><span data-stu-id="98a98-128">Throttling from an external system on which Service Bus depends.</span></span> <span data-ttu-id="98a98-129">從與儲存體和運算資源的互動進行節流。</span><span class="sxs-lookup"><span data-stu-id="98a98-129">Throttling occurs from interactions with storage and compute resources.</span></span>
* <span data-ttu-id="98a98-130">服務匯流排所依賴系統的問題。</span><span class="sxs-lookup"><span data-stu-id="98a98-130">Issue for a system on which Service Bus depends.</span></span> <span data-ttu-id="98a98-131">例如，指定的儲存體部份可能會發生問題。</span><span class="sxs-lookup"><span data-stu-id="98a98-131">For example, a given part of storage can encounter issues.</span></span>
* <span data-ttu-id="98a98-132">單一子系統上的服務匯流排失敗。</span><span class="sxs-lookup"><span data-stu-id="98a98-132">Failure of Service Bus on single subsystem.</span></span> <span data-ttu-id="98a98-133">在此情況下，運算節點可進入不一致的狀態且本身必須重新啟動，導致它提供的所有實體平衡其他節點的負載。</span><span class="sxs-lookup"><span data-stu-id="98a98-133">In this situation, a compute node can get into an inconsistent state and must restart itself, causing all entities it serves to load balance to other nodes.</span></span> <span data-ttu-id="98a98-134">這又會導致短期內的訊息處理速度緩慢。</span><span class="sxs-lookup"><span data-stu-id="98a98-134">This in turn can cause a short period of slow message processing.</span></span>
* <span data-ttu-id="98a98-135">Azure 資料中心內的服務匯流排失敗。</span><span class="sxs-lookup"><span data-stu-id="98a98-135">Failure of Service Bus within an Azure datacenter.</span></span> <span data-ttu-id="98a98-136">這就是「災難性失敗」，系統有數分鐘或數小時的時間無法連線。</span><span class="sxs-lookup"><span data-stu-id="98a98-136">This is a "catastrophic failure" during which the system is unreachable for many minutes or a few hours.</span></span>

> [!NOTE]
> <span data-ttu-id="98a98-137">「儲存體」一詞可表示 Azure 儲存體和 SQL Azure。</span><span class="sxs-lookup"><span data-stu-id="98a98-137">The term **storage** can mean both Azure Storage and SQL Azure.</span></span>
> 
> 

<span data-ttu-id="98a98-138">對於這些問題，服務匯流排有數種緩和措施。</span><span class="sxs-lookup"><span data-stu-id="98a98-138">Service Bus contains a number of mitigations for these issues.</span></span> <span data-ttu-id="98a98-139">下列各節會討論每個問題及其各自的緩和措施。</span><span class="sxs-lookup"><span data-stu-id="98a98-139">The following sections discuss each issue and their respective mitigations.</span></span>

### <a name="throttling"></a><span data-ttu-id="98a98-140">節流</span><span class="sxs-lookup"><span data-stu-id="98a98-140">Throttling</span></span>
<span data-ttu-id="98a98-141">使用服務匯流排，節流可達到協同合作的訊息速率管理。</span><span class="sxs-lookup"><span data-stu-id="98a98-141">With Service Bus, throttling enables cooperative message rate management.</span></span> <span data-ttu-id="98a98-142">每個個別的服務匯流排節點都容納許多實體。</span><span class="sxs-lookup"><span data-stu-id="98a98-142">Each individual Service Bus node houses many entities.</span></span> <span data-ttu-id="98a98-143">每個實體都是從 CPU、記憶體、儲存體和其他面向提出系統需求。</span><span class="sxs-lookup"><span data-stu-id="98a98-143">Each of those entities makes demands on the system in terms of CPU, memory, storage, and other facets.</span></span> <span data-ttu-id="98a98-144">當上述任何面向偵測到超出所定義臨界值的使用量時，服務匯流排可以拒絕指定的要求。</span><span class="sxs-lookup"><span data-stu-id="98a98-144">When any of these facets detects usage that exceeds defined thresholds, Service Bus can deny a given request.</span></span> <span data-ttu-id="98a98-145">呼叫端會收到 [ServerBusyException][ServerBusyException] 並在 10 秒後重試。</span><span class="sxs-lookup"><span data-stu-id="98a98-145">The caller receives a [ServerBusyException][ServerBusyException] and retries after 10 seconds.</span></span>

<span data-ttu-id="98a98-146">在緩和措施中，程式碼必須讀取錯誤並停止任何訊息重試至少 10 秒。</span><span class="sxs-lookup"><span data-stu-id="98a98-146">As a mitigation, the code must read the error and halt any retries of the message for at least 10 seconds.</span></span> <span data-ttu-id="98a98-147">因為此錯誤會發生於客戶應用程式的各個部分，因此預計每個部分都能獨立執行重試邏輯。</span><span class="sxs-lookup"><span data-stu-id="98a98-147">Since the error can happen across pieces of the customer application, it is expected that each piece independently executes the retry logic.</span></span> <span data-ttu-id="98a98-148">此程式碼可藉由在佇列或主題上啟用資料分割，以降低進行節流的機率。</span><span class="sxs-lookup"><span data-stu-id="98a98-148">The code can reduce the probability of being throttled by enabling partitioning on a queue or topic.</span></span>

### <a name="issue-for-an-azure-dependency"></a><span data-ttu-id="98a98-149">Azure 相依性問題</span><span class="sxs-lookup"><span data-stu-id="98a98-149">Issue for an Azure dependency</span></span>
<span data-ttu-id="98a98-150">Azure 中的其他元件可能會不時出現服務問題。</span><span class="sxs-lookup"><span data-stu-id="98a98-150">Other components within Azure can occasionally have service issues.</span></span> <span data-ttu-id="98a98-151">例如，當服務匯流排使用的系統正在升級時，該系統可能會暫時經歷降低的功能。</span><span class="sxs-lookup"><span data-stu-id="98a98-151">For example, when a system that Service Bus uses is being upgraded, that system can temporarily experience reduced capabilities.</span></span> <span data-ttu-id="98a98-152">若要解決這幾類問題，服務匯流排會定期調查並實作緩和措施。</span><span class="sxs-lookup"><span data-stu-id="98a98-152">To work around these types of issues, Service Bus regularly investigates and implements mitigations.</span></span> <span data-ttu-id="98a98-153">這些緩和措施的確會出現副作用。</span><span class="sxs-lookup"><span data-stu-id="98a98-153">Side effects of these mitigations do appear.</span></span> <span data-ttu-id="98a98-154">例如，若要處理儲存體的暫時性問題，服務匯流排會實作可讓訊息傳送作業以一致的方式運作的系統。</span><span class="sxs-lookup"><span data-stu-id="98a98-154">For example, to handle transient issues with storage, Service Bus implements a system that allows message send operations to work consistently.</span></span> <span data-ttu-id="98a98-155">基於緩和措施的本質，傳送的訊息可能需要 15 分鐘的時間才會出現在受影響的佇列或訂用帳戶中，而可供進行接收作業。</span><span class="sxs-lookup"><span data-stu-id="98a98-155">Due to the nature of the mitigation, a sent message can take up to 15 minutes to appear in the affected queue or subscription and be ready for a receive operation.</span></span> <span data-ttu-id="98a98-156">一般而言，大部分實體不會發生這個問題。</span><span class="sxs-lookup"><span data-stu-id="98a98-156">Generally speaking, most entities will not experience this issue.</span></span> <span data-ttu-id="98a98-157">不過，基於 Azure 內服務匯流排中的實體數目，有一小部分的服務匯流排客戶有時會需要此緩和措施。</span><span class="sxs-lookup"><span data-stu-id="98a98-157">However, given the number of entities in Service Bus within Azure, this mitigation is sometimes needed for a small subset of Service Bus customers.</span></span>

### <a name="service-bus-failure-on-a-single-subsystem"></a><span data-ttu-id="98a98-158">單一子系統上的服務匯流排失敗</span><span class="sxs-lookup"><span data-stu-id="98a98-158">Service Bus failure on a single subsystem</span></span>
<span data-ttu-id="98a98-159">在任何應用程式中，有些情況會導致服務匯流排的內部元件變得不一致。</span><span class="sxs-lookup"><span data-stu-id="98a98-159">With any application, circumstances can cause an internal component of Service Bus to become inconsistent.</span></span> <span data-ttu-id="98a98-160">當服務匯流排偵測到這種情況時，它會從應用程式收集資料以協助診斷發生什麼狀況。</span><span class="sxs-lookup"><span data-stu-id="98a98-160">When Service Bus detects this, it collects data from the application to aid in diagnosing what happened.</span></span> <span data-ttu-id="98a98-161">收集資料後，應用程式會在嘗試回到一致狀態時重新啟動。</span><span class="sxs-lookup"><span data-stu-id="98a98-161">Once the data is collected, the application is restarted in an attempt to return it to a consistent state.</span></span> <span data-ttu-id="98a98-162">這個程序非常迅速地發生，而且會導致實體呈現無法使用長達數分鐘，然而一般的停機時間短很多。</span><span class="sxs-lookup"><span data-stu-id="98a98-162">This process happens fairly quickly, and results in an entity appearing to be unavailable for up to a few minutes, though typical down times are much shorter.</span></span>

<span data-ttu-id="98a98-163">在這些情況下，用戶端應用程式會產生 [System.TimeoutException][System.TimeoutException] 或 [MessagingException][MessagingException] 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="98a98-163">In these cases, the client application generates a [System.TimeoutException][System.TimeoutException] or [MessagingException][MessagingException] exception.</span></span> <span data-ttu-id="98a98-164">服務匯流排包含此問題的緩和措施 (採用自動用戶端重試邏輯形式)。</span><span class="sxs-lookup"><span data-stu-id="98a98-164">Service Bus contains a mitigation for this issue in the form of automated client retry logic.</span></span> <span data-ttu-id="98a98-165">一旦重試期間期滿又未傳遞訊息，您便可以使用[配對的命名空間][paired namespaces]等其他功能來進行探索。</span><span class="sxs-lookup"><span data-stu-id="98a98-165">Once the retry period is exhausted and the message is not delivered, you can explore using other features such as [paired namespaces][paired namespaces].</span></span> <span data-ttu-id="98a98-166">配對的命名空間有其他需要的注意事項 (請見該文章中的討論)。</span><span class="sxs-lookup"><span data-stu-id="98a98-166">Paired namespaces have other caveats that are discussed in that article.</span></span>

### <a name="failure-of-service-bus-within-an-azure-datacenter"></a><span data-ttu-id="98a98-167">Azure 資料中心內的服務匯流排失敗</span><span class="sxs-lookup"><span data-stu-id="98a98-167">Failure of Service Bus within an Azure datacenter</span></span>
<span data-ttu-id="98a98-168">Azure 資料中心失敗的最可能原因是服務匯流排或相依系統的升級部署失敗。</span><span class="sxs-lookup"><span data-stu-id="98a98-168">The most probable reason for a failure in an Azure datacenter is a failed upgrade deployment of Service Bus or a dependent system.</span></span> <span data-ttu-id="98a98-169">隨著平台日趨成熟，這種失敗的可能性已大幅降低。</span><span class="sxs-lookup"><span data-stu-id="98a98-169">As the platform has matured, the likelihood of this type of failure has diminished.</span></span> <span data-ttu-id="98a98-170">發生資料中心失敗的原因也可能包含下列因素︰</span><span class="sxs-lookup"><span data-stu-id="98a98-170">A datacenter failure can also happen for reasons that include the following:</span></span>

* <span data-ttu-id="98a98-171">電力中斷 (電源和供電失效)。</span><span class="sxs-lookup"><span data-stu-id="98a98-171">Electrical outage (power supply and generating power disappear).</span></span>
* <span data-ttu-id="98a98-172">連線 (用戶端與 Azure 之間的網際網路中斷)。</span><span class="sxs-lookup"><span data-stu-id="98a98-172">Connectivity (internet break between your clients and Azure).</span></span>

<span data-ttu-id="98a98-173">在這兩種情況下，自然或人為災難都會造成此問題。</span><span class="sxs-lookup"><span data-stu-id="98a98-173">In both cases, a natural or man-made disaster caused the issue.</span></span> <span data-ttu-id="98a98-174">若要解決這個問題並確保您仍可傳送訊息，您可以使用[配對的命名空間][paired namespaces]，以允許在主要位置再次恢復良好狀況的期間，先將訊息傳送到次要位置。</span><span class="sxs-lookup"><span data-stu-id="98a98-174">To work around this and make sure that you can still send messages, you can use [paired namespaces][paired namespaces] to enable messages to be sent to a second location while the primary location is made healthy again.</span></span> <span data-ttu-id="98a98-175">如需詳細資訊，請參閱[將應用程式與服務匯流排中斷和災難隔絕的最佳做法 (英文)][Best practices for insulating applications against Service Bus outages and disasters]。</span><span class="sxs-lookup"><span data-stu-id="98a98-175">For more information, see [Best practices for insulating applications against Service Bus outages and disasters][Best practices for insulating applications against Service Bus outages and disasters].</span></span>

## <a name="paired-namespaces"></a><span data-ttu-id="98a98-176">配對的命名空間</span><span class="sxs-lookup"><span data-stu-id="98a98-176">Paired namespaces</span></span>
<span data-ttu-id="98a98-177">[配對的命名空間][paired namespaces]功能支援下列案例︰資料中心內的「服務匯流排」實體或部署變得無法使用。</span><span class="sxs-lookup"><span data-stu-id="98a98-177">The [paired namespaces][paired namespaces] feature supports scenarios in which a Service Bus entity or deployment within a data center becomes unavailable.</span></span> <span data-ttu-id="98a98-178">雖然此事件不常發生，但分散式系統仍然必須準備好處理情況最糟的案例。</span><span class="sxs-lookup"><span data-stu-id="98a98-178">While this event occurs infrequently, distributed systems still must be prepared to handle worst case scenarios.</span></span> <span data-ttu-id="98a98-179">通常會因為服務匯流排所依賴的某個元素遇到短期問題而發生此事件。</span><span class="sxs-lookup"><span data-stu-id="98a98-179">Typically, this event happens because some element on which Service Bus depends is experiencing a short-term issue.</span></span> <span data-ttu-id="98a98-180">為了維護中斷期間的應用程式可用性，服務匯流排使用者可以使用兩個不同的命名空間 (最好位於不同的資料中心) 來裝載其傳訊實體。</span><span class="sxs-lookup"><span data-stu-id="98a98-180">To maintain application availability during an outage, Service Bus users can use two separate namespaces, preferably in separate data centers, to host their messaging entities.</span></span> <span data-ttu-id="98a98-181">本節的其餘部分使用下列術語：</span><span class="sxs-lookup"><span data-stu-id="98a98-181">The remainder of this section uses the following terminology:</span></span>

* <span data-ttu-id="98a98-182">主要命名空間︰與您的應用程式互動進行傳送和接收作業的命名空間。</span><span class="sxs-lookup"><span data-stu-id="98a98-182">Primary namespace: The namespace with which your application interacts, for send and receive operations.</span></span>
* <span data-ttu-id="98a98-183">次要命名空間: 做為主要命名空間之備份的命名空間。</span><span class="sxs-lookup"><span data-stu-id="98a98-183">Secondary namespace: The namespace that acts as a backup to the primary namespace.</span></span> <span data-ttu-id="98a98-184">應用程式邏輯不會與此命名空間互動。</span><span class="sxs-lookup"><span data-stu-id="98a98-184">Application logic does not interact with this namespace.</span></span>
* <span data-ttu-id="98a98-185">容錯移轉間隔︰在應用程式從主要命名空間切換至次要命名空間之前接受正常失敗的時間量。</span><span class="sxs-lookup"><span data-stu-id="98a98-185">Failover interval: The amount of time to accept normal failures before the application switches from the primary namespace to the secondary namespace.</span></span>

<span data-ttu-id="98a98-186">配對的命名空間支援「傳送可用性」。</span><span class="sxs-lookup"><span data-stu-id="98a98-186">Paired namespaces support *send availability*.</span></span> <span data-ttu-id="98a98-187">傳送可用性保留了傳送訊息的能力。</span><span class="sxs-lookup"><span data-stu-id="98a98-187">Send availability preserves the ability to send messages.</span></span> <span data-ttu-id="98a98-188">若要使用傳送可用性，您的應用程式必須符合下列需求：</span><span class="sxs-lookup"><span data-stu-id="98a98-188">To use send availability, your application must meet the following requirements:</span></span>

1. <span data-ttu-id="98a98-189">只會從主要命名空間接收訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-189">Messages are only received from the primary namespace.</span></span>
2. <span data-ttu-id="98a98-190">傳送到指定佇列或主題的訊息可能不會按順序抵達。</span><span class="sxs-lookup"><span data-stu-id="98a98-190">Messages sent to a given queue or topic might arrive out of order.</span></span>
3. <span data-ttu-id="98a98-191">工作階段內的訊息可能不會按順序抵達。</span><span class="sxs-lookup"><span data-stu-id="98a98-191">Messages within a session might arrive out of order.</span></span> <span data-ttu-id="98a98-192">這是工作階段的正常功能毀損。</span><span class="sxs-lookup"><span data-stu-id="98a98-192">This is a break from normal functionality of sessions.</span></span> <span data-ttu-id="98a98-193">這表示您的應用程式會使用工作階段以邏輯方式群組訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-193">This means that your application uses sessions to logically group messages.</span></span>
4. <span data-ttu-id="98a98-194">只會在主要命名空間上維護工作階段狀態。</span><span class="sxs-lookup"><span data-stu-id="98a98-194">Session state is only maintained on the primary namespace.</span></span>
5. <span data-ttu-id="98a98-195">在次要佇列將所有訊息傳遞至主要佇列之前，主要佇列可以上線並開始接受訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-195">The primary queue can come online and start accepting messages before the secondary queue delivers all messages into the primary queue.</span></span>

<span data-ttu-id="98a98-196">下列各節討論 API、如何實作 API 以及顯示使用此功能的範例程式碼。</span><span class="sxs-lookup"><span data-stu-id="98a98-196">The following sections discuss the APIs, how the APIs are implemented, and shows sample code that uses the feature.</span></span> <span data-ttu-id="98a98-197">請注意，這項功能有相關聯的計費暗示。</span><span class="sxs-lookup"><span data-stu-id="98a98-197">Note that there are billing implications associated with this feature.</span></span>

### <a name="the-messagingfactorypairnamespaceasync-api"></a><span data-ttu-id="98a98-198">MessagingFactory.PairNamespaceAsync API</span><span class="sxs-lookup"><span data-stu-id="98a98-198">The MessagingFactory.PairNamespaceAsync API</span></span>
<span data-ttu-id="98a98-199">配對的命名空間功能會在 [Microsoft.ServiceBus.Messaging.MessagingFactory][Microsoft.ServiceBus.Messaging.MessagingFactory] 類別上包含 [PairNamespaceAsync][PairNamespaceAsync] 方法：</span><span class="sxs-lookup"><span data-stu-id="98a98-199">The paired namespaces feature includes the [PairNamespaceAsync][PairNamespaceAsync] method on the [Microsoft.ServiceBus.Messaging.MessagingFactory][Microsoft.ServiceBus.Messaging.MessagingFactory] class:</span></span>

```csharp
public Task PairNamespaceAsync(PairedNamespaceOptions options);
```

<span data-ttu-id="98a98-200">當工作完成時，命名空間配對也會完成，而可供任何使用 [MessagingFactory][MessagingFactory] 執行個體建立的 [MessageReceiver][MessageReceiver]、[QueueClient][QueueClient] 或 [TopicClient][TopicClient] 採取動作。</span><span class="sxs-lookup"><span data-stu-id="98a98-200">When the task completes, the namespace pairing is also complete and ready to act upon for any [MessageReceiver][MessageReceiver], [QueueClient][QueueClient], or [TopicClient][TopicClient] created with the [MessagingFactory][MessagingFactory] instance.</span></span> <span data-ttu-id="98a98-201">[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions][Microsoft.ServiceBus.Messaging.PairedNamespaceOptions] 是 [MessagingFactory][MessagingFactory] 物件所提供的不同配對類型的基底類別。</span><span class="sxs-lookup"><span data-stu-id="98a98-201">[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions][Microsoft.ServiceBus.Messaging.PairedNamespaceOptions] is the base class for the different types of pairing that are available with a [MessagingFactory][MessagingFactory] object.</span></span> <span data-ttu-id="98a98-202">目前，唯一的衍生類別是名為 [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] 的類別，它會實作傳送可用性需求。</span><span class="sxs-lookup"><span data-stu-id="98a98-202">Currently, the only derived class is one named [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions], which implements the send availability requirements.</span></span> <span data-ttu-id="98a98-203">[SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] 有一組建立在彼此之上的建構函式。</span><span class="sxs-lookup"><span data-stu-id="98a98-203">[SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] has a set of constructors that build on each other.</span></span> <span data-ttu-id="98a98-204">查看具有大部份參數的建構函式，以便了解其他建構函式的行為。</span><span class="sxs-lookup"><span data-stu-id="98a98-204">Looking at the constructor with the most parameters, you can understand the behavior of the other constructors.</span></span>

```csharp
public SendAvailabilityPairedNamespaceOptions(
    NamespaceManager secondaryNamespaceManager,
    MessagingFactory messagingFactory,
    int backlogQueueCount,
    TimeSpan failoverInterval,
    bool enableSyphon)
```

<span data-ttu-id="98a98-205">這些參數具有下列意義：</span><span class="sxs-lookup"><span data-stu-id="98a98-205">These parameters have the following meanings:</span></span>

* <span data-ttu-id="98a98-206">*secondaryNamespaceManager*：次要命名空間的已初始化 [NamespaceManager][NamespaceManager] 執行個體，可供 [PairNamespaceAsync][PairNamespaceAsync] 方法用來設定次要命名空間。</span><span class="sxs-lookup"><span data-stu-id="98a98-206">*secondaryNamespaceManager*: An initialized [NamespaceManager][NamespaceManager] instance for the secondary namespace that the [PairNamespaceAsync][PairNamespaceAsync] method can use to set up the secondary namespace.</span></span> <span data-ttu-id="98a98-207">命名空間管理員會用來取得命名空間中的佇列清單，並確定必要的待處理項目佇列存在。</span><span class="sxs-lookup"><span data-stu-id="98a98-207">The namespace manager is used to obtain the list of queues in the namespace and to make sure that the required backlog queues exist.</span></span> <span data-ttu-id="98a98-208">如果這些佇列不存在，則會加以建立。</span><span class="sxs-lookup"><span data-stu-id="98a98-208">If those queues do not exist, they are created.</span></span> <span data-ttu-id="98a98-209">[NamespaceManager][NamespaceManager] 必須要能夠使用 **Manage** 宣告來建立權杖。</span><span class="sxs-lookup"><span data-stu-id="98a98-209">[NamespaceManager][NamespaceManager] requires the ability to create a token with the **Manage** claim.</span></span>
* <span data-ttu-id="98a98-210">*messagingFactory*︰次要命名空間的 [MessagingFactory][MessagingFactory] 執行個體。</span><span class="sxs-lookup"><span data-stu-id="98a98-210">*messagingFactory*: The [MessagingFactory][MessagingFactory] instance for the secondary namespace.</span></span> <span data-ttu-id="98a98-211">[MessagingFactory][MessagingFactory] 物件可用來將訊息傳送給積存佇列，而如果 [EnableSyphon][EnableSyphon] 屬性設定為 **true**，還可從該積存佇列接收訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-211">The [MessagingFactory][MessagingFactory] object is used to send and, if the [EnableSyphon][EnableSyphon] property is set to **true**, receive messages from the backlog queues.</span></span>
* <span data-ttu-id="98a98-212">*backlogQueueCount*︰要建立的積存佇列數目。</span><span class="sxs-lookup"><span data-stu-id="98a98-212">*backlogQueueCount*: The number of backlog queues to create.</span></span> <span data-ttu-id="98a98-213">此值必須至少為 1。</span><span class="sxs-lookup"><span data-stu-id="98a98-213">This value must be at least 1.</span></span> <span data-ttu-id="98a98-214">將訊息傳送至待處理項目時，會隨機選擇其中一個佇列。</span><span class="sxs-lookup"><span data-stu-id="98a98-214">When sending messages to the backlog, one of these queues is randomly chosen.</span></span> <span data-ttu-id="98a98-215">如果您將此值設定為 1，則只能使用一個佇列。</span><span class="sxs-lookup"><span data-stu-id="98a98-215">If you set the value to 1, then only one queue can ever be used.</span></span> <span data-ttu-id="98a98-216">當發生此情況且這一個積存佇列產生錯誤時，用戶端便無法嘗試不同的積存佇列，而可能無法傳送您的訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-216">When this happens and the one backlog queue generates errors, the client is not able to try a different backlog queue and may fail to send your message.</span></span> <span data-ttu-id="98a98-217">我們建議將此值設定為較大的值並將此值預設為 10。</span><span class="sxs-lookup"><span data-stu-id="98a98-217">We recommend setting this value to some larger value and default the value to 10.</span></span> <span data-ttu-id="98a98-218">視您的應用程式每天傳送的資料量而定，您可以將此值變更為較大或較小的值。</span><span class="sxs-lookup"><span data-stu-id="98a98-218">You can change this to a higher or lower value depending on how much data your application sends per day.</span></span> <span data-ttu-id="98a98-219">每個待處理項目佇列最多可以保留 5 GB 的訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-219">Each backlog queue can hold up to 5 GB of messages.</span></span>
* <span data-ttu-id="98a98-220">*failoverInterval*︰將任何單一實體切換至次要命名空間之前，您接受主要命名空間失敗的時間量。</span><span class="sxs-lookup"><span data-stu-id="98a98-220">*failoverInterval*: The amount of time during which you will accept failures on the primary namespace before switching any single entity over to the secondary namespace.</span></span> <span data-ttu-id="98a98-221">容錯移轉會以逐一實體的方式進行。</span><span class="sxs-lookup"><span data-stu-id="98a98-221">Failovers occur on an entity-by-entity basis.</span></span> <span data-ttu-id="98a98-222">單一命名空間中的實體經常留存在服務匯流排中的不同節點。</span><span class="sxs-lookup"><span data-stu-id="98a98-222">Entities in a single namespace frequently live in different nodes within Service Bus.</span></span> <span data-ttu-id="98a98-223">某一個實體失敗不表示另一個實體也失敗。</span><span class="sxs-lookup"><span data-stu-id="98a98-223">A failure in one entity does not imply a failure in another.</span></span> <span data-ttu-id="98a98-224">您可以將此值設定為 [System.TimeSpan.Zero][System.TimeSpan.Zero]，以在您的第一個非暫時性失敗後，立即容錯移轉至次要命名空間。</span><span class="sxs-lookup"><span data-stu-id="98a98-224">You can set this value to [System.TimeSpan.Zero][System.TimeSpan.Zero] to failover to the secondary immediately after your first, non-transient failure.</span></span> <span data-ttu-id="98a98-225">觸發容錯移轉計時器的失敗是 [IsTransient][IsTransient] 屬性為 false 的任何 [MessagingException][MessagingException]，或是 [System.TimeoutException][System.TimeoutException]。</span><span class="sxs-lookup"><span data-stu-id="98a98-225">Failures that trigger the failover timer are any [MessagingException][MessagingException] in which the [IsTransient][IsTransient] property is false, or a [System.TimeoutException][System.TimeoutException].</span></span> <span data-ttu-id="98a98-226">其他例外狀況 (例如 [UnauthorizedAccessException][UnauthorizedAccessException]) 並不會導致容錯移轉，因為它們表示的是用戶端設定不正確。</span><span class="sxs-lookup"><span data-stu-id="98a98-226">Other exceptions, such as [UnauthorizedAccessException][UnauthorizedAccessException] do not cause failover, because they indicate that the client is configured incorrectly.</span></span> <span data-ttu-id="98a98-227">[ServerBusyException][ServerBusyException] 不會導致容錯移轉，因為正確的模式是等待 10 秒鐘，然後重新傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-227">A [ServerBusyException][ServerBusyException] does not cause failover because the correct pattern is to wait 10 seconds, then send the message again.</span></span>
* <span data-ttu-id="98a98-228">*enableSyphon*︰表示此特殊的配對應該也會將訊息從次要命名空間擷取回主要命名空間。</span><span class="sxs-lookup"><span data-stu-id="98a98-228">*enableSyphon*: Indicates that this particular pairing should also syphon messages from the secondary namespace back to the primary namespace.</span></span> <span data-ttu-id="98a98-229">一般而言，傳送訊息的應用程式應將此值設定為 **false**；接收訊息的應用程式應將此值設定為 **true**。</span><span class="sxs-lookup"><span data-stu-id="98a98-229">In general, applications that send messages should set this value to **false**; applications that receive messages should set this value to **true**.</span></span> <span data-ttu-id="98a98-230">原因是訊息接收端通常比訊息傳送端少。</span><span class="sxs-lookup"><span data-stu-id="98a98-230">The reason for this is that frequently, there are fewer message receivers than message senders.</span></span> <span data-ttu-id="98a98-231">視接收端的數目而定，您可以選擇讓單一應用程式執行個體處理 Syphon 職責。</span><span class="sxs-lookup"><span data-stu-id="98a98-231">Depending on the number of receivers, you can choose to have a single application instance handle the syphon duties.</span></span> <span data-ttu-id="98a98-232">使用許多接收端會牽涉到每個待處理項目佇列的計費。</span><span class="sxs-lookup"><span data-stu-id="98a98-232">Using many receivers has billing implications for each backlog queue.</span></span>

<span data-ttu-id="98a98-233">若要使用程式碼，請建立主要 [MessagingFactory][MessagingFactory] 執行個體、次要 [MessagingFactory][MessagingFactory] 執行個體、次要 [NamespaceManager][NamespaceManager] 執行個體和 [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] 執行個體。</span><span class="sxs-lookup"><span data-stu-id="98a98-233">To use the code, create a primary [MessagingFactory][MessagingFactory] instance, a secondary [MessagingFactory][MessagingFactory] instance, a secondary [NamespaceManager][NamespaceManager] instance, and a [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance.</span></span> <span data-ttu-id="98a98-234">呼叫很簡單，如下所示：</span><span class="sxs-lookup"><span data-stu-id="98a98-234">The call can be as simple as the following:</span></span>

```csharp
SendAvailabilityPairedNamespaceOptions sendAvailabilityOptions = new SendAvailabilityPairedNamespaceOptions(secondaryNamespaceManager, secondary);
primary.PairNamespaceAsync(sendAvailabilityOptions).Wait();
```

<span data-ttu-id="98a98-235">當 [PairNamespaceAsync][PairNamespaceAsync] 方法所傳回的工作完成時，即表示所有項目都已設定妥當並可供使用。</span><span class="sxs-lookup"><span data-stu-id="98a98-235">When the task returned by the [PairNamespaceAsync][PairNamespaceAsync] method completes, everything is set up and ready to use.</span></span> <span data-ttu-id="98a98-236">傳回工作之前，您可能尚未完成配對正常運作所需的所有背景工作。</span><span class="sxs-lookup"><span data-stu-id="98a98-236">Before the task is returned, you may not have completed all of the background work necessary for the pairing to work right.</span></span> <span data-ttu-id="98a98-237">因此，直到工作傳回時，您才能開始傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="98a98-237">As a result, you should not start sending messages until the task returns.</span></span> <span data-ttu-id="98a98-238">如果發生任何失敗，例如認證錯誤或無法建立待處理項目佇列，則會在工作完成時立即擲回這些例外狀況。</span><span class="sxs-lookup"><span data-stu-id="98a98-238">If any failures occurred, such as bad credentials, or failure to create the backlog queues, those exceptions will be thrown once the task completes.</span></span> <span data-ttu-id="98a98-239">在工作傳回後，請檢查 [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] 執行個體上的 [BacklogQueueCount][BacklogQueueCount] 屬性，以確認已找到或建立佇列。</span><span class="sxs-lookup"><span data-stu-id="98a98-239">Once the task returns, verify that the queues were found or created by examining the [BacklogQueueCount][BacklogQueueCount] property on your [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance.</span></span> <span data-ttu-id="98a98-240">對於前面的程式碼，該作業會顯示如下:</span><span class="sxs-lookup"><span data-stu-id="98a98-240">For the preceding code, that operation appears as follows:</span></span>

```csharp
if (sendAvailabilityOptions.BacklogQueueCount < 1)
{
    // Handle case where no queues were created.
}
```

## <a name="next-steps"></a><span data-ttu-id="98a98-241">後續步驟</span><span class="sxs-lookup"><span data-stu-id="98a98-241">Next steps</span></span>
<span data-ttu-id="98a98-242">既然您已了解服務匯流排中非同步傳訊的基本概念，請閱讀[配對的命名空間][paired namespaces]以取得更多詳細資料。</span><span class="sxs-lookup"><span data-stu-id="98a98-242">Now that you've learned the basics of asynchronous messaging in Service Bus, read more details about [paired namespaces][paired namespaces].</span></span>

[ServerBusyException]: /dotnet/api/microsoft.servicebus.messaging.serverbusyexception
[System.TimeoutException]: https://msdn.microsoft.com/library/system.timeoutexception.aspx
[MessagingException]: /dotnet/api/microsoft.servicebus.messaging.messagingexception
[Best practices for insulating applications against Service Bus outages and disasters]: service-bus-outages-disasters.md
[Microsoft.ServiceBus.Messaging.MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[MessageReceiver]: /dotnet/api/microsoft.servicebus.messaging.messagereceiver
[QueueClient]: /dotnet/api/microsoft.servicebus.messaging.queueclient
[TopicClient]: /dotnet/api/microsoft.servicebus.messaging.topicclient
[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.pairednamespaceoptions
[MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[SendAvailabilityPairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions
[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager
[PairNamespaceAsync]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_PairNamespaceAsync_Microsoft_ServiceBus_Messaging_PairedNamespaceOptions_
[EnableSyphon]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_EnableSyphon
[System.TimeSpan.Zero]: https://msdn.microsoft.com/library/system.timespan.zero.aspx
[IsTransient]: /dotnet/api/microsoft.servicebus.messaging.messagingexception#Microsoft_ServiceBus_Messaging_MessagingException_IsTransient
[UnauthorizedAccessException]: https://msdn.microsoft.com/library/system.unauthorizedaccessexception.aspx
[BacklogQueueCount]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_BacklogQueueCount
[paired namespaces]: service-bus-paired-namespaces.md
