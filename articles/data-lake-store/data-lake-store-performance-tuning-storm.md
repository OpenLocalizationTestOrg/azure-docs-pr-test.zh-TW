---
title: "aaaAzure 資料湖存放區 Storm 效能調整指導方針 |Microsoft 文件"
description: "Azure Data Lake Store Storm 效能微調方針"
services: data-lake-store
documentationcenter: 
author: stewu
manager: amitkul
editor: stewu
ms.assetid: ebde7b9f-2e51-4d43-b7ab-566417221335
ms.service: data-lake-store
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: big-data
ms.date: 12/19/2016
ms.author: stewu
ms.openlocfilehash: 5412fd46cf2373f5877030913df4fe1fc6f5473a
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="performance-tuning-guidance-for-storm-on-hdinsight-and-azure-data-lake-store"></a><span data-ttu-id="a46a0-103">HDInsight 和 Azure Data Lake Store 上的 Storm 效能微調方針</span><span class="sxs-lookup"><span data-stu-id="a46a0-103">Performance tuning guidance for Storm on HDInsight and Azure Data Lake Store</span></span>

<span data-ttu-id="a46a0-104">了解 hello 微調 Azure Storm 拓樸的 hello 效能時應考慮的因素。</span><span class="sxs-lookup"><span data-stu-id="a46a0-104">Understand hello factors that should be considered when you tune hello performance of an Azure Storm topology.</span></span> <span data-ttu-id="a46a0-105">比方說，是工作的重要的 toounderstand hello 特性 hello 完成依 hello spouts 和 hello 攻擊 （hello 工作是否 I/O 或記憶體）。</span><span class="sxs-lookup"><span data-stu-id="a46a0-105">For example, it's important toounderstand hello characteristics of hello work done by hello spouts and hello bolts (whether hello work is I/O or memory intensive).</span></span> <span data-ttu-id="a46a0-106">本文探討各種效能微調指導方針，包括疑難排解方面的常見問題。</span><span class="sxs-lookup"><span data-stu-id="a46a0-106">This article covers a range of performance tuning guidelines, including troubleshooting common issues.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="a46a0-107">必要條件</span><span class="sxs-lookup"><span data-stu-id="a46a0-107">Prerequisites</span></span>

* <span data-ttu-id="a46a0-108">**Azure 訂用帳戶**。</span><span class="sxs-lookup"><span data-stu-id="a46a0-108">**An Azure subscription**.</span></span> <span data-ttu-id="a46a0-109">請參閱 [取得 Azure 免費試用](https://azure.microsoft.com/pricing/free-trial/)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-109">See [Get Azure free trial](https://azure.microsoft.com/pricing/free-trial/).</span></span>
* <span data-ttu-id="a46a0-110">**Azure Data Lake Store 帳戶**。</span><span class="sxs-lookup"><span data-stu-id="a46a0-110">**An Azure Data Lake Store account**.</span></span> <span data-ttu-id="a46a0-111">如需有關指示 toocreate 一個，請參閱[開始使用 Azure Data Lake Store](data-lake-store-get-started-portal.md)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-111">For instructions on how toocreate one, see [Get started with Azure Data Lake Store](data-lake-store-get-started-portal.md).</span></span>
* <span data-ttu-id="a46a0-112">**Azure HDInsight 叢集**與存取 tooa Data Lake Store 帳戶。</span><span class="sxs-lookup"><span data-stu-id="a46a0-112">**An Azure HDInsight cluster** with access tooa Data Lake Store account.</span></span> <span data-ttu-id="a46a0-113">請參閱 [建立具有 Data Lake Store 的 HDInsight 叢集](data-lake-store-hdinsight-hadoop-use-portal.md)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-113">See [Create an HDInsight cluster with Data Lake Store](data-lake-store-hdinsight-hadoop-use-portal.md).</span></span> <span data-ttu-id="a46a0-114">請確定您已啟用遠端桌面 hello 叢集。</span><span class="sxs-lookup"><span data-stu-id="a46a0-114">Make sure you enable Remote Desktop for hello cluster.</span></span>
* <span data-ttu-id="a46a0-115">**在 Data Lake Store 上執行 Storm 叢集**。</span><span class="sxs-lookup"><span data-stu-id="a46a0-115">**Running a Storm cluster on Data Lake Store**.</span></span> <span data-ttu-id="a46a0-116">如需詳細資訊，請參閱 [HDInsight 上的 Storm](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-116">For more information, see [Storm on HDInsight](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview).</span></span>
* <span data-ttu-id="a46a0-117">**Data Lake Store 的效能微調指導方針**。</span><span class="sxs-lookup"><span data-stu-id="a46a0-117">**Performance tuning guidelines on Data Lake Store**.</span></span>  <span data-ttu-id="a46a0-118">如需一般的效能概念，請參閱 [Data Lake Store 效能微調指導方針](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-118">For general performance concepts, see [Data Lake Store Performance Tuning Guidance](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance).</span></span>  

## <a name="tune-hello-parallelism-of-hello-topology"></a><span data-ttu-id="a46a0-119">微調 hello 拓樸的 hello 平行處理原則</span><span class="sxs-lookup"><span data-stu-id="a46a0-119">Tune hello parallelism of hello topology</span></span>

<span data-ttu-id="a46a0-120">您可能會增加資料湖存放區中的 hello I/O tooand hello 並行可以 tooimprove 效能。</span><span class="sxs-lookup"><span data-stu-id="a46a0-120">You might be able tooimprove performance by increasing hello concurrency of hello I/O tooand from Data Lake Store.</span></span> <span data-ttu-id="a46a0-121">Storm 拓撲具有一組決定 hello 平行處理原則的組態：</span><span class="sxs-lookup"><span data-stu-id="a46a0-121">A Storm topology has a set of configurations that determine hello parallelism:</span></span>
* <span data-ttu-id="a46a0-122">背景工作處理序 （hello 工作者平均分散於 hello Vm） 數目。</span><span class="sxs-lookup"><span data-stu-id="a46a0-122">Number of worker processes (hello workers are evenly distributed across hello VMs).</span></span>
* <span data-ttu-id="a46a0-123">Spout 執行程式執行個體數目。</span><span class="sxs-lookup"><span data-stu-id="a46a0-123">Number of spout executor instances.</span></span>
* <span data-ttu-id="a46a0-124">Bolt 執行程式執行個體數目。</span><span class="sxs-lookup"><span data-stu-id="a46a0-124">Number of bolt executor instances.</span></span>
* <span data-ttu-id="a46a0-125">Spout 工作數目。</span><span class="sxs-lookup"><span data-stu-id="a46a0-125">Number of spout tasks.</span></span>
* <span data-ttu-id="a46a0-126">Bolt 工作數目。</span><span class="sxs-lookup"><span data-stu-id="a46a0-126">Number of bolt tasks.</span></span>

<span data-ttu-id="a46a0-127">例如，在叢集上具有 4 個 Vm 和 4 的背景工作處理序、 32 spout 執行程式和 32 spout 工作和 256 閃電執行程式和 512 閃電工作，請考慮 hello 下列功能：</span><span class="sxs-lookup"><span data-stu-id="a46a0-127">For example, on a cluster with 4 VMs and 4 worker processes, 32 spout executors and 32 spout tasks, and 256 bolt executors and 512 bolt tasks, consider hello following:</span></span>

<span data-ttu-id="a46a0-128">每個監督員 (背景工作節點) 具有單一背景工作 Java 虛擬機器 (JVM) 處理序。</span><span class="sxs-lookup"><span data-stu-id="a46a0-128">Each supervisor, which is a worker node, has a single worker Java virtual machine (JVM) process.</span></span> <span data-ttu-id="a46a0-129">此 JVM 處理序管理 4 個 Spout 執行緒和 64 個 Bolt 執行緒。</span><span class="sxs-lookup"><span data-stu-id="a46a0-129">This JVM process manages 4 spout threads and 64 bolt threads.</span></span> <span data-ttu-id="a46a0-130">在每個執行緒內，工作會循序執行。</span><span class="sxs-lookup"><span data-stu-id="a46a0-130">Within each thread, tasks are run sequentially.</span></span> <span data-ttu-id="a46a0-131">以上述組態的 hello，每個 spout 執行緒有 1 項工作中，而且每個閃電執行緒 2 工作。</span><span class="sxs-lookup"><span data-stu-id="a46a0-131">With hello preceding configuration, each spout thread has 1 task, and each bolt thread has 2 tasks.</span></span>

<span data-ttu-id="a46a0-132">在出現，如下 hello 相關的各種元件以及它們如何影響 hello 層級的平行處理原則，您必須：</span><span class="sxs-lookup"><span data-stu-id="a46a0-132">In Storm, here are hello various components involved, and how they affect hello level of parallelism you have:</span></span>
* <span data-ttu-id="a46a0-133">hello 前端節點 (稱為 Nimbus Storm 中) 是使用的 toosubmit 及管理工作。</span><span class="sxs-lookup"><span data-stu-id="a46a0-133">hello head node (called Nimbus in Storm) is used toosubmit and manage jobs.</span></span> <span data-ttu-id="a46a0-134">這些節點 hello 平行處理原則程度上有任何影響。</span><span class="sxs-lookup"><span data-stu-id="a46a0-134">These nodes have no impact on hello degree of parallelism.</span></span>
* <span data-ttu-id="a46a0-135">hello 監督員節點。</span><span class="sxs-lookup"><span data-stu-id="a46a0-135">hello supervisor nodes.</span></span> <span data-ttu-id="a46a0-136">在 HDInsight，這會對應 tooa 背景工作節點 Azure VM。</span><span class="sxs-lookup"><span data-stu-id="a46a0-136">In HDInsight, this corresponds tooa worker node Azure VM.</span></span>
* <span data-ttu-id="a46a0-137">hello 工作者工作是在 hello Vm 中執行的 Storm 程序。</span><span class="sxs-lookup"><span data-stu-id="a46a0-137">hello worker tasks are Storm processes running in hello VMs.</span></span> <span data-ttu-id="a46a0-138">每個背景工作 」 工作會對應 tooa JVM 執行個體。</span><span class="sxs-lookup"><span data-stu-id="a46a0-138">Each worker task corresponds tooa JVM instance.</span></span> <span data-ttu-id="a46a0-139">Storm 分散 hello 數目的工作者處理序指定 toohello 背景工作節點盡量平均。</span><span class="sxs-lookup"><span data-stu-id="a46a0-139">Storm distributes hello number of worker processes you specify toohello worker nodes as evenly as possible.</span></span>
* <span data-ttu-id="a46a0-140">Spout 和 Bolt 執行程式執行個體。</span><span class="sxs-lookup"><span data-stu-id="a46a0-140">Spout and bolt executor instances.</span></span> <span data-ttu-id="a46a0-141">每一個執行程式執行個體對應 tooa hello 工作者 (JVMs) 內執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="a46a0-141">Each executor instance corresponds tooa thread running within hello workers (JVMs).</span></span>
* <span data-ttu-id="a46a0-142">Storm 工作。</span><span class="sxs-lookup"><span data-stu-id="a46a0-142">Storm tasks.</span></span> <span data-ttu-id="a46a0-143">這些工作是每個執行緒所執行的邏輯工作。</span><span class="sxs-lookup"><span data-stu-id="a46a0-143">These are logical tasks that each of these threads run.</span></span> <span data-ttu-id="a46a0-144">這不會變更 hello 層級的平行處理原則，因此如果您或不需要每次執行程式的多個工作，您應該評估。</span><span class="sxs-lookup"><span data-stu-id="a46a0-144">This does not change hello level of parallelism, so you should evaluate if you need multiple tasks per executor or not.</span></span>

### <a name="get-hello-best-performance-from-data-lake-store"></a><span data-ttu-id="a46a0-145">從資料湖存放區取得 hello 達到最佳效能</span><span class="sxs-lookup"><span data-stu-id="a46a0-145">Get hello best performance from Data Lake Store</span></span>

<span data-ttu-id="a46a0-146">當使用資料湖存放區，如果您不要 hello 遵循發生 hello 達到最佳效能：</span><span class="sxs-lookup"><span data-stu-id="a46a0-146">When working with Data Lake Store, you get hello best performance if you do hello following:</span></span>
* <span data-ttu-id="a46a0-147">將小型附加項目聯合成為較大的大小 (最好是 4 MB)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-147">Coalesce your small appends into larger sizes (ideally 4 MB).</span></span>
* <span data-ttu-id="a46a0-148">盡可能提出最多的並行要求。</span><span class="sxs-lookup"><span data-stu-id="a46a0-148">Do as many concurrent requests as you can.</span></span> <span data-ttu-id="a46a0-149">因為每個閃電執行緒正在進行封鎖讀取，您會想 toohave hello 範圍的每個核心的 8-12 執行緒中的某處。</span><span class="sxs-lookup"><span data-stu-id="a46a0-149">Because each bolt thread is doing blocking reads, you want toohave somewhere in hello range of 8-12 threads per core.</span></span> <span data-ttu-id="a46a0-150">這可防止也使用 hello NIC 和 hello CPU。</span><span class="sxs-lookup"><span data-stu-id="a46a0-150">This keeps hello NIC and hello CPU well utilized.</span></span> <span data-ttu-id="a46a0-151">較大的 VM 可允許更多的並行要求。</span><span class="sxs-lookup"><span data-stu-id="a46a0-151">A larger VM enables more concurrent requests.</span></span>  

### <a name="example-topology"></a><span data-ttu-id="a46a0-152">範例拓撲</span><span class="sxs-lookup"><span data-stu-id="a46a0-152">Example topology</span></span>

<span data-ttu-id="a46a0-153">假設您擁有 8 個背景工作節點的叢集，叢集中具有 D13v2 Azure VM。</span><span class="sxs-lookup"><span data-stu-id="a46a0-153">Let’s assume you have an 8 worker node cluster with a D13v2 Azure VM.</span></span> <span data-ttu-id="a46a0-154">此 VM 有 8 個核心，因此之間 hello 8 個背景工作節點，您有 64 核心總數。</span><span class="sxs-lookup"><span data-stu-id="a46a0-154">This VM has 8 cores, so among hello 8 worker nodes, you have 64 total cores.</span></span>

<span data-ttu-id="a46a0-155">假設我們讓每個核心執行 8 個 Bolt 執行緒。</span><span class="sxs-lookup"><span data-stu-id="a46a0-155">Let’s say we do 8 bolt threads per core.</span></span> <span data-ttu-id="a46a0-156">若給定 64 個核心，這表示我們總共需要 512 個 Bolt 執行程式執行個體 (亦即執行緒)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-156">Given 64 cores, that means we want 512 total bolt executor instances (that is, threads).</span></span> <span data-ttu-id="a46a0-157">在此情況下，假設我們以每個 VM，一個 JVM 開頭並主要是使用內 hello JVM tooachieve 並行 hello 執行緒並行存取。</span><span class="sxs-lookup"><span data-stu-id="a46a0-157">In this case, let’s say we start with one JVM per VM, and mainly use hello thread concurrency within hello JVM tooachieve concurrency.</span></span> <span data-ttu-id="a46a0-158">這表示我們需要 8 個背景工作的工作 (每個 Azure VM 一個工作) 和 512 個 Bolt 執行程式。</span><span class="sxs-lookup"><span data-stu-id="a46a0-158">That means we need 8 worker tasks (one per Azure VM), and 512 bolt executors.</span></span> <span data-ttu-id="a46a0-159">指定這個設定，嘗試 toodistribute hello 工作者背景工作節點 （也稱為監督員節點） 之間平均分配給每個背景工作節點 1 Storm JVM。</span><span class="sxs-lookup"><span data-stu-id="a46a0-159">Given this configuration, Storm tries toodistribute hello workers evenly across worker nodes (also known as supervisor nodes), giving each worker node 1 JVM.</span></span> <span data-ttu-id="a46a0-160">現在內 hello 監督員，Storm 嘗試監督員之間的平均 toodistribute hello 執行程式，讓每個主管 (也就是 JVM) 8 執行緒每個。</span><span class="sxs-lookup"><span data-stu-id="a46a0-160">Now within hello supervisors, Storm tries toodistribute hello executors evenly between supervisors, giving each supervisor (that is, JVM) 8 threads each.</span></span>

## <a name="tune-additional-parameters"></a><span data-ttu-id="a46a0-161">微調其他參數</span><span class="sxs-lookup"><span data-stu-id="a46a0-161">Tune additional parameters</span></span>
<span data-ttu-id="a46a0-162">您擁有 hello 基本拓撲之後，您可以考慮是否要 tootweak 任何 hello 參數：</span><span class="sxs-lookup"><span data-stu-id="a46a0-162">After you have hello basic topology, you can consider whether you want tootweak any of hello parameters:</span></span>
* <span data-ttu-id="a46a0-163">**每個背景工作節點的 JVM 數目。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-163">**Number of JVMs per worker node.**</span></span> <span data-ttu-id="a46a0-164">如果您在記憶體中裝載了一個大型資料結構 (例如，查閱資料表)，每個 JVM 都需要個別的複本。</span><span class="sxs-lookup"><span data-stu-id="a46a0-164">If you have a large data structure (for example, a lookup table) that you host in memory, each JVM requires a separate copy.</span></span> <span data-ttu-id="a46a0-165">或者，您可以使用 hello 資料結構跨許多執行緒，如果您有較少 JVMs。</span><span class="sxs-lookup"><span data-stu-id="a46a0-165">Alternatively, you can use hello data structure across many threads if you have fewer JVMs.</span></span> <span data-ttu-id="a46a0-166">Hello 閃電 i/o hello JVMs 數目不會太多的差異，以做為 hello 加入這些 JVMs 跨執行緒數。</span><span class="sxs-lookup"><span data-stu-id="a46a0-166">For hello bolt’s I/O, hello number of JVMs does not make as much of a difference as hello number of threads added across those JVMs.</span></span> <span data-ttu-id="a46a0-167">為了簡單起見，它是個不錯的主意 toohave 其中每個背景工作的 JVM。</span><span class="sxs-lookup"><span data-stu-id="a46a0-167">For simplicity, it's a good idea toohave one JVM per worker.</span></span> <span data-ttu-id="a46a0-168">根據您閃電正在進行或哪些應用程式處理中，您需要，但您可能需要 toochange 這個數字。</span><span class="sxs-lookup"><span data-stu-id="a46a0-168">Depending on what your bolt is doing or what application processing you require, though, you may need toochange this number.</span></span>
* <span data-ttu-id="a46a0-169">**Spout 執行程式的數目。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-169">**Number of spout executors.**</span></span> <span data-ttu-id="a46a0-170">由於 hello 上述範例使用發射撰寫 tooData 湖存放區，但 hello spouts 數目不是直接相關 toohello 閃電效能。</span><span class="sxs-lookup"><span data-stu-id="a46a0-170">Because hello preceding example uses bolts for writing tooData Lake Store, hello number of spouts is not directly relevant toohello bolt performance.</span></span> <span data-ttu-id="a46a0-171">不過，根據 hello 量處理或 I/O hello spout 中的情況個不錯的主意 tootune hello spouts 為了達到最佳效能。</span><span class="sxs-lookup"><span data-stu-id="a46a0-171">However, depending on hello amount of processing or I/O happening in hello spout, it's a good idea tootune hello spouts for best performance.</span></span> <span data-ttu-id="a46a0-172">確定您有足夠 spouts toobe 無法 tookeep hello 發射忙碌中。</span><span class="sxs-lookup"><span data-stu-id="a46a0-172">Ensure that you have enough spouts toobe able tookeep hello bolts busy.</span></span> <span data-ttu-id="a46a0-173">hello spouts hello 輸出速率應該符合 hello 發射 hello 的輸送量。</span><span class="sxs-lookup"><span data-stu-id="a46a0-173">hello output rates of hello spouts should match hello throughput of hello bolts.</span></span> <span data-ttu-id="a46a0-174">hello 實際組態取決於 hello spout。</span><span class="sxs-lookup"><span data-stu-id="a46a0-174">hello actual configuration depends on hello spout.</span></span>
* <span data-ttu-id="a46a0-175">**工作數目。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-175">**Number of tasks.**</span></span> <span data-ttu-id="a46a0-176">每個 Bolt 都會以單一執行緒的形式來執行。</span><span class="sxs-lookup"><span data-stu-id="a46a0-176">Each bolt runs as a single thread.</span></span> <span data-ttu-id="a46a0-177">每個 Bolt 的其他工作不會提供任何額外的並行能力。</span><span class="sxs-lookup"><span data-stu-id="a46a0-177">Additional tasks per bolt don't provide any additional concurrency.</span></span> <span data-ttu-id="a46a0-178">hello 唯一的時間，就會是好處的如果您的認可 hello tuple 的程序會大比例的閃電執行時間。</span><span class="sxs-lookup"><span data-stu-id="a46a0-178">hello only time they are of benefit is if your process of acknowledging hello tuple takes a large proportion of your bolt execution time.</span></span> <span data-ttu-id="a46a0-179">它是個不錯的主意 toogroup 成較大的多個 tuple 附加從 hello 閃電傳送通知之前，先。</span><span class="sxs-lookup"><span data-stu-id="a46a0-179">It's a good idea toogroup many tuples into a larger append before you send an acknowledgement from hello bolt.</span></span> <span data-ttu-id="a46a0-180">因此，在大部分情況下，多個工作不會提供額外的好處。</span><span class="sxs-lookup"><span data-stu-id="a46a0-180">So, in most cases, multiple tasks provide no additional benefit.</span></span>
* <span data-ttu-id="a46a0-181">**本機或隨機群組。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-181">**Local or shuffle grouping.**</span></span> <span data-ttu-id="a46a0-182">啟用此設定時，tuple 會傳送 hello 內 toobolts 相同的工作者處理序。</span><span class="sxs-lookup"><span data-stu-id="a46a0-182">When this setting is enabled, tuples are sent toobolts within hello same worker process.</span></span> <span data-ttu-id="a46a0-183">這可降低處理序間的通訊和網路呼叫。</span><span class="sxs-lookup"><span data-stu-id="a46a0-183">This reduces inter-process communication and network calls.</span></span> <span data-ttu-id="a46a0-184">這是大部分拓撲的建議作法。</span><span class="sxs-lookup"><span data-stu-id="a46a0-184">This is recommended for most topologies.</span></span>

<span data-ttu-id="a46a0-185">這個基本案例是不錯的起點。</span><span class="sxs-lookup"><span data-stu-id="a46a0-185">This basic scenario is a good starting point.</span></span> <span data-ttu-id="a46a0-186">測試以您自己的資料 tootweak hello 前面參數 tooachieve 達到最佳效能。</span><span class="sxs-lookup"><span data-stu-id="a46a0-186">Test with your own data tootweak hello preceding parameters tooachieve optimal performance.</span></span>

## <a name="tune-hello-spout"></a><span data-ttu-id="a46a0-187">微調 hello spout</span><span class="sxs-lookup"><span data-stu-id="a46a0-187">Tune hello spout</span></span>

<span data-ttu-id="a46a0-188">您可以修改下列設定 tootune hello spout hello。</span><span class="sxs-lookup"><span data-stu-id="a46a0-188">You can modify hello following settings tootune hello spout.</span></span>

- <span data-ttu-id="a46a0-189">**Tuple 逾時︰topology.message.timeout.secs**。</span><span class="sxs-lookup"><span data-stu-id="a46a0-189">**Tuple timeout: topology.message.timeout.secs**.</span></span> <span data-ttu-id="a46a0-190">此設定決定 hello 長時間的訊息會 toocomplete，並接收通知，才會視為失敗。</span><span class="sxs-lookup"><span data-stu-id="a46a0-190">This setting determines hello amount of time a message takes toocomplete, and receive acknowledgement, before it is considered failed.</span></span>

- <span data-ttu-id="a46a0-191">**每個背景工作處理序的記憶體上限：worker.childopts**。</span><span class="sxs-lookup"><span data-stu-id="a46a0-191">**Max memory per worker process: worker.childopts**.</span></span> <span data-ttu-id="a46a0-192">此設定可讓您指定其他命令列參數 toohello Java 背景工作。</span><span class="sxs-lookup"><span data-stu-id="a46a0-192">This setting lets you specify additional command-line parameters toohello Java workers.</span></span> <span data-ttu-id="a46a0-193">hello 最常使用的設定是 XmX，決定 hello 配置的最大記憶體 tooa JVM 的堆積。</span><span class="sxs-lookup"><span data-stu-id="a46a0-193">hello most commonly used setting here is XmX, which determines hello maximum memory allocated tooa JVM’s heap.</span></span>

- <span data-ttu-id="a46a0-194">**Spout 暫止上限：topology.max.spout.pending**。</span><span class="sxs-lookup"><span data-stu-id="a46a0-194">**Max spout pending: topology.max.spout.pending**.</span></span> <span data-ttu-id="a46a0-195">此設定會決定 hello 隨時都可以在到飛行 （尚未認可 hello 拓撲中的所有節點），每個 spout 執行緒的 tuple 數目。</span><span class="sxs-lookup"><span data-stu-id="a46a0-195">This setting determines hello number of tuples that can in be flight (not yet acknowledged at all nodes in hello topology) per spout thread at any time.</span></span>

 <span data-ttu-id="a46a0-196">良好的計算 toodo 是 tooestimate hello 大小每個您 tuple。</span><span class="sxs-lookup"><span data-stu-id="a46a0-196">A good calculation toodo is tooestimate hello size of each of your tuples.</span></span> <span data-ttu-id="a46a0-197">然後找出一個 Spout 執行緒有多少記憶體。</span><span class="sxs-lookup"><span data-stu-id="a46a0-197">Then figure out how much memory one spout thread has.</span></span> <span data-ttu-id="a46a0-198">hello 配置 tooa 執行緒，此值，以分隔的記憶體總數應可提供 hello 暫止的參數的最大 spout hello 上限。</span><span class="sxs-lookup"><span data-stu-id="a46a0-198">hello total memory allocated tooa thread, divided by this value, should give you hello upper bound for hello max spout pending parameter.</span></span>

## <a name="tune-hello-bolt"></a><span data-ttu-id="a46a0-199">微調 hello 閃電</span><span class="sxs-lookup"><span data-stu-id="a46a0-199">Tune hello bolt</span></span>
<span data-ttu-id="a46a0-200">當您撰寫 tooData 湖存放區時，設定大小的同步處理原則 （hello 用戶端上的緩衝處理） too4 MB。</span><span class="sxs-lookup"><span data-stu-id="a46a0-200">When you're writing tooData Lake Store, set a size sync policy (buffer on hello client side) too4 MB.</span></span> <span data-ttu-id="a46a0-201">只有當 hello 緩衝區大小為 hello 這個值時，則執行排清或 hsync()。</span><span class="sxs-lookup"><span data-stu-id="a46a0-201">A flushing or hsync() is then performed only when hello buffer size is hello at this value.</span></span> <span data-ttu-id="a46a0-202">hello hello 工作者 VM 上的 Data Lake Store 驅動程式會自動執行這種緩衝處理，除非您明確地執行 hsync()。</span><span class="sxs-lookup"><span data-stu-id="a46a0-202">hello Data Lake Store driver on hello worker VM automatically does this buffering, unless you explicitly perform an hsync().</span></span>

<span data-ttu-id="a46a0-203">hello 預設資料湖存放區出現閃電有一個大小同步處理原則 (fileBufferSize) 的參數可以是使用的 tootune 這個參數。</span><span class="sxs-lookup"><span data-stu-id="a46a0-203">hello default Data Lake Store Storm bolt has a size sync policy parameter (fileBufferSize) that can be used tootune this parameter.</span></span>

<span data-ttu-id="a46a0-204">在 O-大量拓撲中，它是個不錯的主意 toohave tooits 自己的檔案，tooset 每個閃電執行緒寫入檔案輪動原則 (fileRotationSize)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-204">In I/O-intensive topologies, it's a good idea toohave each bolt thread write tooits own file, and tooset a file rotation policy (fileRotationSize).</span></span> <span data-ttu-id="a46a0-205">Hello 檔案達到特定大小，會自動排清 hello 資料流，並寫入新的檔案。</span><span class="sxs-lookup"><span data-stu-id="a46a0-205">When hello file reaches a certain size, hello stream is automatically flushed and a new file is written to.</span></span> <span data-ttu-id="a46a0-206">hello 建議的輪替檔案大小為 1GB。</span><span class="sxs-lookup"><span data-stu-id="a46a0-206">hello recommended file size for rotation is 1 GB.</span></span>

### <a name="handle-tuple-data"></a><span data-ttu-id="a46a0-207">處理 Tuple 資料</span><span class="sxs-lookup"><span data-stu-id="a46a0-207">Handle tuple data</span></span>

<span data-ttu-id="a46a0-208">在出現，spout 持有 tooa tuple 直到 hello 閃電明確認可。</span><span class="sxs-lookup"><span data-stu-id="a46a0-208">In Storm, a spout holds on tooa tuple until it is explicitly acknowledged by hello bolt.</span></span> <span data-ttu-id="a46a0-209">如果已讀取的 hello 閃電 tuple，但尚未認可，hello spout 可能不會有保存到資料湖存放區的後端。</span><span class="sxs-lookup"><span data-stu-id="a46a0-209">If a tuple has been read by hello bolt but has not been acknowledged yet, hello spout might not have persisted into Data Lake Store back end.</span></span> <span data-ttu-id="a46a0-210">Tuple 會在認可之後，可以保證持續性 hello 閃電 hello spout，並可接著刪除正在讀取從任何來源中的 hello 來源資料。</span><span class="sxs-lookup"><span data-stu-id="a46a0-210">After a tuple is acknowledged, hello spout can be guaranteed persistence by hello bolt, and can then delete hello source data from whatever source it is reading from.</span></span>  

<span data-ttu-id="a46a0-211">資料湖存放區的最佳效能，有 hello 閃電 4 MB 的 tuple 資料的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="a46a0-211">For best performance on Data Lake Store, have hello bolt buffer 4 MB of tuple data.</span></span> <span data-ttu-id="a46a0-212">接著，撰寫的 toohello 回資料湖存放區端一個 4 MB 寫入。</span><span class="sxs-lookup"><span data-stu-id="a46a0-212">Then write toohello Data Lake Store back end as one 4-MB write.</span></span> <span data-ttu-id="a46a0-213">Hello 資料已成功寫入的 toohello 存放區之後 （所呼叫的 hflush()) hello 閃電可以了解 hello 資料回復 toohello spout。</span><span class="sxs-lookup"><span data-stu-id="a46a0-213">After hello data has been successfully written toohello store (by calling hflush()), hello bolt can acknowledge hello data back toohello spout.</span></span> <span data-ttu-id="a46a0-214">這是什麼 hello 範例閃電提供這裡沒有。</span><span class="sxs-lookup"><span data-stu-id="a46a0-214">This is what hello example bolt supplied here does.</span></span> <span data-ttu-id="a46a0-215">它也是可接受 toohold 更大量的 tuple 之前進行 hello hflush() 呼叫與 hello 認可的 tuple。</span><span class="sxs-lookup"><span data-stu-id="a46a0-215">It is also acceptable toohold a larger number of tuples before hello hflush() call is made and hello tuples acknowledged.</span></span> <span data-ttu-id="a46a0-216">不過，這會增加 hello 傳送 hello spout 需要 toohold，，因此會增加 hello 的每個 JVM 所需的記憶體數量的 tuple 數目。</span><span class="sxs-lookup"><span data-stu-id="a46a0-216">However, this increases hello number of tuples in flight that hello spout needs toohold, and therefore increases hello amount of memory required per JVM.</span></span>

> [!NOTE]
<span data-ttu-id="a46a0-217">基於其他非效能，應用程式可能有更頻繁地 （在資料大小小於 4 MB） 的需求 tooacknowledge tuple。</span><span class="sxs-lookup"><span data-stu-id="a46a0-217">Applications might have a requirement tooacknowledge tuples more frequently (at data sizes less than 4 MB) for other non-performance reasons.</span></span> <span data-ttu-id="a46a0-218">不過，可能會影響 hello I/O 輸送量 toohello 存放裝置後端。</span><span class="sxs-lookup"><span data-stu-id="a46a0-218">However, that might affect hello I/O throughput toohello storage back end.</span></span> <span data-ttu-id="a46a0-219">請仔細權衡 hello 閃電 I/O 效能對這些權衡取捨。</span><span class="sxs-lookup"><span data-stu-id="a46a0-219">Carefully weigh this tradeoff against hello bolt’s I/O performance.</span></span>

<span data-ttu-id="a46a0-220">如果 tuple 的 hello 內送速率不高，因此 hello 4 MB 緩衝區會很長的時間 toofill，請考慮緩和這由：</span><span class="sxs-lookup"><span data-stu-id="a46a0-220">If hello incoming rate of tuples is not high, so hello 4-MB buffer takes a long time toofill, consider mitigating this by:</span></span>
* <span data-ttu-id="a46a0-221">減少攻擊的 hello 數量，因此會有較少的緩衝區 toofill。</span><span class="sxs-lookup"><span data-stu-id="a46a0-221">Reducing hello number of bolts, so there are fewer buffers toofill.</span></span>
* <span data-ttu-id="a46a0-222">具有以時間為基礎或以計數為基礎的原則，其中 hflush() 觸發每隔 x 排清或每個 y 毫秒，並累積到目前為止的 hello tuple 都已認可後。</span><span class="sxs-lookup"><span data-stu-id="a46a0-222">Having a time-based or count-based policy, where an hflush() is triggered every x flushes or every y milliseconds, and hello tuples accumulated so far are acknowledged back.</span></span>

<span data-ttu-id="a46a0-223">請注意，在此情況下 hello 輸送量較低，事件的速度變慢，最大輸送量並非 hello 最大目標還是。</span><span class="sxs-lookup"><span data-stu-id="a46a0-223">Note that hello throughput in this case is lower, but with a slow rate of events, maximum throughput is not hello biggest objective anyway.</span></span> <span data-ttu-id="a46a0-224">這些防護功能，幫助您減少 hello 透過 toohello 存放區 tuple tooflow 所花費的總時間。</span><span class="sxs-lookup"><span data-stu-id="a46a0-224">These mitigations help you reduce hello total time that it takes for a tuple tooflow through toohello store.</span></span> <span data-ttu-id="a46a0-225">如果您無論如何都想要即時管線 (即使事件速率會偏低)，這一點可能就很重要。</span><span class="sxs-lookup"><span data-stu-id="a46a0-225">This might matter if you want a real-time pipeline even with a low event rate.</span></span> <span data-ttu-id="a46a0-226">另外請注意，如果內送的 tuple 速率過低時，應調整 hello topology.message.timeout_secs 參數，因此 hello tuple 不會逾時取得經過緩衝處理或處理。</span><span class="sxs-lookup"><span data-stu-id="a46a0-226">Also note that if your incoming tuple rate is low, you should adjust hello topology.message.timeout_secs parameter, so hello tuples don’t time out while they are getting buffered or processed.</span></span>

## <a name="monitor-your-topology-in-storm"></a><span data-ttu-id="a46a0-227">監視 Storm 中的拓撲</span><span class="sxs-lookup"><span data-stu-id="a46a0-227">Monitor your topology in Storm</span></span>  
<span data-ttu-id="a46a0-228">執行您的拓撲時，您可以在 hello Storm 使用者介面來進行監視。</span><span class="sxs-lookup"><span data-stu-id="a46a0-228">While your topology is running, you can monitor it in hello Storm user interface.</span></span> <span data-ttu-id="a46a0-229">以下是在 hello 主要參數 toolook:</span><span class="sxs-lookup"><span data-stu-id="a46a0-229">Here are hello main parameters toolook at:</span></span>

* <span data-ttu-id="a46a0-230">**總處理序執行延遲。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-230">**Total process execution latency.**</span></span> <span data-ttu-id="a46a0-231">這是一個 tuple 所需 toobe hello spout 所發出、 處理 hello 閃電和認可的 hello 平均時間。</span><span class="sxs-lookup"><span data-stu-id="a46a0-231">This is hello average time one tuple takes toobe emitted by hello spout, processed by hello bolt, and acknowledged.</span></span>

* <span data-ttu-id="a46a0-232">**總 Bolt 處理序延遲。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-232">**Total bolt process latency.**</span></span> <span data-ttu-id="a46a0-233">這是 hello 直到其接收到通知，在 hello 閃電 hello tuple 所花費的平均時間。</span><span class="sxs-lookup"><span data-stu-id="a46a0-233">This is hello average time spent by hello tuple at hello bolt until it receives an acknowledgement.</span></span>

* <span data-ttu-id="a46a0-234">**總 Bolt 執行延遲。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-234">**Total bolt execute latency.**</span></span> <span data-ttu-id="a46a0-235">這是 hello 平均 hello 閃電 hello 中所花費的時間執行的方法。</span><span class="sxs-lookup"><span data-stu-id="a46a0-235">This is hello average time spent by hello bolt in hello execute method.</span></span>

* <span data-ttu-id="a46a0-236">**失敗次數。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-236">**Number of failures.**</span></span> <span data-ttu-id="a46a0-237">這是指 toohello 失敗 toobe 完全處理這些逾時之前的 tuple 數目。</span><span class="sxs-lookup"><span data-stu-id="a46a0-237">This refers toohello number of tuples that failed toobe fully processed before they timed out.</span></span>

* <span data-ttu-id="a46a0-238">**容量。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-238">**Capacity.**</span></span> <span data-ttu-id="a46a0-239">這是系統忙碌程度的量值。</span><span class="sxs-lookup"><span data-stu-id="a46a0-239">This is a measure of how busy your system is.</span></span> <span data-ttu-id="a46a0-240">如果這個數字為 1，Bolt 會以它最快的速度工作。</span><span class="sxs-lookup"><span data-stu-id="a46a0-240">If this number is 1, your bolts are working as fast as they can.</span></span> <span data-ttu-id="a46a0-241">如果是小於 1，增加 hello 平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="a46a0-241">If it is less than 1, increase hello parallelism.</span></span> <span data-ttu-id="a46a0-242">如果是大於 1，減少 hello 平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="a46a0-242">If it is greater than 1, reduce hello parallelism.</span></span>

## <a name="troubleshoot-common-problems"></a><span data-ttu-id="a46a0-243">針對常見問題進行疑難排解</span><span class="sxs-lookup"><span data-stu-id="a46a0-243">Troubleshoot common problems</span></span>
<span data-ttu-id="a46a0-244">以下是一些常見的疑難排解案例。</span><span class="sxs-lookup"><span data-stu-id="a46a0-244">Here are a few common troubleshooting scenarios.</span></span>
* <span data-ttu-id="a46a0-245">**許多 Tuple 逾時。**查看 hello 瓶頸何在 hello 拓撲 toodetermine 的每個節點。</span><span class="sxs-lookup"><span data-stu-id="a46a0-245">**Many tuples are timing out.** Look at each node in hello topology toodetermine where hello bottleneck is.</span></span> <span data-ttu-id="a46a0-246">hello 最常見的原因是 hello 發射並不能 tookeep 向上與 hello spouts。</span><span class="sxs-lookup"><span data-stu-id="a46a0-246">hello most common reason for this is that hello bolts are not able tookeep up with hello spouts.</span></span> <span data-ttu-id="a46a0-247">這會導致 tootuples 繼續 hello 等候 toobe 處理時的內部緩衝區。</span><span class="sxs-lookup"><span data-stu-id="a46a0-247">This leads tootuples clogging hello internal buffers while waiting toobe processed.</span></span> <span data-ttu-id="a46a0-248">請考慮增加 hello 逾時值或減少 hello max spout 暫止。</span><span class="sxs-lookup"><span data-stu-id="a46a0-248">Consider increasing hello timeout value or decreasing hello max spout pending.</span></span>

* <span data-ttu-id="a46a0-249">**總處理序執行延遲很高，但 Bolt 處理序延遲卻很低。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-249">**There is a high total process execution latency, but a low bolt process latency.**</span></span> <span data-ttu-id="a46a0-250">在此情況下，很可能的 hello tuple 都尚未被認可速度夠快。</span><span class="sxs-lookup"><span data-stu-id="a46a0-250">In this case, it is possible that hello tuples are not being acknowledged fast enough.</span></span> <span data-ttu-id="a46a0-251">請確認認可者的數量足夠。</span><span class="sxs-lookup"><span data-stu-id="a46a0-251">Check that there are a sufficient number of acknowledgers.</span></span> <span data-ttu-id="a46a0-252">另一個可能性是，它們會 hello 在佇列中等待太久之前 hello 釘開始處理它們。</span><span class="sxs-lookup"><span data-stu-id="a46a0-252">Another possibility is that they are waiting in hello queue for too long before hello bolts start processing them.</span></span> <span data-ttu-id="a46a0-253">減少 hello max spout 暫止。</span><span class="sxs-lookup"><span data-stu-id="a46a0-253">Decrease hello max spout pending.</span></span>

* <span data-ttu-id="a46a0-254">**Bolt 執行延遲很高。**</span><span class="sxs-lookup"><span data-stu-id="a46a0-254">**There is a high bolt execute latency.**</span></span> <span data-ttu-id="a46a0-255">這表示您閃電 hello execute （） 方法時間太長。</span><span class="sxs-lookup"><span data-stu-id="a46a0-255">This means that hello execute() method of your bolt is taking too long.</span></span> <span data-ttu-id="a46a0-256">最佳化 hello 程式碼，或查看寫入大小，排清的行為。</span><span class="sxs-lookup"><span data-stu-id="a46a0-256">Optimize hello code, or look at write sizes and flush behavior.</span></span>

### <a name="data-lake-store-throttling"></a><span data-ttu-id="a46a0-257">Data Lake Store 節流</span><span class="sxs-lookup"><span data-stu-id="a46a0-257">Data Lake Store throttling</span></span>
<span data-ttu-id="a46a0-258">如果您遇到 hello 限制的資料湖存放區所提供的頻寬，您可能會看到工作失敗。</span><span class="sxs-lookup"><span data-stu-id="a46a0-258">If you hit hello limits of bandwidth provided by Data Lake Store, you might see task failures.</span></span> <span data-ttu-id="a46a0-259">請檢查工作記錄中的節流錯誤。</span><span class="sxs-lookup"><span data-stu-id="a46a0-259">Check task logs for throttling errors.</span></span> <span data-ttu-id="a46a0-260">您可以藉由增加容器大小減少 hello 平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="a46a0-260">You can decrease hello parallelism by increasing container size.</span></span>    

<span data-ttu-id="a46a0-261">如果您節流，toocheck 啟用 hello 偵錯 hello 用戶端記錄：</span><span class="sxs-lookup"><span data-stu-id="a46a0-261">toocheck if you are getting throttled, enable hello debug logging on hello client side:</span></span>

1. <span data-ttu-id="a46a0-262">在**Ambari** > **Storm** > **Config** > **進階 storm-背景工作層 log4j**，變更**&lt;根層級 ="info"&gt;** 太**&lt;根層級 ="debug"&gt;**。</span><span class="sxs-lookup"><span data-stu-id="a46a0-262">In **Ambari** > **Storm** > **Config** > **Advanced storm-worker-log4j**, change **&lt;root level="info"&gt;** too**&lt;root level=”debug”&gt;**.</span></span> <span data-ttu-id="a46a0-263">重新啟動所有 hello 節點/服務 hello 組態 tootake 效果。</span><span class="sxs-lookup"><span data-stu-id="a46a0-263">Restart all hello nodes/service for hello configuration tootake effect.</span></span>
2. <span data-ttu-id="a46a0-264">監視 hello Storm 拓撲登入的背景工作節點 (在 /var/log/storm/worker-artifacts /&lt;TopologyName&gt;/&lt;連接埠&gt;/worker.log) 節流例外狀況的資料湖存放區。</span><span class="sxs-lookup"><span data-stu-id="a46a0-264">Monitor hello Storm topology logs on worker nodes (under /var/log/storm/worker-artifacts/&lt;TopologyName&gt;/&lt;port&gt;/worker.log) for Data Lake Store throttling exceptions.</span></span>

## <a name="next-steps"></a><span data-ttu-id="a46a0-265">後續步驟</span><span class="sxs-lookup"><span data-stu-id="a46a0-265">Next steps</span></span>
<span data-ttu-id="a46a0-266">Storm 的其他效能微調請參考[此部落格](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-266">Additional performance tuning for Storm can be referenced in [this blog](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/).</span></span>

<span data-ttu-id="a46a0-267">其他範例 toorun，請參閱[GitHub 上的此一](https://github.com/hdinsight/storm-performance-automation)。</span><span class="sxs-lookup"><span data-stu-id="a46a0-267">For an additional example toorun, see [this one on GitHub](https://github.com/hdinsight/storm-performance-automation).</span></span>
