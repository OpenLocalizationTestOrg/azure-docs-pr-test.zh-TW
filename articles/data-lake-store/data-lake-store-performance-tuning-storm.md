---
title: "Azure Data Lake Store Storm 效能微調方針 | Microsoft Docs"
description: "Azure Data Lake Store Storm 效能微調方針"
services: data-lake-store
documentationcenter: 
author: stewu
manager: amitkul
editor: stewu
ms.assetid: ebde7b9f-2e51-4d43-b7ab-566417221335
ms.service: data-lake-store
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: big-data
ms.date: 12/19/2016
ms.author: stewu
ms.openlocfilehash: 1dfa93643f45a96ded3fd022aa8b1c71d487acb4
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="performance-tuning-guidance-for-storm-on-hdinsight-and-azure-data-lake-store"></a><span data-ttu-id="1e644-103">HDInsight 和 Azure Data Lake Store 上的 Storm 效能微調方針</span><span class="sxs-lookup"><span data-stu-id="1e644-103">Performance tuning guidance for Storm on HDInsight and Azure Data Lake Store</span></span>

<span data-ttu-id="1e644-104">了解在微調 Azure Storm 拓撲的效能時應考量的因素。</span><span class="sxs-lookup"><span data-stu-id="1e644-104">Understand the factors that should be considered when you tune the performance of an Azure Storm topology.</span></span> <span data-ttu-id="1e644-105">例如，務必要了解由 Spout 和 Bolt 所完成之工作 (不論是 I/O 密集或記憶體密集工作) 的特性。</span><span class="sxs-lookup"><span data-stu-id="1e644-105">For example, it's important to understand the characteristics of the work done by the spouts and the bolts (whether the work is I/O or memory intensive).</span></span> <span data-ttu-id="1e644-106">本文探討各種效能微調指導方針，包括疑難排解方面的常見問題。</span><span class="sxs-lookup"><span data-stu-id="1e644-106">This article covers a range of performance tuning guidelines, including troubleshooting common issues.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="1e644-107">必要條件</span><span class="sxs-lookup"><span data-stu-id="1e644-107">Prerequisites</span></span>

* <span data-ttu-id="1e644-108">**Azure 訂用帳戶**。</span><span class="sxs-lookup"><span data-stu-id="1e644-108">**An Azure subscription**.</span></span> <span data-ttu-id="1e644-109">請參閱 [取得 Azure 免費試用](https://azure.microsoft.com/pricing/free-trial/)。</span><span class="sxs-lookup"><span data-stu-id="1e644-109">See [Get Azure free trial](https://azure.microsoft.com/pricing/free-trial/).</span></span>
* <span data-ttu-id="1e644-110">**Azure Data Lake Store 帳戶**。</span><span class="sxs-lookup"><span data-stu-id="1e644-110">**An Azure Data Lake Store account**.</span></span> <span data-ttu-id="1e644-111">如需有關如何建立帳戶的詳細指示，請參閱[開始使用 Azure Data Lake Store](data-lake-store-get-started-portal.md)。</span><span class="sxs-lookup"><span data-stu-id="1e644-111">For instructions on how to create one, see [Get started with Azure Data Lake Store](data-lake-store-get-started-portal.md).</span></span>
* <span data-ttu-id="1e644-112">可存取 Data Lake Store 帳戶的 **Azure HDInsight 叢集**。</span><span class="sxs-lookup"><span data-stu-id="1e644-112">**An Azure HDInsight cluster** with access to a Data Lake Store account.</span></span> <span data-ttu-id="1e644-113">請參閱 [建立具有 Data Lake Store 的 HDInsight 叢集](data-lake-store-hdinsight-hadoop-use-portal.md)。</span><span class="sxs-lookup"><span data-stu-id="1e644-113">See [Create an HDInsight cluster with Data Lake Store](data-lake-store-hdinsight-hadoop-use-portal.md).</span></span> <span data-ttu-id="1e644-114">請確實為叢集啟用遠端桌面。</span><span class="sxs-lookup"><span data-stu-id="1e644-114">Make sure you enable Remote Desktop for the cluster.</span></span>
* <span data-ttu-id="1e644-115">**在 Data Lake Store 上執行 Storm 叢集**。</span><span class="sxs-lookup"><span data-stu-id="1e644-115">**Running a Storm cluster on Data Lake Store**.</span></span> <span data-ttu-id="1e644-116">如需詳細資訊，請參閱 [HDInsight 上的 Storm](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview)。</span><span class="sxs-lookup"><span data-stu-id="1e644-116">For more information, see [Storm on HDInsight](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview).</span></span>
* <span data-ttu-id="1e644-117">**Data Lake Store 的效能微調指導方針**。</span><span class="sxs-lookup"><span data-stu-id="1e644-117">**Performance tuning guidelines on Data Lake Store**.</span></span>  <span data-ttu-id="1e644-118">如需一般的效能概念，請參閱 [Data Lake Store 效能微調指導方針](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance)。</span><span class="sxs-lookup"><span data-stu-id="1e644-118">For general performance concepts, see [Data Lake Store Performance Tuning Guidance](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance).</span></span>  

## <a name="tune-the-parallelism-of-the-topology"></a><span data-ttu-id="1e644-119">調整拓撲的平行處理原則</span><span class="sxs-lookup"><span data-stu-id="1e644-119">Tune the parallelism of the topology</span></span>

<span data-ttu-id="1e644-120">增加 Data Lake Store 的往返 I/O 並行能力或許能提升效能。</span><span class="sxs-lookup"><span data-stu-id="1e644-120">You might be able to improve performance by increasing the concurrency of the I/O to and from Data Lake Store.</span></span> <span data-ttu-id="1e644-121">Storm 拓撲有一組可決定平行處理原則的組態︰</span><span class="sxs-lookup"><span data-stu-id="1e644-121">A Storm topology has a set of configurations that determine the parallelism:</span></span>
* <span data-ttu-id="1e644-122">背景工作處理序數目 (背景工作會平均分散給 VM)。</span><span class="sxs-lookup"><span data-stu-id="1e644-122">Number of worker processes (the workers are evenly distributed across the VMs).</span></span>
* <span data-ttu-id="1e644-123">Spout 執行程式執行個體數目。</span><span class="sxs-lookup"><span data-stu-id="1e644-123">Number of spout executor instances.</span></span>
* <span data-ttu-id="1e644-124">Bolt 執行程式執行個體數目。</span><span class="sxs-lookup"><span data-stu-id="1e644-124">Number of bolt executor instances.</span></span>
* <span data-ttu-id="1e644-125">Spout 工作數目。</span><span class="sxs-lookup"><span data-stu-id="1e644-125">Number of spout tasks.</span></span>
* <span data-ttu-id="1e644-126">Bolt 工作數目。</span><span class="sxs-lookup"><span data-stu-id="1e644-126">Number of bolt tasks.</span></span>

<span data-ttu-id="1e644-127">例如，在具有 4 個 VM 和 4 個背景工作處理序、32 個 Spout 執行程式和 32 個 Spout 工作，以及 256 個 Bolt 執行程式和 512 個 Bolt 工作的叢集上，請考慮下列情況︰</span><span class="sxs-lookup"><span data-stu-id="1e644-127">For example, on a cluster with 4 VMs and 4 worker processes, 32 spout executors and 32 spout tasks, and 256 bolt executors and 512 bolt tasks, consider the following:</span></span>

<span data-ttu-id="1e644-128">每個監督員 (背景工作節點) 具有單一背景工作 Java 虛擬機器 (JVM) 處理序。</span><span class="sxs-lookup"><span data-stu-id="1e644-128">Each supervisor, which is a worker node, has a single worker Java virtual machine (JVM) process.</span></span> <span data-ttu-id="1e644-129">此 JVM 處理序管理 4 個 Spout 執行緒和 64 個 Bolt 執行緒。</span><span class="sxs-lookup"><span data-stu-id="1e644-129">This JVM process manages 4 spout threads and 64 bolt threads.</span></span> <span data-ttu-id="1e644-130">在每個執行緒內，工作會循序執行。</span><span class="sxs-lookup"><span data-stu-id="1e644-130">Within each thread, tasks are run sequentially.</span></span> <span data-ttu-id="1e644-131">在上述組態中，每個 Spout 執行緒有 1 個工作，而每個 Bolt 執行緒有 2 個工作。</span><span class="sxs-lookup"><span data-stu-id="1e644-131">With the preceding configuration, each spout thread has 1 task, and each bolt thread has 2 tasks.</span></span>

<span data-ttu-id="1e644-132">在 Storm 中，以下是所涉及的各種元件，以及它們會如何影響您所擁有的平行處理原則層級︰</span><span class="sxs-lookup"><span data-stu-id="1e644-132">In Storm, here are the various components involved, and how they affect the level of parallelism you have:</span></span>
* <span data-ttu-id="1e644-133">前端節點 (在 Storm 中稱為 Nimbus) 可用來提交和管理作業。</span><span class="sxs-lookup"><span data-stu-id="1e644-133">The head node (called Nimbus in Storm) is used to submit and manage jobs.</span></span> <span data-ttu-id="1e644-134">這些節點不會影響平行處理原則的程度。</span><span class="sxs-lookup"><span data-stu-id="1e644-134">These nodes have no impact on the degree of parallelism.</span></span>
* <span data-ttu-id="1e644-135">監督員節點。</span><span class="sxs-lookup"><span data-stu-id="1e644-135">The supervisor nodes.</span></span> <span data-ttu-id="1e644-136">在 HDInsight 中，這會對應至背景工作節點 Azure VM。</span><span class="sxs-lookup"><span data-stu-id="1e644-136">In HDInsight, this corresponds to a worker node Azure VM.</span></span>
* <span data-ttu-id="1e644-137">背景工作的工作是在 VM 中執行的 Storm 處理序。</span><span class="sxs-lookup"><span data-stu-id="1e644-137">The worker tasks are Storm processes running in the VMs.</span></span> <span data-ttu-id="1e644-138">每個背景工作的工作會對應至 JVM 執行個體。</span><span class="sxs-lookup"><span data-stu-id="1e644-138">Each worker task corresponds to a JVM instance.</span></span> <span data-ttu-id="1e644-139">Storm 會盡量地將您指定的背景工作處理序數目平均分散給背景工作節點。</span><span class="sxs-lookup"><span data-stu-id="1e644-139">Storm distributes the number of worker processes you specify to the worker nodes as evenly as possible.</span></span>
* <span data-ttu-id="1e644-140">Spout 和 Bolt 執行程式執行個體。</span><span class="sxs-lookup"><span data-stu-id="1e644-140">Spout and bolt executor instances.</span></span> <span data-ttu-id="1e644-141">每個執行程式執行個體會對應至在背景工作 (JVM) 內執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="1e644-141">Each executor instance corresponds to a thread running within the workers (JVMs).</span></span>
* <span data-ttu-id="1e644-142">Storm 工作。</span><span class="sxs-lookup"><span data-stu-id="1e644-142">Storm tasks.</span></span> <span data-ttu-id="1e644-143">這些工作是每個執行緒所執行的邏輯工作。</span><span class="sxs-lookup"><span data-stu-id="1e644-143">These are logical tasks that each of these threads run.</span></span> <span data-ttu-id="1e644-144">這不會變更平行處理原則的層級，因此您應該評估每個執行程式是否需要多個工作。</span><span class="sxs-lookup"><span data-stu-id="1e644-144">This does not change the level of parallelism, so you should evaluate if you need multiple tasks per executor or not.</span></span>

### <a name="get-the-best-performance-from-data-lake-store"></a><span data-ttu-id="1e644-145">從 Data Lake Store 獲得最佳效能</span><span class="sxs-lookup"><span data-stu-id="1e644-145">Get the best performance from Data Lake Store</span></span>

<span data-ttu-id="1e644-146">在使用 Data Lake Store 時，如果您執行下列作業，就能獲得最佳效能︰</span><span class="sxs-lookup"><span data-stu-id="1e644-146">When working with Data Lake Store, you get the best performance if you do the following:</span></span>
* <span data-ttu-id="1e644-147">將小型附加項目聯合成為較大的大小 (最好是 4 MB)。</span><span class="sxs-lookup"><span data-stu-id="1e644-147">Coalesce your small appends into larger sizes (ideally 4 MB).</span></span>
* <span data-ttu-id="1e644-148">盡可能提出最多的並行要求。</span><span class="sxs-lookup"><span data-stu-id="1e644-148">Do as many concurrent requests as you can.</span></span> <span data-ttu-id="1e644-149">因為每個 Bolt 執行緒都會進行區塊讀取，您會想要讓每個核心擁有 8-12 個左右的執行緒。</span><span class="sxs-lookup"><span data-stu-id="1e644-149">Because each bolt thread is doing blocking reads, you want to have somewhere in the range of 8-12 threads per core.</span></span> <span data-ttu-id="1e644-150">這會讓 NIC 和 CPU 受到充分利用。</span><span class="sxs-lookup"><span data-stu-id="1e644-150">This keeps the NIC and the CPU well utilized.</span></span> <span data-ttu-id="1e644-151">較大的 VM 可允許更多的並行要求。</span><span class="sxs-lookup"><span data-stu-id="1e644-151">A larger VM enables more concurrent requests.</span></span>  

### <a name="example-topology"></a><span data-ttu-id="1e644-152">範例拓撲</span><span class="sxs-lookup"><span data-stu-id="1e644-152">Example topology</span></span>

<span data-ttu-id="1e644-153">假設您擁有 8 個背景工作節點的叢集，叢集中具有 D13v2 Azure VM。</span><span class="sxs-lookup"><span data-stu-id="1e644-153">Let’s assume you have an 8 worker node cluster with a D13v2 Azure VM.</span></span> <span data-ttu-id="1e644-154">此 VM 有 8 個核心，因此在 8 個背景工作節點之中，總共會有 64 個核心。</span><span class="sxs-lookup"><span data-stu-id="1e644-154">This VM has 8 cores, so among the 8 worker nodes, you have 64 total cores.</span></span>

<span data-ttu-id="1e644-155">假設我們讓每個核心執行 8 個 Bolt 執行緒。</span><span class="sxs-lookup"><span data-stu-id="1e644-155">Let’s say we do 8 bolt threads per core.</span></span> <span data-ttu-id="1e644-156">若給定 64 個核心，這表示我們總共需要 512 個 Bolt 執行程式執行個體 (亦即執行緒)。</span><span class="sxs-lookup"><span data-stu-id="1e644-156">Given 64 cores, that means we want 512 total bolt executor instances (that is, threads).</span></span> <span data-ttu-id="1e644-157">在此情況下，假設我們一開始讓每個 VM 擁有一個 JVM，並且大多在 JVM 內使用執行緒並行存取以達到並行效果。</span><span class="sxs-lookup"><span data-stu-id="1e644-157">In this case, let’s say we start with one JVM per VM, and mainly use the thread concurrency within the JVM to achieve concurrency.</span></span> <span data-ttu-id="1e644-158">這表示我們需要 8 個背景工作的工作 (每個 Azure VM 一個工作) 和 512 個 Bolt 執行程式。</span><span class="sxs-lookup"><span data-stu-id="1e644-158">That means we need 8 worker tasks (one per Azure VM), and 512 bolt executors.</span></span> <span data-ttu-id="1e644-159">若給定此組態，Storm 會嘗試將背景工作平均分散給背景工作節點 (也稱為監督員節點)，讓每個背景工作節點有 1 個 JVM。</span><span class="sxs-lookup"><span data-stu-id="1e644-159">Given this configuration, Storm tries to distribute the workers evenly across worker nodes (also known as supervisor nodes), giving each worker node 1 JVM.</span></span> <span data-ttu-id="1e644-160">現在在監督員內，Storm 會嘗試在監督員之間平均分散執行程式，讓每個監督員 (亦即 JVM) 各有 8 個執行緒。</span><span class="sxs-lookup"><span data-stu-id="1e644-160">Now within the supervisors, Storm tries to distribute the executors evenly between supervisors, giving each supervisor (that is, JVM) 8 threads each.</span></span>

## <a name="tune-additional-parameters"></a><span data-ttu-id="1e644-161">微調其他參數</span><span class="sxs-lookup"><span data-stu-id="1e644-161">Tune additional parameters</span></span>
<span data-ttu-id="1e644-162">在擁有基本拓撲之後，您可以考慮是否要調整任何參數︰</span><span class="sxs-lookup"><span data-stu-id="1e644-162">After you have the basic topology, you can consider whether you want to tweak any of the parameters:</span></span>
* <span data-ttu-id="1e644-163">**每個背景工作節點的 JVM 數目。**</span><span class="sxs-lookup"><span data-stu-id="1e644-163">**Number of JVMs per worker node.**</span></span> <span data-ttu-id="1e644-164">如果您在記憶體中裝載了一個大型資料結構 (例如，查閱資料表)，每個 JVM 都需要個別的複本。</span><span class="sxs-lookup"><span data-stu-id="1e644-164">If you have a large data structure (for example, a lookup table) that you host in memory, each JVM requires a separate copy.</span></span> <span data-ttu-id="1e644-165">或者，如果您的 JVM 較少，您可以使用跨多個執行緒的資料結構。</span><span class="sxs-lookup"><span data-stu-id="1e644-165">Alternatively, you can use the data structure across many threads if you have fewer JVMs.</span></span> <span data-ttu-id="1e644-166">針對 Bolt 的 I/O，JVM 數目所造成的差異，不會比跨這些 JVM 所新增的執行緒數目還多。</span><span class="sxs-lookup"><span data-stu-id="1e644-166">For the bolt’s I/O, the number of JVMs does not make as much of a difference as the number of threads added across those JVMs.</span></span> <span data-ttu-id="1e644-167">為了簡單起見，最好讓每個背景工作有一個 JVM。</span><span class="sxs-lookup"><span data-stu-id="1e644-167">For simplicity, it's a good idea to have one JVM per worker.</span></span> <span data-ttu-id="1e644-168">但根據 Bolt 所執行的作業或您所需的應用程式處理而定，您可能需要變更此數量。</span><span class="sxs-lookup"><span data-stu-id="1e644-168">Depending on what your bolt is doing or what application processing you require, though, you may need to change this number.</span></span>
* <span data-ttu-id="1e644-169">**Spout 執行程式的數目。**</span><span class="sxs-lookup"><span data-stu-id="1e644-169">**Number of spout executors.**</span></span> <span data-ttu-id="1e644-170">因為上述範例使用 Bolt 來寫入至 Data Lake Store，所以 Spout 的數目不會與 Bolt 的效能直接相關。</span><span class="sxs-lookup"><span data-stu-id="1e644-170">Because the preceding example uses bolts for writing to Data Lake Store, the number of spouts is not directly relevant to the bolt performance.</span></span> <span data-ttu-id="1e644-171">不過，根據 Spout 中發生的處理或 I/O 數量，最好是微調 Spout 以獲得最佳效能。</span><span class="sxs-lookup"><span data-stu-id="1e644-171">However, depending on the amount of processing or I/O happening in the spout, it's a good idea to tune the spouts for best performance.</span></span> <span data-ttu-id="1e644-172">確定您有足夠的 Spout 能讓 Bolt 保持忙碌。</span><span class="sxs-lookup"><span data-stu-id="1e644-172">Ensure that you have enough spouts to be able to keep the bolts busy.</span></span> <span data-ttu-id="1e644-173">Spout 的輸出速率應該符合 Bolt 的輸送量。</span><span class="sxs-lookup"><span data-stu-id="1e644-173">The output rates of the spouts should match the throughput of the bolts.</span></span> <span data-ttu-id="1e644-174">實際組態取決於 Spout。</span><span class="sxs-lookup"><span data-stu-id="1e644-174">The actual configuration depends on the spout.</span></span>
* <span data-ttu-id="1e644-175">**工作數目。**</span><span class="sxs-lookup"><span data-stu-id="1e644-175">**Number of tasks.**</span></span> <span data-ttu-id="1e644-176">每個 Bolt 都會以單一執行緒的形式來執行。</span><span class="sxs-lookup"><span data-stu-id="1e644-176">Each bolt runs as a single thread.</span></span> <span data-ttu-id="1e644-177">每個 Bolt 的其他工作不會提供任何額外的並行能力。</span><span class="sxs-lookup"><span data-stu-id="1e644-177">Additional tasks per bolt don't provide any additional concurrency.</span></span> <span data-ttu-id="1e644-178">如果認可 Tuple 的處理序會佔用 Bolt 大部分的執行時間，它們的優點才會浮現。</span><span class="sxs-lookup"><span data-stu-id="1e644-178">The only time they are of benefit is if your process of acknowledging the tuple takes a large proportion of your bolt execution time.</span></span> <span data-ttu-id="1e644-179">您最好先將許多 Tuple 群組成較大的附加項目，再從 Bolt 傳送認可。</span><span class="sxs-lookup"><span data-stu-id="1e644-179">It's a good idea to group many tuples into a larger append before you send an acknowledgement from the bolt.</span></span> <span data-ttu-id="1e644-180">因此，在大部分情況下，多個工作不會提供額外的好處。</span><span class="sxs-lookup"><span data-stu-id="1e644-180">So, in most cases, multiple tasks provide no additional benefit.</span></span>
* <span data-ttu-id="1e644-181">**本機或隨機群組。**</span><span class="sxs-lookup"><span data-stu-id="1e644-181">**Local or shuffle grouping.**</span></span> <span data-ttu-id="1e644-182">本設定啟用時，會將 Tuple 傳送至相同背景工作處理序內的 Bolt。</span><span class="sxs-lookup"><span data-stu-id="1e644-182">When this setting is enabled, tuples are sent to bolts within the same worker process.</span></span> <span data-ttu-id="1e644-183">這可降低處理序間的通訊和網路呼叫。</span><span class="sxs-lookup"><span data-stu-id="1e644-183">This reduces inter-process communication and network calls.</span></span> <span data-ttu-id="1e644-184">這是大部分拓撲的建議作法。</span><span class="sxs-lookup"><span data-stu-id="1e644-184">This is recommended for most topologies.</span></span>

<span data-ttu-id="1e644-185">這個基本案例是不錯的起點。</span><span class="sxs-lookup"><span data-stu-id="1e644-185">This basic scenario is a good starting point.</span></span> <span data-ttu-id="1e644-186">使用您自己的資料進行測試來調整前述參數，以達到最佳效能。</span><span class="sxs-lookup"><span data-stu-id="1e644-186">Test with your own data to tweak the preceding parameters to achieve optimal performance.</span></span>

## <a name="tune-the-spout"></a><span data-ttu-id="1e644-187">微調 Spout</span><span class="sxs-lookup"><span data-stu-id="1e644-187">Tune the spout</span></span>

<span data-ttu-id="1e644-188">您可以修改下列設定來微調 Spout。</span><span class="sxs-lookup"><span data-stu-id="1e644-188">You can modify the following settings to tune the spout.</span></span>

- <span data-ttu-id="1e644-189">**Tuple 逾時︰topology.message.timeout.secs**。</span><span class="sxs-lookup"><span data-stu-id="1e644-189">**Tuple timeout: topology.message.timeout.secs**.</span></span> <span data-ttu-id="1e644-190">此設定會決定訊息完成和接收認可所需的時間量，在此時間後，便會將訊息視為失敗。</span><span class="sxs-lookup"><span data-stu-id="1e644-190">This setting determines the amount of time a message takes to complete, and receive acknowledgement, before it is considered failed.</span></span>

- <span data-ttu-id="1e644-191">**每個背景工作處理序的記憶體上限：worker.childopts**。</span><span class="sxs-lookup"><span data-stu-id="1e644-191">**Max memory per worker process: worker.childopts**.</span></span> <span data-ttu-id="1e644-192">此設定可讓您指定 Java 背景工作的其他命令列參數。</span><span class="sxs-lookup"><span data-stu-id="1e644-192">This setting lets you specify additional command-line parameters to the Java workers.</span></span> <span data-ttu-id="1e644-193">這裡最常使用的設定是 XmX，它會決定配置給 JVM 堆積的記憶體上限。</span><span class="sxs-lookup"><span data-stu-id="1e644-193">The most commonly used setting here is XmX, which determines the maximum memory allocated to a JVM’s heap.</span></span>

- <span data-ttu-id="1e644-194">**Spout 暫止上限：topology.max.spout.pending**。</span><span class="sxs-lookup"><span data-stu-id="1e644-194">**Max spout pending: topology.max.spout.pending**.</span></span> <span data-ttu-id="1e644-195">此設定會決定任何時候每個 Spout 執行緒可以有的傳輸中 (尚未在拓撲中的所有節點上受到認可) Tuple 數目。</span><span class="sxs-lookup"><span data-stu-id="1e644-195">This setting determines the number of tuples that can in be flight (not yet acknowledged at all nodes in the topology) per spout thread at any time.</span></span>

 <span data-ttu-id="1e644-196">良好的計算方式是估計每個 Tuple 的大小。</span><span class="sxs-lookup"><span data-stu-id="1e644-196">A good calculation to do is to estimate the size of each of your tuples.</span></span> <span data-ttu-id="1e644-197">然後找出一個 Spout 執行緒有多少記憶體。</span><span class="sxs-lookup"><span data-stu-id="1e644-197">Then figure out how much memory one spout thread has.</span></span> <span data-ttu-id="1e644-198">配置給執行緒的記憶體總數除以這個值，應該就能得出最大 Spout 暫止參數的上限。</span><span class="sxs-lookup"><span data-stu-id="1e644-198">The total memory allocated to a thread, divided by this value, should give you the upper bound for the max spout pending parameter.</span></span>

## <a name="tune-the-bolt"></a><span data-ttu-id="1e644-199">微調 Bolt</span><span class="sxs-lookup"><span data-stu-id="1e644-199">Tune the bolt</span></span>
<span data-ttu-id="1e644-200">在寫入至 Data Lake Store 時，請將大小同步處理原則 (用戶端上的緩衝區) 設為 4 MB。</span><span class="sxs-lookup"><span data-stu-id="1e644-200">When you're writing to Data Lake Store, set a size sync policy (buffer on the client side) to 4 MB.</span></span> <span data-ttu-id="1e644-201">當緩衝區大小達到上述值時，便會執行排清或 hsync()。</span><span class="sxs-lookup"><span data-stu-id="1e644-201">A flushing or hsync() is then performed only when the buffer size is the at this value.</span></span> <span data-ttu-id="1e644-202">背景工作 VM 上的 Data Lake Store 驅動程式會自動執行此緩衝作業，除非您明確執行 hsync()。</span><span class="sxs-lookup"><span data-stu-id="1e644-202">The Data Lake Store driver on the worker VM automatically does this buffering, unless you explicitly perform an hsync().</span></span>

<span data-ttu-id="1e644-203">預設 Data Lake Store Storm Bolt 有一個大小同步處理原則參數 (fileBufferSize) 可用來調整此參數。</span><span class="sxs-lookup"><span data-stu-id="1e644-203">The default Data Lake Store Storm bolt has a size sync policy parameter (fileBufferSize) that can be used to tune this parameter.</span></span>

<span data-ttu-id="1e644-204">在 I/O 密集的拓撲中，最好讓每個 Bolt 執行緒寫入到自己的檔案中，並設定檔案輪替原則 (fileRotationSize)。</span><span class="sxs-lookup"><span data-stu-id="1e644-204">In I/O-intensive topologies, it's a good idea to have each bolt thread write to its own file, and to set a file rotation policy (fileRotationSize).</span></span> <span data-ttu-id="1e644-205">當檔案達到特定大小時，就會自動排清資料流，並在其中寫入新檔案。</span><span class="sxs-lookup"><span data-stu-id="1e644-205">When the file reaches a certain size, the stream is automatically flushed and a new file is written to.</span></span> <span data-ttu-id="1e644-206">建議的輪替檔案大小為 1 GB。</span><span class="sxs-lookup"><span data-stu-id="1e644-206">The recommended file size for rotation is 1 GB.</span></span>

### <a name="handle-tuple-data"></a><span data-ttu-id="1e644-207">處理 Tuple 資料</span><span class="sxs-lookup"><span data-stu-id="1e644-207">Handle tuple data</span></span>

<span data-ttu-id="1e644-208">在 Storm 中，Spout 會控制住 Tuple，直到後者受到 Bolt 明確認可。</span><span class="sxs-lookup"><span data-stu-id="1e644-208">In Storm, a spout holds on to a tuple until it is explicitly acknowledged by the bolt.</span></span> <span data-ttu-id="1e644-209">如果 Tuple 已被 Bolt 讀取，卻未受到認可，就表示 Spout 可能未持續到 Data Lake Store 後端。</span><span class="sxs-lookup"><span data-stu-id="1e644-209">If a tuple has been read by the bolt but has not been acknowledged yet, the spout might not have persisted into Data Lake Store back end.</span></span> <span data-ttu-id="1e644-210">在 Tuple 受到認可後，Spout 就可由 Bolt 保證持續性，然後它就可以刪除來源資料，不論該資料是讀取自任何來源。</span><span class="sxs-lookup"><span data-stu-id="1e644-210">After a tuple is acknowledged, the spout can be guaranteed persistence by the bolt, and can then delete the source data from whatever source it is reading from.</span></span>  

<span data-ttu-id="1e644-211">為了在 Data Lake Store 獲得最佳效能，請讓 Bolt 緩衝 4 MB 的 Tuple 資料。</span><span class="sxs-lookup"><span data-stu-id="1e644-211">For best performance on Data Lake Store, have the bolt buffer 4 MB of tuple data.</span></span> <span data-ttu-id="1e644-212">然後以一個 4 MB 寫入作業的形式寫入至 Data Lake Store 後端。</span><span class="sxs-lookup"><span data-stu-id="1e644-212">Then write to the Data Lake Store back end as one 4-MB write.</span></span> <span data-ttu-id="1e644-213">在資料成功地寫入至存放區 (透過呼叫 hflush()) 後，Bolt 就可以將資料認可回到 Spout。</span><span class="sxs-lookup"><span data-stu-id="1e644-213">After the data has been successfully written to the store (by calling hflush()), the bolt can acknowledge the data back to the spout.</span></span> <span data-ttu-id="1e644-214">此處提供的範例 Bolt 就是這種作法。</span><span class="sxs-lookup"><span data-stu-id="1e644-214">This is what the example bolt supplied here does.</span></span> <span data-ttu-id="1e644-215">您也可以先保存較大量的 Tuple 再呼叫 hflush() 並認可 Tuple。</span><span class="sxs-lookup"><span data-stu-id="1e644-215">It is also acceptable to hold a larger number of tuples before the hflush() call is made and the tuples acknowledged.</span></span> <span data-ttu-id="1e644-216">不過，這會增加 Spout 需要保存的傳輸中 Tuple 數目，因此會增加每個 JVM 需要的記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="1e644-216">However, this increases the number of tuples in flight that the spout needs to hold, and therefore increases the amount of memory required per JVM.</span></span>

> [!NOTE]
<span data-ttu-id="1e644-217">基於其他非效能理由，應用程式可能需要更加頻繁地認可 Tuple (在資料大小小於 4 MB 時)。</span><span class="sxs-lookup"><span data-stu-id="1e644-217">Applications might have a requirement to acknowledge tuples more frequently (at data sizes less than 4 MB) for other non-performance reasons.</span></span> <span data-ttu-id="1e644-218">不過，這可能會影響儲存體後端的 I/O 輸送量。</span><span class="sxs-lookup"><span data-stu-id="1e644-218">However, that might affect the I/O throughput to the storage back end.</span></span> <span data-ttu-id="1e644-219">請針對此一缺點與 Bolt 的 I/O 效能進行仔細衡量。</span><span class="sxs-lookup"><span data-stu-id="1e644-219">Carefully weigh this tradeoff against the bolt’s I/O performance.</span></span>

<span data-ttu-id="1e644-220">如果 Tuple 的傳入速率不高，因此 4 MB 的緩衝區需要很久才能填滿，請考慮以下列方式減輕此問題︰</span><span class="sxs-lookup"><span data-stu-id="1e644-220">If the incoming rate of tuples is not high, so the 4-MB buffer takes a long time to fill, consider mitigating this by:</span></span>
* <span data-ttu-id="1e644-221">減少 Bolt 數目，讓要填滿的緩衝區變少。</span><span class="sxs-lookup"><span data-stu-id="1e644-221">Reducing the number of bolts, so there are fewer buffers to fill.</span></span>
* <span data-ttu-id="1e644-222">設定以時間或計數為基礎的原則，其中 hflush() 每隔 x 次排清或每隔 y 毫秒就會觸發，並將累積到目前為止的 Tuple 認可回去。</span><span class="sxs-lookup"><span data-stu-id="1e644-222">Having a time-based or count-based policy, where an hflush() is triggered every x flushes or every y milliseconds, and the tuples accumulated so far are acknowledged back.</span></span>

<span data-ttu-id="1e644-223">請注意，輸送量在此情況下會降低，但在低事件速率下，反正最大輸送量不是我們的最大目標。</span><span class="sxs-lookup"><span data-stu-id="1e644-223">Note that the throughput in this case is lower, but with a slow rate of events, maximum throughput is not the biggest objective anyway.</span></span> <span data-ttu-id="1e644-224">這些減輕措施可幫助您減少 Tuple 流動至存放區所需的總時間。</span><span class="sxs-lookup"><span data-stu-id="1e644-224">These mitigations help you reduce the total time that it takes for a tuple to flow through to the store.</span></span> <span data-ttu-id="1e644-225">如果您無論如何都想要即時管線 (即使事件速率會偏低)，這一點可能就很重要。</span><span class="sxs-lookup"><span data-stu-id="1e644-225">This might matter if you want a real-time pipeline even with a low event rate.</span></span> <span data-ttu-id="1e644-226">也請注意，如果傳入的 Tuple 速率較低，您應該調整 topology.message.timeout_secs 參數，讓 Tuple 不會在進行緩衝處理或處理時逾時。</span><span class="sxs-lookup"><span data-stu-id="1e644-226">Also note that if your incoming tuple rate is low, you should adjust the topology.message.timeout_secs parameter, so the tuples don’t time out while they are getting buffered or processed.</span></span>

## <a name="monitor-your-topology-in-storm"></a><span data-ttu-id="1e644-227">監視 Storm 中的拓撲</span><span class="sxs-lookup"><span data-stu-id="1e644-227">Monitor your topology in Storm</span></span>  
<span data-ttu-id="1e644-228">當您的拓撲在執行時，您可以在 Storm 使用者介面中進行監視。</span><span class="sxs-lookup"><span data-stu-id="1e644-228">While your topology is running, you can monitor it in the Storm user interface.</span></span> <span data-ttu-id="1e644-229">以下是應該注意的主要參數︰</span><span class="sxs-lookup"><span data-stu-id="1e644-229">Here are the main parameters to look at:</span></span>

* <span data-ttu-id="1e644-230">**總處理序執行延遲。**</span><span class="sxs-lookup"><span data-stu-id="1e644-230">**Total process execution latency.**</span></span> <span data-ttu-id="1e644-231">這是一個 Tuple 由 Spout 發出、由 Bolt 處理並受到認可所花費的平均時間。</span><span class="sxs-lookup"><span data-stu-id="1e644-231">This is the average time one tuple takes to be emitted by the spout, processed by the bolt, and acknowledged.</span></span>

* <span data-ttu-id="1e644-232">**總 Bolt 處理序延遲。**</span><span class="sxs-lookup"><span data-stu-id="1e644-232">**Total bolt process latency.**</span></span> <span data-ttu-id="1e644-233">這是 Tuple 收到認可之前在 Bolt 所花費的平均時間。</span><span class="sxs-lookup"><span data-stu-id="1e644-233">This is the average time spent by the tuple at the bolt until it receives an acknowledgement.</span></span>

* <span data-ttu-id="1e644-234">**總 Bolt 執行延遲。**</span><span class="sxs-lookup"><span data-stu-id="1e644-234">**Total bolt execute latency.**</span></span> <span data-ttu-id="1e644-235">這是 Bolt 在 execute 方法所花費的平均時間。</span><span class="sxs-lookup"><span data-stu-id="1e644-235">This is the average time spent by the bolt in the execute method.</span></span>

* <span data-ttu-id="1e644-236">**失敗次數。**</span><span class="sxs-lookup"><span data-stu-id="1e644-236">**Number of failures.**</span></span> <span data-ttu-id="1e644-237">這是指 Tuple 在逾時之前能夠無法完全處理的次數。</span><span class="sxs-lookup"><span data-stu-id="1e644-237">This refers to the number of tuples that failed to be fully processed before they timed out.</span></span>

* <span data-ttu-id="1e644-238">**容量。**</span><span class="sxs-lookup"><span data-stu-id="1e644-238">**Capacity.**</span></span> <span data-ttu-id="1e644-239">這是系統忙碌程度的量值。</span><span class="sxs-lookup"><span data-stu-id="1e644-239">This is a measure of how busy your system is.</span></span> <span data-ttu-id="1e644-240">如果這個數字為 1，Bolt 會以它最快的速度工作。</span><span class="sxs-lookup"><span data-stu-id="1e644-240">If this number is 1, your bolts are working as fast as they can.</span></span> <span data-ttu-id="1e644-241">如果小於 1，將會增加平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="1e644-241">If it is less than 1, increase the parallelism.</span></span> <span data-ttu-id="1e644-242">如果大於 1，則會減少平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="1e644-242">If it is greater than 1, reduce the parallelism.</span></span>

## <a name="troubleshoot-common-problems"></a><span data-ttu-id="1e644-243">針對常見問題進行疑難排解</span><span class="sxs-lookup"><span data-stu-id="1e644-243">Troubleshoot common problems</span></span>
<span data-ttu-id="1e644-244">以下是一些常見的疑難排解案例。</span><span class="sxs-lookup"><span data-stu-id="1e644-244">Here are a few common troubleshooting scenarios.</span></span>
* <span data-ttu-id="1e644-245">**許多 Tuple 逾時。**</span><span class="sxs-lookup"><span data-stu-id="1e644-245">**Many tuples are timing out.**</span></span> <span data-ttu-id="1e644-246">查看拓撲中的每個節點，以判斷瓶頸所在。</span><span class="sxs-lookup"><span data-stu-id="1e644-246">Look at each node in the topology to determine where the bottleneck is.</span></span> <span data-ttu-id="1e644-247">最常見的原因是 Bolt 無法跟上 Spout。</span><span class="sxs-lookup"><span data-stu-id="1e644-247">The most common reason for this is that the bolts are not able to keep up with the spouts.</span></span> <span data-ttu-id="1e644-248">這導致 Tuple 在等待處理時阻塞了內部緩衝區。</span><span class="sxs-lookup"><span data-stu-id="1e644-248">This leads to tuples clogging the internal buffers while waiting to be processed.</span></span> <span data-ttu-id="1e644-249">請考慮增加逾時值，或減少 Spout 暫止上限。</span><span class="sxs-lookup"><span data-stu-id="1e644-249">Consider increasing the timeout value or decreasing the max spout pending.</span></span>

* <span data-ttu-id="1e644-250">**總處理序執行延遲很高，但 Bolt 處理序延遲卻很低。**</span><span class="sxs-lookup"><span data-stu-id="1e644-250">**There is a high total process execution latency, but a low bolt process latency.**</span></span> <span data-ttu-id="1e644-251">在此情況下，認可 Tuple 的速度可能不夠快。</span><span class="sxs-lookup"><span data-stu-id="1e644-251">In this case, it is possible that the tuples are not being acknowledged fast enough.</span></span> <span data-ttu-id="1e644-252">請確認認可者的數量足夠。</span><span class="sxs-lookup"><span data-stu-id="1e644-252">Check that there are a sufficient number of acknowledgers.</span></span> <span data-ttu-id="1e644-253">另一個可能的原因是，它們在佇列中等待很久之後，Bolt 才開始處理。</span><span class="sxs-lookup"><span data-stu-id="1e644-253">Another possibility is that they are waiting in the queue for too long before the bolts start processing them.</span></span> <span data-ttu-id="1e644-254">減少 Spout 暫止上限。</span><span class="sxs-lookup"><span data-stu-id="1e644-254">Decrease the max spout pending.</span></span>

* <span data-ttu-id="1e644-255">**Bolt 執行延遲很高。**</span><span class="sxs-lookup"><span data-stu-id="1e644-255">**There is a high bolt execute latency.**</span></span> <span data-ttu-id="1e644-256">這表示 Bolt 的 execute() 方法花費太久時間。</span><span class="sxs-lookup"><span data-stu-id="1e644-256">This means that the execute() method of your bolt is taking too long.</span></span> <span data-ttu-id="1e644-257">請將程式碼最佳化，或查看寫入大小和排清行為。</span><span class="sxs-lookup"><span data-stu-id="1e644-257">Optimize the code, or look at write sizes and flush behavior.</span></span>

### <a name="data-lake-store-throttling"></a><span data-ttu-id="1e644-258">Data Lake Store 節流</span><span class="sxs-lookup"><span data-stu-id="1e644-258">Data Lake Store throttling</span></span>
<span data-ttu-id="1e644-259">如果您達到 Data Lake Store 所提供的頻寬限制，您可能會看到工作失敗。</span><span class="sxs-lookup"><span data-stu-id="1e644-259">If you hit the limits of bandwidth provided by Data Lake Store, you might see task failures.</span></span> <span data-ttu-id="1e644-260">請檢查工作記錄中的節流錯誤。</span><span class="sxs-lookup"><span data-stu-id="1e644-260">Check task logs for throttling errors.</span></span> <span data-ttu-id="1e644-261">您可以藉由增加容器大小來減少平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="1e644-261">You can decrease the parallelism by increasing container size.</span></span>    

<span data-ttu-id="1e644-262">若要檢查您是否遭到節流，請在用戶端啟用偵錯記錄：</span><span class="sxs-lookup"><span data-stu-id="1e644-262">To check if you are getting throttled, enable the debug logging on the client side:</span></span>

1. <span data-ttu-id="1e644-263">在 [Ambari] > [Storm] > [設定] > [Advanced storm-worker-log4j] 中，將 **&lt;root level="info"&gt;** 變更為 **&lt;root level=”debug”&gt;**。</span><span class="sxs-lookup"><span data-stu-id="1e644-263">In **Ambari** > **Storm** > **Config** > **Advanced storm-worker-log4j**, change **&lt;root level="info"&gt;** to **&lt;root level=”debug”&gt;**.</span></span> <span data-ttu-id="1e644-264">重新啟動所有節點/服務，以便讓設定生效。</span><span class="sxs-lookup"><span data-stu-id="1e644-264">Restart all the nodes/service for the configuration to take effect.</span></span>
2. <span data-ttu-id="1e644-265">監視背景工作節點上的 Storm 拓撲記錄檔 (在 /var/log/storm/worker-artifacts/&lt;TopologyName&gt;/&lt;port&gt;/worker.log 下)，注意是否有 Data Lake Store 節流例外狀況。</span><span class="sxs-lookup"><span data-stu-id="1e644-265">Monitor the Storm topology logs on worker nodes (under /var/log/storm/worker-artifacts/&lt;TopologyName&gt;/&lt;port&gt;/worker.log) for Data Lake Store throttling exceptions.</span></span>

## <a name="next-steps"></a><span data-ttu-id="1e644-266">後續步驟</span><span class="sxs-lookup"><span data-stu-id="1e644-266">Next steps</span></span>
<span data-ttu-id="1e644-267">Storm 的其他效能微調請參考[此部落格](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/)。</span><span class="sxs-lookup"><span data-stu-id="1e644-267">Additional performance tuning for Storm can be referenced in [this blog](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/).</span></span>

<span data-ttu-id="1e644-268">如需可執行的其他範例，請參閱 [GitHub 上的這一個](https://github.com/hdinsight/storm-performance-automation)。</span><span class="sxs-lookup"><span data-stu-id="1e644-268">For an additional example to run, see [this one on GitHub](https://github.com/hdinsight/storm-performance-automation).</span></span>
