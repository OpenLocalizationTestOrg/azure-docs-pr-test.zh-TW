---
title: "Azure SQL Database 效能微調指引 | Microsoft Docs"
description: "本文可協助您判斷要為您的應用程式選擇哪個服務層。 文中也會建議微調應用程式以充分利用 Azure SQL Database 的方式。"
services: sql-database
documentationcenter: na
author: CarlRabeler
manager: jhubbard
editor: 
ms.assetid: dd8d95fa-24b2-4233-b3f1-8e8952a7a22b
ms.service: sql-database
ms.custom: monitor & tune
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: data-management
ms.date: 02/09/2017
ms.author: carlrab
ms.openlocfilehash: dc0244f0e0949b172c391825057f5c14893a5158
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="tuning-performance-in-azure-sql-database"></a><span data-ttu-id="8a803-104">微調 Azure SQL Database 中的資料庫效能</span><span class="sxs-lookup"><span data-stu-id="8a803-104">Tuning performance in Azure SQL Database</span></span>

<span data-ttu-id="8a803-105">Azure SQL Database 提供您可以用來改善資料庫效能的[建議](sql-database-advisor.md)，或您可讓 Azure SQL Database [自動調整應用程式](sql-database-automatic-tuning.md)並套用可改善工作負載效能的變更。</span><span class="sxs-lookup"><span data-stu-id="8a803-105">Azure SQL Database provides [recommendations](sql-database-advisor.md) that you can use to improve performance of your database, or you can let Azure SQL Database [automatically adapt to your application](sql-database-automatic-tuning.md) and apply changes that will improve performance of your workload.</span></span>

<span data-ttu-id="8a803-106">如果沒有任何適用的建議且仍有效能問題，您可以使用下列方法來改善效能：</span><span class="sxs-lookup"><span data-stu-id="8a803-106">In you don't have any applicable recommendations, and you still have performance issues, you might use the following methods to improve performances:</span></span>
1. <span data-ttu-id="8a803-107">增加[服務層](sql-database-service-tiers.md)並將更多資源提供給您的資料庫。</span><span class="sxs-lookup"><span data-stu-id="8a803-107">Increase [service tiers](sql-database-service-tiers.md) and provide more resources to your database.</span></span>
2. <span data-ttu-id="8a803-108">微調您的應用程式，並套用一些可以改善效能的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="8a803-108">Tune your application and apply some best practices that can improve performance.</span></span> 
3. <span data-ttu-id="8a803-109">變更索引和查詢來微調資料庫，更有效率地使用資料。</span><span class="sxs-lookup"><span data-stu-id="8a803-109">Tune the database by changing indexes and queries to more efficiently work with data.</span></span>

<span data-ttu-id="8a803-110">這些都是手動方法，因為您必須決定要選擇的[服務層](sql-database-service-tiers.md)，或您必須重寫應用程式或資料庫的程式碼，以及部署所做的變更。</span><span class="sxs-lookup"><span data-stu-id="8a803-110">These are manual methods because you need to decide what [service tiers](sql-database-service-tiers.md) you would choose or you would need to rewrite application or database code and deply the changes.</span></span>

## <a name="increasing-performance-tier-of-your-database"></a><span data-ttu-id="8a803-111">增加資料庫的效能層級</span><span class="sxs-lookup"><span data-stu-id="8a803-111">Increasing performance tier of your database</span></span>

<span data-ttu-id="8a803-112">Azure SQL Database 提供四個[服務層](sql-database-service-tiers.md)供您選擇：基本、標準、進階及進階 RS (以資料庫輸送量單位 (簡稱 [DTU](sql-database-what-is-a-dtu.md)) 測量效能)。</span><span class="sxs-lookup"><span data-stu-id="8a803-112">Azure SQL Database offers four [service tiers](sql-database-service-tiers.md) that you can choose from: Basic, Standard, Premium, and Premium RS (performance is measured in database throughput units, or [DTUs](sql-database-what-is-a-dtu.md).</span></span> <span data-ttu-id="8a803-113">每個服務層會嚴格地隔離出 SQL Database 可以使用的資源，並保證該服務層級會有可預測的效能。</span><span class="sxs-lookup"><span data-stu-id="8a803-113">Each service tier strictly isolates the resources that your SQL database can use, and guarantees predictable performance for that service level.</span></span> <span data-ttu-id="8a803-114">在本文中，我們會提供指引來協助您選擇應用程式的服務層。</span><span class="sxs-lookup"><span data-stu-id="8a803-114">In this article, we offer guidance that can help you choose the service tier for your application.</span></span> <span data-ttu-id="8a803-115">我們也會討論您可以微調應用程式以充分利用 Azure SQL Database 的方式。</span><span class="sxs-lookup"><span data-stu-id="8a803-115">We also discuss ways that you can tune your application to get the most from Azure SQL Database.</span></span>

> [!NOTE]
> <span data-ttu-id="8a803-116">本文著重在 Azure SQL Database 中單一資料庫的效能指引。</span><span class="sxs-lookup"><span data-stu-id="8a803-116">This article focuses on performance guidance for single databases in Azure SQL Database.</span></span> <span data-ttu-id="8a803-117">如需彈性集區的相關效能指引，請參閱[彈性集區的價格和效能考量](sql-database-elastic-pool-guidance.md)。</span><span class="sxs-lookup"><span data-stu-id="8a803-117">For performance guidance related to elastic pools, see [Price and performance considerations for elastic pools](sql-database-elastic-pool-guidance.md).</span></span> <span data-ttu-id="8a803-118">但請注意，您可以將本文的諸多微調建議套用到彈性集區中的資料庫，並獲得類似的效能優點。</span><span class="sxs-lookup"><span data-stu-id="8a803-118">Note, though, that you can apply many of the tuning recommendations in this article to databases in an elastic pool, and get similar performance benefits.</span></span>
> 

* <span data-ttu-id="8a803-119">**基本**：基本服務層會每小時為每個資料庫提供良好的效能可預測性。</span><span class="sxs-lookup"><span data-stu-id="8a803-119">**Basic**: The Basic service tier offers good performance predictability for each database, hour over hour.</span></span> <span data-ttu-id="8a803-120">在基本資料庫中，會有足夠的資源可在不會有多個並行要求的小型資料庫中支援良好的效能。</span><span class="sxs-lookup"><span data-stu-id="8a803-120">In a Basic database, sufficient resources support good performance in a small database that doesn't have multiple concurrent requests.</span></span> <span data-ttu-id="8a803-121">使用基本服務層時的一般使用案例如下：</span><span class="sxs-lookup"><span data-stu-id="8a803-121">Typical use cases when you would use Basic service tier are:</span></span>
  * <span data-ttu-id="8a803-122">**您剛開始使用 Azure SQL Database**。</span><span class="sxs-lookup"><span data-stu-id="8a803-122">**You're just getting started with Azure SQL Database**.</span></span> <span data-ttu-id="8a803-123">開發中的應用程式通常不需要很高的效能等級。</span><span class="sxs-lookup"><span data-stu-id="8a803-123">Applications that are in development often don't need high-performance levels.</span></span> <span data-ttu-id="8a803-124">基本資料庫的價格便宜，是適合用來開發或測試資料庫的理想環境。</span><span class="sxs-lookup"><span data-stu-id="8a803-124">Basic databases are an ideal environment for database development or testing, at a low price point.</span></span>
  * <span data-ttu-id="8a803-125">**您的資料庫只有單一使用者**。</span><span class="sxs-lookup"><span data-stu-id="8a803-125">**You have a database with a single user**.</span></span> <span data-ttu-id="8a803-126">將單一使用者與資料庫相關聯的應用程式通常沒有高度的並行存取和效能需求。</span><span class="sxs-lookup"><span data-stu-id="8a803-126">Applications that associate a single user with a database typically don’t have high concurrency and performance requirements.</span></span> <span data-ttu-id="8a803-127">這些應用程式適合使用基本服務層。</span><span class="sxs-lookup"><span data-stu-id="8a803-127">These applications are candidates for the Basic service tier.</span></span>
* <span data-ttu-id="8a803-128">**標準**：標準服務層提供更佳的效能可預測性，還可讓具有多個並行要求的資料庫發揮更高效能，例如工作群組和 Web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="8a803-128">**Standard**: The Standard service tier offers improved performance predictability and provides good performance for databases that have multiple concurrent requests, like workgroup and web applications.</span></span> <span data-ttu-id="8a803-129">當您使用標準服務層資料庫時，您可以根據可預測的效能，每分鐘調整資料庫應用程式的大小。</span><span class="sxs-lookup"><span data-stu-id="8a803-129">When you choose a Standard service tier database, you can size your database application based on predictable performance, minute over minute.</span></span>
  * <span data-ttu-id="8a803-130">**您的資料庫有多個並行要求**。</span><span class="sxs-lookup"><span data-stu-id="8a803-130">**Your database has multiple concurrent requests**.</span></span> <span data-ttu-id="8a803-131">一次服務多名使用者的應用程式通常需要較高的效能等級。</span><span class="sxs-lookup"><span data-stu-id="8a803-131">Applications that service more than one user at a time usually need higher performance levels.</span></span> <span data-ttu-id="8a803-132">例如，支援多個並行查詢且 IO 流量需求為低至中的工作群組或 Web 應用程式，都適合使用標準服務層。</span><span class="sxs-lookup"><span data-stu-id="8a803-132">For example, workgroup or web applications that have low to medium IO traffic requirements supporting multiple concurrent queries are good candidates for the Standard service tier.</span></span>
* <span data-ttu-id="8a803-133">**進階**：進階服務層會針對每個進階資料庫，每秒提供可預測的效能。</span><span class="sxs-lookup"><span data-stu-id="8a803-133">**Premium**: The Premium service tier provides predictable performance, second over second, for each Premium database.</span></span> <span data-ttu-id="8a803-134">當您選擇進階服務層時，您可以根據資料庫的尖峰負載調整資料庫應用程式的大小。</span><span class="sxs-lookup"><span data-stu-id="8a803-134">When you choose the Premium service tier, you can size your database application based on the peak load for that database.</span></span> <span data-ttu-id="8a803-135">此方案可去除效能差異可能會導致小型查詢所花費的時間，超過延遲敏感作業預期花費時間的情況。</span><span class="sxs-lookup"><span data-stu-id="8a803-135">The plan removes cases in which performance variance can cause small queries to take longer than expected in latency-sensitive operations.</span></span> <span data-ttu-id="8a803-136">此模型可大幅簡化應用程式的開發與產品驗證週期，這些應用程式必須提出尖峰資源需求、效能差異或查詢延遲的相關強式陳述式。</span><span class="sxs-lookup"><span data-stu-id="8a803-136">This model can greatly simplify the development and product validation cycles for applications that need to make strong statements about peak resource needs, performance variance, or query latency.</span></span> <span data-ttu-id="8a803-137">大多數進階服務層使用案例具有下列一或多項特性︰</span><span class="sxs-lookup"><span data-stu-id="8a803-137">Most Premium service tier use cases have one or more of these characteristics:</span></span>
  * <span data-ttu-id="8a803-138">**高尖峰負載**。</span><span class="sxs-lookup"><span data-stu-id="8a803-138">**High peak load**.</span></span> <span data-ttu-id="8a803-139">需要大量 CPU、記憶體或輸入/輸出 (I/O) 以完成其作業的應用程式，需要的是專用、高效能的等級。</span><span class="sxs-lookup"><span data-stu-id="8a803-139">An application that requires substantial CPU, memory, or input/output (I/O) to complete its operations requires a dedicated, high-performance level.</span></span> <span data-ttu-id="8a803-140">例如，已知會長時間取用數個 CPU 核心的資料庫作業，就適合使用進階服務層。</span><span class="sxs-lookup"><span data-stu-id="8a803-140">For example, a database operation known to consume several CPU cores for an extended time is a candidate for the Premium service tier.</span></span>
  * <span data-ttu-id="8a803-141">**許多並行要求**。</span><span class="sxs-lookup"><span data-stu-id="8a803-141">**Many concurrent requests**.</span></span> <span data-ttu-id="8a803-142">某些資料庫應用程式會為許多並行要求提供服務，例如，在為具有高流量的網站提供服務時。</span><span class="sxs-lookup"><span data-stu-id="8a803-142">Some database applications service many concurrent requests, for example, when serving a website that has a high traffic volume.</span></span> <span data-ttu-id="8a803-143">基本和標準服務層會限制每個資料庫的並行要求數目。</span><span class="sxs-lookup"><span data-stu-id="8a803-143">Basic and Standard service tiers limit the number of concurrent requests per database.</span></span> <span data-ttu-id="8a803-144">需要更多連線的應用程式必須選擇適當的預留大小才能處理最大數目的所需要求。</span><span class="sxs-lookup"><span data-stu-id="8a803-144">Applications that require more connections would need to choose an appropriate reservation size to handle the maximum number of needed requests.</span></span>
  * <span data-ttu-id="8a803-145">**低延遲**。</span><span class="sxs-lookup"><span data-stu-id="8a803-145">**Low latency**.</span></span> <span data-ttu-id="8a803-146">某些應用程式必須保證在最短的時間內傳回資料庫回應。</span><span class="sxs-lookup"><span data-stu-id="8a803-146">Some applications need to guarantee a response from the database in minimal time.</span></span> <span data-ttu-id="8a803-147">如果呼叫特定的預存程序做為更廣泛客戶作業的一部分，您可能需要該呼叫在 20 毫秒 (也就是 99% 的時間) 內傳回回應。</span><span class="sxs-lookup"><span data-stu-id="8a803-147">If a specific stored procedure is called as part of a broader customer operation, you might have a requirement to have a return from that call in no more than 20 milliseconds, 99 percent of the time.</span></span> <span data-ttu-id="8a803-148">這類應用程式會受益於高階資料庫，以確定所需的運算能力可供使用。</span><span class="sxs-lookup"><span data-stu-id="8a803-148">This type of application benefits from the Premium service tier, to make sure that the required computing power is available.</span></span>
* <span data-ttu-id="8a803-149">**進階 RS**：進階 RS 專為需要大量 IO 但不需要高可用性保證的工作負載所設計。</span><span class="sxs-lookup"><span data-stu-id="8a803-149">**Premium RS**: The Premium RS tier is designed for IO-intensive workloads that do not require the highest availability guarantees.</span></span> <span data-ttu-id="8a803-150">範例包括測試高效能工作負載，或資料庫不是記錄系統的分析工作負載。</span><span class="sxs-lookup"><span data-stu-id="8a803-150">Examples include testing high-performance workloads, or an analytical workload where the database is not the system of record.</span></span>

<span data-ttu-id="8a803-151">您需要的 SQL Database 服務等級取決於每個資源維度的尖峰負載需求。</span><span class="sxs-lookup"><span data-stu-id="8a803-151">The service level that you need for your SQL database depends on the peak load requirements for each resource dimension.</span></span> <span data-ttu-id="8a803-152">有些應用程式雖使用少量的某一資源，但卻對其他資源有大量需求。</span><span class="sxs-lookup"><span data-stu-id="8a803-152">Some applications use a trivial amount of a single resource, but have significant requirements for other resources.</span></span>

### <a name="service-tier-capabilities-and-limits"></a><span data-ttu-id="8a803-153">服務層的功能和限制</span><span class="sxs-lookup"><span data-stu-id="8a803-153">Service tier capabilities and limits</span></span>

<span data-ttu-id="8a803-154">您在每個服務層都可以設定效能等級，因此能夠彈性地只支付所需容量的費用。</span><span class="sxs-lookup"><span data-stu-id="8a803-154">At each service tier, you set the performance level, so you have the flexibility to pay only for the capacity you need.</span></span> <span data-ttu-id="8a803-155">您可以在工作負載變更時向上或向下 [調整容量](sql-database-service-tiers.md)。</span><span class="sxs-lookup"><span data-stu-id="8a803-155">You can [adjust capacity](sql-database-service-tiers.md), up or down, as workload changes.</span></span> <span data-ttu-id="8a803-156">比方說，如果資料庫工作負載在返校購物季期間很高，您可以在一段固定時間內 (7 月到 9 月) 提高資料庫的效能等級。</span><span class="sxs-lookup"><span data-stu-id="8a803-156">For example, if your database workload is high during the back-to-school shopping season, you might increase the performance level for the database for a set time, July through September.</span></span> <span data-ttu-id="8a803-157">當旺季結束時，您可以將效能等級降低。</span><span class="sxs-lookup"><span data-stu-id="8a803-157">You can reduce it when your peak season ends.</span></span> <span data-ttu-id="8a803-158">您可以依據商務季節性最佳化您的雲端環境，藉以將支出降到最低。</span><span class="sxs-lookup"><span data-stu-id="8a803-158">You can minimize what you pay by optimizing your cloud environment to the seasonality of your business.</span></span> <span data-ttu-id="8a803-159">此模型也非常適合軟體產品發行週期。</span><span class="sxs-lookup"><span data-stu-id="8a803-159">This model also works well for software product release cycles.</span></span> <span data-ttu-id="8a803-160">測試小組可以在執行測試回合時配置容量，然後在測試完成時釋放該容量。</span><span class="sxs-lookup"><span data-stu-id="8a803-160">A test team might allocate capacity while it does test runs, and then release that capacity when they finish testing.</span></span> <span data-ttu-id="8a803-161">在容量要求模型中，您可以在需要時付費使用容量，避免將支出花費在可能很少使用的專用資源上。</span><span class="sxs-lookup"><span data-stu-id="8a803-161">In a capacity request model, you pay for capacity as you need it, and avoid spending on dedicated resources that you might rarely use.</span></span>

### <a name="why-service-tiers"></a><span data-ttu-id="8a803-162">為何使用服務層？</span><span class="sxs-lookup"><span data-stu-id="8a803-162">Why service tiers?</span></span>
<span data-ttu-id="8a803-163">雖然每個資料庫的工作負載可能不同，但服務層的目的是要在各種效能等級提供效能可預測性。</span><span class="sxs-lookup"><span data-stu-id="8a803-163">Although each database workload can differ, the purpose of service tiers is to provide performance predictability at various performance levels.</span></span> <span data-ttu-id="8a803-164">對資料庫有大規模資源需求的客戶，則可以在更專用的運算環境中工作。</span><span class="sxs-lookup"><span data-stu-id="8a803-164">Customers with large-scale database resource requirements can work in a more dedicated computing environment.</span></span>

## <a name="tune-your-application"></a><span data-ttu-id="8a803-165">微調應用程式</span><span class="sxs-lookup"><span data-stu-id="8a803-165">Tune your application</span></span>
<span data-ttu-id="8a803-166">在傳統的內部部署 SQL Server 中，初始容量規劃的程序通常會和在生產環境中執行應用程式的程序分開。</span><span class="sxs-lookup"><span data-stu-id="8a803-166">In traditional on-premises SQL Server, the process of initial capacity planning often is separated from the process of running an application in production.</span></span> <span data-ttu-id="8a803-167">先購買硬體和產品授權，之後再微調效能。</span><span class="sxs-lookup"><span data-stu-id="8a803-167">Hardware and product licenses are purchased first, and performance tuning is done afterward.</span></span> <span data-ttu-id="8a803-168">當您使用 Azure SQL Database 時，最好是將執行和微調應用程式的程序交織在一起。</span><span class="sxs-lookup"><span data-stu-id="8a803-168">When you use Azure SQL Database, it's a good idea to interweave the process of running an application and tuning it.</span></span> <span data-ttu-id="8a803-169">透過容量隨選的付費模型，您可以微調應用程式以使用目前需要的最少資源，而不是根據對應用程式未來成長計劃的猜測 (這通常是不正確的) 來過度佈建。</span><span class="sxs-lookup"><span data-stu-id="8a803-169">With the model of paying for capacity on demand, you can tune your application to use the minimum resources needed now, instead of overprovisioning on hardware based on guesses of future growth plans for an application, which often are incorrect.</span></span> <span data-ttu-id="8a803-170">某些客戶可能會選擇不微調應用程式，而改為選擇過度佈建硬體資源。</span><span class="sxs-lookup"><span data-stu-id="8a803-170">Some customers might choose not to tune an application, and instead choose to overprovision hardware resources.</span></span> <span data-ttu-id="8a803-171">若您不想在忙碌時期變更關鍵應用程式，這種方法可能很適合。</span><span class="sxs-lookup"><span data-stu-id="8a803-171">This approach might be a good idea if you don't want to change a key application during a busy period.</span></span> <span data-ttu-id="8a803-172">但是，當您使用 Azure SQL Database 中的服務層時，微調應用程式可以最小化資源需求並降低每月帳單。</span><span class="sxs-lookup"><span data-stu-id="8a803-172">But, tuning an application can minimize resource requirements and lower monthly bills when you use the service tiers in Azure SQL Database.</span></span>

### <a name="application-characteristics"></a><span data-ttu-id="8a803-173">應用程式特性</span><span class="sxs-lookup"><span data-stu-id="8a803-173">Application characteristics</span></span>
<span data-ttu-id="8a803-174">雖然 Azure SQL Database 服務層的設計可以改善應用程式的效能穩定性和可預測性，但某些最佳做法可以協助您微調應用程式，以更充分利用某一效能等級的資源。</span><span class="sxs-lookup"><span data-stu-id="8a803-174">Although Azure SQL Database service tiers are designed to improve performance stability and predictability for an application, some best practices can help you tune your application to better take advantage of the resources at a performance level.</span></span> <span data-ttu-id="8a803-175">雖然許多應用程式只藉由切換至較高的效能等級或服務層就能有顯著的效能提升，但是某些應用程式需要額外的微調才能從較高的服務等級獲益。</span><span class="sxs-lookup"><span data-stu-id="8a803-175">Although many applications have significant performance gains simply by switching to a higher performance level or service tier, some applications need additional tuning to benefit from a higher level of service.</span></span> <span data-ttu-id="8a803-176">為了提高效能，請考慮為具有下列特性的應用程式進行額外的應用程式微調︰</span><span class="sxs-lookup"><span data-stu-id="8a803-176">For increased performance, consider additional application tuning for applications that have these characteristics:</span></span>

* <span data-ttu-id="8a803-177">**因為「多對話」行為而使效能變慢的應用程式**。</span><span class="sxs-lookup"><span data-stu-id="8a803-177">**Applications that have slow performance because of "chatty" behavior**.</span></span> <span data-ttu-id="8a803-178">多對話應用程式會產生過多對網路延遲敏感的資料存取作業。</span><span class="sxs-lookup"><span data-stu-id="8a803-178">Chatty applications make excessive data access operations that are sensitive to network latency.</span></span> <span data-ttu-id="8a803-179">您可能需要修改這類應用程式以減少 SQL Database 的資料存取作業數目。</span><span class="sxs-lookup"><span data-stu-id="8a803-179">You might need to modify these kinds of applications to reduce the number of data access operations to the SQL database.</span></span> <span data-ttu-id="8a803-180">比方說，您可以藉由使用某些技術來改善應用程式效能，例如批次處理特定查詢或將查詢移至預存程序。</span><span class="sxs-lookup"><span data-stu-id="8a803-180">For example, you might improve application performance by using techniques like batching ad-hoc queries or moving the queries to stored procedures.</span></span> <span data-ttu-id="8a803-181">如需詳細資訊，請參閱 [批次查詢](#batch-queries)。</span><span class="sxs-lookup"><span data-stu-id="8a803-181">For more information, see [Batch queries](#batch-queries).</span></span>
* <span data-ttu-id="8a803-182">**無法由整部單一電腦支援之具有大量工作負載的資料庫**。</span><span class="sxs-lookup"><span data-stu-id="8a803-182">**Databases with an intensive workload that can't be supported by an entire single machine**.</span></span> <span data-ttu-id="8a803-183">超過最高進階效能等級資源的資料庫可能會受益於相應放大工作負載。</span><span class="sxs-lookup"><span data-stu-id="8a803-183">Databases that exceed the resources of the highest Premium performance level might benefit from scaling out the workload.</span></span> <span data-ttu-id="8a803-184">如需詳細資訊，請參閱[跨資料庫分區化](#cross-database-sharding)和[功能資料分割](#functional-partitioning)。</span><span class="sxs-lookup"><span data-stu-id="8a803-184">For more information, see [Cross-database sharding](#cross-database-sharding) and [Functional partitioning](#functional-partitioning).</span></span>
* <span data-ttu-id="8a803-185">**具有次佳查詢的應用程式**。</span><span class="sxs-lookup"><span data-stu-id="8a803-185">**Applications that have suboptimal queries**.</span></span> <span data-ttu-id="8a803-186">其查詢未經適當微調的應用程式，尤其是位在資料存取層中者，可能無法受益於較高的效能等級。</span><span class="sxs-lookup"><span data-stu-id="8a803-186">Applications, especially those in the data access layer, that have poorly tuned queries might not benefit from a higher performance level.</span></span> <span data-ttu-id="8a803-187">這包括缺少 WHERE 子句、具有遺漏的索引或具有過時統計資料的查詢。</span><span class="sxs-lookup"><span data-stu-id="8a803-187">This includes queries that lack a WHERE clause, have missing indexes, or have outdated statistics.</span></span> <span data-ttu-id="8a803-188">這些應用程式會受益於標準查詢效能微調技術。</span><span class="sxs-lookup"><span data-stu-id="8a803-188">These applications benefit from standard query performance-tuning techniques.</span></span> <span data-ttu-id="8a803-189">如需詳細資訊，請參閱[遺漏索引](#identifying-and-adding-missing-indexes)和[查詢微調和提示](#query-tuning-and-hinting)。</span><span class="sxs-lookup"><span data-stu-id="8a803-189">For more information, see [Missing indexes](#identifying-and-adding-missing-indexes) and [Query tuning and hinting](#query-tuning-and-hinting).</span></span>
* <span data-ttu-id="8a803-190">**具有次佳資料存取設計的應用程式**。</span><span class="sxs-lookup"><span data-stu-id="8a803-190">**Applications that have suboptimal data access design**.</span></span> <span data-ttu-id="8a803-191">具有內在資料存取並行問題的應用程式，例如死結，可能無法受益於較高的效能等級。</span><span class="sxs-lookup"><span data-stu-id="8a803-191">Applications that have inherent data access concurrency issues, for example deadlocking, might not benefit from a higher performance level.</span></span> <span data-ttu-id="8a803-192">請考慮藉由使用 Azure 快取服務或其他快取技術來快取用戶端的資料，以減少對 Azure SQL Database 的往返作業。</span><span class="sxs-lookup"><span data-stu-id="8a803-192">Consider reducing round trips against the Azure SQL Database by caching data on the client side with the Azure Caching service or another caching technology.</span></span> <span data-ttu-id="8a803-193">請參閱 [應用程式層快取](#application-tier-caching)。</span><span class="sxs-lookup"><span data-stu-id="8a803-193">See [Application tier caching](#application-tier-caching).</span></span>

## <a name="tune-your-database"></a><span data-ttu-id="8a803-194">微調資料庫</span><span class="sxs-lookup"><span data-stu-id="8a803-194">Tune your database</span></span>
<span data-ttu-id="8a803-195">在本節中，我們會討論一些技術，您可以用這些技術來微調 Azure SQL Database 以獲取應用程式的最佳效能，並且盡可能在最小的效能等級中執行。</span><span class="sxs-lookup"><span data-stu-id="8a803-195">In this section, we look at some techniques that you can use to tune Azure SQL Database to gain the best performance for your application and run it at the lowest possible performance level.</span></span> <span data-ttu-id="8a803-196">其中有些技術符合傳統的 SQL Server 微調最佳做法，但是其他技術則是專屬於 Azure SQL Database。</span><span class="sxs-lookup"><span data-stu-id="8a803-196">Some of these techniques match traditional SQL Server tuning best practices, but others are specific to Azure SQL Database.</span></span> <span data-ttu-id="8a803-197">在某些情況下，您可以檢查資料庫已取用的資源來尋找要進一步微調的區域，並擴充傳統的 SQL Server 技術以使其適用於 Azure SQL Database。</span><span class="sxs-lookup"><span data-stu-id="8a803-197">In some cases, you can examine the consumed resources for a database to find areas to further tune and extend traditional SQL Server techniques to work in Azure SQL Database.</span></span>

### <a name="identify-performance-issues-using-azure-portal"></a><span data-ttu-id="8a803-198">使用 Azure 入口網站找出效能問題</span><span class="sxs-lookup"><span data-stu-id="8a803-198">Identify performance issues using Azure portal</span></span>
<span data-ttu-id="8a803-199">Azure 入口網站中有下列工具協助您分析及修正 SQL Database 的效能問題：</span><span class="sxs-lookup"><span data-stu-id="8a803-199">The following tools in the Azure portal can help you analyze and fix performance issues with your SQL database:</span></span>

* [<span data-ttu-id="8a803-200">查詢效能深入解析</span><span class="sxs-lookup"><span data-stu-id="8a803-200">Query Performance Insight</span></span>](sql-database-query-performance.md)
* [<span data-ttu-id="8a803-201">SQL Database 建議程式</span><span class="sxs-lookup"><span data-stu-id="8a803-201">SQL Database Advisor</span></span>](sql-database-advisor.md)

<span data-ttu-id="8a803-202">Azure 入口網站有關於這兩個工具以及其使用方式的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="8a803-202">The Azure portal has more information about both of these tools and how to use them.</span></span> <span data-ttu-id="8a803-203">若要有效率地診斷並更正問題，建議您先嘗試使用 Azure 入口網站中的這兩個工具。</span><span class="sxs-lookup"><span data-stu-id="8a803-203">To efficiently diagnose and correct problems, we recommend that you first try the tools in the Azure portal.</span></span> <span data-ttu-id="8a803-204">我們建議您使用接下來要討論的手動微調方法，以處理特殊情況下的遺漏索引和查詢微調。</span><span class="sxs-lookup"><span data-stu-id="8a803-204">We recommend that you use the manual tuning approaches that we discuss next, for missing indexes and query tuning, in special cases.</span></span>

<span data-ttu-id="8a803-205">如需識別 Azure SQL Database 中問題的詳細資訊，可在[效能監視](sql-database-single-database-monitor.md)一文中找到。</span><span class="sxs-lookup"><span data-stu-id="8a803-205">Find more information about identifying issues in Azure SQL Database on [performance monitoring](sql-database-single-database-monitor.md) article.</span></span>

### <a name="identifying-and-adding-missing-indexes"></a><span data-ttu-id="8a803-206">找出並新增遺漏的索引</span><span class="sxs-lookup"><span data-stu-id="8a803-206">Identifying and adding missing indexes</span></span>
<span data-ttu-id="8a803-207">OLTP 資料庫效能中常見的問題與實體資料庫設計相關。</span><span class="sxs-lookup"><span data-stu-id="8a803-207">A common problem in OLTP database performance relates to the physical database design.</span></span> <span data-ttu-id="8a803-208">資料庫結構描述的設計和轉移通常不會經過大規模測試 (無論是在負載或資料數量)。</span><span class="sxs-lookup"><span data-stu-id="8a803-208">Often, database schemas are designed and shipped without testing at scale (either in load or in data volume).</span></span> <span data-ttu-id="8a803-209">不幸的是，查詢計劃的效能可能只有小規模可以接受，但是在面臨實際執行等級的資料數量時會大幅降低。</span><span class="sxs-lookup"><span data-stu-id="8a803-209">Unfortunately, the performance of a query plan might be acceptable on a small scale but degrade substantially under production-level data volumes.</span></span> <span data-ttu-id="8a803-210">此問題最常見的來源是缺少適當的索引來滿足篩選或查詢中的其他限制。</span><span class="sxs-lookup"><span data-stu-id="8a803-210">The most common source of this issue is the lack of appropriate indexes to satisfy filters or other restrictions in a query.</span></span> <span data-ttu-id="8a803-211">遺漏的索引通常會在索引搜尋可以滿足時，以資料表掃描的形式呈現。</span><span class="sxs-lookup"><span data-stu-id="8a803-211">Often, missing indexes manifests as a table scan when an index seek could suffice.</span></span>

<span data-ttu-id="8a803-212">在此範例中，選取的查詢計劃會在搜尋即可滿足需要時使用掃描︰</span><span class="sxs-lookup"><span data-stu-id="8a803-212">In this example, the selected query plan uses a scan when a seek would suffice:</span></span>

    DROP TABLE dbo.missingindex;
    CREATE TABLE dbo.missingindex (col1 INT IDENTITY PRIMARY KEY, col2 INT);
    DECLARE @a int = 0;
    SET NOCOUNT ON;
    BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO dbo.missingindex(col2) VALUES (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION;
    GO
    SELECT m1.col1
    FROM dbo.missingindex m1 INNER JOIN dbo.missingindex m2 ON(m1.col1=m2.col1)
    WHERE m1.col2 = 4;

![具有遺漏索引的查詢計劃](./media/sql-database-performance-guidance/query_plan_missing_indexes.png)

<span data-ttu-id="8a803-214">Azure SQL Database 可協助您尋找和修正常見的遺漏索引狀況。</span><span class="sxs-lookup"><span data-stu-id="8a803-214">Azure SQL Database can help you find and fix common missing index conditions.</span></span> <span data-ttu-id="8a803-215">Azure SQL Database 內建的 DMV 會查看查詢編譯，其中的索引會大幅減少執行查詢的估計成本。</span><span class="sxs-lookup"><span data-stu-id="8a803-215">DMVs that are built into Azure SQL Database look at query compilations in which an index would significantly reduce the estimated cost to run a query.</span></span> <span data-ttu-id="8a803-216">執行查詢期間，SQL Database 會追蹤每個查詢計劃的執行頻率，並追蹤執行查詢計劃和其中存在該索引之假設查詢計劃之間的預估落差。</span><span class="sxs-lookup"><span data-stu-id="8a803-216">During query execution, SQL Database tracks how often each query plan is executed, and tracks the estimated gap between the executing query plan and the imagined one where that index existed.</span></span> <span data-ttu-id="8a803-217">您可以使用這些 DMV 快速推測哪些實體資料庫設計變更可能會改善資料庫和其實際工作負載的整體工作負載成本。</span><span class="sxs-lookup"><span data-stu-id="8a803-217">You can use these DMVs to quickly guess which changes to your physical database design might improve overall workload cost for a database and its real workload.</span></span>

<span data-ttu-id="8a803-218">您可以使用下列查詢來評估潛在的遺漏索引︰</span><span class="sxs-lookup"><span data-stu-id="8a803-218">You can use this query to evaluate potential missing indexes:</span></span>

    SELECT CONVERT (varchar, getdate(), 126) AS runtime,
        mig.index_group_handle, mid.index_handle,
        CONVERT (decimal (28,1), migs.avg_total_user_cost * migs.avg_user_impact *
                (migs.user_seeks + migs.user_scans)) AS improvement_measure,
        'CREATE INDEX missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' +
                  CONVERT (varchar, mid.index_handle) + ' ON ' + mid.statement + '
                  (' + ISNULL (mid.equality_columns,'')
                  + CASE WHEN mid.equality_columns IS NOT NULL
                              AND mid.inequality_columns IS NOT NULL
                         THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '')
                  + ')'
                  + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement,
        migs.*,
        mid.database_id,
        mid.[object_id]
    FROM sys.dm_db_missing_index_groups AS mig
    INNER JOIN sys.dm_db_missing_index_group_stats AS migs
        ON migs.group_handle = mig.index_group_handle
    INNER JOIN sys.dm_db_missing_index_details AS mid
        ON mig.index_handle = mid.index_handle
    ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC

<span data-ttu-id="8a803-219">在此範例中，查詢導致了這項建議︰</span><span class="sxs-lookup"><span data-stu-id="8a803-219">In this example, the query resulted in this suggestion:</span></span>

    CREATE INDEX missing_index_5006_5005 ON [dbo].[missingindex] ([col2])  

<span data-ttu-id="8a803-220">在其建立之後，同一個 SELECT 陳述式會挑選不同的計劃，其使用搜尋而不是掃描，然後更有效率地執行計劃：</span><span class="sxs-lookup"><span data-stu-id="8a803-220">After it's created, that same SELECT statement picks a different plan, which uses a seek instead of a scan, and then executes the plan more efficiently:</span></span>

![具有已更正索引的查詢計劃](./media/sql-database-performance-guidance/query_plan_corrected_indexes.png)

<span data-ttu-id="8a803-222">重要的觀念是共用商品系統的 I/O 容量會比專用伺服器電腦的容量受到更多限制。</span><span class="sxs-lookup"><span data-stu-id="8a803-222">The key insight is that the I/O capacity of a shared, commodity system is more limited than that of a dedicated server machine.</span></span> <span data-ttu-id="8a803-223">重點在於要最小化不必要的 I/O，才能在 Azure SQL Database 的服務層中，於每個效能等級的 DTU 內充分利用此系統。</span><span class="sxs-lookup"><span data-stu-id="8a803-223">There's a premium on minimizing unnecessary I/O to take maximum advantage of the system in the DTU of each performance level of the Azure SQL Database service tiers.</span></span> <span data-ttu-id="8a803-224">適當的實體資料庫設計選項可以大幅改善個別查詢的延遲、改善每個縮放單位中可處理的並行要求輸送量，並最小化滿足查詢所需的成本。</span><span class="sxs-lookup"><span data-stu-id="8a803-224">Appropriate physical database design choices can significantly improve the latency for individual queries, improve the throughput of concurrent requests handled per scale unit, and minimize the costs required to satisfy the query.</span></span> <span data-ttu-id="8a803-225">如需有關遺漏索引 DMV 的詳細資訊，請參閱 [sys.dm_db_missing_index_details](https://msdn.microsoft.com/library/ms345434.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8a803-225">For more information about the missing index DMVs, see [sys.dm_db_missing_index_details](https://msdn.microsoft.com/library/ms345434.aspx).</span></span>

### <a name="query-tuning-and-hinting"></a><span data-ttu-id="8a803-226">查詢微調和提示</span><span class="sxs-lookup"><span data-stu-id="8a803-226">Query tuning and hinting</span></span>
<span data-ttu-id="8a803-227">Azure SQL Database 內的查詢最佳化工具類似於傳統的 SQL Server 查詢最佳化工具。</span><span class="sxs-lookup"><span data-stu-id="8a803-227">The query optimizer in Azure SQL Database is similar to the traditional SQL Server query optimizer.</span></span> <span data-ttu-id="8a803-228">微調查詢和了解查詢最佳化工具之推論模型限制的大多數最佳做法也適用於 Azure SQL Database。</span><span class="sxs-lookup"><span data-stu-id="8a803-228">Most of the best practices for tuning queries and understanding the reasoning model limitations for the query optimizer also apply to Azure SQL Database.</span></span> <span data-ttu-id="8a803-229">如果您微調 Azure SQL Database 中的查詢，您可以因為減少彙整資源需求而獲得額外好處。</span><span class="sxs-lookup"><span data-stu-id="8a803-229">If you tune queries in Azure SQL Database, you might get the additional benefit of reducing aggregate resource demands.</span></span> <span data-ttu-id="8a803-230">您的應用程式能夠以低於未經微調之查詢的成本執行，因為它可以在較低的效能等級中執行。</span><span class="sxs-lookup"><span data-stu-id="8a803-230">Your application might be able to run at a lower cost than an untuned equivalent because it can run at a lower performance level.</span></span>

<span data-ttu-id="8a803-231">SQL Server 中常見並且也適用於 Azure SQL Database 的範例是查詢最佳化工具如何「探查」參數。</span><span class="sxs-lookup"><span data-stu-id="8a803-231">An example that is common in SQL Server and which also applies to Azure SQL Database is how the query optimizer "sniffs" parameters.</span></span> <span data-ttu-id="8a803-232">在編譯期間，查詢最佳化工具會評估參數值以判斷該值是否可以產生較佳的查詢計劃。</span><span class="sxs-lookup"><span data-stu-id="8a803-232">During compilation, the query optimizer evaluates the current value of a parameter to determine whether it can generate a more optimal query plan.</span></span> <span data-ttu-id="8a803-233">雖然這個策略產生的查詢計劃通常在速度上明顯優於不知道參數值就編譯的計劃，但是此策略目前在 SQL Server 和 Azure SQL Database 中的運作狀況並不完美。</span><span class="sxs-lookup"><span data-stu-id="8a803-233">Although this strategy often can lead to a query plan that is significantly faster than a plan compiled without known parameter values, currently it works imperfectly both in SQL Server and in Azure SQL Database.</span></span> <span data-ttu-id="8a803-234">有時參數並未經過探查，有時則是參數已經過探查，但產生的計劃對工作負載中的整組參數值而言只是次佳的。</span><span class="sxs-lookup"><span data-stu-id="8a803-234">Sometimes the parameter is not sniffed, and sometimes the parameter is sniffed but the generated plan is suboptimal for the full set of parameter values in a workload.</span></span> <span data-ttu-id="8a803-235">Microsoft 包括查詢提示 (指示詞)，因此您可以更刻意地指定意圖及覆寫參數探查的預設行為。</span><span class="sxs-lookup"><span data-stu-id="8a803-235">Microsoft includes query hints (directives) so that you can specify intent more deliberately and override the default behavior of parameter sniffing.</span></span> <span data-ttu-id="8a803-236">如果您使用提示，您通常可以修正指定客戶工作負載的預設 SQL Server 或 Azure SQL Database 行為不完美的情況。</span><span class="sxs-lookup"><span data-stu-id="8a803-236">Often, if you use hints, you can fix cases in which the default SQL Server or Azure SQL Database behavior is imperfect for a specific customer workload.</span></span>

<span data-ttu-id="8a803-237">下一個範例會示範查詢處理器如何產生對效能和資源需求都不盡理想的計劃。</span><span class="sxs-lookup"><span data-stu-id="8a803-237">The next example demonstrates how the query processor can generate a plan that is suboptimal both for performance and resource requirements.</span></span> <span data-ttu-id="8a803-238">此範例也會示範如果您使用查詢提示，則可以降低 SQL Database 的查詢執行時間和資源需求︰</span><span class="sxs-lookup"><span data-stu-id="8a803-238">This example also shows that if you use a query hint, you can reduce query run time and resource requirements for your SQL database:</span></span>

    DROP TABLE psptest1;
    CREATE TABLE psptest1(col1 int primary key identity, col2 int, col3 binary(200));

    DECLARE @a int = 0;
    SET NOCOUNT ON;
    BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO psptest1(col2) values (1);
        INSERT INTO psptest1(col2) values (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION
    CREATE INDEX i1 on psptest1(col2);
    GO

    CREATE PROCEDURE psp1 (@param1 int)
    AS
    BEGIN
        INSERT INTO t1 SELECT * FROM psptest1
        WHERE col2 = @param1
        ORDER BY col2;
    END
    GO

    CREATE PROCEDURE psp2 (@param2 int)
    AS
    BEGIN
        INSERT INTO t1 SELECT * FROM psptest1 WHERE col2 = @param2
        ORDER BY col2
        OPTION (OPTIMIZE FOR (@param2 UNKNOWN))
    END
    GO

    CREATE TABLE t1 (col1 int primary key, col2 int, col3 binary(200));
    GO

<span data-ttu-id="8a803-239">設定程式碼會建立一個具有扭曲資料散發的資料表。</span><span class="sxs-lookup"><span data-stu-id="8a803-239">The setup code creates a table that has skewed data distribution.</span></span> <span data-ttu-id="8a803-240">最佳的查詢計劃會根據選取的參數而有差異。</span><span class="sxs-lookup"><span data-stu-id="8a803-240">The optimal query plan differs based on which parameter is selected.</span></span> <span data-ttu-id="8a803-241">不幸的是，計劃快取行為並不一定會根據最常見的參數值重新編譯查詢。</span><span class="sxs-lookup"><span data-stu-id="8a803-241">Unfortunately, the plan caching behavior doesn't always recompile the query based on the most common parameter value.</span></span> <span data-ttu-id="8a803-242">因此，即使不同的計劃會是平均來說較好的計劃選項，仍有可能會快取不盡理想的計劃並用於許多值。</span><span class="sxs-lookup"><span data-stu-id="8a803-242">So, it's possible for a suboptimal plan to be cached and used for many values, even when a different plan might be a better plan choice on average.</span></span> <span data-ttu-id="8a803-243">然後，查詢計劃會建立兩個完全相同的預存程序，唯一的差異是其中一個有特殊的查詢提示。</span><span class="sxs-lookup"><span data-stu-id="8a803-243">Then the query plan creates two stored procedures that are identical, except that one has a special query hint.</span></span>

<span data-ttu-id="8a803-244">**範例 (第 1 部分)**</span><span class="sxs-lookup"><span data-stu-id="8a803-244">**Example, part 1**</span></span>

    -- Prime Procedure Cache with scan plan
    EXEC psp1 @param1=1;
    TRUNCATE TABLE t1;

    -- Iterate multiple times to show the performance difference
    DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp1 @param1=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END

<span data-ttu-id="8a803-245">**範例 (第 2 部分)**</span><span class="sxs-lookup"><span data-stu-id="8a803-245">**Example, part 2**</span></span>

<span data-ttu-id="8a803-246">(建議您先等待至少 10 分鐘再開始範例的第 2 部分，這樣一來，所產生之遙測資料的結果才會截然不同)。</span><span class="sxs-lookup"><span data-stu-id="8a803-246">(We recommend that you wait at least 10 minutes before you begin part 2 of the example, so that the results are distinct in the resulting telemetry data.)</span></span>

    EXEC psp2 @param2=1;
    TRUNCATE TABLE t1;

    DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp2 @param2=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END

<span data-ttu-id="8a803-247">此範例中的每個部分都嘗試執行參數化的 insert 陳述式 1000 次 (以產生足夠的負載來做為測試資料集)。</span><span class="sxs-lookup"><span data-stu-id="8a803-247">Each part of this example attempts to run a parameterized insert statement 1,000 times (to generate a sufficient load to use as a test data set).</span></span> <span data-ttu-id="8a803-248">當它執行預存程序時，查詢處理器會檢查第一次編譯 (參數「探查」) 期間傳遞至程序的參數值。</span><span class="sxs-lookup"><span data-stu-id="8a803-248">When it executes stored procedures, the query processor examines the parameter value that is passed to the procedure during its first compilation (parameter "sniffing").</span></span> <span data-ttu-id="8a803-249">即使參數值不同，處理器還是會快取產生的計劃並用於稍後的叫用。</span><span class="sxs-lookup"><span data-stu-id="8a803-249">The processor caches the resulting plan and uses it for later invocations, even if the parameter value is different.</span></span> <span data-ttu-id="8a803-250">最佳的計劃可能不會用於所有情況。</span><span class="sxs-lookup"><span data-stu-id="8a803-250">The optimal plan might not be used in all cases.</span></span> <span data-ttu-id="8a803-251">有時候您必須引導最佳化工具挑選計劃，相較於第一次編譯查詢時的特定案例，此計劃較適合平均案例。</span><span class="sxs-lookup"><span data-stu-id="8a803-251">Sometimes you need to guide the optimizer to pick a plan that is better for the average case rather than the specific case from when the query was first compiled.</span></span> <span data-ttu-id="8a803-252">在此範例中，初始計劃會產生「掃描」計劃，此計劃會讀取所有資料列來尋找符合參數的每個值：</span><span class="sxs-lookup"><span data-stu-id="8a803-252">In this example, the initial plan generates a "scan" plan that reads all rows to find each value that matches the parameter:</span></span>

![使用掃描計劃微調查詢](./media/sql-database-performance-guidance/query_tuning_1.png)

<span data-ttu-id="8a803-254">因為我們以值 1 執行此程序，所以產生的計劃會是值 1 的最佳選擇，但是對資料表中的其他值而言未必是最佳的。</span><span class="sxs-lookup"><span data-stu-id="8a803-254">Because we executed the procedure by using the value 1, the resulting plan was optimal for the value 1 but was suboptimal for all other values in the table.</span></span> <span data-ttu-id="8a803-255">如果您隨機挑選每個計劃，因為該計劃執行得更慢而且使用更多資源，因此結果可能不是您要的。</span><span class="sxs-lookup"><span data-stu-id="8a803-255">The result likely isn't what you would want if you were to pick each plan randomly, because the plan performs more slowly and uses more resources.</span></span>

<span data-ttu-id="8a803-256">如果您以 `SET STATISTICS IO` 設為 `ON` 來執行測試，此範例會在幕後完成邏輯掃描工作。</span><span class="sxs-lookup"><span data-stu-id="8a803-256">If you run the test with `SET STATISTICS IO` set to `ON`, the logical scan work in this example is done behind the scenes.</span></span> <span data-ttu-id="8a803-257">您可以看到計劃完成了 1,148 次讀取 (如果平均案例是只傳回一個資料列，則此計劃是沒效率的)：</span><span class="sxs-lookup"><span data-stu-id="8a803-257">You can see that there are 1,148 reads done by the plan (which is inefficient, if the average case is to return just one row):</span></span>

![使用邏輯掃描微調查詢](./media/sql-database-performance-guidance/query_tuning_2.png)

<span data-ttu-id="8a803-259">此範例的第二個部分使用查詢提示告訴最佳化工具，在編譯處理程序期間使用特定值。</span><span class="sxs-lookup"><span data-stu-id="8a803-259">The second part of the example uses a query hint to tell the optimizer to use a specific value during the compilation process.</span></span> <span data-ttu-id="8a803-260">在此情況下，它會強制查詢處理器忽略傳遞做為參數的值，並改為假設 `UNKNOWN`。</span><span class="sxs-lookup"><span data-stu-id="8a803-260">In this case, it forces the query processor to ignore the value that is passed as the parameter, and instead to assume `UNKNOWN`.</span></span> <span data-ttu-id="8a803-261">這表示資料表中具有平均頻率的值 (忽略扭曲)。</span><span class="sxs-lookup"><span data-stu-id="8a803-261">This refers to a value that has the average frequency in the table (ignoring skew).</span></span> <span data-ttu-id="8a803-262">產生的計劃是以搜尋為基礎的計劃，平均而言會比此範例第 1 部分的計劃更快速並使用較少資源：</span><span class="sxs-lookup"><span data-stu-id="8a803-262">The resulting plan is a seek-based plan that is faster and uses fewer resources, on average, than the plan in part 1 of this example:</span></span>

![使用查詢提示微調查詢](./media/sql-database-performance-guidance/query_tuning_3.png)

<span data-ttu-id="8a803-264">您可以在 **sys.resource_stats** 資料表中看到這個影響 (從您執行測試的時間到資料填入資料表的時間會發生延遲)。</span><span class="sxs-lookup"><span data-stu-id="8a803-264">You can see the effect in the **sys.resource_stats** table (there is a delay from the time that you execute the test and when the data populates the table).</span></span> <span data-ttu-id="8a803-265">在此範例中，第 1 部分會在 22:25:00 時間範圍期間執行，而第 2 部分會在 22:35:00 執行。</span><span class="sxs-lookup"><span data-stu-id="8a803-265">For this example, part 1 executed during the 22:25:00 time window, and part 2 executed at 22:35:00.</span></span> <span data-ttu-id="8a803-266">較早的時間範圍在該時間範圍內使用的資源比較晚的時間範圍還多 (因為計劃效率改善)。</span><span class="sxs-lookup"><span data-stu-id="8a803-266">The earlier time window used more resources in that time window than the later one (because of plan efficiency improvements).</span></span>

    SELECT TOP 1000 *
    FROM sys.resource_stats
    WHERE database_name = 'resource1'
    ORDER BY start_time DESC

![查詢微調範例結果](./media/sql-database-performance-guidance/query_tuning_4.png)

> [!NOTE]
> <span data-ttu-id="8a803-268">雖然此範例中的數量已刻意簡化，次佳參數的影響還是很明顯，尤其是對於較大型的資料庫。</span><span class="sxs-lookup"><span data-stu-id="8a803-268">Although the volume in this example is intentionally small, the effect of suboptimal parameters can be substantial, especially on larger databases.</span></span> <span data-ttu-id="8a803-269">在極端的情況下，快速案例之間的差異可達數秒，而緩慢案例之間的差異可達數小時。</span><span class="sxs-lookup"><span data-stu-id="8a803-269">The difference, in extreme cases, can be between seconds for fast cases and hours for slow cases.</span></span>
> 
> 

<span data-ttu-id="8a803-270">您可以檢查 **sys.resource_stats** 來判斷測試使用的資源比另一個測試多或少。</span><span class="sxs-lookup"><span data-stu-id="8a803-270">You can examine **sys.resource_stats** to determine whether the resource for a test uses more or fewer resources than another test.</span></span> <span data-ttu-id="8a803-271">在比較資料時，請將測試的時間隔開，讓它們不在 **sys.resource_stats** 檢視的同一個 5 分鐘時間範圍內。</span><span class="sxs-lookup"><span data-stu-id="8a803-271">When you compare data, separate the timing of tests so that they are not in the same 5-minute window in the **sys.resource_stats** view.</span></span> <span data-ttu-id="8a803-272">練習的目標是要最小化使用的資源總量，而不是最小化尖峰資源。</span><span class="sxs-lookup"><span data-stu-id="8a803-272">The goal of the exercise is to minimize the total amount of resources used, and not to minimize the peak resources.</span></span> <span data-ttu-id="8a803-273">一般而言，最佳化一段延遲的程式碼也可減少資源耗用量。</span><span class="sxs-lookup"><span data-stu-id="8a803-273">Generally, optimizing a piece of code for latency also reduces resource consumption.</span></span> <span data-ttu-id="8a803-274">請確定您對應用程式所做的變更是必要的，而且這些變更不會讓使用應用程式的某人在使用查詢提示時對客戶體驗造成負面影響。</span><span class="sxs-lookup"><span data-stu-id="8a803-274">Make sure that the changes you make to an application are necessary, and that the changes don't negatively affect the customer experience for someone who might be using query hints in the application.</span></span>

<span data-ttu-id="8a803-275">如果工作負載具有一組重複的查詢，擷取並驗證您計劃選項的最適化通常是合理的，因為這會讓主控資料庫所需的資源大小單位降到最低。</span><span class="sxs-lookup"><span data-stu-id="8a803-275">If a workload has a set of repeating queries, often it makes sense to capture and validate the optimality of your plan choices because it drives the minimum resource size unit required to host the database.</span></span> <span data-ttu-id="8a803-276">在驗證之後，請偶爾重新檢查計劃以確保它們不會降級。</span><span class="sxs-lookup"><span data-stu-id="8a803-276">After you validate it, occasionally reexamine the plans to help you make sure that they have not degraded.</span></span> <span data-ttu-id="8a803-277">您可以深入了解 [查詢提示 (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8a803-277">You can learn more about [query hints (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).</span></span>

### <a name="cross-database-sharding"></a><span data-ttu-id="8a803-278">跨資料庫分區化</span><span class="sxs-lookup"><span data-stu-id="8a803-278">Cross-database sharding</span></span>
<span data-ttu-id="8a803-279">因為 Azure SQL Database 會在商用硬體上執行，所以單一資料庫的容量限制會比傳統的內部部署 SQL Server 安裝更低。</span><span class="sxs-lookup"><span data-stu-id="8a803-279">Because Azure SQL Database runs on commodity hardware, the capacity limits for a single database are lower than for a traditional on-premises SQL Server installation.</span></span> <span data-ttu-id="8a803-280">有些客戶會在資料庫作業不符合 Azure SQL Database 中的單一資料庫限制時，使用分區化技術在多個資料庫散佈這些作業。</span><span class="sxs-lookup"><span data-stu-id="8a803-280">Some customers use sharding techniques to spread database operations over multiple databases when the operations don't fit inside the limits of a single database in Azure SQL Database.</span></span> <span data-ttu-id="8a803-281">在 Azure SQL Database 上使用分區化技術的大部分客戶都會在跨多個資料庫的單一維度上分割其資料。</span><span class="sxs-lookup"><span data-stu-id="8a803-281">Most customers who use sharding techniques in Azure SQL Database split their data on a single dimension across multiple databases.</span></span> <span data-ttu-id="8a803-282">針對此方法，您必須了解 OLTP 應用程式通常會執行的交易只會套用到結構描述內的一個資料列或一小組資料列。</span><span class="sxs-lookup"><span data-stu-id="8a803-282">For this approach, you need to understand that OLTP applications often perform transactions that apply to only one row or to a small group of rows in the schema.</span></span>

> [!NOTE]
> <span data-ttu-id="8a803-283">SQL Database 現在提供可協助分區化的程式庫。</span><span class="sxs-lookup"><span data-stu-id="8a803-283">SQL Database now provides a library to assist with sharding.</span></span> <span data-ttu-id="8a803-284">如需詳細資訊，請參閱 [彈性資料庫用戶端程式庫概觀](sql-database-elastic-database-client-library.md)。</span><span class="sxs-lookup"><span data-stu-id="8a803-284">For more information, see [Elastic Database client library overview](sql-database-elastic-database-client-library.md).</span></span>
> 
> 

<span data-ttu-id="8a803-285">例如，如果資料庫有客戶名稱、訂單及訂單詳細資料 (如 SQL Server 隨附的傳統範例 Northwind 資料庫)，則您可以透過以相關訂單和訂單詳細資料等資訊來分組客戶，將這項資料分割至多個資料庫。</span><span class="sxs-lookup"><span data-stu-id="8a803-285">For example, if a database has customer name, order, and order details (like the traditional example Northwind database that ships with SQL Server), you could split this data into multiple databases by grouping a customer with the related order and order detail information.</span></span> <span data-ttu-id="8a803-286">您可以保證客戶的資料會保留在單一資料庫內。</span><span class="sxs-lookup"><span data-stu-id="8a803-286">You can guarantee that the customer's data stays in a single database.</span></span> <span data-ttu-id="8a803-287">應用程式會跨資料庫分割不同的客戶，跨多個資料庫有效分配負載。</span><span class="sxs-lookup"><span data-stu-id="8a803-287">The application would split different customers across databases, effectively spreading the load across multiple databases.</span></span> <span data-ttu-id="8a803-288">透過分區化，客戶不但可以避免資料庫大小上限，Azure SQL Database 也能處理明顯大於不同效能等級限制的工作負載，前提是每個個別資料庫符合其 DTU。</span><span class="sxs-lookup"><span data-stu-id="8a803-288">With sharding, customers not only can avoid the maximum database size limit, but Azure SQL Database also can process workloads that are significantly larger than the limits of the different performance levels, as long as each individual database fits into its DTU.</span></span>

<span data-ttu-id="8a803-289">雖然資料庫分區化不會減少方案的彙整資源容量，但可以非常有效地支援分配到多個資料庫的非常大型方案。</span><span class="sxs-lookup"><span data-stu-id="8a803-289">Although database sharding doesn't reduce the aggregate resource capacity for a solution, it's highly effective at supporting very large solutions that are spread over multiple databases.</span></span> <span data-ttu-id="8a803-290">每個資料庫可以在不同的效能等級執行以支援具有高資源需求且非常大型的「有效」資料庫。</span><span class="sxs-lookup"><span data-stu-id="8a803-290">Each database can run at a different performance level to support very large, "effective" databases with high resource requirements.</span></span>

### <a name="functional-partitioning"></a><span data-ttu-id="8a803-291">功能資料分割</span><span class="sxs-lookup"><span data-stu-id="8a803-291">Functional partitioning</span></span>
<span data-ttu-id="8a803-292">SQL Server 使用者通常會在單一資料庫內結合許多功能。</span><span class="sxs-lookup"><span data-stu-id="8a803-292">SQL Server users often combine many functions in a single database.</span></span> <span data-ttu-id="8a803-293">例如，如果應用程式有管理商店庫存的邏輯，該資料庫可能具有的邏輯會與庫存、追蹤訂單、預存程序和管理月底報告的索引或具體化檢視相關聯。</span><span class="sxs-lookup"><span data-stu-id="8a803-293">For example, if an application has logic to manage inventory for a store, that database might have logic associated with inventory, tracking purchase orders, stored procedures, and indexed or materialized views that manage end-of-month reporting.</span></span> <span data-ttu-id="8a803-294">這項技術可以簡化備份等作業的資料庫管理，但也需要您調整硬體大小來跨應用程式的所有功能處理尖峰負載。</span><span class="sxs-lookup"><span data-stu-id="8a803-294">This technique makes it easier to administer the database for operations like backup, but it also requires you to size the hardware to handle the peak load across all functions of an application.</span></span>

<span data-ttu-id="8a803-295">如果您在 Azure SQL Database 中使用相應放大架構，則最好將應用程式的不同功能分割至不同資料庫。</span><span class="sxs-lookup"><span data-stu-id="8a803-295">If you use a scale-out architecture in Azure SQL Database, it's a good idea to split different functions of an application into different databases.</span></span> <span data-ttu-id="8a803-296">使用這項技術時，每個應用程式都可以獨立縮放。</span><span class="sxs-lookup"><span data-stu-id="8a803-296">By using this technique, each application scales independently.</span></span> <span data-ttu-id="8a803-297">隨著應用程式變得更忙碌 (而且資料庫上的負載增加)，系統管理員可為應用程式內的每個功能選擇獨立的效能等級。</span><span class="sxs-lookup"><span data-stu-id="8a803-297">As an application becomes busier (and the load on the database increases), the administrator can choose independent performance levels for each function in the application.</span></span> <span data-ttu-id="8a803-298">此架構在達到限制時，應用程式會比單一商用電腦可處理的應用程式還大，因為負載會分配給多部電腦。</span><span class="sxs-lookup"><span data-stu-id="8a803-298">At the limit, with this architecture, an application can be larger than a single commodity machine can handle because the load is spread across multiple machines.</span></span>

### <a name="batch-queries"></a><span data-ttu-id="8a803-299">批次查詢</span><span class="sxs-lookup"><span data-stu-id="8a803-299">Batch queries</span></span>
<span data-ttu-id="8a803-300">對於使用大量、頻繁的特定查詢存取資料的應用程式而言，大量的回應時間都花費在應用程式層和和 Azure SQL Database 層之間的網路通訊上。</span><span class="sxs-lookup"><span data-stu-id="8a803-300">For applications that access data by using high-volume, frequent, ad hoc querying, a substantial amount of response time is spent on network communication between the application tier and the Azure SQL Database tier.</span></span> <span data-ttu-id="8a803-301">即使應用程式和 Azure SQL Database 都位於相同的資料中心，兩者之間的網路延遲還是可能因為大量資料存取作業而放大。</span><span class="sxs-lookup"><span data-stu-id="8a803-301">Even when both the application and Azure SQL Database are in the same data center, the network latency between the two might be magnified by a large number of data access operations.</span></span> <span data-ttu-id="8a803-302">若要減少資料存取作業的網路往返，請考慮選擇批次處理特定查詢或將其編譯成預存程序。</span><span class="sxs-lookup"><span data-stu-id="8a803-302">To reduce the network round trips for the data access operations, consider using the option to either batch the ad hoc queries, or to compile them as stored procedures.</span></span> <span data-ttu-id="8a803-303">如果您批次處理特定查詢，您可以將多個查詢當做一個大型批次，在單一往返中傳送到 Azure SQL Database。</span><span class="sxs-lookup"><span data-stu-id="8a803-303">If you batch the ad hoc queries, you can send multiple queries as one large batch in a single trip to Azure SQL Database.</span></span> <span data-ttu-id="8a803-304">如果您在預存程序中編譯特定查詢，您可以達到和對其進行批次處理時相同的結果。</span><span class="sxs-lookup"><span data-stu-id="8a803-304">If you compile ad hoc queries in a stored procedure, you could achieve the same result as if you batch them.</span></span> <span data-ttu-id="8a803-305">使用預存程序也能讓您獲益，因為在 Azure SQL Database 中快取查詢計劃的機會增加，因此您可以再次使於預存程序。</span><span class="sxs-lookup"><span data-stu-id="8a803-305">Using a stored procedure also gives you the benefit of increasing the chances of caching the query plans in Azure SQL Database so you can use the stored procedure again.</span></span>

<span data-ttu-id="8a803-306">某些應用程式是寫入密集型的。</span><span class="sxs-lookup"><span data-stu-id="8a803-306">Some applications are write-intensive.</span></span> <span data-ttu-id="8a803-307">有時候，您可以藉由考慮如何一併批次處理寫入來減少資料庫上的 I/O 總負載。</span><span class="sxs-lookup"><span data-stu-id="8a803-307">Sometimes you can reduce the total I/O load on a database by considering how to batch writes together.</span></span> <span data-ttu-id="8a803-308">這通常與在預存程序及特定查詢內使用明確的交易而不是自動認可的交易一樣容易。</span><span class="sxs-lookup"><span data-stu-id="8a803-308">Often, this is as simple as using explicit transactions instead of auto-commit transactions in stored procedures and ad hoc batches.</span></span> <span data-ttu-id="8a803-309">如需評估您可以使用的不同技術，請參閱 [Azure 中 SQL Database 應用程式的批次處理技術](https://msdn.microsoft.com/library/windowsazure/dn132615.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8a803-309">For an evaluation of different techniques you can use, see [Batching techniques for SQL Database applications in Azure](https://msdn.microsoft.com/library/windowsazure/dn132615.aspx).</span></span> <span data-ttu-id="8a803-310">實驗您自己的工作負載來尋找正確的批次處理模型。</span><span class="sxs-lookup"><span data-stu-id="8a803-310">Experiment with your own workload to find the right model for batching.</span></span> <span data-ttu-id="8a803-311">請務必了解，模型在交易一致性保證上可能稍有不同。</span><span class="sxs-lookup"><span data-stu-id="8a803-311">Be sure to understand that a model might have slightly different transactional consistency guarantees.</span></span> <span data-ttu-id="8a803-312">要尋找可最小化資源使用的適當工作負載，就必須找出一致性與效能權衡取捨的正確組合。</span><span class="sxs-lookup"><span data-stu-id="8a803-312">Finding the right workload that minimizes resource use requires finding the right combination of consistency and performance trade-offs.</span></span>

### <a name="application-tier-caching"></a><span data-ttu-id="8a803-313">應用程式層快取</span><span class="sxs-lookup"><span data-stu-id="8a803-313">Application-tier caching</span></span>
<span data-ttu-id="8a803-314">某些資料庫應用程式具有大量讀取工作負載。</span><span class="sxs-lookup"><span data-stu-id="8a803-314">Some database applications have read-heavy workloads.</span></span> <span data-ttu-id="8a803-315">對應用程式層進行快取可能會減少資料庫上的負載，並可能使用 Azure SQL Database 而有機會降低支援資料庫所需的效能等級。</span><span class="sxs-lookup"><span data-stu-id="8a803-315">Caching layers might reduce the load on the database and might potentially reduce the performance level required to support a database by using Azure SQL Database.</span></span> <span data-ttu-id="8a803-316">使用 [Azure Redis 快取](https://azure.microsoft.com/services/cache/)時，如果您具有大量讀取工作負載，您可以讀取資料一次 (或可能每個應用程式層電腦讀取一次，取決於設定方式)，然後將該資料儲存在 SQL Database 之外。</span><span class="sxs-lookup"><span data-stu-id="8a803-316">With [Azure Redis Cache](https://azure.microsoft.com/services/cache/), if you have a read-heavy workload, you can read the data once (or perhaps once per application-tier machine, depending on how it is configured), and then store that data outside your SQL database.</span></span> <span data-ttu-id="8a803-317">此方式可減少資料庫負載 (CPU 和讀取 I/O)，但會對交易一致性造成影響，因為從快取讀取的資料可能不會與資料庫中的資料同步。</span><span class="sxs-lookup"><span data-stu-id="8a803-317">This is a way to reduce database load (CPU and read I/O), but there is an effect on transactional consistency because the data being read from the cache might be out of sync with the data in the database.</span></span> <span data-ttu-id="8a803-318">雖然許多應用程式可接受一定程度的不一致性，但並非所有工作負載都是如此。</span><span class="sxs-lookup"><span data-stu-id="8a803-318">Although in many applications some level of inconsistency is acceptable, that's not true for all workloads.</span></span> <span data-ttu-id="8a803-319">您應該充分了解應用程式的任何需求，然後再實作應用程式層快取策略。</span><span class="sxs-lookup"><span data-stu-id="8a803-319">You should fully understand any application requirements before you implement an application-tier caching strategy.</span></span>

## <a name="next-steps"></a><span data-ttu-id="8a803-320">後續步驟</span><span class="sxs-lookup"><span data-stu-id="8a803-320">Next steps</span></span>
* <span data-ttu-id="8a803-321">如需服務層的詳細資訊，請參閱 [SQL Database 選項和效能](sql-database-service-tiers.md)</span><span class="sxs-lookup"><span data-stu-id="8a803-321">For more information about service tiers, see [SQL Database options and performance](sql-database-service-tiers.md)</span></span>
* <span data-ttu-id="8a803-322">如需彈性集區的詳細資訊，請參閱[什麼是 Azure 彈性集區？](sql-database-elastic-pool.md)</span><span class="sxs-lookup"><span data-stu-id="8a803-322">For more information about elastic pools, see [What is an Azure elastic pool?](sql-database-elastic-pool.md)</span></span>
* <span data-ttu-id="8a803-323">如需效能和彈性集區的相關資訊，請參閱 [考慮使用彈性集區的時機](sql-database-elastic-pool-guidance.md)</span><span class="sxs-lookup"><span data-stu-id="8a803-323">For information about performance and elastic pools, see [When to consider an elastic pool](sql-database-elastic-pool-guidance.md)</span></span>

