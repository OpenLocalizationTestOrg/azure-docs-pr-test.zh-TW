---
title: "使用 Entity Framework aaaUsing 彈性資料庫用戶端程式庫 |Microsoft 文件"
description: "使用彈性資料庫用戶端程式庫與和 Entity Framework 來編寫資料庫"
services: sql-database
documentationcenter: 
manager: jhubbard
author: torsteng
editor: 
ms.assetid: b9c3065b-cb92-41be-aa7f-deba23e7e159
ms.service: sql-database
ms.custom: scale out apps
ms.workload: sql-database
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/06/2017
ms.author: torsteng
ms.openlocfilehash: 917f6d28d9855c0b42afe2c008613a9bbb3ec6b6
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="elastic-database-client-library-with-entity-framework"></a><span data-ttu-id="c450d-103">搭配使用彈性資料庫用戶端程式庫與 Entity Framework</span><span class="sxs-lookup"><span data-stu-id="c450d-103">Elastic Database client library with Entity Framework</span></span>
<span data-ttu-id="c450d-104">這份文件的 Entity Framework 應用程式，都需要以 hello toointegrate 顯示 hello 變更[彈性資料庫工具](sql-database-elastic-scale-introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="c450d-104">This document shows hello changes in an Entity Framework application that are needed toointegrate with hello [Elastic Database tools](sql-database-elastic-scale-introduction.md).</span></span> <span data-ttu-id="c450d-105">hello 重點在於撰寫[分區對應管理](sql-database-elastic-scale-shard-map-management.md)和[資料依存路由](sql-database-elastic-scale-data-dependent-routing.md)以 hello Entity Framework **Code First**方法。</span><span class="sxs-lookup"><span data-stu-id="c450d-105">hello focus is on composing [shard map management](sql-database-elastic-scale-shard-map-management.md) and [data-dependent routing](sql-database-elastic-scale-data-dependent-routing.md) with hello Entity Framework **Code First** approach.</span></span> <span data-ttu-id="c450d-106">hello [Code First-新的資料庫](http://msdn.microsoft.com/data/jj193542.aspx)EF 教學課程做為我們執行中範例整份文件。</span><span class="sxs-lookup"><span data-stu-id="c450d-106">hello [Code First - New Database](http://msdn.microsoft.com/data/jj193542.aspx) tutorial for EF serves as our running example throughout this document.</span></span> <span data-ttu-id="c450d-107">hello 隨附這份文件的範例程式碼是彈性資料庫工具的一部分設定 hello Visual Studio 程式碼範例中的樣本。</span><span class="sxs-lookup"><span data-stu-id="c450d-107">hello sample code accompanying this document is part of elastic database tools' set of samples in hello Visual Studio Code Samples.</span></span>

## <a name="downloading-and-running-hello-sample-code"></a><span data-ttu-id="c450d-108">下載並執行 hello 範例程式碼</span><span class="sxs-lookup"><span data-stu-id="c450d-108">Downloading and Running hello Sample Code</span></span>
<span data-ttu-id="c450d-109">這個發行項 toodownload hello 程式碼：</span><span class="sxs-lookup"><span data-stu-id="c450d-109">toodownload hello code for this article:</span></span>

* <span data-ttu-id="c450d-110">需要 visual Studio 2012 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="c450d-110">Visual Studio 2012 or later is required.</span></span> 
* <span data-ttu-id="c450d-111">下載 hello[彈性 DB 工具適用於 Azure SQL 的實體架構整合範例](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba)從 MSDN。</span><span class="sxs-lookup"><span data-stu-id="c450d-111">Download hello [Elastic DB Tools for Azure SQL - Entity Framework Integration sample](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) from MSDN.</span></span> <span data-ttu-id="c450d-112">將解壓縮 hello 範例 tooa 選擇的位置。</span><span class="sxs-lookup"><span data-stu-id="c450d-112">Unzip hello sample tooa location of your choosing.</span></span>
* <span data-ttu-id="c450d-113">啟動 Visual Studio。</span><span class="sxs-lookup"><span data-stu-id="c450d-113">Start Visual Studio.</span></span> 
* <span data-ttu-id="c450d-114">在 Visual Studio 中，選取 [檔案] -> [開啟專案/方案]。</span><span class="sxs-lookup"><span data-stu-id="c450d-114">In Visual Studio, select File -> Open Project/Solution.</span></span> 
* <span data-ttu-id="c450d-115">在 [hello**開啟專案**] 對話方塊中，瀏覽您所下載的 toohello 範例並選取**EntityFrameworkCodeFirst.sln** tooopen hello 範例。</span><span class="sxs-lookup"><span data-stu-id="c450d-115">In hello **Open Project** dialog, navigate toohello sample you downloaded and select **EntityFrameworkCodeFirst.sln** tooopen hello sample.</span></span> 

<span data-ttu-id="c450d-116">toorun hello 範例中，您需要 toocreate 三個空白的資料庫中 Azure SQL Database:</span><span class="sxs-lookup"><span data-stu-id="c450d-116">toorun hello sample, you need toocreate three empty databases in Azure SQL Database:</span></span>

* <span data-ttu-id="c450d-117">分區對應管理員資料庫</span><span class="sxs-lookup"><span data-stu-id="c450d-117">Shard Map Manager database</span></span>
* <span data-ttu-id="c450d-118">分區 1 資料庫</span><span class="sxs-lookup"><span data-stu-id="c450d-118">Shard 1 database</span></span>
* <span data-ttu-id="c450d-119">分區 2 資料庫</span><span class="sxs-lookup"><span data-stu-id="c450d-119">Shard 2 database</span></span>

<span data-ttu-id="c450d-120">一旦您已經建立這些資料庫，填寫 hello 預留位置中**Program.cs**您的 Azure SQL DB 伺服器名稱、 hello 資料庫名稱與認證 tooconnect toohello 資料庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-120">Once you have created these databases, fill in hello place holders in **Program.cs** with your Azure SQL DB server name, hello database names and your credentials tooconnect toohello databases.</span></span> <span data-ttu-id="c450d-121">建置 Visual Studio 中的 hello 方案。</span><span class="sxs-lookup"><span data-stu-id="c450d-121">Build hello solution in Visual Studio.</span></span> <span data-ttu-id="c450d-122">Visual Studio 會下載所需的 hello NuGet 套件 hello 彈性資料庫用戶端程式庫、 Entity Framework 與暫時性錯誤處理 hello 建置程序的一部分。</span><span class="sxs-lookup"><span data-stu-id="c450d-122">Visual Studio will download hello required NuGet packages for hello elastic database client library, Entity Framework, and Transient Fault handling as part of hello build process.</span></span> <span data-ttu-id="c450d-123">請確定您的解決方案已啟用還原 NuGet 封裝。</span><span class="sxs-lookup"><span data-stu-id="c450d-123">Make sure that restoring NuGet packages is enabled for your solution.</span></span> <span data-ttu-id="c450d-124">以滑鼠右鍵按一下 hello Visual Studio 方案總管 中的 hello 方案檔，您可以啟用這項設定。</span><span class="sxs-lookup"><span data-stu-id="c450d-124">You can enable this setting by right-clicking on hello solution file in hello Visual Studio Solution Explorer.</span></span> 

## <a name="entity-framework-workflows"></a><span data-ttu-id="c450d-125">Entity Framework 工作流程</span><span class="sxs-lookup"><span data-stu-id="c450d-125">Entity Framework workflows</span></span>
<span data-ttu-id="c450d-126">Entity Framework 開發人員必須依賴 hello 下列四個工作流程 toobuild 應用程式和應用程式物件的 tooensure 持續性的其中一個：</span><span class="sxs-lookup"><span data-stu-id="c450d-126">Entity Framework developers rely on one of hello following four workflows toobuild applications and tooensure persistence for application objects:</span></span> 

* <span data-ttu-id="c450d-127">**Code First （新的資料庫）**: hello EF 開發人員建立 hello 應用程式程式碼中的 hello 模型，並接著 EF hello 資料庫會從產生它。</span><span class="sxs-lookup"><span data-stu-id="c450d-127">**Code First (New Database)**: hello EF developer creates hello model in hello application code and then EF generates hello database from it.</span></span> 
* <span data-ttu-id="c450d-128">**Code First （現有的資料庫）**: hello 開發人員可讓 EF hello hello 模型的應用程式程式碼產生從現有的資料庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-128">**Code First (Existing Database)**: hello developer lets EF generate hello application code for hello model from an existing database.</span></span>
* <span data-ttu-id="c450d-129">**建立第一個模型**: hello 開發人員建立 hello EF 設計工具中的 hello 模型，並接著 EF hello 資料庫會根據建立 hello 模型。</span><span class="sxs-lookup"><span data-stu-id="c450d-129">**Model First**: hello developer creates hello model in hello EF designer and then EF creates hello database from hello model.</span></span>
* <span data-ttu-id="c450d-130">**資料庫的第一個**: hello 開發人員會使用 EF tooling tooinfer hello 模型，從現有的資料庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-130">**Database First**: hello developer uses EF tooling tooinfer hello model from an existing database.</span></span> 

<span data-ttu-id="c450d-131">所有這些方法會依賴 hello DbContext 類別 tootransparently 管理資料庫連接及應用程式的資料庫結構描述。</span><span class="sxs-lookup"><span data-stu-id="c450d-131">All these approaches rely on hello DbContext class tootransparently manage database connections and database schema for an application.</span></span> <span data-ttu-id="c450d-132">我們會討論在 hello 件稍後詳細 hello DbContext 基底類別的不同建構函式可讓不同的層級的控制連線建立啟動載入和結構描述建立資料庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-132">As we will discuss in more detail later in hello document, different constructors on hello DbContext base class allow for different levels of control over connection creation, database bootstrapping and schema creation.</span></span> <span data-ttu-id="c450d-133">挑戰源自主要與 hello 連接管理功能的 hello 資料依存路由介面提供交集 hello database 連接管理 EF 所提供的 hello 事實 hello 彈性資料庫用戶端程式庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-133">Challenges arise primarily from hello fact that hello database connection management provided by EF intersects with hello connection management capabilities of hello data dependent routing interfaces provided by hello elastic database client library.</span></span> 

## <a name="elastic-database-tools-assumptions"></a><span data-ttu-id="c450d-134">彈性資料庫工具假設</span><span class="sxs-lookup"><span data-stu-id="c450d-134">Elastic database tools assumptions</span></span>
<span data-ttu-id="c450d-135">關於詞彙定義，請參閱 [彈性資料庫工具字彙](sql-database-elastic-scale-glossary.md)。</span><span class="sxs-lookup"><span data-stu-id="c450d-135">For term definitions, see [Elastic Database tools glossary](sql-database-elastic-scale-glossary.md).</span></span>

<span data-ttu-id="c450d-136">在彈性資料庫用戶端程式庫中，您會定義應用程式資料的資料分割，稱為 Shardlet。</span><span class="sxs-lookup"><span data-stu-id="c450d-136">With elastic database client library, you define partitions of your application data called shardlets.</span></span> <span data-ttu-id="c450d-137">Shardlet 的分區化索引鍵來識別和對應的 toospecific 資料庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-137">Shardlets are identified by a sharding key and are mapped toospecific databases.</span></span> <span data-ttu-id="c450d-138">應用程式可能需要的資料庫與散發 hello shardlet tooprovide 足夠容量或指定目前的商務需求的效能。</span><span class="sxs-lookup"><span data-stu-id="c450d-138">An application may have as many databases as needed and distribute hello shardlets tooprovide enough capacity or performance given current business requirements.</span></span> <span data-ttu-id="c450d-139">hello 對應的分區化索引鍵值 toohello 資料庫儲存 hello 彈性資料庫用戶端應用程式開發介面所提供的分區對應。</span><span class="sxs-lookup"><span data-stu-id="c450d-139">hello mapping of sharding key values toohello databases is stored by a shard map provided by hello elastic database client APIs.</span></span> <span data-ttu-id="c450d-140">我們將這項功能稱為 **分區對應管理**，簡稱為 SMM。</span><span class="sxs-lookup"><span data-stu-id="c450d-140">We call this capability **Shard Map Management**, or SMM for short.</span></span> <span data-ttu-id="c450d-141">hello 分區對應也可做為 hello broker 的要求進行分區化索引鍵的資料庫連線。</span><span class="sxs-lookup"><span data-stu-id="c450d-141">hello shard map also serves as hello broker of database connections for requests that carry a sharding key.</span></span> <span data-ttu-id="c450d-142">我們 toothis 功能作為**資料依存路由**。</span><span class="sxs-lookup"><span data-stu-id="c450d-142">We refer toothis capability as **data-dependent routing**.</span></span> 

<span data-ttu-id="c450d-143">hello 分區對應管理員防止不一致的檢視為 shardlet 資料發生並行的 shardlet 管理作業 （例如從一個分區 tooanother 重新配置的資料） 時可能發生的使用者。</span><span class="sxs-lookup"><span data-stu-id="c450d-143">hello shard map manager protects users from inconsistent views into shardlet data that can occur when concurrent shardlet management operations (such as relocating data from one shard tooanother) are happening.</span></span> <span data-ttu-id="c450d-144">toodo，hello hello 用戶端程式庫 broker hello 資料庫連接的應用程式所管理的分區對應。</span><span class="sxs-lookup"><span data-stu-id="c450d-144">toodo so, hello shard maps managed by hello client library broker hello database connections for an application.</span></span> <span data-ttu-id="c450d-145">這可讓 hello 分區對應功能 tooautomatically 終止資料庫連接時分區管理作業可能會影響已建立 hello 連線的 hello shardlet。</span><span class="sxs-lookup"><span data-stu-id="c450d-145">This allows hello shard map functionality tooautomatically kill a database connection when shard management operations could impact hello shardlet that hello connection has been created for.</span></span> <span data-ttu-id="c450d-146">這種方法需要 toointegrate 某些 EF 的功能，例如建立新的連線，從現有的一個 toocheck 資料庫存在。</span><span class="sxs-lookup"><span data-stu-id="c450d-146">This approach needs toointegrate with some of EF’s functionality, such as creating new connections from an existing one toocheck for database existence.</span></span> <span data-ttu-id="c450d-147">一般情況下，我們觀察已經過的 hello 標準 DbContext 建構函式只有可靠地運作可以順利複製的已關閉的資料庫連接的 EF 工作。</span><span class="sxs-lookup"><span data-stu-id="c450d-147">In general, our observation has been that hello standard DbContext constructors only work reliably for closed database connections that can safely be cloned for EF work.</span></span> <span data-ttu-id="c450d-148">hello 設計原則，彈性資料庫，而是 tooonly broker 開啟連線。</span><span class="sxs-lookup"><span data-stu-id="c450d-148">hello design principle of elastic database instead is tooonly broker opened connections.</span></span> <span data-ttu-id="c450d-149">其中一個可能會認為關閉連接，然後再將它傳遞 toohello EF DbContext hello 用戶端程式庫代理或許可以解決此問題。</span><span class="sxs-lookup"><span data-stu-id="c450d-149">One might think that closing a connection brokered by hello client library before handing it over toohello EF DbContext may solve this issue.</span></span> <span data-ttu-id="c450d-150">不過，藉由關閉 hello 連接和信賴憑證者在 EF toore 開啟它，其中一個 foregoes hello 程式庫所執行的 hello 驗證和一致性檢查。</span><span class="sxs-lookup"><span data-stu-id="c450d-150">However, by closing hello connection and relying on EF toore-open it, one foregoes hello validation and consistency checks performed by hello library.</span></span> <span data-ttu-id="c450d-151">hello 移轉功能 EF，不過，使用這些連接 toomanage hello 基礎資料庫結構描述是透明的 toohello 應用程式的方式。</span><span class="sxs-lookup"><span data-stu-id="c450d-151">hello migrations functionality in EF, however, uses these connections toomanage hello underlying database schema in a way that is transparent toohello application.</span></span> <span data-ttu-id="c450d-152">在理想情況下，我們會 tooretain 等結合所有這些功能從 hello 彈性資料庫用戶端程式庫和 EF hello 中的相同的應用程式。</span><span class="sxs-lookup"><span data-stu-id="c450d-152">Ideally, we would like tooretain and combine all these capabilities from both hello elastic database client library and EF in hello same application.</span></span> <span data-ttu-id="c450d-153">hello 下列章節會討論這些屬性和更詳細的需求。</span><span class="sxs-lookup"><span data-stu-id="c450d-153">hello following section discusses these properties and requirements in more detail.</span></span> 

## <a name="requirements"></a><span data-ttu-id="c450d-154">需求</span><span class="sxs-lookup"><span data-stu-id="c450d-154">Requirements</span></span>
<span data-ttu-id="c450d-155">當使用 hello 彈性資料庫用戶端程式庫和 Entity Framework 應用程式開發介面，我們想要 tooretain hello 下列屬性：</span><span class="sxs-lookup"><span data-stu-id="c450d-155">When working with both hello elastic database client library and Entity Framework APIs, we want tooretain hello following properties:</span></span> 

* <span data-ttu-id="c450d-156">**向外延展**: hello 資料 hello 分區化應用程式層的視 hello 容量需求的 hello 應用程式的 tooadd 或移除資料庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-156">**Scale-out**: tooadd or remove databases from hello data tier of hello sharded application as necessary for hello capacity demands of hello application.</span></span> <span data-ttu-id="c450d-157">這表示控制 hello hello 建立和刪除的資料庫和使用 hello 彈性資料庫分區對應管理員 Api toomanage 資料庫和對應的 shardlet。</span><span class="sxs-lookup"><span data-stu-id="c450d-157">This means control over hello hello creation and deletion of databases and using hello elastic database shard map manager APIs toomanage databases, and mappings of shardlets.</span></span> 
* <span data-ttu-id="c450d-158">**一致性**: hello 應用程式會使用分區化，並使用 hello 資料依存路由的功能 hello 用戶端程式庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-158">**Consistency**: hello application employs sharding, and uses hello data dependent routing capabilities of hello client library.</span></span> <span data-ttu-id="c450d-159">tooavoid 損毀或不正確的查詢結果，在由代理連線 hello 分區對應管理員。</span><span class="sxs-lookup"><span data-stu-id="c450d-159">tooavoid corruption or wrong query results, connections are brokered through hello shard map manager.</span></span> <span data-ttu-id="c450d-160">這也會保留驗證和一致性。</span><span class="sxs-lookup"><span data-stu-id="c450d-160">This also retains validation and consistency.</span></span>
* <span data-ttu-id="c450d-161">**Code First**: tooretain hello 的方便性，不論 EF 的程式碼的第一個範例。</span><span class="sxs-lookup"><span data-stu-id="c450d-161">**Code First**: tooretain hello convenience of EF’s code first paradigm.</span></span> <span data-ttu-id="c450d-162">在 Code First hello 應用程式中的類別會以透明的方式對應 toohello 基礎資料庫結構。</span><span class="sxs-lookup"><span data-stu-id="c450d-162">In Code First, classes in hello application are mapped transparently toohello underlying database structures.</span></span> <span data-ttu-id="c450d-163">hello 應用程式程式碼會與 遮罩 hello 基礎資料庫處理所涉及的大部分層面的 DbSets 互動。</span><span class="sxs-lookup"><span data-stu-id="c450d-163">hello application code interacts with DbSets that mask most aspects involved in hello underlying database processing.</span></span>
* <span data-ttu-id="c450d-164">**結構描述**：Entity Framework 會處理建立初始資料庫結構描述，以及結構描述後續透過移轉的演進。</span><span class="sxs-lookup"><span data-stu-id="c450d-164">**Schema**: Entity Framework handles initial database schema creation and subsequent schema evolution through migrations.</span></span> <span data-ttu-id="c450d-165">藉由保留這些功能，調整您的應用程式就容易 hello 資料發展。</span><span class="sxs-lookup"><span data-stu-id="c450d-165">By retaining these capabilities, adapting your app is easy as hello data evolves.</span></span> 

<span data-ttu-id="c450d-166">hello 下列指導方針會指示如何 toosatisfy 使用彈性資料庫工具的第一個程式碼應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="c450d-166">hello following guidance instructs how toosatisfy these requirements for Code First applications using elastic database tools.</span></span> 

## <a name="data-dependent-routing-using-ef-dbcontext"></a><span data-ttu-id="c450d-167">使用 EF DbContext 的資料相依路由</span><span class="sxs-lookup"><span data-stu-id="c450d-167">Data dependent routing using EF DbContext</span></span>
<span data-ttu-id="c450d-168">資料庫與 Entity Framework 的連接通常是透過 **DbContext**的子類別管理。</span><span class="sxs-lookup"><span data-stu-id="c450d-168">Database connections with Entity Framework are typically managed through subclasses of **DbContext**.</span></span> <span data-ttu-id="c450d-169">從 **DbContext**衍生來建立這些子類別。</span><span class="sxs-lookup"><span data-stu-id="c450d-169">Create these subclasses by deriving from **DbContext**.</span></span> <span data-ttu-id="c450d-170">這可讓您定義您**DbSets**實作 hello 應用程式的 CLR 物件的資料庫為基礎集合。</span><span class="sxs-lookup"><span data-stu-id="c450d-170">This is where you define your **DbSets** that implement hello database-backed collections of CLR objects for your application.</span></span> <span data-ttu-id="c450d-171">我們可以在 hello 內容中的資料依存路由，來識別不一定是保存的其他 EF 程式碼第一個應用程式案例的一些很有幫助屬性：</span><span class="sxs-lookup"><span data-stu-id="c450d-171">In hello context of data dependent routing, we can identify several helpful properties that do not necessarily hold for other EF code first application scenarios:</span></span> 

* <span data-ttu-id="c450d-172">hello 資料庫已經存在，且已註冊 hello 彈性資料庫分區對應中。</span><span class="sxs-lookup"><span data-stu-id="c450d-172">hello database already exists and has been registered in hello elastic database shard map.</span></span> 
* <span data-ttu-id="c450d-173">hello 結構描述的 hello 應用程式已經部署的 toohello 資料庫 （如下所述）。</span><span class="sxs-lookup"><span data-stu-id="c450d-173">hello schema of hello application has already been deployed toohello database (explained below).</span></span> 
* <span data-ttu-id="c450d-174">資料依存路由 toohello 資料庫的連接是由 hello 分區對應代理。</span><span class="sxs-lookup"><span data-stu-id="c450d-174">Data-dependent routing connections toohello database are brokered by hello shard map.</span></span> 

<span data-ttu-id="c450d-175">toointegrate **DbContexts**具有資料依存路由的向外延展：</span><span class="sxs-lookup"><span data-stu-id="c450d-175">toointegrate **DbContexts** with data-dependent routing for scale-out:</span></span>

1. <span data-ttu-id="c450d-176">建立 hello 分區對應管理員，透過 hello 彈性資料庫用戶端介面的實體資料庫的連接</span><span class="sxs-lookup"><span data-stu-id="c450d-176">Create physical database connections through hello elastic database client interfaces of hello shard map manager,</span></span> 
2. <span data-ttu-id="c450d-177">自動換行以 hello hello 連接**DbContext**子類別</span><span class="sxs-lookup"><span data-stu-id="c450d-177">Wrap hello connection with hello **DbContext** subclass</span></span>
3. <span data-ttu-id="c450d-178">向下 hello 連接傳入 hello **DbContext**基底類別 tooensure hello EF 端上的所有 hello 處理也會都發生。</span><span class="sxs-lookup"><span data-stu-id="c450d-178">Pass hello connection down into hello **DbContext** base classes tooensure all hello processing on hello EF side happens as well.</span></span> 

<span data-ttu-id="c450d-179">hello，下列程式碼範例將示範這個方法。</span><span class="sxs-lookup"><span data-stu-id="c450d-179">hello following code example illustrates this approach.</span></span> <span data-ttu-id="c450d-180">（此程式碼也是 hello 隨附的 Visual Studio 專案中）</span><span class="sxs-lookup"><span data-stu-id="c450d-180">(This code is also in hello accompanying Visual Studio project)</span></span>

    public class ElasticScaleContext<T> : DbContext
    {
    public DbSet<Blog> Blogs { get; set; }
    …

        // C'tor for data dependent routing. This call will open a validated connection 
        // routed toohello proper shard by hello shard map manager. 
        // Note that hello base class c'tor call will fail for an open connection
        // if migrations need toobe done and SQL credentials are used. This is hello reason for hello 
        // separation of c'tors into hello data-dependent routing case (this c'tor) and hello internal c'tor for new shards.
        public ElasticScaleContext(ShardMap shardMap, T shardingKey, string connectionStr)
            : base(CreateDDRConnection(shardMap, shardingKey, connectionStr), 
            true /* contextOwnsConnection */)
        {
        }

        // Only static methods are allowed in calls into base class c'tors.
        private static DbConnection CreateDDRConnection(
        ShardMap shardMap, 
        T shardingKey, 
        string connectionStr)
        {
            // No initialization
            Database.SetInitializer<ElasticScaleContext<T>>(null);

            // Ask shard map toobroker a validated connection for hello given key
            SqlConnection conn = shardMap.OpenConnectionForKey<T>
                                (shardingKey, connectionStr, ConnectionOptions.Validate);
            return conn;
        }    

## <a name="main-points"></a><span data-ttu-id="c450d-181">重點</span><span class="sxs-lookup"><span data-stu-id="c450d-181">Main points</span></span>
* <span data-ttu-id="c450d-182">新的建構函式取代 hello hello DbContext 子類別中的預設建構函式</span><span class="sxs-lookup"><span data-stu-id="c450d-182">A new constructor replaces hello default constructor in hello DbContext subclass</span></span> 
* <span data-ttu-id="c450d-183">hello 新建構函式會採用所需的資料依存路由透過彈性資料庫用戶端程式庫的 hello 引數：</span><span class="sxs-lookup"><span data-stu-id="c450d-183">hello new constructor takes hello arguments that are required for data dependent routing through elastic database client library:</span></span>
  
  * <span data-ttu-id="c450d-184">hello 分區對應 tooaccess hello 資料依存路由的介面，</span><span class="sxs-lookup"><span data-stu-id="c450d-184">hello shard map tooaccess hello data-dependent routing interfaces,</span></span>
  * <span data-ttu-id="c450d-185">hello 分區化索引鍵 tooidentify hello shardlet，</span><span class="sxs-lookup"><span data-stu-id="c450d-185">hello sharding key tooidentify hello shardlet,</span></span>
  * <span data-ttu-id="c450d-186">含 hello 資料依存路由連線 toohello 分區的 hello 認證的連接字串。</span><span class="sxs-lookup"><span data-stu-id="c450d-186">a connection string with hello credentials for hello data-dependent routing connection toohello shard.</span></span> 
* <span data-ttu-id="c450d-187">hello 呼叫 toohello 基底類別建構函式繞道到靜態方法，會執行所有的 hello 步驟所需的資料依存路由。</span><span class="sxs-lookup"><span data-stu-id="c450d-187">hello call toohello base class constructor takes a detour into a static method that performs all hello steps necessary for data-dependent routing.</span></span> 
  
  * <span data-ttu-id="c450d-188">它會使用 hello 分區對應 tooestablish 的開啟連接的 hello OpenConnectionForKey 呼叫的 hello 彈性資料庫用戶端介面。</span><span class="sxs-lookup"><span data-stu-id="c450d-188">It uses hello OpenConnectionForKey call of hello elastic database client interfaces on hello shard map tooestablish an open connection.</span></span>
  * <span data-ttu-id="c450d-189">hello 分區對應會建立保留 hello 指定分區化索引鍵的 hello shardlet 的 hello 開啟連接 toohello 分區。</span><span class="sxs-lookup"><span data-stu-id="c450d-189">hello shard map creates hello open connection toohello shard that holds hello shardlet for hello given sharding key.</span></span>
  * <span data-ttu-id="c450d-190">這個開啟的連接會傳遞這個連接會 toobe 而非讓 EF 自動建立新的連接使用 EF DbContext tooindicate 後 toohello 基底類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="c450d-190">This open connection is passed back toohello base class constructor of DbContext tooindicate that this connection is toobe used by EF instead of letting EF create a new connection automatically.</span></span> <span data-ttu-id="c450d-191">此方式 hello 連線已經加上 hello 彈性資料庫用戶端應用程式開發介面，讓它可以保證在分區對應管理作業的一致性。</span><span class="sxs-lookup"><span data-stu-id="c450d-191">This way hello connection has been tagged by hello elastic database client API so that it can guarantee consistency under shard map management operations.</span></span>

<span data-ttu-id="c450d-192">用於 DbContext 子類別而不是在程式碼中的 hello 預設建構函式中的 hello 新建構函式。</span><span class="sxs-lookup"><span data-stu-id="c450d-192">Use hello new constructor for your DbContext subclass instead of hello default constructor in your code.</span></span> <span data-ttu-id="c450d-193">下列是一個範例：</span><span class="sxs-lookup"><span data-stu-id="c450d-193">Here is an example:</span></span> 

    // Create and save a new blog.

    Console.Write("Enter a name for a new blog: "); 
    var name = Console.ReadLine(); 

    using (var db = new ElasticScaleContext<int>( 
                            sharding.ShardMap,  
                            tenantId1,  
                            connStrBldr.ConnectionString)) 
    { 
        var blog = new Blog { Name = name }; 
        db.Blogs.Add(blog); 
        db.SaveChanges(); 

        // Display all Blogs for tenant 1 
        var query = from b in db.Blogs 
                    orderby b.Name 
                    select b; 
     … 
    }

<span data-ttu-id="c450d-194">hello 新建構函式會開啟 hello 保留 hello hello shardlet hello 值所識別的資料連接 toohello 分區**tenantid1**。</span><span class="sxs-lookup"><span data-stu-id="c450d-194">hello new constructor opens hello connection toohello shard that holds hello data for hello shardlet identified by hello value of **tenantid1**.</span></span> <span data-ttu-id="c450d-195">hello hello 中的程式碼**使用**區塊會維持不變的 tooaccess hello **DbSet**部落格上的 hello 分區使用 EF **tenantid1**。</span><span class="sxs-lookup"><span data-stu-id="c450d-195">hello code in hello **using** block stays unchanged tooaccess hello **DbSet** for blogs using EF on hello shard for **tenantid1**.</span></span> <span data-ttu-id="c450d-196">這會針對 hello hello 所有資料庫作業現在會使用區塊中的程式碼範圍 toohello 一個分區變更語意其中**tenantid1**會保留。</span><span class="sxs-lookup"><span data-stu-id="c450d-196">This changes semantics for hello code in hello using block such that all database operations are now scoped toohello one shard where **tenantid1** is kept.</span></span> <span data-ttu-id="c450d-197">比方說，LINQ 查詢透過 hello 部落格**DbSet**就只會傳回儲存在目前的分區，hello 上的部落格，但不是 hello 是儲存在其他分區。</span><span class="sxs-lookup"><span data-stu-id="c450d-197">For instance, a LINQ query over hello blogs **DbSet** would only return blogs stored on hello current shard, but not hello ones stored on other shards.</span></span>  

#### <a name="transient-faults-handling"></a><span data-ttu-id="c450d-198">暫時性錯誤處理</span><span class="sxs-lookup"><span data-stu-id="c450d-198">Transient faults handling</span></span>
<span data-ttu-id="c450d-199">hello Microsoft Patterns & Practices 團隊發行的 hello [hello 暫時性錯誤處理應用程式區塊](https://msdn.microsoft.com/library/dn440719.aspx)。</span><span class="sxs-lookup"><span data-stu-id="c450d-199">hello Microsoft Patterns & Practices team published hello [hello Transient Fault Handling Application Block](https://msdn.microsoft.com/library/dn440719.aspx).</span></span> <span data-ttu-id="c450d-200">hello 程式庫會使用彈性延展 EF 結合的用戶端程式庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-200">hello library is used with elastic scale client library in combination with EF.</span></span> <span data-ttu-id="c450d-201">不過，確保任何暫時性例外狀況傳回 tooa 位置，而我們可以確保該 hello 新建構函式正在使用暫時性錯誤後，讓任何新連接嘗試使用我們強制 hello 建構函式。</span><span class="sxs-lookup"><span data-stu-id="c450d-201">However, ensure that any transient exception returns tooa place where we can ensure that hello new constructor is being used after a transient fault so that any new connection attempt is made using hello constructors we have tweaked.</span></span> <span data-ttu-id="c450d-202">否則，不保證分區，且不保證 hello 連線正確連接 toohello 會維護 toohello 分區對應會發生的變更時。</span><span class="sxs-lookup"><span data-stu-id="c450d-202">Otherwise, a connection toohello correct shard is not guaranteed, and there are no assurances hello connection is maintained as changes toohello shard map occur.</span></span> 

<span data-ttu-id="c450d-203">hello 下列程式碼範例說明如何 SQL 重試原則來使用周圍 hello 新**DbContext**子類別建構函式：</span><span class="sxs-lookup"><span data-stu-id="c450d-203">hello following code sample illustrates how a SQL retry policy can be used around hello new **DbContext** subclass constructors:</span></span> 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() => 
    { 
        using (var db = new ElasticScaleContext<int>( 
                                sharding.ShardMap,  
                                tenantId1,  
                                connStrBldr.ConnectionString)) 
            { 
                    var blog = new Blog { Name = name }; 
                    db.Blogs.Add(blog); 
                    db.SaveChanges(); 
            … 
            } 
        }); 

<span data-ttu-id="c450d-204">**SqlDatabaseUtils.SqlRetryPolicy** hello 在上述程式碼會定義為**SqlDatabaseTransientErrorDetectionStrategy** 10，和 5 秒的重試計數等候重試之間的時間。</span><span class="sxs-lookup"><span data-stu-id="c450d-204">**SqlDatabaseUtils.SqlRetryPolicy** in hello code above is defined as a **SqlDatabaseTransientErrorDetectionStrategy** with a retry count of 10, and 5 seconds wait time between retries.</span></span> <span data-ttu-id="c450d-205">這種方法很類似 toohello 指引 EF 和使用者起始的交易 (請參閱[限制以重試一次 (EF6 及更新版本) 的執行策略](http://msdn.microsoft.com/data/dn307226)。</span><span class="sxs-lookup"><span data-stu-id="c450d-205">This approach is similar toohello guidance for EF and user-initiated transactions (see [Limitations with Retrying Execution Strategies (EF6 onwards)](http://msdn.microsoft.com/data/dn307226).</span></span> <span data-ttu-id="c450d-206">這兩種情況需要該 hello 應用程式可以控制 hello 範圍 toowhich hello 暫時性例外狀況傳回： tooeither 重新開啟 hello 交易，或 （如下所示） 重新建立 hello 內容從使用 hello 彈性資料庫 hello 適當建構函式用戶端程式庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-206">Both situations require that hello application program controls hello scope toowhich hello transient exception returns: tooeither reopen hello transaction, or (as shown) recreate hello context from hello proper constructor that uses hello elastic database client library.</span></span>

<span data-ttu-id="c450d-207">hello 需要 toocontrol 因為暫時性例外狀況傳回範圍中需要我們也會妨礙 hello 內建的 hello 使用**SqlAzureExecutionStrategy**所附 EF。</span><span class="sxs-lookup"><span data-stu-id="c450d-207">hello need toocontrol where transient exceptions take us back in scope also precludes hello use of hello built-in **SqlAzureExecutionStrategy** that comes with EF.</span></span> <span data-ttu-id="c450d-208">**SqlAzureExecutionStrategy**會重新開啟連線，但是不會使用**OpenConnectionForKey** ，因此略過所有執行 hello 一部分的 hello 驗證**OpenConnectionForKey**呼叫。</span><span class="sxs-lookup"><span data-stu-id="c450d-208">**SqlAzureExecutionStrategy** would reopen a connection but not use **OpenConnectionForKey** and therefore bypass all hello validation that is performed as part of hello **OpenConnectionForKey** call.</span></span> <span data-ttu-id="c450d-209">相反地，hello 程式碼範例會使用 hello 內建**DefaultExecutionStrategy** ，也提供的 EF。</span><span class="sxs-lookup"><span data-stu-id="c450d-209">Instead, hello code sample uses hello built-in **DefaultExecutionStrategy** that also comes with EF.</span></span> <span data-ttu-id="c450d-210">相對於太**SqlAzureExecutionStrategy**，其運作正常的暫時性錯誤處理 hello 重試原則的組合。</span><span class="sxs-lookup"><span data-stu-id="c450d-210">As opposed too**SqlAzureExecutionStrategy**, it works correctly in combination with hello retry policy from Transient Fault Handling.</span></span> <span data-ttu-id="c450d-211">hello 執行原則設定中 hello **ElasticScaleDbConfiguration**類別。</span><span class="sxs-lookup"><span data-stu-id="c450d-211">hello execution policy is set in hello **ElasticScaleDbConfiguration** class.</span></span> <span data-ttu-id="c450d-212">請注意，我們決定不 toouse **DefaultSqlExecutionStrategy**因為建議 toouse **SqlAzureExecutionStrategy**發生暫時性的例外狀況-這會導致 toowrong 行為所述。</span><span class="sxs-lookup"><span data-stu-id="c450d-212">Note that we decided not toouse **DefaultSqlExecutionStrategy** since it suggests toouse **SqlAzureExecutionStrategy** if transient exceptions occur - which would lead toowrong behavior as discussed.</span></span> <span data-ttu-id="c450d-213">Hello 不同的重試原則和 EF 的詳細資訊，請參閱[Connection Resiliency in EF](http://msdn.microsoft.com/data/dn456835.aspx)。</span><span class="sxs-lookup"><span data-stu-id="c450d-213">For more information on hello different retry policies and EF, see [Connection Resiliency in EF](http://msdn.microsoft.com/data/dn456835.aspx).</span></span>     

#### <a name="constructor-rewrites"></a><span data-ttu-id="c450d-214">建構函式重寫</span><span class="sxs-lookup"><span data-stu-id="c450d-214">Constructor rewrites</span></span>
<span data-ttu-id="c450d-215">hello 上述的程式碼範例說明 hello 預設建構函式重寫為所需的順序 toouse 資料依存路由以 hello Entity Framework 中的應用程式。</span><span class="sxs-lookup"><span data-stu-id="c450d-215">hello code examples above illustrate hello default constructor re-writes required for your application in order toouse  data dependent routing with hello Entity Framework.</span></span> <span data-ttu-id="c450d-216">下表中的 hello 一般化這個方法 tooother 建構函式。</span><span class="sxs-lookup"><span data-stu-id="c450d-216">hello following table generalizes this approach tooother constructors.</span></span> 

| <span data-ttu-id="c450d-217">目前的建構函式</span><span class="sxs-lookup"><span data-stu-id="c450d-217">Current Constructor</span></span> | <span data-ttu-id="c450d-218">重寫的資料建構函式</span><span class="sxs-lookup"><span data-stu-id="c450d-218">Rewritten Constructor for data</span></span> | <span data-ttu-id="c450d-219">基底建構函式</span><span class="sxs-lookup"><span data-stu-id="c450d-219">Base Constructor</span></span> | <span data-ttu-id="c450d-220">注意事項</span><span class="sxs-lookup"><span data-stu-id="c450d-220">Notes</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="c450d-221">MyContext()</span><span class="sxs-lookup"><span data-stu-id="c450d-221">MyContext()</span></span> |<span data-ttu-id="c450d-222">ElasticScaleContext(ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="c450d-222">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="c450d-223">DbContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-223">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="c450d-224">hello 連線需要 toobe hello 分區對應和 hello 資料依存路由索引鍵的函式。</span><span class="sxs-lookup"><span data-stu-id="c450d-224">hello connection needs toobe a function of hello shard map and hello data-dependent routing key.</span></span> <span data-ttu-id="c450d-225">您需要的 EF tooby 行程自動連線建立，並改用 hello 分區對應 toobroker hello 連線。</span><span class="sxs-lookup"><span data-stu-id="c450d-225">You need tooby-pass automatic connection creation by EF and instead use hello shard map toobroker hello connection.</span></span> |
| <span data-ttu-id="c450d-226">MyContext(string)</span><span class="sxs-lookup"><span data-stu-id="c450d-226">MyContext(string)</span></span> |<span data-ttu-id="c450d-227">ElasticScaleContext(ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="c450d-227">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="c450d-228">DbContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-228">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="c450d-229">hello 連接是 hello 分區對應和 hello 資料依存路由索引鍵的函式。</span><span class="sxs-lookup"><span data-stu-id="c450d-229">hello connection is a function of hello shard map and hello data-dependent routing key.</span></span> <span data-ttu-id="c450d-230">固定的資料庫名稱或連接字串將無法運作，您會看到略過驗證的 hello 分區對應。</span><span class="sxs-lookup"><span data-stu-id="c450d-230">A fixed database name or connection string will not work as they by-pass validation by hello shard map.</span></span> |
| <span data-ttu-id="c450d-231">MyContext(DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="c450d-231">MyContext(DbCompiledModel)</span></span> |<span data-ttu-id="c450d-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="c450d-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="c450d-233">DbContext(DbConnection, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-233">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="c450d-234">將取得 hello 連線建立 hello 指定 hello 模型提供的檔名的分區化對應和分區化索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c450d-234">hello connection will get created for hello given shard map and sharding key with hello model provided.</span></span> <span data-ttu-id="c450d-235">將傳遞 toohello 基底 c'tor hello 編譯的模型。</span><span class="sxs-lookup"><span data-stu-id="c450d-235">hello compiled model will be passed on toohello base c’tor.</span></span> |
| <span data-ttu-id="c450d-236">MyContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-236">MyContext(DbConnection, bool)</span></span> |<span data-ttu-id="c450d-237">ElasticScaleContext(ShardMap, TKey, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-237">ElasticScaleContext(ShardMap, TKey, bool)</span></span> |<span data-ttu-id="c450d-238">DbContext(DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-238">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="c450d-239">hello 連線需要 toobe 推斷從 hello 分區對應 hello 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c450d-239">hello connection needs toobe inferred from hello shard map and hello key.</span></span> <span data-ttu-id="c450d-240">（除非該輸入已經使用 hello 分區對應和 hello 金鑰），不能提供它做為輸入。</span><span class="sxs-lookup"><span data-stu-id="c450d-240">It cannot be provided as an input (unless that input was already using hello shard map and hello key).</span></span> <span data-ttu-id="c450d-241">將傳遞 hello 布林值。</span><span class="sxs-lookup"><span data-stu-id="c450d-241">hello Boolean will be passed on.</span></span> |
| <span data-ttu-id="c450d-242">MyContext(string, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="c450d-242">MyContext(string, DbCompiledModel)</span></span> |<span data-ttu-id="c450d-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="c450d-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="c450d-244">DbContext(DbConnection, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-244">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="c450d-245">hello 連線需要 toobe 推斷從 hello 分區對應 hello 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c450d-245">hello connection needs toobe inferred from hello shard map and hello key.</span></span> <span data-ttu-id="c450d-246">（除非已使用該輸入，hello 分區對應和 hello 金鑰），不能提供它做為輸入。</span><span class="sxs-lookup"><span data-stu-id="c450d-246">It cannot be provided as an input (unless that input was using hello shard map and hello key).</span></span> <span data-ttu-id="c450d-247">將傳遞 hello 編譯的模型。</span><span class="sxs-lookup"><span data-stu-id="c450d-247">hello compiled model will be passed on.</span></span> |
| <span data-ttu-id="c450d-248">MyContext(ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-248">MyContext(ObjectContext, bool)</span></span> |<span data-ttu-id="c450d-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span></span> |<span data-ttu-id="c450d-250">DbContext(ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-250">DbContext(ObjectContext, bool)</span></span> |<span data-ttu-id="c450d-251">hello 新建構函式需要 tooensure hello 當做輸入傳遞 ObjectContext 中的任何連接是重新路由的 tooa 連接受彈性延展。</span><span class="sxs-lookup"><span data-stu-id="c450d-251">hello new constructor needs tooensure that any connection in hello ObjectContext passed as an input is re-routed tooa connection managed by Elastic Scale.</span></span> <span data-ttu-id="c450d-252">ObjectContexts 詳細的討論已超出本文件 hello 範圍。</span><span class="sxs-lookup"><span data-stu-id="c450d-252">A detailed discussion of ObjectContexts is beyond hello scope of this document.</span></span> |
| <span data-ttu-id="c450d-253">MyContext(DbConnection, DbCompiledModel,bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-253">MyContext(DbConnection, DbCompiledModel,bool)</span></span> |<span data-ttu-id="c450d-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="c450d-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span></span> |<span data-ttu-id="c450d-255">DbContext(DbConnection, DbCompiledModel, bool);</span><span class="sxs-lookup"><span data-stu-id="c450d-255">DbContext(DbConnection, DbCompiledModel, bool);</span></span> |<span data-ttu-id="c450d-256">hello 連線需要 toobe 推斷從 hello 分區對應 hello 索引鍵。</span><span class="sxs-lookup"><span data-stu-id="c450d-256">hello connection needs toobe inferred from hello shard map and hello key.</span></span> <span data-ttu-id="c450d-257">（除非該輸入已經使用 hello 分區對應和 hello 金鑰），無法提供 hello 連接做為輸入。</span><span class="sxs-lookup"><span data-stu-id="c450d-257">hello connection cannot be provided as an input (unless that input was already using hello shard map and hello key).</span></span> <span data-ttu-id="c450d-258">模型和布林值會傳遞 toohello 基底類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="c450d-258">Model and Boolean are passed on toohello base class constructor.</span></span> |

## <a name="shard-schema-deployment-through-ef-migrations"></a><span data-ttu-id="c450d-259">透過 EF 移轉的分區結構描述部署</span><span class="sxs-lookup"><span data-stu-id="c450d-259">Shard schema deployment through EF migrations</span></span>
<span data-ttu-id="c450d-260">管理自動的結構描述是方便 hello Entity Framework 所提供。</span><span class="sxs-lookup"><span data-stu-id="c450d-260">Automatic schema management is a convenience provided by hello Entity Framework.</span></span> <span data-ttu-id="c450d-261">Hello 在內容中使用彈性資料庫工具的應用程式，我們想 tooretain 此功能 tooautomatically 佈建 hello 結構描述建立 toonewly 分區時的資料庫會加入 toohello 分區化應用程式。</span><span class="sxs-lookup"><span data-stu-id="c450d-261">In hello context of applications using elastic database tools, we want tooretain this capability tooautomatically provision hello schema toonewly created shards when databases are added toohello sharded application.</span></span> <span data-ttu-id="c450d-262">hello 主要使用案例是在 hello 資料層分區化應用程式使用 EF tooincrease 容量。</span><span class="sxs-lookup"><span data-stu-id="c450d-262">hello primary use case is tooincrease capacity at hello data tier for sharded applications using EF.</span></span> <span data-ttu-id="c450d-263">信賴憑證者的結構描述管理 EF 的功能與 EF 上建置分區化應用程式減少 hello 資料庫管理工作。</span><span class="sxs-lookup"><span data-stu-id="c450d-263">Relying on EF’s capabilities for schema management reduces hello database administration effort with a sharded application built on EF.</span></span> 

<span data-ttu-id="c450d-264">透過 EF 移轉的結構描述部署在 **未開啟的連接**上表現最好。</span><span class="sxs-lookup"><span data-stu-id="c450d-264">Schema deployment through EF migrations works best on **unopened connections**.</span></span> <span data-ttu-id="c450d-265">這是相較之下 toohello 案例資料依存路由依賴 hello 彈性資料庫用戶端應用程式開發介面所提供的 hello 開啟連接。</span><span class="sxs-lookup"><span data-stu-id="c450d-265">This is in contrast toohello scenario for data dependent routing that relies on hello opened connection provided by hello elastic database client API.</span></span> <span data-ttu-id="c450d-266">另一項差異是 hello 一致性需求： 所有資料依存路由連線 tooprotect 針對並行分區對應管理的理想 tooensure 一致性，同時它不是初始的結構描述部署 tooa 新資料庫的相關問題具有尚未在 hello 分區對應中，尚未註冊，且尚未在已配置 toohold shardlet。</span><span class="sxs-lookup"><span data-stu-id="c450d-266">Another difference is hello consistency requirement: While desirable tooensure consistency for all data-dependent routing connections tooprotect against concurrent shard map manipulation, it is not a concern with initial schema deployment tooa new database that has not yet been registered in hello shard map, and not yet been allocated toohold shardlets.</span></span> <span data-ttu-id="c450d-267">我們因此可依賴此案例中，做為相對於 toodata 依存路由規則的資料庫連接。</span><span class="sxs-lookup"><span data-stu-id="c450d-267">We can therefore rely on regular database connections for this scenarios, as opposed toodata-dependent routing.</span></span>  

<span data-ttu-id="c450d-268">這會導致 tooan 方法其中透過 EF 移轉的結構描述部署與緊密結合 hello hello 新的資料庫註冊為 hello 應用程式的分區對應中的分區。</span><span class="sxs-lookup"><span data-stu-id="c450d-268">This leads tooan approach where schema deployment through EF migrations is tightly coupled with hello registration of hello new database as a shard in hello application’s shard map.</span></span> <span data-ttu-id="c450d-269">這會依賴 hello 下列必要條件：</span><span class="sxs-lookup"><span data-stu-id="c450d-269">This relies on hello following prerequisites:</span></span> 

* <span data-ttu-id="c450d-270">已建立 hello 資料庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-270">hello database has already been created.</span></span> 
* <span data-ttu-id="c450d-271">hello 資料庫是空的-它會保留任何的使用者結構描述和任何使用者資料。</span><span class="sxs-lookup"><span data-stu-id="c450d-271">hello database is empty - it holds no user schema and no user data.</span></span>
* <span data-ttu-id="c450d-272">hello 資料庫尚未無法透過 hello 彈性資料庫用戶端應用程式開發介面資料依存路由的存取。</span><span class="sxs-lookup"><span data-stu-id="c450d-272">hello database cannot yet be accessed through hello elastic database client APIs for data-dependent routing.</span></span> 

<span data-ttu-id="c450d-273">這些先決條件備妥，我們可以建立一般未開啟**SqlConnection** tookick 關閉結構描述部署的 EF 移轉。</span><span class="sxs-lookup"><span data-stu-id="c450d-273">With these prerequisites in place, we can create a regular un-opened **SqlConnection** tookick off EF migrations for schema deployment.</span></span> <span data-ttu-id="c450d-274">hello，下列程式碼範例將示範這個方法。</span><span class="sxs-lookup"><span data-stu-id="c450d-274">hello following code sample illustrates this approach.</span></span> 

        // Enter a new shard - i.e. an empty database - toohello shard map, allocate a first tenant tooit  
        // and kick off EF intialization of hello database toodeploy schema 

        public void RegisterNewShard(string server, string database, string connStr, int key) 
        { 

            Shard shard = this.ShardMap.CreateShard(new ShardLocation(server, database)); 

            SqlConnectionStringBuilder connStrBldr = new SqlConnectionStringBuilder(connStr); 
            connStrBldr.DataSource = server; 
            connStrBldr.InitialCatalog = database; 

            // Go into a DbContext tootrigger migrations and schema deployment for hello new shard. 
            // This requires an un-opened connection. 
            using (var db = new ElasticScaleContext<int>(connStrBldr.ConnectionString)) 
            { 
                // Run a query tooengage EF migrations 
                (from b in db.Blogs 
                    select b).Count(); 
            } 

            // Register hello mapping of hello tenant toohello shard in hello shard map. 
            // After this step, data-dependent routing on hello shard map can be used 

            this.ShardMap.CreatePointMapping(key, shard); 
        } 


<span data-ttu-id="c450d-275">這個範例會顯示 hello 方法**RegisterNewShard**暫存器 hello 在 hello 分區對應中，分區部署 hello 透過 EF 移轉的結構描述和儲存的分區化索引鍵 toohello 分區對應。</span><span class="sxs-lookup"><span data-stu-id="c450d-275">This sample shows hello method **RegisterNewShard** that registers hello shard in hello shard map, deploys hello schema through EF migrations, and stores a mapping of a sharding key toohello shard.</span></span> <span data-ttu-id="c450d-276">它依賴 hello 的建構函式**DbContext**子類別 (**ElasticScaleContext** hello 範例中)，使用 SQL 連接字串做為輸入。</span><span class="sxs-lookup"><span data-stu-id="c450d-276">It relies on a constructor of hello **DbContext** subclass (**ElasticScaleContext** in hello sample) that takes a SQL connection string as input.</span></span> <span data-ttu-id="c450d-277">這個建構函式的 hello 程式碼是明瞭，為下列範例所示的 hello:</span><span class="sxs-lookup"><span data-stu-id="c450d-277">hello code of this constructor is straight-forward, as hello following example shows:</span></span> 

        // C'tor toodeploy schema and migrations tooa new shard 
        protected internal ElasticScaleContext(string connectionString) 
            : base(SetInitializerForConnection(connectionString)) 
        { 
        } 

        // Only static methods are allowed in calls into base class c'tors 
        private static string SetInitializerForConnection(string connnectionString) 
        { 
            // We want existence checks so that hello schema can get deployed 
            Database.SetInitializer<ElasticScaleContext<T>>( 
        new CreateDatabaseIfNotExists<ElasticScaleContext<T>>()); 

            return connnectionString; 
        } 

<span data-ttu-id="c450d-278">其中一個可能使用 hello hello 建構函式繼承自 hello 基底類別版本。</span><span class="sxs-lookup"><span data-stu-id="c450d-278">One might have used hello version of hello constructor inherited from hello base class.</span></span> <span data-ttu-id="c450d-279">但 hello EF 預設初始設定式的 hello 程式碼需要 tooensure 在連接時使用。</span><span class="sxs-lookup"><span data-stu-id="c450d-279">But hello code needs tooensure that hello default initializer for EF is used when connecting.</span></span> <span data-ttu-id="c450d-280">因此 hello 簡短繞道至 hello hello 連接字串 hello 基底類別建構函式呼叫之前的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="c450d-280">Hence hello short detour into hello static method before calling into hello base class constructor with hello connection string.</span></span> <span data-ttu-id="c450d-281">請注意，分區的 hello 註冊應該執行不發生衝突的 EF hello 初始設定式設定不同的應用程式定義域或處理序 tooensure 中。</span><span class="sxs-lookup"><span data-stu-id="c450d-281">Note that hello registration of shards should run in a different app domain or process tooensure that hello initializer settings for EF do not conflict.</span></span> 

## <a name="limitations"></a><span data-ttu-id="c450d-282">限制</span><span class="sxs-lookup"><span data-stu-id="c450d-282">Limitations</span></span>
<span data-ttu-id="c450d-283">這份文件中所述的 hello 方法需要有幾項限制：</span><span class="sxs-lookup"><span data-stu-id="c450d-283">hello approaches outlined in this document entail a couple of limitations:</span></span> 

* <span data-ttu-id="c450d-284">使用 EF 應用程式**LocalDb**使用彈性資料庫用戶端程式庫之前先 toomigrate tooa 一般 SQL Server 資料庫。</span><span class="sxs-lookup"><span data-stu-id="c450d-284">EF applications that use **LocalDb** first need toomigrate tooa regular SQL Server database before using elastic database client library.</span></span> <span data-ttu-id="c450d-285">使用 **LocalDb**時，無法透過分區化與 Elastic Scale 來相應放大應用程式。</span><span class="sxs-lookup"><span data-stu-id="c450d-285">Scaling out an application through sharding with Elastic Scale is not possible with **LocalDb**.</span></span> <span data-ttu-id="c450d-286">請注意，仍可使用 **LocalDb**來開發。</span><span class="sxs-lookup"><span data-stu-id="c450d-286">Note that development can still use **LocalDb**.</span></span> 
* <span data-ttu-id="c450d-287">表示資料庫結構描述變更的任何變更 toohello 應用程式需要透過在所有分區的 EF 移轉 toogo。</span><span class="sxs-lookup"><span data-stu-id="c450d-287">Any changes toohello application that imply database schema changes need toogo through EF migrations on all shards.</span></span> <span data-ttu-id="c450d-288">本文件的 hello 範例程式碼不會示範如何 toodo 這。</span><span class="sxs-lookup"><span data-stu-id="c450d-288">hello sample code for this document does not demonstrate how toodo this.</span></span> <span data-ttu-id="c450d-289">請考慮更新資料庫具有 ConnectionString 參數 tooiterate 透過所有分區。擷取 hello T-SQL 指令碼或暫止移轉使用 Update-database 搭配 hello hello-指令碼選項，並套用 hello T-SQL 指令碼 tooyour 分區。</span><span class="sxs-lookup"><span data-stu-id="c450d-289">Consider using Update-Database with a ConnectionString parameter tooiterate over all shards; or extract hello T-SQL script for hello pending migration using Update-Database with hello -Script option and apply hello T-SQL script tooyour shards.</span></span>  
* <span data-ttu-id="c450d-290">指定要求，則會假設其資料庫處理的所有包含在單一分區中的 hello hello 要求所提供的分區化索引鍵識別。</span><span class="sxs-lookup"><span data-stu-id="c450d-290">Given a request, it is assumed that all of its database processing is contained within a single shard as identified by hello sharding key provided by hello request.</span></span> <span data-ttu-id="c450d-291">不過，這項假設不一定永遠成立。</span><span class="sxs-lookup"><span data-stu-id="c450d-291">However, this assumption does not always hold true.</span></span> <span data-ttu-id="c450d-292">例如，當不可能 toomake 分區化索引鍵使用。</span><span class="sxs-lookup"><span data-stu-id="c450d-292">For example, when it is not possible toomake a sharding key available.</span></span> <span data-ttu-id="c450d-293">tooaddress hello，用戶端程式庫提供 hello **MultiShardQuery**類別會實作抽象的查詢數個分區的連線。</span><span class="sxs-lookup"><span data-stu-id="c450d-293">tooaddress this, hello client library provides hello **MultiShardQuery** class that implements a connection abstraction for querying over several shards.</span></span> <span data-ttu-id="c450d-294">學習 toouse hello **MultiShardQuery**搭配 EF 超出本文的 hello 範圍</span><span class="sxs-lookup"><span data-stu-id="c450d-294">Learning toouse hello **MultiShardQuery** in combination with EF is beyond hello scope of this document</span></span>

## <a name="conclusion"></a><span data-ttu-id="c450d-295">結論</span><span class="sxs-lookup"><span data-stu-id="c450d-295">Conclusion</span></span>
<span data-ttu-id="c450d-296">Hello 這份文件中所述的步驟，透過 EF 應用程式可以使用 hello 彈性資料庫用戶端程式庫的功能資料依存路由重構建構函式的 hello **DbContext** hello EF 中使用的子類別應用程式。</span><span class="sxs-lookup"><span data-stu-id="c450d-296">Through hello steps outlined in this document, EF applications can use hello elastic database client library's capability for data dependent routing by refactoring constructors of hello **DbContext** subclasses used in hello EF application.</span></span> <span data-ttu-id="c450d-297">此限制 hello 變更所需 toothose 位置**DbContext**類別已存在。</span><span class="sxs-lookup"><span data-stu-id="c450d-297">This limits hello  changes required toothose places where **DbContext** classes already exist.</span></span> <span data-ttu-id="c450d-298">此外，EF 應用程式可以繼續從自動結構描述部署 toobenefit 結合叫用 hello 必要 EF 移轉，而 hello 註冊新的分區和 hello 分區對應中的對應的 hello 步驟。</span><span class="sxs-lookup"><span data-stu-id="c450d-298">In addition, EF applications can continue toobenefit from automatic schema deployment by combining hello steps that invoke hello necessary EF migrations with hello registration of new shards and mappings in hello shard map.</span></span> 

[!INCLUDE [elastic-scale-include](../../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-use-entity-framework-applications-visual-studio/sample.png
