---
title: "管理 Microsoft Azure 儲存體中的並行存取"
description: "如何管理 Blob、佇列、資料表和檔案服務的並行存取"
services: storage
documentationcenter: 
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 8b894af2f15cd22f04701c545d8250e20b99a094
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/11/2017
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a><span data-ttu-id="2587f-103">管理 Microsoft Azure 儲存體中的並行存取</span><span class="sxs-lookup"><span data-stu-id="2587f-103">Managing Concurrency in Microsoft Azure Storage</span></span>
## <a name="overview"></a><span data-ttu-id="2587f-104">概觀</span><span class="sxs-lookup"><span data-stu-id="2587f-104">Overview</span></span>
<span data-ttu-id="2587f-105">現代以網際網路為基礎的應用程式通常會有多個使用者同時檢視及更新資料。</span><span class="sxs-lookup"><span data-stu-id="2587f-105">Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</span></span> <span data-ttu-id="2587f-106">這使得應用程式開發人員不得不認真思考如何為其使用者提供可預測的使用經驗，尤其是有多個使用者可更新相同資料的案例。</span><span class="sxs-lookup"><span data-stu-id="2587f-106">This requires application developers to think carefully about how to provide a predictable experience to their end users, particularly for scenarios where multiple users can update the same data.</span></span> <span data-ttu-id="2587f-107">開發人員通常會考量三個主要的資料並行存取策略：</span><span class="sxs-lookup"><span data-stu-id="2587f-107">There are three main data concurrency strategies developers will typically consider:</span></span>  

1. <span data-ttu-id="2587f-108">開放式並行存取 – 執行更新的應用程式將在其更新的過程中，驗證在應用程式上次讀取資料後，該資料是否有所變更。</span><span class="sxs-lookup"><span data-stu-id="2587f-108">Optimistic concurrency – An application performing an update will as part of its update verify if the data has changed since the application last read that data.</span></span> <span data-ttu-id="2587f-109">例如，如果兩個檢視 wiki 頁面的使用者對相同的頁面進行更新，則 wiki 平台必須確定第二個更新並未覆寫第一個更新，並確定兩個使用者都了解其更新是否成功。</span><span class="sxs-lookup"><span data-stu-id="2587f-109">For example, if two users viewing a wiki page make an update to the same page then the wiki platform must ensure that the second update does not overwrite the first update – and that both users understand whether their update was successful or not.</span></span> <span data-ttu-id="2587f-110">此策略最常用在 Web 應用程式中。</span><span class="sxs-lookup"><span data-stu-id="2587f-110">This strategy is most often used in web applications.</span></span>
2. <span data-ttu-id="2587f-111">封閉式並行存取 – 要執行更新的應用程式會鎖定物件以防止其他使用者更新資料，直到鎖定解除為止。</span><span class="sxs-lookup"><span data-stu-id="2587f-111">Pessimistic concurrency – An application looking to perform an update will take a lock on an object preventing other users from updating the data until the lock is released.</span></span> <span data-ttu-id="2587f-112">例如，在只有 master 會執行更新的主從式資料複寫案例中，master 通常會長時間保有資料的獨佔鎖定，以確保他人無法更新該資料。</span><span class="sxs-lookup"><span data-stu-id="2587f-112">For example, in a master/slave data replication scenario where only the master will perform updates the master will typically hold an exclusive lock for an extended period of time on the data to ensure no one else can update it.</span></span>
3. <span data-ttu-id="2587f-113">最後寫入為準 – 此方法會直接允許任何更新作業的執行，而不會先驗證在應用程式第一次讀取資料後，是否有任何其他應用程式更新過該資料。</span><span class="sxs-lookup"><span data-stu-id="2587f-113">Last writer wins – An approach that allows any update operations to proceed without verifying if any other application has updated the data since the application first read the data.</span></span> <span data-ttu-id="2587f-114">此策略 (或非正式策略) 通常用在因資料分割的方式而不可能有多個使用者存取相同資料的情況中。</span><span class="sxs-lookup"><span data-stu-id="2587f-114">This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access the same data.</span></span> <span data-ttu-id="2587f-115">在處理暫時性資料串流的情況中，也可以利用此策略。</span><span class="sxs-lookup"><span data-stu-id="2587f-115">It can also be useful where short-lived data streams are being processed.</span></span>  

<span data-ttu-id="2587f-116">本文將概略說明 Azure 儲存體平台如何為這三種並行存取策略提供絕佳支援，以簡化開發工作。</span><span class="sxs-lookup"><span data-stu-id="2587f-116">This article provides an overview of how the Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</span></span>  

## <a name="azure-storage--simplifies-cloud-development"></a><span data-ttu-id="2587f-117">Azure 儲存體 – 簡化雲端開發</span><span class="sxs-lookup"><span data-stu-id="2587f-117">Azure Storage – Simplifies Cloud Development</span></span>
<span data-ttu-id="2587f-118">Azure 儲存體服務對這三種策略都可支援，但此服務依其設計主要是要支援增強式一致性模型，以確保在儲存體服務認可資料插入或更新作業時，所有對該資料的進一步存取都可看見最新的更新，因此這項服務在為開放式和封閉式並行存取提供完整支援的能力上是有差別的。</span><span class="sxs-lookup"><span data-stu-id="2587f-118">The Azure storage service supports all three strategies, although it is distinctive in its ability to provide full support for optimistic and pessimistic concurrency because it was designed to embrace a strong consistency model which guarantees that when the Storage service commits a data insert or update operation all further accesses to that data will see the latest update.</span></span> <span data-ttu-id="2587f-119">使用最終一致性模型的儲存體平台在一個使用者執行寫入與其他使用者可看見更新資料的時間上會有延遲，因而會使用戶端應用程式的開發複雜化，以防止使用者受到不一致的影響。</span><span class="sxs-lookup"><span data-stu-id="2587f-119">Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when the updated data can be seen by other users thus complicating development of client applications in order to prevent inconsistencies from affecting end users.</span></span>  

<span data-ttu-id="2587f-120">除了選取適當的並行存取策略以外，開發人員也應注意儲存體平台隔離變更的方式，尤其是在不同交易間對相同物件的變更。</span><span class="sxs-lookup"><span data-stu-id="2587f-120">In addition to selecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes to the same object across transactions.</span></span> <span data-ttu-id="2587f-121">Azure 儲存體服務會使用快照隔離，讓讀取作業與寫入作業在單一資料分割內同時執行。</span><span class="sxs-lookup"><span data-stu-id="2587f-121">The Azure storage service uses snapshot isolation to allow read operations to happen concurrently with write operations within a single partition.</span></span> <span data-ttu-id="2587f-122">不同於其他隔離層級，快照隔離可確保所有讀取皆可看見資料的一致快照，即使在更新執行時亦然 – 基本上是藉由在更新交易進行處理時傳回最新的認可值。</span><span class="sxs-lookup"><span data-stu-id="2587f-122">Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of the data even while updates are occurring – essentially by returning the last committed values while an update transaction is being processed.</span></span>  

## <a name="managing-concurrency-in-blob-storage"></a><span data-ttu-id="2587f-123">管理 Blob 儲存體中的並行存取</span><span class="sxs-lookup"><span data-stu-id="2587f-123">Managing Concurrency in Blob storage</span></span>
<span data-ttu-id="2587f-124">您可以選擇使用開放式或封閉式並行存取模型，來管理對 Blob 服務中的 Blob 和容器的存取。</span><span class="sxs-lookup"><span data-stu-id="2587f-124">You can opt to use either optimistic or pessimistic concurrency models to manage access to blobs and containers in the blob service.</span></span> <span data-ttu-id="2587f-125">如果您未明確指定策略，依預設會採用「最後寫入為準」。</span><span class="sxs-lookup"><span data-stu-id="2587f-125">If you do not explicitly specify a strategy last writes wins is the default.</span></span>  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a><span data-ttu-id="2587f-126">Blob 和容器的開放式並行存取</span><span class="sxs-lookup"><span data-stu-id="2587f-126">Optimistic concurrency for blobs and containers</span></span>
<span data-ttu-id="2587f-127">儲存體服務會為每個儲存的物件指派識別碼。</span><span class="sxs-lookup"><span data-stu-id="2587f-127">The Storage service assigns an identifier to every object stored.</span></span> <span data-ttu-id="2587f-128">此識別碼會在每次對物件執行更新作業時更新。</span><span class="sxs-lookup"><span data-stu-id="2587f-128">This identifier is updated every time an update operation is performed on an object.</span></span> <span data-ttu-id="2587f-129">此識別碼會使用在 HTTP 通訊協定內定義的 ETag (實體標記) 標頭，隨附在 HTTP GET 回應中傳回至用戶端。</span><span class="sxs-lookup"><span data-stu-id="2587f-129">The identifier is returned to the client as part of an HTTP GET response using the ETag (entity tag) header that is defined within the HTTP protocol.</span></span> <span data-ttu-id="2587f-130">對此類物件執行更新的使用者可將原始 ETag 連同條件式標頭一併傳入，以確保只有在符合特定條件時才會執行更新。在此案例中，條件是 "If-Match" 標頭，它會要求儲存體服務必須確定在更新要求中指定的 ETag 值，與儲存體服務中儲存的值是相同的。</span><span class="sxs-lookup"><span data-stu-id="2587f-130">A user performing an update on such an object can send in the original ETag along with a conditional header to ensure that an update will only occur if a certain condition has been met – in this case the condition is an "If-Match" header which requires the Storage Service to ensure the value of the ETag specified in the update request is the same as that stored in the Storage Service.</span></span>  

<span data-ttu-id="2587f-131">此程序大致如下：</span><span class="sxs-lookup"><span data-stu-id="2587f-131">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="2587f-132">從儲存體服務中擷取 Blob，回應中會包含 HTTP ETag 標頭值，用來識別儲存體服務中目前的物件版本。</span><span class="sxs-lookup"><span data-stu-id="2587f-132">Retrieve a blob from the storage service, the response includes an HTTP ETag Header value that identifies the current version of the object in the storage service.</span></span>
2. <span data-ttu-id="2587f-133">當您更新 Blob 時，請將您在步驟 1 中接收到的 ETag 值納入您傳送至服務之要求的 **If-Match** 條件式標頭中。</span><span class="sxs-lookup"><span data-stu-id="2587f-133">When you update the blob, include the ETag value you received in step 1 in the **If-Match** conditional header of the request you send to the service.</span></span>
3. <span data-ttu-id="2587f-134">服務會比較要求中的 ETag 值與 Blob 目前的 ETag 值。</span><span class="sxs-lookup"><span data-stu-id="2587f-134">The service compares the ETag value in the request with the current ETag value of the blob.</span></span>
4. <span data-ttu-id="2587f-135">如果 Blob 目前的 ETag 值與要求中的 **If-Match** 條件式標頭內的 ETag 不是相同版本，服務會將 412 錯誤傳回至用戶端。</span><span class="sxs-lookup"><span data-stu-id="2587f-135">If the current ETag value of the blob is a different version than the ETag in the **If-Match** conditional header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="2587f-136">這會向用戶端指出在用戶端擷取 Blob 後，有另一個程序更新過該 Blob。</span><span class="sxs-lookup"><span data-stu-id="2587f-136">This indicates to the client that another process has updated the blob since the client retrieved it.</span></span>
5. <span data-ttu-id="2587f-137">如果 Blob 目前的 ETag 值與要求中的 **If-Match** 條件式標頭內的 ETag 是相同版本，服務將會執行要求的作業，並更新 Blob 目前的 ETag 值，以顯示它已建立新版本。</span><span class="sxs-lookup"><span data-stu-id="2587f-137">If the current ETag value of the blob is the same version as the ETag in the **If-Match** conditional header in the request, the service performs the requested operation and updates the current ETag value of the blob to show that it has created a new version.</span></span>  

<span data-ttu-id="2587f-138">下列 C# 程式碼片段 (使用用戶端儲存體程式庫 4.2.0) 所顯示的簡易範例，說明如何根據從先前擷取或插入之 Blob 的屬性中存取的 ETag 值，來建構 **If-Match AccessCondition** 。</span><span class="sxs-lookup"><span data-stu-id="2587f-138">The following C# snippet (using the Client Storage Library 4.2.0) shows a simple example of how to construct an **If-Match AccessCondition** based on the ETag value that is accessed from the properties of a blob that was previously either retrieved or inserted.</span></span> <span data-ttu-id="2587f-139">接著它會在更新 blob 時使用 **AccessCondition** 物件：**AccessCondition** 物件會將 **If-Match** 標頭新增至要求。</span><span class="sxs-lookup"><span data-stu-id="2587f-139">It then uses the **AccessCondition** object when it updating the blob: the **AccessCondition** object adds the **If-Match** header to the request.</span></span> <span data-ttu-id="2587f-140">如果有其他程序更新了 Blob，Blob 服務將會傳回 HTTP 412 (預先指定的條件失敗) 狀態訊息。</span><span class="sxs-lookup"><span data-stu-id="2587f-140">If another process has updated the blob, the blob service returns an HTTP 412 (Precondition Failed) status message.</span></span> <span data-ttu-id="2587f-141">此處可下載完整的範例： [使用 Azure 儲存體管理並行存取](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)。</span><span class="sxs-lookup"><span data-stu-id="2587f-141">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>  

```csharp
// Retrieve the ETag from the newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// to storage blob service which returns the etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try to update the blob using the orignal ETag provided when the blob was created
try
{
    Console.WriteLine("Trying to update blob using orignal etag to generate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants to handle the 3rd party updated content.
    }
    else
        throw;
}  
```

<span data-ttu-id="2587f-142">儲存體服務也包含對其他條件式標頭的支援，例如 **If-Modified-Since**、**If-Unmodified-Since** 和 **If-None-Match** 及其組合。</span><span class="sxs-lookup"><span data-stu-id="2587f-142">The Storage Service also includes support for additional conditional headers such as **If-Modified-Since**, **If-Unmodified-Since** and **If-None-Match** as well as combinations thereof.</span></span> <span data-ttu-id="2587f-143">如需詳細資訊，請參閱 MSDN 上的 [為 Blob 服務作業指定條件式標頭](http://msdn.microsoft.com/library/azure/dd179371.aspx) 。</span><span class="sxs-lookup"><span data-stu-id="2587f-143">For more information see [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) on MSDN.</span></span>  

<span data-ttu-id="2587f-144">下表彙總了在要求中接受條件式標頭 (例如 **If-Match** ) 以及在回應中傳回 ETag 值的容器作業。</span><span class="sxs-lookup"><span data-stu-id="2587f-144">The following table summarizes the container operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>  

| <span data-ttu-id="2587f-145">作業</span><span class="sxs-lookup"><span data-stu-id="2587f-145">Operation</span></span> | <span data-ttu-id="2587f-146">傳回容器 ETag 值</span><span class="sxs-lookup"><span data-stu-id="2587f-146">Returns Container ETag value</span></span> | <span data-ttu-id="2587f-147">接受條件式標頭</span><span class="sxs-lookup"><span data-stu-id="2587f-147">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="2587f-148">建立容器</span><span class="sxs-lookup"><span data-stu-id="2587f-148">Create Container</span></span> |<span data-ttu-id="2587f-149">是</span><span class="sxs-lookup"><span data-stu-id="2587f-149">Yes</span></span> |<span data-ttu-id="2587f-150">否</span><span class="sxs-lookup"><span data-stu-id="2587f-150">No</span></span> |
| <span data-ttu-id="2587f-151">取得容器屬性</span><span class="sxs-lookup"><span data-stu-id="2587f-151">Get Container Properties</span></span> |<span data-ttu-id="2587f-152">是</span><span class="sxs-lookup"><span data-stu-id="2587f-152">Yes</span></span> |<span data-ttu-id="2587f-153">否</span><span class="sxs-lookup"><span data-stu-id="2587f-153">No</span></span> |
| <span data-ttu-id="2587f-154">取得容器中繼資料</span><span class="sxs-lookup"><span data-stu-id="2587f-154">Get Container Metadata</span></span> |<span data-ttu-id="2587f-155">是</span><span class="sxs-lookup"><span data-stu-id="2587f-155">Yes</span></span> |<span data-ttu-id="2587f-156">否</span><span class="sxs-lookup"><span data-stu-id="2587f-156">No</span></span> |
| <span data-ttu-id="2587f-157">設定容器中繼資料</span><span class="sxs-lookup"><span data-stu-id="2587f-157">Set Container Metadata</span></span> |<span data-ttu-id="2587f-158">是</span><span class="sxs-lookup"><span data-stu-id="2587f-158">Yes</span></span> |<span data-ttu-id="2587f-159">是</span><span class="sxs-lookup"><span data-stu-id="2587f-159">Yes</span></span> |
| <span data-ttu-id="2587f-160">取得容器 ACL</span><span class="sxs-lookup"><span data-stu-id="2587f-160">Get Container ACL</span></span> |<span data-ttu-id="2587f-161">是</span><span class="sxs-lookup"><span data-stu-id="2587f-161">Yes</span></span> |<span data-ttu-id="2587f-162">否</span><span class="sxs-lookup"><span data-stu-id="2587f-162">No</span></span> |
| <span data-ttu-id="2587f-163">設定容器 ACL</span><span class="sxs-lookup"><span data-stu-id="2587f-163">Set Container ACL</span></span> |<span data-ttu-id="2587f-164">是</span><span class="sxs-lookup"><span data-stu-id="2587f-164">Yes</span></span> |<span data-ttu-id="2587f-165">是 (*)</span><span class="sxs-lookup"><span data-stu-id="2587f-165">Yes (*)</span></span> |
| <span data-ttu-id="2587f-166">刪除容器</span><span class="sxs-lookup"><span data-stu-id="2587f-166">Delete Container</span></span> |<span data-ttu-id="2587f-167">否</span><span class="sxs-lookup"><span data-stu-id="2587f-167">No</span></span> |<span data-ttu-id="2587f-168">是</span><span class="sxs-lookup"><span data-stu-id="2587f-168">Yes</span></span> |
| <span data-ttu-id="2587f-169">租用容器</span><span class="sxs-lookup"><span data-stu-id="2587f-169">Lease Container</span></span> |<span data-ttu-id="2587f-170">是</span><span class="sxs-lookup"><span data-stu-id="2587f-170">Yes</span></span> |<span data-ttu-id="2587f-171">是</span><span class="sxs-lookup"><span data-stu-id="2587f-171">Yes</span></span> |
| <span data-ttu-id="2587f-172">列出 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-172">List Blobs</span></span> |<span data-ttu-id="2587f-173">否</span><span class="sxs-lookup"><span data-stu-id="2587f-173">No</span></span> |<span data-ttu-id="2587f-174">否</span><span class="sxs-lookup"><span data-stu-id="2587f-174">No</span></span> |

<span data-ttu-id="2587f-175">(*) 系統會快取由 SetContainerACL 定義的權限，而這些權限的更新約需 30 秒來完成填入，在此期間，更新並不一定會一致。</span><span class="sxs-lookup"><span data-stu-id="2587f-175">(*) The permissions defined by SetContainerACL are cached and updates to these permissions take 30 seconds to propagate during which period updates are not guaranteed to be consistent.</span></span>  

<span data-ttu-id="2587f-176">下表彙總了在要求中接受條件式標頭 (例如 **If-Match** ) 以及在回應中傳回 ETag 值的 Blob 作業。</span><span class="sxs-lookup"><span data-stu-id="2587f-176">The following table summarizes the blob operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>

| <span data-ttu-id="2587f-177">作業</span><span class="sxs-lookup"><span data-stu-id="2587f-177">Operation</span></span> | <span data-ttu-id="2587f-178">傳回 ETag 值</span><span class="sxs-lookup"><span data-stu-id="2587f-178">Returns ETag value</span></span> | <span data-ttu-id="2587f-179">接受條件式標頭</span><span class="sxs-lookup"><span data-stu-id="2587f-179">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="2587f-180">放置 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-180">Put Blob</span></span> |<span data-ttu-id="2587f-181">是</span><span class="sxs-lookup"><span data-stu-id="2587f-181">Yes</span></span> |<span data-ttu-id="2587f-182">是</span><span class="sxs-lookup"><span data-stu-id="2587f-182">Yes</span></span> |
| <span data-ttu-id="2587f-183">取得 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-183">Get Blob</span></span> |<span data-ttu-id="2587f-184">是</span><span class="sxs-lookup"><span data-stu-id="2587f-184">Yes</span></span> |<span data-ttu-id="2587f-185">是</span><span class="sxs-lookup"><span data-stu-id="2587f-185">Yes</span></span> |
| <span data-ttu-id="2587f-186">取得 Blob 屬性</span><span class="sxs-lookup"><span data-stu-id="2587f-186">Get Blob Properties</span></span> |<span data-ttu-id="2587f-187">是</span><span class="sxs-lookup"><span data-stu-id="2587f-187">Yes</span></span> |<span data-ttu-id="2587f-188">是</span><span class="sxs-lookup"><span data-stu-id="2587f-188">Yes</span></span> |
| <span data-ttu-id="2587f-189">設定 Blob 屬性</span><span class="sxs-lookup"><span data-stu-id="2587f-189">Set Blob Properties</span></span> |<span data-ttu-id="2587f-190">是</span><span class="sxs-lookup"><span data-stu-id="2587f-190">Yes</span></span> |<span data-ttu-id="2587f-191">是</span><span class="sxs-lookup"><span data-stu-id="2587f-191">Yes</span></span> |
| <span data-ttu-id="2587f-192">取得 Blob 中繼資料</span><span class="sxs-lookup"><span data-stu-id="2587f-192">Get Blob Metadata</span></span> |<span data-ttu-id="2587f-193">是</span><span class="sxs-lookup"><span data-stu-id="2587f-193">Yes</span></span> |<span data-ttu-id="2587f-194">是</span><span class="sxs-lookup"><span data-stu-id="2587f-194">Yes</span></span> |
| <span data-ttu-id="2587f-195">設定 Blob 中繼資料</span><span class="sxs-lookup"><span data-stu-id="2587f-195">Set Blob Metadata</span></span> |<span data-ttu-id="2587f-196">是</span><span class="sxs-lookup"><span data-stu-id="2587f-196">Yes</span></span> |<span data-ttu-id="2587f-197">是</span><span class="sxs-lookup"><span data-stu-id="2587f-197">Yes</span></span> |
| <span data-ttu-id="2587f-198">租用 Blob (*)</span><span class="sxs-lookup"><span data-stu-id="2587f-198">Lease Blob (*)</span></span> |<span data-ttu-id="2587f-199">是</span><span class="sxs-lookup"><span data-stu-id="2587f-199">Yes</span></span> |<span data-ttu-id="2587f-200">是</span><span class="sxs-lookup"><span data-stu-id="2587f-200">Yes</span></span> |
| <span data-ttu-id="2587f-201">快照 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-201">Snapshot Blob</span></span> |<span data-ttu-id="2587f-202">是</span><span class="sxs-lookup"><span data-stu-id="2587f-202">Yes</span></span> |<span data-ttu-id="2587f-203">是</span><span class="sxs-lookup"><span data-stu-id="2587f-203">Yes</span></span> |
| <span data-ttu-id="2587f-204">複製 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-204">Copy Blob</span></span> |<span data-ttu-id="2587f-205">是</span><span class="sxs-lookup"><span data-stu-id="2587f-205">Yes</span></span> |<span data-ttu-id="2587f-206">是 (針對來源及目的地 Blob)</span><span class="sxs-lookup"><span data-stu-id="2587f-206">Yes (for source and destination blob)</span></span> |
| <span data-ttu-id="2587f-207">中止複製 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-207">Abort Copy Blob</span></span> |<span data-ttu-id="2587f-208">否</span><span class="sxs-lookup"><span data-stu-id="2587f-208">No</span></span> |<span data-ttu-id="2587f-209">否</span><span class="sxs-lookup"><span data-stu-id="2587f-209">No</span></span> |
| <span data-ttu-id="2587f-210">刪除 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-210">Delete Blob</span></span> |<span data-ttu-id="2587f-211">否</span><span class="sxs-lookup"><span data-stu-id="2587f-211">No</span></span> |<span data-ttu-id="2587f-212">是</span><span class="sxs-lookup"><span data-stu-id="2587f-212">Yes</span></span> |
| <span data-ttu-id="2587f-213">放置區塊</span><span class="sxs-lookup"><span data-stu-id="2587f-213">Put Block</span></span> |<span data-ttu-id="2587f-214">否</span><span class="sxs-lookup"><span data-stu-id="2587f-214">No</span></span> |<span data-ttu-id="2587f-215">否</span><span class="sxs-lookup"><span data-stu-id="2587f-215">No</span></span> |
| <span data-ttu-id="2587f-216">放置區塊清單</span><span class="sxs-lookup"><span data-stu-id="2587f-216">Put Block List</span></span> |<span data-ttu-id="2587f-217">是</span><span class="sxs-lookup"><span data-stu-id="2587f-217">Yes</span></span> |<span data-ttu-id="2587f-218">是</span><span class="sxs-lookup"><span data-stu-id="2587f-218">Yes</span></span> |
| <span data-ttu-id="2587f-219">取得區塊清單</span><span class="sxs-lookup"><span data-stu-id="2587f-219">Get Block List</span></span> |<span data-ttu-id="2587f-220">是</span><span class="sxs-lookup"><span data-stu-id="2587f-220">Yes</span></span> |<span data-ttu-id="2587f-221">否</span><span class="sxs-lookup"><span data-stu-id="2587f-221">No</span></span> |
| <span data-ttu-id="2587f-222">放置頁面</span><span class="sxs-lookup"><span data-stu-id="2587f-222">Put Page</span></span> |<span data-ttu-id="2587f-223">是</span><span class="sxs-lookup"><span data-stu-id="2587f-223">Yes</span></span> |<span data-ttu-id="2587f-224">是</span><span class="sxs-lookup"><span data-stu-id="2587f-224">Yes</span></span> |
| <span data-ttu-id="2587f-225">取得頁面範圍</span><span class="sxs-lookup"><span data-stu-id="2587f-225">Get Page Ranges</span></span> |<span data-ttu-id="2587f-226">是</span><span class="sxs-lookup"><span data-stu-id="2587f-226">Yes</span></span> |<span data-ttu-id="2587f-227">是</span><span class="sxs-lookup"><span data-stu-id="2587f-227">Yes</span></span> |

<span data-ttu-id="2587f-228">(*) 租用 Blob 並不會變更 Blob 上的 ETag。</span><span class="sxs-lookup"><span data-stu-id="2587f-228">(*) Lease Blob does not change the ETag on a blob.</span></span>  

### <a name="pessimistic-concurrency-for-blobs"></a><span data-ttu-id="2587f-229">Blob 的封閉式並行存取</span><span class="sxs-lookup"><span data-stu-id="2587f-229">Pessimistic concurrency for blobs</span></span>
<span data-ttu-id="2587f-230">若要鎖定 Blob 以進行獨佔使用，您可以取得其 [租用](http://msdn.microsoft.com/library/azure/ee691972.aspx) 。</span><span class="sxs-lookup"><span data-stu-id="2587f-230">To lock a blob for exclusive use, you can acquire a [lease](http://msdn.microsoft.com/library/azure/ee691972.aspx) on it.</span></span> <span data-ttu-id="2587f-231">您取得租用時，可指定需要租用的時間長度：這可以是 15 至 60 秒，也可以是無限期 (等於獨佔鎖定)。</span><span class="sxs-lookup"><span data-stu-id="2587f-231">When you acquire a lease, you specify for how long you need the lease: this can be for between 15 to 60 seconds or infinite which amounts to an exclusive lock.</span></span> <span data-ttu-id="2587f-232">您可以更新有限租用而加以延伸，而且您可以在用完任何租用後加以釋放。</span><span class="sxs-lookup"><span data-stu-id="2587f-232">You can renew a finite lease to extend it, and you can release any lease when you are finished with it.</span></span> <span data-ttu-id="2587f-233">Blob 服務會在有限租用到期時自動加以釋放。</span><span class="sxs-lookup"><span data-stu-id="2587f-233">The blob service automatically releases finite leases when they expire.</span></span>  

<span data-ttu-id="2587f-234">租用可讓不同的同步處理策略獲得支援，包括獨佔寫入/共用讀取、獨佔寫入/獨佔讀取和共用寫入/獨佔讀取。</span><span class="sxs-lookup"><span data-stu-id="2587f-234">Leases enable different synchronization strategies to be supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</span></span> <span data-ttu-id="2587f-235">只要有租用存在，儲存體服務就會強制執行獨佔寫入 (放置、設定和刪除作業)，但要確保讀取作業的獨佔性，開發人員必須確定所有的用戶端應用程式都使用同一個租用識別碼，並確定同一時間只有一個用戶端具有有效的租用識別碼。</span><span class="sxs-lookup"><span data-stu-id="2587f-235">Where a lease exists the storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires the developer to ensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</span></span> <span data-ttu-id="2587f-236">未包含租用識別碼的讀取作業將會導致共用讀取。</span><span class="sxs-lookup"><span data-stu-id="2587f-236">Read operations that do not include a lease ID result in shared reads.</span></span>  

<span data-ttu-id="2587f-237">下列 C# 程式碼片段說明對某個 Blob 取得獨佔租用 30 秒、更新該 Blob 的內容，然後釋放租用的範例。</span><span class="sxs-lookup"><span data-stu-id="2587f-237">The following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating the content of the blob, and then releasing the lease.</span></span> <span data-ttu-id="2587f-238">當您嘗試取得新租用時，若 Blob 上已存在有效租用，則 Blob 服務會傳回「HTTP (409) 衝突」狀態結果。</span><span class="sxs-lookup"><span data-stu-id="2587f-238">If there is already a valid lease on the blob when you try to acquire a new lease, the blob service returns an "HTTP (409) Conflict" status result.</span></span> <span data-ttu-id="2587f-239">下列程式碼片段在要求更新儲存體服務中的 Blob 時，使用 **AccessCondition** 物件封裝租用資訊。</span><span class="sxs-lookup"><span data-stu-id="2587f-239">The snippet below uses an **AccessCondition** object to encapsulate the lease information when it makes a request to update the blob in the storage service.</span></span>  <span data-ttu-id="2587f-240">此處可下載完整的範例： [使用 Azure 儲存體管理並行存取](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)。</span><span class="sxs-lookup"><span data-stu-id="2587f-240">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update to blob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying to update blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

<span data-ttu-id="2587f-241">如果您直接嘗試對已租用的 Blob 執行寫入作業，而未傳送租用識別碼，要求將會失敗，並出現 412 錯誤。</span><span class="sxs-lookup"><span data-stu-id="2587f-241">If you attempt a write operation on a leased blob without passing the lease ID, the request fails with a 412 error.</span></span> <span data-ttu-id="2587f-242">請注意，如果在呼叫 **UploadText** 方法之前租用已過期，但您仍傳送租用識別碼，要求也會失敗，並出現 **412** 錯誤。</span><span class="sxs-lookup"><span data-stu-id="2587f-242">Note that if the lease expires before calling the **UploadText** method but you still pass the lease ID, the request also fails with a **412** error.</span></span> <span data-ttu-id="2587f-243">如需管理租用到期時間和租用識別碼的詳細資訊，請參閱 [租用 Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST 文件。</span><span class="sxs-lookup"><span data-stu-id="2587f-243">For more information about managing lease expiry times and lease ids, see the [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST documentation.</span></span>  

<span data-ttu-id="2587f-244">下列 Blob 作業可使用租用來管理封閉式並行存取：</span><span class="sxs-lookup"><span data-stu-id="2587f-244">The following blob operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="2587f-245">放置 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-245">Put Blob</span></span>
* <span data-ttu-id="2587f-246">取得 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-246">Get Blob</span></span>
* <span data-ttu-id="2587f-247">取得 Blob 屬性</span><span class="sxs-lookup"><span data-stu-id="2587f-247">Get Blob Properties</span></span>
* <span data-ttu-id="2587f-248">設定 Blob 屬性</span><span class="sxs-lookup"><span data-stu-id="2587f-248">Set Blob Properties</span></span>
* <span data-ttu-id="2587f-249">取得 Blob 中繼資料</span><span class="sxs-lookup"><span data-stu-id="2587f-249">Get Blob Metadata</span></span>
* <span data-ttu-id="2587f-250">設定 Blob 中繼資料</span><span class="sxs-lookup"><span data-stu-id="2587f-250">Set Blob Metadata</span></span>
* <span data-ttu-id="2587f-251">刪除 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-251">Delete Blob</span></span>
* <span data-ttu-id="2587f-252">放置區塊</span><span class="sxs-lookup"><span data-stu-id="2587f-252">Put Block</span></span>
* <span data-ttu-id="2587f-253">放置區塊清單</span><span class="sxs-lookup"><span data-stu-id="2587f-253">Put Block List</span></span>
* <span data-ttu-id="2587f-254">取得區塊清單</span><span class="sxs-lookup"><span data-stu-id="2587f-254">Get Block List</span></span>
* <span data-ttu-id="2587f-255">放置頁面</span><span class="sxs-lookup"><span data-stu-id="2587f-255">Put Page</span></span>
* <span data-ttu-id="2587f-256">取得頁面範圍</span><span class="sxs-lookup"><span data-stu-id="2587f-256">Get Page Ranges</span></span>
* <span data-ttu-id="2587f-257">快照 Blob - 若有租用存在，租用識別碼則是選用的</span><span class="sxs-lookup"><span data-stu-id="2587f-257">Snapshot Blob - lease ID optional if a lease exists</span></span>
* <span data-ttu-id="2587f-258">複製 Blob - 若有租用存在於目的地 Blob 上，則必須要有租用識別碼</span><span class="sxs-lookup"><span data-stu-id="2587f-258">Copy Blob - lease ID required if a lease exists on the destination blob</span></span>
* <span data-ttu-id="2587f-259">中止複製 Blob - 若有無限制租用存在於目的地 Blob 上，則必須要有租用識別碼</span><span class="sxs-lookup"><span data-stu-id="2587f-259">Abort Copy Blob - lease ID required if an infinite lease exists on the destination blob</span></span>
* <span data-ttu-id="2587f-260">租用 Blob</span><span class="sxs-lookup"><span data-stu-id="2587f-260">Lease Blob</span></span>  

### <a name="pessimistic-concurrency-for-containers"></a><span data-ttu-id="2587f-261">容器的封閉式並行存取</span><span class="sxs-lookup"><span data-stu-id="2587f-261">Pessimistic concurrency for containers</span></span>
<span data-ttu-id="2587f-262">容器的租用可讓與 Blob 相同的同步處理策略獲得支援 (獨佔寫入/共用讀取、獨佔寫入/獨佔讀取和共用寫入/獨佔讀取)，但不同於 Blob，儲存體服務只會對刪除作業強制執行獨佔性。</span><span class="sxs-lookup"><span data-stu-id="2587f-262">Leases on containers enable the same synchronization strategies to be supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs the storage service only enforces exclusivity on delete operations.</span></span> <span data-ttu-id="2587f-263">若要刪除具有作用中租用的容器，用戶端必須使用刪除要求納入作用中的租用識別碼。</span><span class="sxs-lookup"><span data-stu-id="2587f-263">To delete a container with an active lease, a client must include the active lease ID with the delete request.</span></span> <span data-ttu-id="2587f-264">其他所有的容器作業皆可在已租用的容器上成功執行，而無須納入租用識別碼；在此情況下，這些作業屬於共用作業。</span><span class="sxs-lookup"><span data-stu-id="2587f-264">All other container operations succeed on a leased container without including the lease ID in which case they are shared operations.</span></span> <span data-ttu-id="2587f-265">如果更新 (放置或設定) 或讀取作業需要獨佔性，則開發人員應確定所有的用戶端都使用同一個租用識別碼，並確定同一時間只有一個用戶端具有有效的租用識別碼。</span><span class="sxs-lookup"><span data-stu-id="2587f-265">If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</span></span>  

<span data-ttu-id="2587f-266">下列容器作業可使用租用來管理封閉式並行存取：</span><span class="sxs-lookup"><span data-stu-id="2587f-266">The following container operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="2587f-267">刪除容器</span><span class="sxs-lookup"><span data-stu-id="2587f-267">Delete Container</span></span>
* <span data-ttu-id="2587f-268">取得容器屬性</span><span class="sxs-lookup"><span data-stu-id="2587f-268">Get Container Properties</span></span>
* <span data-ttu-id="2587f-269">取得容器中繼資料</span><span class="sxs-lookup"><span data-stu-id="2587f-269">Get Container Metadata</span></span>
* <span data-ttu-id="2587f-270">設定容器中繼資料</span><span class="sxs-lookup"><span data-stu-id="2587f-270">Set Container Metadata</span></span>
* <span data-ttu-id="2587f-271">取得容器 ACL</span><span class="sxs-lookup"><span data-stu-id="2587f-271">Get Container ACL</span></span>
* <span data-ttu-id="2587f-272">設定容器 ACL</span><span class="sxs-lookup"><span data-stu-id="2587f-272">Set Container ACL</span></span>
* <span data-ttu-id="2587f-273">租用容器</span><span class="sxs-lookup"><span data-stu-id="2587f-273">Lease Container</span></span>  

<span data-ttu-id="2587f-274">如需詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="2587f-274">For more information see:</span></span>  

* [<span data-ttu-id="2587f-275">指定 Blob 服務作業的條件式標頭</span><span class="sxs-lookup"><span data-stu-id="2587f-275">Specifying Conditional Headers for Blob Service Operations</span></span>](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [<span data-ttu-id="2587f-276">租用容器</span><span class="sxs-lookup"><span data-stu-id="2587f-276">Lease Container</span></span>](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [<span data-ttu-id="2587f-277">租用 Blob </span><span class="sxs-lookup"><span data-stu-id="2587f-277">Lease Blob </span></span>](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-the-table-service"></a><span data-ttu-id="2587f-278">管理資料表服務中的並行存取</span><span class="sxs-lookup"><span data-stu-id="2587f-278">Managing Concurrency in the Table Service</span></span>
<span data-ttu-id="2587f-279">當您使用實體時，資料表服務會使用開放式並行存取檢查作為預設行為，這一點不同於必須明確選擇執行開放式並行存取檢查的 Blob 服務。</span><span class="sxs-lookup"><span data-stu-id="2587f-279">The table service uses optimistic concurrency checks as the default behavior when you are working with entities, unlike the blob service where you must explicitly choose to perform optimistic concurrency checks.</span></span> <span data-ttu-id="2587f-280">資料表服務與 Blob 服務的另一個差異是您只能管理實體的並行存取行為，而在使用 Blob 服務時，您可以同時管理容器和 Blob 的並行存取。</span><span class="sxs-lookup"><span data-stu-id="2587f-280">The other difference between the table and blob services is that you can only manage the concurrency behavior of entities whereas with the blob service you can manage the concurrency of both containers and blobs.</span></span>  

<span data-ttu-id="2587f-281">若要使用開放式並行存取，並檢查在您從資料表儲存體服務中擷取實體後是否有其他程序修改了該實體，您可以使用您在資料表服務傳回實體時所接收的 ETag 值。</span><span class="sxs-lookup"><span data-stu-id="2587f-281">To use optimistic concurrency and to check if another process modified an entity since you retrieved it from the table storage service, you can use the ETag value you receive when the table service returns an entity.</span></span> <span data-ttu-id="2587f-282">此程序大致如下：</span><span class="sxs-lookup"><span data-stu-id="2587f-282">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="2587f-283">從資料表儲存體服務中擷取實體，回應中會包含 ETag 值，用來識別與儲存體服務中的該實體相關聯的現行識別碼。</span><span class="sxs-lookup"><span data-stu-id="2587f-283">Retrieve an entity from the table storage service, the response includes an ETag value that identifies the current identifier associated with that entity in the storage service.</span></span>
2. <span data-ttu-id="2587f-284">當您更新實體時，請將您在步驟 1 中接收到的 ETag 值納入您傳送至服務之要求的必要 **If-Match** 標頭中。</span><span class="sxs-lookup"><span data-stu-id="2587f-284">When you update the entity, include the ETag value you received in step 1 in the mandatory **If-Match** header of the request you send to the service.</span></span>
3. <span data-ttu-id="2587f-285">服務會比較要求中的 ETag 值與實體目前的 ETag 值。</span><span class="sxs-lookup"><span data-stu-id="2587f-285">The service compares the ETag value in the request with the current ETag value of the entity.</span></span>
4. <span data-ttu-id="2587f-286">如果實體目前的 ETag 值與要求中的必要 **If-Match** 標頭內的 ETag 不同，服務會將 412 錯誤傳回至用戶端。</span><span class="sxs-lookup"><span data-stu-id="2587f-286">If the current ETag value of the entity is different than the ETag in the mandatory **If-Match** header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="2587f-287">這會向用戶端指出在用戶端擷取實體後，有另一個程序更新過該實體。</span><span class="sxs-lookup"><span data-stu-id="2587f-287">This indicates to the client that another process has updated the entity since the client retrieved it.</span></span>
5. <span data-ttu-id="2587f-288">如果實體目前的 ETag 值與要求中的必要 **If-Match** 標頭內的 ETag 相同，或是 **If-Match** 標頭包含萬用字元 (*)，服務將會執行要求的作業，並更新實體目前的 ETag 值，以顯示它已更新。</span><span class="sxs-lookup"><span data-stu-id="2587f-288">If the current ETag value of the entity is the same as the ETag in the mandatory **If-Match** header in the request or the **If-Match** header contains the wildcard character (*), the service performs the requested operation and updates the current ETag value of the entity to show that it has been updated.</span></span>  

<span data-ttu-id="2587f-289">請注意，不同於 Blob 服務，在使用資料表服務時，用戶端必須在更新要求中納入 **If-Match** 標頭。</span><span class="sxs-lookup"><span data-stu-id="2587f-289">Note that unlike the blob service, the table service requires the client to include an **If-Match** header in update requests.</span></span> <span data-ttu-id="2587f-290">但如果用戶端將要求中的 **If-Match** 標頭設為萬用字元 (*)，則有可能強制執行非條件式更新 (「最後寫入為準」策略)，並略過並行存取檢查。</span><span class="sxs-lookup"><span data-stu-id="2587f-290">However, it is possible to force an unconditional update (last writer wins strategy) and bypass concurrency checks if the client sets the **If-Match** header to the wildcard character (*) in the request.</span></span>  

<span data-ttu-id="2587f-291">下列 C# 程式碼片段說明先前建立或擷取的客戶實體更新了其電子郵件地址。</span><span class="sxs-lookup"><span data-stu-id="2587f-291">The following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</span></span> <span data-ttu-id="2587f-292">初始插入或擷取作業將 ETag 值儲存在客戶物件中，且因為範例在執行取代作業時使用了相同的物件執行個體，因此自動將 ETag 值傳回至資料表服務，使服務能夠檢查是否有並行存取違規。</span><span class="sxs-lookup"><span data-stu-id="2587f-292">The initial insert or retrieve operation stores the ETag value in the customer object, and because the sample uses the same object instance when it executes the replace operation, it automatically sends the ETag value back to the table service, enabling the service to check for concurrency violations.</span></span> <span data-ttu-id="2587f-293">如果有其他程序更新了資料表儲存體中的實體，服務將會傳回 HTTP 412 (預先指定的條件失敗) 狀態訊息。</span><span class="sxs-lookup"><span data-stu-id="2587f-293">If another process has updated the entity in table storage, the service returns an HTTP 412 (Precondition Failed) status message.</span></span>  <span data-ttu-id="2587f-294">此處可下載完整的範例： [使用 Azure 儲存體管理並行存取](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)。</span><span class="sxs-lookup"><span data-stu-id="2587f-294">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

<span data-ttu-id="2587f-295">若要明確停用並行存取檢查，您應在執行取代作業之前，將 **employee** 物件的 **ETag** 屬性設為 "*"。</span><span class="sxs-lookup"><span data-stu-id="2587f-295">To explicitly disable the concurrency check, you should set the **ETag** property of the **employee** object to "*" before you execute the replace operation.</span></span>  

```csharp
customer.ETag = "*";  
```

<span data-ttu-id="2587f-296">下表彙總了資料表實體作業使用 ETag 值的情形：</span><span class="sxs-lookup"><span data-stu-id="2587f-296">The following table summarizes how the table entity operations use ETag values:</span></span>

| <span data-ttu-id="2587f-297">作業</span><span class="sxs-lookup"><span data-stu-id="2587f-297">Operation</span></span> | <span data-ttu-id="2587f-298">傳回 ETag 值</span><span class="sxs-lookup"><span data-stu-id="2587f-298">Returns ETag value</span></span> | <span data-ttu-id="2587f-299">需要 If-Match 要求標頭</span><span class="sxs-lookup"><span data-stu-id="2587f-299">Requires If-Match request header</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="2587f-300">查詢實體</span><span class="sxs-lookup"><span data-stu-id="2587f-300">Query Entities</span></span> |<span data-ttu-id="2587f-301">是</span><span class="sxs-lookup"><span data-stu-id="2587f-301">Yes</span></span> |<span data-ttu-id="2587f-302">否</span><span class="sxs-lookup"><span data-stu-id="2587f-302">No</span></span> |
| <span data-ttu-id="2587f-303">插入實體</span><span class="sxs-lookup"><span data-stu-id="2587f-303">Insert Entity</span></span> |<span data-ttu-id="2587f-304">是</span><span class="sxs-lookup"><span data-stu-id="2587f-304">Yes</span></span> |<span data-ttu-id="2587f-305">否</span><span class="sxs-lookup"><span data-stu-id="2587f-305">No</span></span> |
| <span data-ttu-id="2587f-306">更新實體</span><span class="sxs-lookup"><span data-stu-id="2587f-306">Update Entity</span></span> |<span data-ttu-id="2587f-307">是</span><span class="sxs-lookup"><span data-stu-id="2587f-307">Yes</span></span> |<span data-ttu-id="2587f-308">是</span><span class="sxs-lookup"><span data-stu-id="2587f-308">Yes</span></span> |
| <span data-ttu-id="2587f-309">合併實體</span><span class="sxs-lookup"><span data-stu-id="2587f-309">Merge Entity</span></span> |<span data-ttu-id="2587f-310">是</span><span class="sxs-lookup"><span data-stu-id="2587f-310">Yes</span></span> |<span data-ttu-id="2587f-311">是</span><span class="sxs-lookup"><span data-stu-id="2587f-311">Yes</span></span> |
| <span data-ttu-id="2587f-312">刪除實體</span><span class="sxs-lookup"><span data-stu-id="2587f-312">Delete Entity</span></span> |<span data-ttu-id="2587f-313">否</span><span class="sxs-lookup"><span data-stu-id="2587f-313">No</span></span> |<span data-ttu-id="2587f-314">是</span><span class="sxs-lookup"><span data-stu-id="2587f-314">Yes</span></span> |
| <span data-ttu-id="2587f-315">插入或取代實體</span><span class="sxs-lookup"><span data-stu-id="2587f-315">Insert or Replace Entity</span></span> |<span data-ttu-id="2587f-316">是</span><span class="sxs-lookup"><span data-stu-id="2587f-316">Yes</span></span> |<span data-ttu-id="2587f-317">否</span><span class="sxs-lookup"><span data-stu-id="2587f-317">No</span></span> |
| <span data-ttu-id="2587f-318">插入或合併實體</span><span class="sxs-lookup"><span data-stu-id="2587f-318">Insert or Merge Entity</span></span> |<span data-ttu-id="2587f-319">是</span><span class="sxs-lookup"><span data-stu-id="2587f-319">Yes</span></span> |<span data-ttu-id="2587f-320">否</span><span class="sxs-lookup"><span data-stu-id="2587f-320">No</span></span> |

<span data-ttu-id="2587f-321">請注意，**插入或取代實體**和**插入或合併實體**作業並「不會」執行任何並行存取檢查，因為這些作業不會將 ETag 值傳送至資料表服務。</span><span class="sxs-lookup"><span data-stu-id="2587f-321">Note that the **Insert or Replace Entity** and **Insert or Merge Entity** operations do *not* perform any concurrency checks because they do not send an ETag value to the table service.</span></span>  

<span data-ttu-id="2587f-322">一般而言，使用資料表的開發人員在開發可擴充的應用程式時，應該會採用開放式並行存取。</span><span class="sxs-lookup"><span data-stu-id="2587f-322">In general developers using tables should rely on optimistic concurrency when developing scalable applications.</span></span> <span data-ttu-id="2587f-323">如果需要封閉式鎖定，開發人員在存取資料表時可採用的方法之一，是為每個資料表指派一個指定 Blob，在且在操作資料表之前嘗試租用 Blob。</span><span class="sxs-lookup"><span data-stu-id="2587f-323">If pessimistic locking is needed, one approach developers can take when accessing Tables is to assign a designated blob for each table and try to take a lease on the blob before operating on the table.</span></span> <span data-ttu-id="2587f-324">要使用此方法，應用程式必須確定所有資料存取路徑都在操作資料表之前取得租用。</span><span class="sxs-lookup"><span data-stu-id="2587f-324">This approach does require the application to ensure all data access paths obtain the lease prior to operating on the table.</span></span> <span data-ttu-id="2587f-325">您也應注意，最短租用時間為 15 秒，您應謹慎考量這一點以維持擴充性。</span><span class="sxs-lookup"><span data-stu-id="2587f-325">You should also note that the minimum lease time is 15 seconds which requires careful consideration for scalability.</span></span>  

<span data-ttu-id="2587f-326">如需詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="2587f-326">For more information see:</span></span>  

* [<span data-ttu-id="2587f-327">實體上的作業</span><span class="sxs-lookup"><span data-stu-id="2587f-327">Operations on Entities</span></span>](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-the-queue-service"></a><span data-ttu-id="2587f-328">管理佇列服務中的並行存取</span><span class="sxs-lookup"><span data-stu-id="2587f-328">Managing Concurrency in the Queue Service</span></span>
<span data-ttu-id="2587f-329">在使用佇列服務時必須考量並行存取的案例之一，是有多個用戶端從一個佇列擷取訊息時。</span><span class="sxs-lookup"><span data-stu-id="2587f-329">One scenario in which concurrency is a concern in the queueing service is where multiple clients are retrieving messages from a queue.</span></span> <span data-ttu-id="2587f-330">從佇列擷取訊息時，回應中會包含訊息，以及刪除訊息所需的 pop receipt 值。</span><span class="sxs-lookup"><span data-stu-id="2587f-330">When a message is retrieved from the queue, the response includes the message and a pop receipt value, which is required to delete the message.</span></span> <span data-ttu-id="2587f-331">訊息並不會從佇列中自動刪除，但在擷取之後，其他用戶端在 visibilitytimeout 參數所指定的時間間隔內將看不到此訊息。</span><span class="sxs-lookup"><span data-stu-id="2587f-331">The message is not automatically deleted from the queue, but after it has been retrieved, it is not visible to other clients for the time interval specified by the visibilitytimeout parameter.</span></span> <span data-ttu-id="2587f-332">擷取訊息的用戶端應會在訊息完成處理後、回應的 TimeNextVisible 元素所指定的時間之前刪除訊息；這段時間會根據 visibilitytimeout 參數值計算得出。</span><span class="sxs-lookup"><span data-stu-id="2587f-332">The client that retrieves the message is expected to delete the message after it has been processed, and before the time specified by the TimeNextVisible element of the response, which is calculated based on the value of the visibilitytimeout parameter.</span></span> <span data-ttu-id="2587f-333">visibilitytimeout 的值會加到擷取訊息的時間上，以決定 TimeNextVisible 的值。</span><span class="sxs-lookup"><span data-stu-id="2587f-333">The value of visibilitytimeout is added to the time at which the message is retrieved to determine the value of TimeNextVisible.</span></span>  

<span data-ttu-id="2587f-334">佇列服務並不支援開放式或封閉式並行存取，因此，用戶端在處理擷取自佇列的訊息時，應確定訊息是以冪等方式進行處理的。</span><span class="sxs-lookup"><span data-stu-id="2587f-334">The queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</span></span> <span data-ttu-id="2587f-335">「最後寫入為準」策略可用於更新作業，例如 SetQueueServiceProperties、SetQueueMetaData、SetQueueACL 和 UpdateMessage。</span><span class="sxs-lookup"><span data-stu-id="2587f-335">A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</span></span>  

<span data-ttu-id="2587f-336">如需詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="2587f-336">For more information see:</span></span>  

* [<span data-ttu-id="2587f-337">佇列服務 REST API</span><span class="sxs-lookup"><span data-stu-id="2587f-337">Queue Service REST API</span></span>](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [<span data-ttu-id="2587f-338">取得訊息</span><span class="sxs-lookup"><span data-stu-id="2587f-338">Get Messages</span></span>](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-the-file-service"></a><span data-ttu-id="2587f-339">管理檔案服務中的並行存取</span><span class="sxs-lookup"><span data-stu-id="2587f-339">Managing Concurrency in the File Service</span></span>
<span data-ttu-id="2587f-340">檔案服務可使用兩種不同的通訊協定端點來存取 – SMB 和 REST。</span><span class="sxs-lookup"><span data-stu-id="2587f-340">The file service can be accessed using two different protocol endpoints – SMB and REST.</span></span> <span data-ttu-id="2587f-341">REST 服務不支援開放式鎖定或封閉式鎖定，且所有更新都將遵循「最後寫入為準」策略。</span><span class="sxs-lookup"><span data-stu-id="2587f-341">The REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</span></span> <span data-ttu-id="2587f-342">裝載檔案共用的 SMB 用戶端可利用檔案系統鎖定機制，來管理對共用檔案的存取 – 包括執行封閉式鎖定的功能。</span><span class="sxs-lookup"><span data-stu-id="2587f-342">SMB clients that mount file shares can leverage file system locking mechanisms to manage access to shared files – including the ability to perform pessimistic locking.</span></span> <span data-ttu-id="2587f-343">SMB 用戶端在開啟檔案時，會同時指定檔案存取和共用模式。</span><span class="sxs-lookup"><span data-stu-id="2587f-343">When an SMB client opens a file, it specifies both the file access and share mode.</span></span> <span data-ttu-id="2587f-344">將 [檔案存取] 選項設為 [寫入] 或 [讀取/寫入]，並將 [檔案共用] 模式設為 [無]，會使檔案被 SMB 用戶端鎖定，直到檔案關閉為止。</span><span class="sxs-lookup"><span data-stu-id="2587f-344">Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in the file being locked by an SMB client until the file is closed.</span></span> <span data-ttu-id="2587f-345">如果嘗試對已由 SMB 用戶端鎖定的檔案執行 REST 作業，REST 服務將會傳回狀態碼 409 (衝突) 和錯誤碼 SharingViolation。</span><span class="sxs-lookup"><span data-stu-id="2587f-345">If REST operation is attempted on a file where an SMB client has the file locked the REST service will return status code 409 (Conflict) with error code SharingViolation.</span></span>  

<span data-ttu-id="2587f-346">SMB 用戶端在開啟檔案以進行刪除時，會將檔案標示為「擱置刪除」，直到所有對該檔案的其他 SMB 用戶端開啟控制代碼關閉為止。</span><span class="sxs-lookup"><span data-stu-id="2587f-346">When an SMB client opens a file for delete, it marks the file as pending delete until all other SMB client open handles on that file are closed.</span></span> <span data-ttu-id="2587f-347">在檔案標示為「擱置刪除」時，任何對該檔案的 REST 作業都將傳回狀態碼 409 (衝突) 和錯誤碼 SMBDeletePending。</span><span class="sxs-lookup"><span data-stu-id="2587f-347">While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</span></span> <span data-ttu-id="2587f-348">此時並不會傳回狀態碼 404 (找不到)，因為 SMB 用戶端有可能在關閉檔案之前移除擱置刪除旗標。</span><span class="sxs-lookup"><span data-stu-id="2587f-348">Status code 404 (Not Found) is not returned since it is possible for the SMB client to remove the pending deletion flag prior to closing the file.</span></span> <span data-ttu-id="2587f-349">換句話說，狀態碼 404 (找不到) 只有可能在檔案已移除時出現。</span><span class="sxs-lookup"><span data-stu-id="2587f-349">In other words, status code 404 (Not Found) is only expected when the file has been removed.</span></span> <span data-ttu-id="2587f-350">請注意，處於 SMB 擱置刪除狀態的檔案將不會包含在 [列出檔案] 結果中。同時請注意，「REST 刪除檔案」和「REST 刪除目錄」作業的認可是整體性的，而不會導致擱置刪除狀態。</span><span class="sxs-lookup"><span data-stu-id="2587f-350">Note that while a file is in a SMB pending delete state, it will not be included in the List Files results.Also note that the REST Delete File and REST Delete Directory operations are committed atomically and do not result in pending delete state.</span></span>  

<span data-ttu-id="2587f-351">如需詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="2587f-351">For more information see:</span></span>  

* [<span data-ttu-id="2587f-352">管理檔案鎖定</span><span class="sxs-lookup"><span data-stu-id="2587f-352">Managing File Locks</span></span>](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a><span data-ttu-id="2587f-353">摘要和後續步驟</span><span class="sxs-lookup"><span data-stu-id="2587f-353">Summary and Next Steps</span></span>
<span data-ttu-id="2587f-354">Microsoft Azure 儲存體服務的設計已符合最複雜的線上應用程式的需求，而不會迫使開發人員犧牲或再三考量主要的設計假設，例如已被開發人員視為理所當然的並行存取和資料一致性。</span><span class="sxs-lookup"><span data-stu-id="2587f-354">The Microsoft Azure Storage service has been designed to meet the needs of the most complex online applications without forcing developers to compromise or rethink key design assumptions such as concurrency and data consistency that they have come to take for granted.</span></span>  

<span data-ttu-id="2587f-355">如需此部落格中參考的完整範例應用程式：</span><span class="sxs-lookup"><span data-stu-id="2587f-355">For the complete sample application referenced in this blog:</span></span>  

* [<span data-ttu-id="2587f-356">使用 Azure 儲存體管理並行存取 - 範例應用程式</span><span class="sxs-lookup"><span data-stu-id="2587f-356">Managing Concurrency using Azure Storage - Sample Application</span></span>](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

<span data-ttu-id="2587f-357">如需 Azure 儲存體的詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="2587f-357">For more information on Azure Storage see:</span></span>  

* [<span data-ttu-id="2587f-358">Microsoft Azure 儲存體首頁</span><span class="sxs-lookup"><span data-stu-id="2587f-358">Microsoft Azure Storage Home Page</span></span>](https://azure.microsoft.com/services/storage/)
* [<span data-ttu-id="2587f-359">Azure 儲存體簡介</span><span class="sxs-lookup"><span data-stu-id="2587f-359">Introduction to Azure Storage</span></span>](storage-introduction.md)
* <span data-ttu-id="2587f-360">[Blob](storage-dotnet-how-to-use-blobs.md)、[資料表](storage-dotnet-how-to-use-tables.md)、[佇列](storage-dotnet-how-to-use-queues.md)及[檔案](storage-dotnet-how-to-use-files.md)的儲存體入門</span><span class="sxs-lookup"><span data-stu-id="2587f-360">Storage Getting Started for [Blob](storage-dotnet-how-to-use-blobs.md), [Table](storage-dotnet-how-to-use-tables.md),  [Queues](storage-dotnet-how-to-use-queues.md), and [Files](storage-dotnet-how-to-use-files.md)</span></span>
* <span data-ttu-id="2587f-361">儲存體架構 – [Azure 儲存體：具有高度一致性的高可用性雲端儲存體服務](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span><span class="sxs-lookup"><span data-stu-id="2587f-361">Storage Architecture – [Azure Storage : A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span></span>

