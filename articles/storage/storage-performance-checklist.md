---
title: "aaaAzure 存放裝置效能和延展性檢查清單 |Microsoft 文件"
description: "在開發具效能的應用程式中使用 Azure 儲存體的實證做法檢查清單。"
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: c0cd77da4a1abda42c018255ed93215b71f4fad8
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="43121-103">Microsoft Azure 儲存體效能與延展性檢查清單</span><span class="sxs-lookup"><span data-stu-id="43121-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="43121-104">概觀</span><span class="sxs-lookup"><span data-stu-id="43121-104">Overview</span></span>
<span data-ttu-id="43121-105">Hello hello Microsoft Azure 儲存體服務版本，Microsoft 開發了數實證作法為以高效能的方式使用這些服務，並且這篇文章提供 tooconsolidate hello 其中最重要成檢查清單樣式清單。</span><span class="sxs-lookup"><span data-stu-id="43121-105">Since hello release of hello Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves tooconsolidate hello most important of them into a checklist-style list.</span></span> <span data-ttu-id="43121-106">這篇文章的 hello 用意是 toohelp 應用程式開發人員，確認它們正在使用 Azure 儲存體和 toohelp 它們找出其他經過證實的作法，應考慮採用經過證實的作法。</span><span class="sxs-lookup"><span data-stu-id="43121-106">hello intention of this article is toohelp application developers verify they are using proven practices with Azure Storage and toohelp them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="43121-107">這篇文章不會嘗試 toocover 每個可能的效能和擴充性最佳化 — 小的影響或廣泛適用排除它。</span><span class="sxs-lookup"><span data-stu-id="43121-107">This article does not attempt toocover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="43121-108">hello 應用程式的行為的 toohello 範圍可以預測進行設計時，它會在早期介意有用 tookeep tooavoid 設計所會遇到效能問題。</span><span class="sxs-lookup"><span data-stu-id="43121-108">toohello extent that hello application's behavior can be predicted during design, it's useful tookeep these in mind early on tooavoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="43121-109">使用 Azure 儲存體的每個應用程式開發人員應該採取 hello 時間 tooread 本文中，並檢查 他或她的應用程式遵循每個 hello 證明下面所列的作法。</span><span class="sxs-lookup"><span data-stu-id="43121-109">Every application developer using Azure Storage should take hello time tooread this article, and check that his or her application follows each of hello proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="43121-110">檢查清單</span><span class="sxs-lookup"><span data-stu-id="43121-110">Checklist</span></span>
<span data-ttu-id="43121-111">本文會證明 hello 作法組織成 hello 下列群組中。</span><span class="sxs-lookup"><span data-stu-id="43121-111">This article organizes hello proven practices into hello following groups.</span></span> <span data-ttu-id="43121-112">已經實證做法的適用對象：</span><span class="sxs-lookup"><span data-stu-id="43121-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="43121-113">所有 Azure 儲存體服務 (Blob、資料表、佇列和檔案)</span><span class="sxs-lookup"><span data-stu-id="43121-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="43121-114">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-114">Blobs</span></span>
* <span data-ttu-id="43121-115">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-115">Tables</span></span>
* <span data-ttu-id="43121-116">佇列</span><span class="sxs-lookup"><span data-stu-id="43121-116">Queues</span></span>  

| <span data-ttu-id="43121-117">完成</span><span class="sxs-lookup"><span data-stu-id="43121-117">Done</span></span> | <span data-ttu-id="43121-118">領域</span><span class="sxs-lookup"><span data-stu-id="43121-118">Area</span></span> | <span data-ttu-id="43121-119">類別</span><span class="sxs-lookup"><span data-stu-id="43121-119">Category</span></span> | <span data-ttu-id="43121-120">問題</span><span class="sxs-lookup"><span data-stu-id="43121-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="43121-121">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-121">All Services</span></span> |<span data-ttu-id="43121-122">延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-122">Scalability Targets</span></span> |[<span data-ttu-id="43121-123">設計應用程式 tooavoid 即將 hello 延展性目標嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-123">Is your application designed tooavoid approaching hello scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="43121-124">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-124">All Services</span></span> |<span data-ttu-id="43121-125">延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-125">Scalability Targets</span></span> |[<span data-ttu-id="43121-126">是您的命名慣例設計 tooenable 進一步負載平衡嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-126">Is your naming convention designed tooenable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="43121-127">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-127">All Services</span></span> |<span data-ttu-id="43121-128">網路</span><span class="sxs-lookup"><span data-stu-id="43121-128">Networking</span></span> |[<span data-ttu-id="43121-129">用戶端端裝置有夠高的頻寬及需要低度延遲 tooachieve hello 效能？</span><span class="sxs-lookup"><span data-stu-id="43121-129">Do client side devices have sufficiently high bandwidth and low latency tooachieve hello performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="43121-130">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-130">All Services</span></span> |<span data-ttu-id="43121-131">網路</span><span class="sxs-lookup"><span data-stu-id="43121-131">Networking</span></span> |[<span data-ttu-id="43121-132">用戶端裝置是否有足夠高的品質連結？</span><span class="sxs-lookup"><span data-stu-id="43121-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="43121-133">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-133">All Services</span></span> |<span data-ttu-id="43121-134">網路</span><span class="sxs-lookup"><span data-stu-id="43121-134">Networking</span></span> |[<span data-ttu-id="43121-135">Hello 用戶端應用程式是否位於 <"近乎 hello 儲存體帳戶？</span><span class="sxs-lookup"><span data-stu-id="43121-135">Is hello client application located "near" hello storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="43121-136">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-136">All Services</span></span> |<span data-ttu-id="43121-137">內容發佈</span><span class="sxs-lookup"><span data-stu-id="43121-137">Content Distribution</span></span> |[<span data-ttu-id="43121-138">您是否會使用 CDN 進行內容發佈？</span><span class="sxs-lookup"><span data-stu-id="43121-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="43121-139">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-139">All Services</span></span> |<span data-ttu-id="43121-140">直接用戶端存取</span><span class="sxs-lookup"><span data-stu-id="43121-140">Direct Client Access</span></span> |[<span data-ttu-id="43121-141">您使用 SAS 和 CORS tooallow 直接存取 toostorage 而非 proxy？</span><span class="sxs-lookup"><span data-stu-id="43121-141">Are you using SAS and CORS tooallow direct access toostorage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="43121-142">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-142">All Services</span></span> |<span data-ttu-id="43121-143">快取</span><span class="sxs-lookup"><span data-stu-id="43121-143">Caching</span></span> |[<span data-ttu-id="43121-144">您的應用程式是否會針對重複使用和極少變更的資料進行快取？</span><span class="sxs-lookup"><span data-stu-id="43121-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="43121-145">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-145">All Services</span></span> |<span data-ttu-id="43121-146">快取</span><span class="sxs-lookup"><span data-stu-id="43121-146">Caching</span></span> |[<span data-ttu-id="43121-147">您的應用程式是否會批次執行更新 (在用戶端快取更新，然後以大型集合的方式上傳)？</span><span class="sxs-lookup"><span data-stu-id="43121-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="43121-148">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-148">All Services</span></span> |<span data-ttu-id="43121-149">.NET 組態</span><span class="sxs-lookup"><span data-stu-id="43121-149">.NET Configuration</span></span> |[<span data-ttu-id="43121-150">您已設定您的用戶端 toouse 足夠數目的並行連線嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-150">Have you configured your client toouse a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="43121-151">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-151">All Services</span></span> |<span data-ttu-id="43121-152">.NET 組態</span><span class="sxs-lookup"><span data-stu-id="43121-152">.NET Configuration</span></span> |[<span data-ttu-id="43121-153">您已設定.NET toouse 足夠的執行緒數目？</span><span class="sxs-lookup"><span data-stu-id="43121-153">Have you configured .NET toouse a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="43121-154">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-154">All Services</span></span> |<span data-ttu-id="43121-155">.NET 組態</span><span class="sxs-lookup"><span data-stu-id="43121-155">.NET Configuration</span></span> |[<span data-ttu-id="43121-156">您使用的是已改善記憶體回收的 .NET 4.5 或更新版本嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="43121-157">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-157">All Services</span></span> |<span data-ttu-id="43121-158">平行處理原則</span><span class="sxs-lookup"><span data-stu-id="43121-158">Parallelism</span></span> |[<span data-ttu-id="43121-159">您已確保，讓您的用戶端功能 」 或 「 hello 延展性目標不多載平行處理原則適當地限定嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or hello scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="43121-160">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-160">All Services</span></span> |<span data-ttu-id="43121-161">工具</span><span class="sxs-lookup"><span data-stu-id="43121-161">Tools</span></span> |[<span data-ttu-id="43121-162">您可以使用 Microsoft hello 最新版本會提供用戶端程式庫和工具？</span><span class="sxs-lookup"><span data-stu-id="43121-162">Are you using hello latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="43121-163">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-163">All Services</span></span> |<span data-ttu-id="43121-164">重試</span><span class="sxs-lookup"><span data-stu-id="43121-164">Retries</span></span> |[<span data-ttu-id="43121-165">您是否針對節流錯誤和逾時使用指數輪詢重試原則？</span><span class="sxs-lookup"><span data-stu-id="43121-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="43121-166">所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-166">All Services</span></span> |<span data-ttu-id="43121-167">重試</span><span class="sxs-lookup"><span data-stu-id="43121-167">Retries</span></span> |[<span data-ttu-id="43121-168">您的應用程式是否避免重試不能再嘗試的錯誤？</span><span class="sxs-lookup"><span data-stu-id="43121-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="43121-169">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-169">Blobs</span></span> |<span data-ttu-id="43121-170">延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-170">Scalability Targets</span></span> |[<span data-ttu-id="43121-171">您是嘔有大量的用戶端並行存取單一物件？</span><span class="sxs-lookup"><span data-stu-id="43121-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="43121-172">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-172">Blobs</span></span> |<span data-ttu-id="43121-173">延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-173">Scalability Targets</span></span> |[<span data-ttu-id="43121-174">您的應用程式仍使用單一 blob 的 hello 頻寬或作業的延展性目標內？</span><span class="sxs-lookup"><span data-stu-id="43121-174">Is your application staying within hello bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="43121-175">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-175">Blobs</span></span> |<span data-ttu-id="43121-176">複製 Blob</span><span class="sxs-lookup"><span data-stu-id="43121-176">Copying Blobs</span></span> |[<span data-ttu-id="43121-177">您是否以有效的方式複製 Blob？</span><span class="sxs-lookup"><span data-stu-id="43121-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="43121-178">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-178">Blobs</span></span> |<span data-ttu-id="43121-179">複製 Blob</span><span class="sxs-lookup"><span data-stu-id="43121-179">Copying Blobs</span></span> |[<span data-ttu-id="43121-180">您是否使用 AzCopy 進行 Blob 的大量複製？</span><span class="sxs-lookup"><span data-stu-id="43121-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="43121-181">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-181">Blobs</span></span> |<span data-ttu-id="43121-182">複製 Blob</span><span class="sxs-lookup"><span data-stu-id="43121-182">Copying Blobs</span></span> |[<span data-ttu-id="43121-183">您使用 Azure 匯入/匯出 tootransfer 非常大量的資料？</span><span class="sxs-lookup"><span data-stu-id="43121-183">Are you using Azure Import/Export tootransfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="43121-184">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-184">Blobs</span></span> |<span data-ttu-id="43121-185">使用中繼資料</span><span class="sxs-lookup"><span data-stu-id="43121-185">Use Metadata</span></span> |[<span data-ttu-id="43121-186">您是否將 Blob 相關的常用中繼資料儲存在它的中繼資料內？</span><span class="sxs-lookup"><span data-stu-id="43121-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="43121-187">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-187">Blobs</span></span> |<span data-ttu-id="43121-188">快速上傳</span><span class="sxs-lookup"><span data-stu-id="43121-188">Uploading Fast</span></span> |[<span data-ttu-id="43121-189">當快速嘗試 tooupload 一個 blob，您要上傳區塊，以平行方式？</span><span class="sxs-lookup"><span data-stu-id="43121-189">When trying tooupload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="43121-190">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-190">Blobs</span></span> |<span data-ttu-id="43121-191">快速上傳</span><span class="sxs-lookup"><span data-stu-id="43121-191">Uploading Fast</span></span> |[<span data-ttu-id="43121-192">當快速嘗試 tooupload 許多 blob，您要上傳 blob 以平行方式？</span><span class="sxs-lookup"><span data-stu-id="43121-192">When trying tooupload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="43121-193">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-193">Blobs</span></span> |<span data-ttu-id="43121-194">正確的 Blob 類型</span><span class="sxs-lookup"><span data-stu-id="43121-194">Correct Blob Type</span></span> |[<span data-ttu-id="43121-195">您是否在適當的時機使用分頁 Blob 或區塊 Blob？</span><span class="sxs-lookup"><span data-stu-id="43121-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="43121-196">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-196">Tables</span></span> |<span data-ttu-id="43121-197">延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-197">Scalability Targets</span></span> |[<span data-ttu-id="43121-198">是您接近 hello 延展性目標的每秒的實體嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-198">Are you approaching hello scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="43121-199">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-199">Tables</span></span> |<span data-ttu-id="43121-200">組態</span><span class="sxs-lookup"><span data-stu-id="43121-200">Configuration</span></span> |[<span data-ttu-id="43121-201">您是否使用 JSON 來處理資料表要求？</span><span class="sxs-lookup"><span data-stu-id="43121-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="43121-202">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-202">Tables</span></span> |<span data-ttu-id="43121-203">組態</span><span class="sxs-lookup"><span data-stu-id="43121-203">Configuration</span></span> |[<span data-ttu-id="43121-204">您關閉了 Nagle tooimprove hello 效能的小型要求嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-204">Have you turned Nagle off tooimprove hello performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="43121-205">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-205">Tables</span></span> |<span data-ttu-id="43121-206">資料表和資料分割</span><span class="sxs-lookup"><span data-stu-id="43121-206">Tables and Partitions</span></span> |[<span data-ttu-id="43121-207">您是否已正確分割您的資料？</span><span class="sxs-lookup"><span data-stu-id="43121-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="43121-208">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-208">Tables</span></span> |<span data-ttu-id="43121-209">常用資料分割</span><span class="sxs-lookup"><span data-stu-id="43121-209">Hot Partitions</span></span> |[<span data-ttu-id="43121-210">您是否避免只開頭附加和只結尾附加模式？</span><span class="sxs-lookup"><span data-stu-id="43121-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="43121-211">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-211">Tables</span></span> |<span data-ttu-id="43121-212">常用資料分割</span><span class="sxs-lookup"><span data-stu-id="43121-212">Hot Partitions</span></span> |[<span data-ttu-id="43121-213">您的插入/更新是否散佈到許多資料分割中？</span><span class="sxs-lookup"><span data-stu-id="43121-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="43121-214">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-214">Tables</span></span> |<span data-ttu-id="43121-215">查詢範圍</span><span class="sxs-lookup"><span data-stu-id="43121-215">Query Scope</span></span> |[<span data-ttu-id="43121-216">您所設計點查詢 toobe 在大部分情況下，與資料表查詢 toobe 謹慎使用您結構描述的 tooallow 嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-216">Have you designed your schema tooallow for point queries toobe used in most cases, and table queries toobe used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="43121-217">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-217">Tables</span></span> |<span data-ttu-id="43121-218">查詢密度</span><span class="sxs-lookup"><span data-stu-id="43121-218">Query Density</span></span> |[<span data-ttu-id="43121-219">您的查詢是否通常只掃描並傳回應用程式將使用的列？</span><span class="sxs-lookup"><span data-stu-id="43121-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="43121-220">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-220">Tables</span></span> |<span data-ttu-id="43121-221">限制傳回資料</span><span class="sxs-lookup"><span data-stu-id="43121-221">Limiting Returned Data</span></span> |[<span data-ttu-id="43121-222">您會使用篩選 tooavoid 傳回的實體不需要用到嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-222">Are you using filtering tooavoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="43121-223">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-223">Tables</span></span> |<span data-ttu-id="43121-224">限制傳回資料</span><span class="sxs-lookup"><span data-stu-id="43121-224">Limiting Returned Data</span></span> |[<span data-ttu-id="43121-225">您使用投影 tooavoid 傳回不需要的屬性？</span><span class="sxs-lookup"><span data-stu-id="43121-225">Are you using projection tooavoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="43121-226">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-226">Tables</span></span> |<span data-ttu-id="43121-227">反正規化</span><span class="sxs-lookup"><span data-stu-id="43121-227">Denormalization</span></span> |[<span data-ttu-id="43121-228">使得嘗試 tooget 資料時，避免效率不佳的查詢或多個讀取的要求有未標準化資料嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying tooget data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="43121-229">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-229">Tables</span></span> |<span data-ttu-id="43121-230">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="43121-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="43121-231">您會批次要求需要 toobe 交易式，或者可以在 hello 相同時間 tooreduce 往返嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-231">Are you batching requests that need toobe transactional or can be done at hello same time tooreduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="43121-232">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-232">Tables</span></span> |<span data-ttu-id="43121-233">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="43121-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="43121-234">您會避免擷取實體只 toodetermine toocall 是否插入或更新？</span><span class="sxs-lookup"><span data-stu-id="43121-234">Are you avoiding retrieving an entity just toodetermine whether toocall insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="43121-235">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-235">Tables</span></span> |<span data-ttu-id="43121-236">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="43121-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="43121-237">您是否考慮將經常會被一起擷取的一系列資料，以屬性的方式儲存在單一實體中 (而非儲存在多個實體中)？</span><span class="sxs-lookup"><span data-stu-id="43121-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="43121-238">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-238">Tables</span></span> |<span data-ttu-id="43121-239">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="43121-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="43121-240">針對總是會被一起擷取並可以批次執行方式寫入的實體 (例如時間序列資料)，您是否考慮使用 Blob (而非資料表)？</span><span class="sxs-lookup"><span data-stu-id="43121-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="43121-241">佇列</span><span class="sxs-lookup"><span data-stu-id="43121-241">Queues</span></span> |<span data-ttu-id="43121-242">延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-242">Scalability Targets</span></span> |[<span data-ttu-id="43121-243">每秒的訊息是您接近 hello 延展性目標嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-243">Are you approaching hello scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="43121-244">佇列</span><span class="sxs-lookup"><span data-stu-id="43121-244">Queues</span></span> |<span data-ttu-id="43121-245">組態</span><span class="sxs-lookup"><span data-stu-id="43121-245">Configuration</span></span> |[<span data-ttu-id="43121-246">您關閉了 Nagle tooimprove hello 效能的小型要求嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-246">Have you turned Nagle off tooimprove hello performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="43121-247">佇列</span><span class="sxs-lookup"><span data-stu-id="43121-247">Queues</span></span> |<span data-ttu-id="43121-248">訊息大小</span><span class="sxs-lookup"><span data-stu-id="43121-248">Message Size</span></span> |[<span data-ttu-id="43121-249">Compact tooimprove hello 效能 hello 佇列的是您的郵件？</span><span class="sxs-lookup"><span data-stu-id="43121-249">Are your messages compact tooimprove hello performance of hello queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="43121-250">佇列</span><span class="sxs-lookup"><span data-stu-id="43121-250">Queues</span></span> |<span data-ttu-id="43121-251">大量擷取</span><span class="sxs-lookup"><span data-stu-id="43121-251">Bulk Retrieve</span></span> |[<span data-ttu-id="43121-252">您是否在單一 "Get" 操作中擷取多則訊息？</span><span class="sxs-lookup"><span data-stu-id="43121-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="43121-253">佇列</span><span class="sxs-lookup"><span data-stu-id="43121-253">Queues</span></span> |<span data-ttu-id="43121-254">輪詢頻率</span><span class="sxs-lookup"><span data-stu-id="43121-254">Polling Frequency</span></span> |[<span data-ttu-id="43121-255">正在輪詢經常看得見您的應用程式的延遲足夠 tooreduce hello？</span><span class="sxs-lookup"><span data-stu-id="43121-255">Are you polling frequently enough tooreduce hello perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="43121-256">佇列</span><span class="sxs-lookup"><span data-stu-id="43121-256">Queues</span></span> |<span data-ttu-id="43121-257">更新訊息</span><span class="sxs-lookup"><span data-stu-id="43121-257">Update Message</span></span> |[<span data-ttu-id="43121-258">您使用 UpdateMessage toostore 進度中處理訊息，避免必須 tooreprocess hello 整個訊息，如果發生錯誤？</span><span class="sxs-lookup"><span data-stu-id="43121-258">Are you using UpdateMessage toostore progress in processing messages, avoiding having tooreprocess hello entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="43121-259">佇列</span><span class="sxs-lookup"><span data-stu-id="43121-259">Queues</span></span> |<span data-ttu-id="43121-260">架構</span><span class="sxs-lookup"><span data-stu-id="43121-260">Architecture</span></span> |[<span data-ttu-id="43121-261">您使用佇列 toomake 整個應用程式更具擴充性透過獨立然後維持長時間執行工作負載超出 hello 關鍵路徑和小數位數？</span><span class="sxs-lookup"><span data-stu-id="43121-261">Are you using queues toomake your entire application more scalable by keeping long-running workloads out of hello critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="43121-262"><a name="allservices"></a>所有服務</span><span class="sxs-lookup"><span data-stu-id="43121-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="43121-263">此區段會列出實證適用 toohello 使用任何 hello Azure 儲存體服務 （blob、 資料表、 佇列或檔案） 的作法。</span><span class="sxs-lookup"><span data-stu-id="43121-263">This section lists proven practices that are applicable toohello use of any of hello Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="43121-264"><a name="subheading1"></a>延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="43121-265">每個 hello Azure 儲存體服務具有延展性目標容量 (GB)，交易率和頻寬。</span><span class="sxs-lookup"><span data-stu-id="43121-265">Each of hello Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="43121-266">如果您的應用程式接近或超過任何 hello 延展性目標，它可能會遇到增加了的交易延遲或節流。</span><span class="sxs-lookup"><span data-stu-id="43121-266">If your application approaches or exceeds any of hello scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="43121-267">當儲存體服務會先調節應用程式時，hello 服務會開始 tooreturn 「 503 伺服器忙碌中 」 或 「 500 作業逾時 」 錯誤代碼的某些儲存體交易。</span><span class="sxs-lookup"><span data-stu-id="43121-267">When a Storage service throttles your application, hello service begins tooreturn "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="43121-268">本節將討論這兩個具有延展性目標和頻寬延展性目標的 hello 一般方法 toodealing 特別。</span><span class="sxs-lookup"><span data-stu-id="43121-268">This section discusses both hello general approach toodealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="43121-269">處理個別的儲存體服務的後續章節將討論在 hello 內容中的該特定服務的延展性目標：</span><span class="sxs-lookup"><span data-stu-id="43121-269">Later sections that deal with individual storage services discuss scalability targets in hello context of that specific service:</span></span>  

* [<span data-ttu-id="43121-270">Blob 頻寬和每秒要求數</span><span class="sxs-lookup"><span data-stu-id="43121-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="43121-271">每秒的資料表實體</span><span class="sxs-lookup"><span data-stu-id="43121-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="43121-272">每秒佇列訊息</span><span class="sxs-lookup"><span data-stu-id="43121-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="43121-273"><a name="sub1bandwidth"></a>所有服務的頻寬延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="43121-274">Hello 撰寫本文時，在 hello 美國地理備援儲存體 (GRS) 帳戶中的 hello 頻寬目標都是 10 gb / 秒 (Gbps) 的輸入 （資料會傳送 toohello 儲存體帳戶） 和 20 Gbps 輸出 （hello 儲存體帳戶所送出的資料）。</span><span class="sxs-lookup"><span data-stu-id="43121-274">At hello time of writing, hello bandwidth targets in hello US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent toohello storage account) and 20 Gbps for egress (data sent from hello storage account).</span></span> <span data-ttu-id="43121-275">本機備援儲存體 (LRS) 帳戶，hello 限制較高的-20 Gbps 針對 ingress 和 egress 30 gbps 之間。</span><span class="sxs-lookup"><span data-stu-id="43121-275">For a locally redundant storage (LRS) account, hello limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="43121-276">國際頻寬可能有較低的限制，您可以在我們的 [延展性目標頁面](http://msdn.microsoft.com/library/azure/dn249410.aspx)上找到此資訊。</span><span class="sxs-lookup"><span data-stu-id="43121-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="43121-277">如需有關 hello 儲存體備援選項的詳細資訊，請參閱中的 hello 連結[實用資源](#sub1useful)下方。</span><span class="sxs-lookup"><span data-stu-id="43121-277">For more information on hello storage redundancy options, see hello links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-toodo-when-approaching-a-scalability-target"></a><span data-ttu-id="43121-278">接近的延展性目標時，哪些 toodo</span><span class="sxs-lookup"><span data-stu-id="43121-278">What toodo when approaching a scalability target</span></span>
<span data-ttu-id="43121-279">如果您的應用程式已接近 hello 單一儲存體帳戶的延展性目標，請考慮採用下列方法 hello 的其中一個：</span><span class="sxs-lookup"><span data-stu-id="43121-279">If your application is approaching hello scalability targets for a single storage account, consider adopting one of hello following approaches:</span></span>  

* <span data-ttu-id="43121-280">考慮會導致應用程式 tooapproach 的 hello 工作負載，或超出 hello 延展性目標。</span><span class="sxs-lookup"><span data-stu-id="43121-280">Reconsider hello workload that causes your application tooapproach or exceed hello scalability target.</span></span> <span data-ttu-id="43121-281">可以在設計以不同的方式較少的頻寬或容量或較少的交易 toouse 嗎？</span><span class="sxs-lookup"><span data-stu-id="43121-281">Can you design it differently toouse less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="43121-282">如果應用程式必須超過 hello 延展性目標的其中一個，您應該建立多個儲存體帳戶和資料分割應用程式資料的多個儲存體帳戶間。</span><span class="sxs-lookup"><span data-stu-id="43121-282">If an application must exceed one of hello scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="43121-283">如果您使用此模式，則是確定 toodesign 您的應用程式，讓您可以新增更多的儲存體帳戶中 hello 未來進行負載平衡。</span><span class="sxs-lookup"><span data-stu-id="43121-283">If you use this pattern, then be sure toodesign your application so that you can add more storage accounts in hello future for load balancing.</span></span> <span data-ttu-id="43121-284">在撰寫本文時，每個 Azure 訂用帳戶可以有 too100 儲存體帳戶。</span><span class="sxs-lookup"><span data-stu-id="43121-284">At time of writing, each Azure subscription can have up too100 storage accounts.</span></span>  <span data-ttu-id="43121-285">除了儲存資料、進行交易或傳輸資料等使用方式外，儲存體帳戶也不會有其他費用。</span><span class="sxs-lookup"><span data-stu-id="43121-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="43121-286">如果您的應用程式叫用 hello 頻寬目標時，請考慮壓縮 hello 用戶端 tooreduce hello 所需的頻寬 toosend hello 資料 toohello 儲存體服務中的資料。</span><span class="sxs-lookup"><span data-stu-id="43121-286">If your application hits hello bandwidth targets, consider compressing data in hello client tooreduce hello bandwidth required toosend hello data toohello storage service.</span></span>  <span data-ttu-id="43121-287">請注意，在節省頻寬並提高網路效能的同時，這也可能出現某些負面影響。</span><span class="sxs-lookup"><span data-stu-id="43121-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="43121-288">您應該評估這個到期 toohello 其他的處理需求來壓縮和解壓縮資料 hello 用戶端中的 hello 效能影響。</span><span class="sxs-lookup"><span data-stu-id="43121-288">You should evaluate hello performance impact of this due toohello additional processing requirements for compressing and decompressing data in hello client.</span></span> <span data-ttu-id="43121-289">此外，儲存壓縮的資料可讓更困難 tootroubleshoot 問題，因為它可能是使用標準工具更難 tooview 儲存資料。</span><span class="sxs-lookup"><span data-stu-id="43121-289">In addition, storing compressed data can make it more difficult tootroubleshoot issues since it could be more difficult tooview stored data using standard tools.</span></span>
* <span data-ttu-id="43121-290">如果您的應用程式叫用 hello 延展性目標時，請確定您使用指數型輪詢重試 (請參閱[重試](#subheading14))。</span><span class="sxs-lookup"><span data-stu-id="43121-290">If your application hits hello scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="43121-291">它的較佳 toomake 確定永遠不會處理 hello 延展性目標 （透過使用其中一個方法上方的 hello），但這可確保您的應用程式將不會只維持快速重試，進行節流變差的 hello。</span><span class="sxs-lookup"><span data-stu-id="43121-291">It's better toomake sure you never approach hello scalability targets (by using one of hello above methods), but this will ensure your application won't just keep retrying rapidly, making hello throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="43121-292">有用資源</span><span class="sxs-lookup"><span data-stu-id="43121-292">Useful Resources</span></span>
<span data-ttu-id="43121-293">下列連結查看 hello 提供延展性目標的其他詳細資料：</span><span class="sxs-lookup"><span data-stu-id="43121-293">hello following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="43121-294">如需延展性目標的資訊，請參閱 [Azure 儲存體延展性和效能目標](storage-scalability-targets.md) 。</span><span class="sxs-lookup"><span data-stu-id="43121-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="43121-295">請參閱[Azure 儲存體複寫](storage-redundancy.md)hello 部落格文章和[Azure 儲存體備援選項和讀取權限地理備援儲存體](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx)有關儲存體備援選項。</span><span class="sxs-lookup"><span data-stu-id="43121-295">See [Azure Storage replication](storage-redundancy.md) and hello blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="43121-296">如需 Azure 服務定價的最新資訊，請參閱 [Azure 定價](https://azure.microsoft.com/pricing/overview/)。</span><span class="sxs-lookup"><span data-stu-id="43121-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="43121-297"><a name="subheading47"></a>分割區命名慣例</span><span class="sxs-lookup"><span data-stu-id="43121-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="43121-298">Azure 儲存體使用範圍架構的資料分割配置 tooscale 和負載平衡 hello 系統。</span><span class="sxs-lookup"><span data-stu-id="43121-298">Azure Storage uses a range-based partitioning scheme tooscale and load balance hello system.</span></span> <span data-ttu-id="43121-299">hello 資料分割索引鍵已使用的 toopartition 資料成範圍，而且這些範圍系統中都是負載平衡 hello。</span><span class="sxs-lookup"><span data-stu-id="43121-299">hello partition key is used toopartition data into ranges and these ranges are load-balanced across hello system.</span></span> <span data-ttu-id="43121-300">這表示例如語彙排序 （例如 msftpayroll、 msftperformance、 msftemployees 等等），或使用時間戳記 （log20160101、 log20160102、 log20160102 等等） 的命名慣例將共享 toohello 資料分割正在潛在共置於 hello相同資料分割伺服器上，直到負載平衡作業會將它們分成較小的範圍。</span><span class="sxs-lookup"><span data-stu-id="43121-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself toohello partitions being potentially co-located on hello same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="43121-301">例如，容器內的所有 blob 會都提供由單一伺服器上，直到 hello 負載這些 blob 需要進一步重新平衡 hello 分割區範圍。</span><span class="sxs-lookup"><span data-stu-id="43121-301">For example, all blobs within a container can be served by a single server until hello load on these blobs requires further rebalancing of hello partition ranges.</span></span> <span data-ttu-id="43121-302">同樣地，一群輕的帳戶，以語彙順序排列其名稱可能會提供服務由單一伺服器 hello 直到載入上一個或所有這些帳戶都需要它們 toobe 分割跨越多個資料分割伺服器。</span><span class="sxs-lookup"><span data-stu-id="43121-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until hello load on one or all of these accounts require them toobe split across multiple partitions servers.</span></span> <span data-ttu-id="43121-303">每項負載平衡作業可能會影響 hello 延遲的儲存體呼叫 hello 作業期間。</span><span class="sxs-lookup"><span data-stu-id="43121-303">Each load balancing operation may impact hello latency of storage calls during hello operation.</span></span> <span data-ttu-id="43121-304">hello 系統的能力 toohandle 突然出現尖峰流量 tooa 磁碟分割的單一資料分割伺服器 hello 延展性受限於直到 hello 負載平衡作業已盡力而為中，重新平衡 hello 資料分割索引鍵範圍。</span><span class="sxs-lookup"><span data-stu-id="43121-304">hello system's ability toohandle a sudden burst of traffic tooa partition is limited by hello scalability of a single partition server until hello load balancing operation kicks-in and rebalances hello partition key range.</span></span>  

<span data-ttu-id="43121-305">您可以依照這類作業某些最佳作法 tooreduce hello 頻率。</span><span class="sxs-lookup"><span data-stu-id="43121-305">You can follow some best practices tooreduce hello frequency of such operations.</span></span>  

* <span data-ttu-id="43121-306">請檢查您使用的帳戶、 容器、 blob、 資料表和佇列，密切 hello 命名慣例。</span><span class="sxs-lookup"><span data-stu-id="43121-306">Examine hello naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="43121-307">請考慮使用最符合您需求的雜湊函數，在帳戶名稱前加上 3 位數的雜湊。</span><span class="sxs-lookup"><span data-stu-id="43121-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="43121-308">如果您將組織資料，可使用時間戳記或數字識別元，則必須 tooensure 您不使用僅附加 （或僅前面加上） 的流量模式。</span><span class="sxs-lookup"><span data-stu-id="43121-308">If you organize your data using timestamps or numerical identifiers, you have tooensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="43121-309">這些模式並不適合範圍為基礎系統、 分割及無法負責人 tooall hello 流量進入 tooa 單一資料分割和限制 hello 系統從有效負載平衡。</span><span class="sxs-lookup"><span data-stu-id="43121-309">These patterns are not suitable for a range -based partitioning system, and could lead tooall hello traffic going tooa single partition and limiting hello system from effectively load balancing.</span></span> <span data-ttu-id="43121-310">比方說，如果您有每日使用時間戳記，例如 yyyymmdd，然後 hello 的所有流量 blob 物件的每日作業的作業會導向 tooa 單一物件由單一資料分割伺服器。</span><span class="sxs-lookup"><span data-stu-id="43121-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all hello traffic for that daily operation is directed tooa single object which is served by a single partition server.</span></span> <span data-ttu-id="43121-311">看看是否會限制每個 blob 的 hello 和限制您的需求和分解成多個 blob 的這項作業，如有需要請考慮每個資料分割。</span><span class="sxs-lookup"><span data-stu-id="43121-311">Look at whether hello per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="43121-312">同樣地，如果您在資料表中儲存時間序列資料，可能是 hello 的所有流量導向 toohello 最後一部分 hello 索引鍵的命名空間。</span><span class="sxs-lookup"><span data-stu-id="43121-312">Similarly, if you store time series data in your tables, all hello traffic could be directed toohello last part of hello key namespace.</span></span> <span data-ttu-id="43121-313">如果您必須使用時間戳記或數字的識別碼，作為前置詞 hello 識別碼與 3 位數雜湊或時間戳記前置詞 hello 秒數部分 hello 時間，例如 ssyyyymmdd hello 案例。</span><span class="sxs-lookup"><span data-stu-id="43121-313">If you must use timestamps or numerical IDs, prefix hello id with a 3-digit hash, or in hello case of timestamps prefix hello seconds part of hello time such as ssyyyymmdd.</span></span> <span data-ttu-id="43121-314">如果定期執行列出和查詢作業，請選擇會限制查詢次數的雜湊函數。</span><span class="sxs-lookup"><span data-stu-id="43121-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="43121-315">其他情況，隨機的前置詞即足以應付。</span><span class="sxs-lookup"><span data-stu-id="43121-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="43121-316">其他資料分割配置使用 Azure 儲存體中的 hello 的詳細資訊，請參閱 hello sosp 文件[這裡](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf)。</span><span class="sxs-lookup"><span data-stu-id="43121-316">For additional information on hello partitioning scheme used in Azure Storage, read hello SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="43121-317">網路</span><span class="sxs-lookup"><span data-stu-id="43121-317">Networking</span></span>
<span data-ttu-id="43121-318">Hello API 呼叫上述不相關，而通常 hello 實體網路的條件約束 hello 應用程式效能造成顯著的影響。</span><span class="sxs-lookup"><span data-stu-id="43121-318">While hello API calls matter, often hello physical network constraints of hello application have a significant impact on performance.</span></span> <span data-ttu-id="43121-319">hello 以下說明的某些使用者可能會遇到的限制。</span><span class="sxs-lookup"><span data-stu-id="43121-319">hello following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="43121-320">用戶端網路功能</span><span class="sxs-lookup"><span data-stu-id="43121-320">Client Network Capability</span></span>
##### <span data-ttu-id="43121-321"><a name="subheading2"></a>輸送量</span><span class="sxs-lookup"><span data-stu-id="43121-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="43121-322">為了使頻寬，hello 問題通常是 hello hello 用戶端功能。</span><span class="sxs-lookup"><span data-stu-id="43121-322">For bandwidth, hello problem is often hello capabilities of hello client.</span></span> <span data-ttu-id="43121-323">例如，當單一儲存體帳戶可處理 10 Gbps 以上的輸入時 (請參閱[頻寬延展性目標](#sub1bandwidth))，「 小型 」 的 Azure 背景工作角色執行個體中的 hello 網路速度，才能夠大約 100 Mbps。</span><span class="sxs-lookup"><span data-stu-id="43121-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), hello network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="43121-324">較大型的 Azure 執行個體擁有較大容量的 NIC，因此，如果您需要單一機器的較高網路限制，您應考慮使用較大型的執行個體或更多的 VM。</span><span class="sxs-lookup"><span data-stu-id="43121-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="43121-325">如果您要從開啟的內部部署應用程式存取儲存體服務，則 hello 相同規則適用於： 了解 hello 的 hello 用戶端裝置和 hello 網路連線 toohello Azure 儲存體位置的網路功能，並可改善這些視或設計您的應用程式 toowork 內其功能。</span><span class="sxs-lookup"><span data-stu-id="43121-325">If you are accessing a Storage service from an on premises application, then hello same rule applies: understand hello network capabilities of hello client device and hello network connectivity toohello Azure Storage location and either improve them as needed or design your application toowork within their capabilities.</span></span>  

##### <span data-ttu-id="43121-326"><a name="subheading3"></a>連結品質</span><span class="sxs-lookup"><span data-stu-id="43121-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="43121-327">與任何網路使用方式一樣，請留意導致錯誤和封包遺失的網路狀況將會減慢有效的輸送量。</span><span class="sxs-lookup"><span data-stu-id="43121-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="43121-328">使用 WireShark 或 NetMon 可能有助於診斷此問題。</span><span class="sxs-lookup"><span data-stu-id="43121-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="43121-329">有用資源</span><span class="sxs-lookup"><span data-stu-id="43121-329">Useful Resources</span></span>
<span data-ttu-id="43121-330">如需虛擬機器大小與所配置頻寬的詳細資訊，請參閱 [Windows VM 大小](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)或 [Linux VM 大小](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)。</span><span class="sxs-lookup"><span data-stu-id="43121-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="43121-331"><a name="subheading4"></a>位置</span><span class="sxs-lookup"><span data-stu-id="43121-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="43121-332">在任何分散式環境中，放置 hello 附近 toohello 伺服器的用戶端傳遞 hello 達到最佳效能。</span><span class="sxs-lookup"><span data-stu-id="43121-332">In any distributed environment, placing hello client near toohello server delivers in hello best performance.</span></span> <span data-ttu-id="43121-333">存取 Azure 儲存體與 hello 最低延遲，請針對您的用戶端 hello 最佳位置是 hello 內相同的 Azure 區域。</span><span class="sxs-lookup"><span data-stu-id="43121-333">For accessing Azure Storage with hello lowest latency, hello best location for your client is within hello same Azure region.</span></span> <span data-ttu-id="43121-334">例如，如果您擁有使用 Azure 儲存體的 Azure 網站，您應將這兩者置於單一區域內 (例如，美國西部或東南亞)。</span><span class="sxs-lookup"><span data-stu-id="43121-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="43121-335">這樣會減少 hello 延遲與成本的 hello — hello 撰寫本文時，在單一區域內的頻寬是免費的。</span><span class="sxs-lookup"><span data-stu-id="43121-335">This reduces hello latency and hello cost — at hello time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="43121-336">如果您的用戶端應用程式不會裝載在 Azure 中 （例如行動裝置應用程式或內部部署企業服務），然後再次將 hello 儲存體帳戶放在附近 toohello 裝置存取它，區域將通常降低延遲。</span><span class="sxs-lookup"><span data-stu-id="43121-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing hello storage account in a region near toohello devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="43121-337">如果您的用戶端分散的十分廣泛 (例如，有些用戶端在北美，有些在歐洲)，則您應考慮使用多個儲存體帳戶：一個位於北美地區，一個位於歐洲地區。</span><span class="sxs-lookup"><span data-stu-id="43121-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="43121-338">這將有助於 tooreduce 延遲兩個區域中的使用者。</span><span class="sxs-lookup"><span data-stu-id="43121-338">This will help tooreduce latency for users in both regions.</span></span> <span data-ttu-id="43121-339">這種方法時，通常更容易 tooimplement hello 資料 hello 應用程式存放區為特定 tooindividual users，而且不需要儲存體帳戶之間複寫資料。</span><span class="sxs-lookup"><span data-stu-id="43121-339">This approach is usually easier tooimplement if hello data hello application stores is specific tooindividual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="43121-340">廣泛的內容發佈，建議使用 CDN – 請參閱 hello 下一節，如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="43121-340">For broad content distribution, a CDN is recommended – see hello next section for more details.</span></span>  

### <span data-ttu-id="43121-341"><a name="subheading5"></a>內容發佈</span><span class="sxs-lookup"><span data-stu-id="43121-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="43121-342">有時候，在位於相同的內容 toomany 使用者 （例如產品示範 hello 首頁上的網站中使用的視訊），應用程式需求 tooserve hello hello 同一個或多個區域。</span><span class="sxs-lookup"><span data-stu-id="43121-342">Sometimes, an application needs tooserve hello same content toomany users (e.g. a product demo video used in hello home page of a website), located in either hello same or multiple regions.</span></span> <span data-ttu-id="43121-343">在此案例中，您應該使用內容傳遞網路 (CDN)，例如 Azure CDN，hello CDN 會使用 Azure 儲存體，當做 hello hello 資料來源。</span><span class="sxs-lookup"><span data-stu-id="43121-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and hello CDN would use Azure storage as hello origin of hello data.</span></span> <span data-ttu-id="43121-344">不同的 Azure 儲存體帳戶存在於單一區域，無法將內容傳遞低延遲 tooother 區域，Azure CDN 會使用伺服器 hello 世界各地的多個資料中心內。</span><span class="sxs-lookup"><span data-stu-id="43121-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency tooother regions, Azure CDN uses servers in multiple data centers around hello world.</span></span> <span data-ttu-id="43121-345">此外，CDN 通常可以支援比單一儲存體帳戶高很多的輸出限制。</span><span class="sxs-lookup"><span data-stu-id="43121-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="43121-346">如需 Azure CDN 的詳細資訊，請參閱 [Azure CDN](https://azure.microsoft.com/services/cdn/)。</span><span class="sxs-lookup"><span data-stu-id="43121-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="43121-347"><a name="subheading6"></a>使用 SAS 和 CORS</span><span class="sxs-lookup"><span data-stu-id="43121-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="43121-348">當您需要 JavaScript 等使用者 web 瀏覽器或 Azure 儲存體中的行動電話應用程式 tooaccess 資料中的 tooauthorize 程式碼時，其中一個方法是 toouse 做為 proxy 的 web 角色中的應用程式： hello 使用者的裝置驗證 hello web 角色，其在開啟驗證與 hello 儲存體服務。</span><span class="sxs-lookup"><span data-stu-id="43121-348">When you need tooauthorize code such as JavaScript in a user's web browser or a mobile phone app tooaccess data in Azure Storage, one approach is toouse an application in web role as a proxy: hello user's device authenticates with hello web role, which in turn authenticates with hello storage service.</span></span> <span data-ttu-id="43121-349">如此一來，您可以避免在未受到保護的裝置上公開您的儲存體帳戶金鑰。</span><span class="sxs-lookup"><span data-stu-id="43121-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="43121-350">然而，這會造成較大的工作負擔 hello web 角色上因為 hello 使用者的裝置之間傳送的 hello 的所有資料和 hello 儲存體服務都必須經過 hello web 角色。</span><span class="sxs-lookup"><span data-stu-id="43121-350">However, this places a big overhead on hello web role because all hello data transferred between hello user's device and hello storage service must pass through hello web role.</span></span> <span data-ttu-id="43121-351">您可以避免跨原始資源共用標頭 」 (CORS) 搭配使用共用存取簽章 (SAS)，有時也做為 proxy 使用 web 角色 hello 儲存體服務。</span><span class="sxs-lookup"><span data-stu-id="43121-351">You can avoid using a web role as a proxy for hello storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="43121-352">使用 SAS 時，您可以讓您的使用者裝置 toomake 要求直接 tooa 儲存體服務透過有限的存取語彙基元。</span><span class="sxs-lookup"><span data-stu-id="43121-352">Using SAS, you can allow your user's device toomake requests directly tooa storage service by means of a limited access token.</span></span> <span data-ttu-id="43121-353">比方說，如果使用者想 tooupload 相片 tooyour 應用程式時，web 角色就可以產生並傳送 toohello 使用者的裝置會授與權限 toowrite tooa 特定 blob 或容器 hello （hello SAS 權杖過期前） 的 下一步 30 分鐘的 SAS 權杖。</span><span class="sxs-lookup"><span data-stu-id="43121-353">For example, if a user wants tooupload a photo tooyour application, your web role can generate and send toohello user's device a SAS token that grants permission toowrite tooa specific blob or container for hello next 30 minutes (after which hello SAS token expires).</span></span>

<span data-ttu-id="43121-354">一般來說，在瀏覽器將不允許 JavaScript 等"PUT"tooanother 網域一個網域 tooperform 作業特定的網站所裝載的網頁中。</span><span class="sxs-lookup"><span data-stu-id="43121-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain tooperform specific operations such as a "PUT" tooanother domain.</span></span> <span data-ttu-id="43121-355">例如，如果您裝載 web 角色在"contosomarketing.cloudapp.net 」，並想 toouse 用戶端端 JavaScript tooupload"contosoproducts.blob.core.windows.net"blob tooyour 儲存體帳戶，hello 瀏覽器的 「 相同來源原則 」 將禁止這作業。</span><span class="sxs-lookup"><span data-stu-id="43121-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want toouse client side JavaScript tooupload a blob tooyour storage account at "contosoproducts.blob.core.windows.net," hello browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="43121-356">CORS 是瀏覽器的功能，可讓 hello 目標網域 （在此案例的 hello 儲存體帳戶） toocommunicate toohello 瀏覽器信任要求源自於 hello 來源網域中 （在此案例的 hello 的 web 角色）。</span><span class="sxs-lookup"><span data-stu-id="43121-356">CORS is a browser feature that allows hello target domain (in this case hello storage account) toocommunicate toohello browser that it trusts requests originating in hello source domain (in this case hello web role).</span></span>  

<span data-ttu-id="43121-357">這些技術可協助您避免 Web 應用程式上的不必要負荷 (和瓶頸)。</span><span class="sxs-lookup"><span data-stu-id="43121-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="43121-358">有用資源</span><span class="sxs-lookup"><span data-stu-id="43121-358">Useful Resources</span></span>
<span data-ttu-id="43121-359">如需 SAS 的詳細資訊，請參閱[共用存取簽章，第 1 部分： 了解 hello SAS 模型](storage-dotnet-shared-access-signature-part-1.md)。</span><span class="sxs-lookup"><span data-stu-id="43121-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding hello SAS Model](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="43121-360">如需有關 CORS 的詳細資訊，請參閱[hello Azure 儲存體服務的跨原始資源共用 (CORS) 支援](http://msdn.microsoft.com/library/azure/dn535601.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43121-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for hello Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="43121-361">快取</span><span class="sxs-lookup"><span data-stu-id="43121-361">Caching</span></span>
#### <span data-ttu-id="43121-362"><a name="subheading7"></a>取得資料</span><span class="sxs-lookup"><span data-stu-id="43121-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="43121-363">一般來說，從服務中一次取得資料勝過分兩次取得資料。</span><span class="sxs-lookup"><span data-stu-id="43121-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="43121-364">請考慮 MVC web 應用程式執行 web 角色已從 hello 儲存體服務 tooserve 內容 tooa 使用者擷取 50 MB blob 中的 hello 範例。</span><span class="sxs-lookup"><span data-stu-id="43121-364">Consider hello example of an MVC web application running in a web role that has already retrieved a 50MB blob from hello storage service tooserve as content tooa user.</span></span> <span data-ttu-id="43121-365">hello 應用程式無法擷取該相同 blob 每次使用者要求，或它可以快取在本機 toodisk 和重複使用 hello 快取的版本的後續使用者要求。</span><span class="sxs-lookup"><span data-stu-id="43121-365">hello application could then retrieve that same blob every time a user requests it, or it could cache it locally toodisk and reuse hello cached version for subsequent user requests.</span></span> <span data-ttu-id="43121-366">此外，每當使用者要求 hello 資料時，hello 應用程式可以發出 GET 與條件式標頭修改時間，這會避免發生 hello 整個 blob。 如果它尚未被修改。</span><span class="sxs-lookup"><span data-stu-id="43121-366">Furthermore, whenever a user requests hello data, hello application could issue GET with a conditional header for modification time, which would avoid getting hello entire blob if it hasn't been modified.</span></span> <span data-ttu-id="43121-367">您可以套用這個相同的模式 tooworking 資料表實體。</span><span class="sxs-lookup"><span data-stu-id="43121-367">You can apply this same pattern tooworking with table entities.</span></span>  

<span data-ttu-id="43121-368">在某些情況下，您可能會決定您的應用程式可以假設該 hello blob 擷取它，而且，在此期間 hello 期間應用程式不需要 toocheck 如果 hello blob 已修改後的短暫仍然有效。</span><span class="sxs-lookup"><span data-stu-id="43121-368">In some cases, you may decide that your application can assume that hello blob remains valid for a short period after retrieving it, and that during this period hello application does not need toocheck if hello blob was modified.</span></span>

<span data-ttu-id="43121-369">設定、 查閱和 hello 應用程式永遠會使用其他資料是很好的候選項快取。</span><span class="sxs-lookup"><span data-stu-id="43121-369">Configuration, lookup, and other data that are always used by hello application are great candidates for caching.</span></span>  

<span data-ttu-id="43121-370">如需如何 tooget blob 的內容 toodiscover hello 的上次修改日期的範例使用.NET，請參閱[設定和擷取屬性和中繼資料](storage-properties-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="43121-370">For an example of how tooget a blob's properties toodiscover hello last modified date using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span> <span data-ttu-id="43121-371">如需條件式下載的詳細資訊，請參閱 [有條件地重新整理 Blob 的本機複本](http://msdn.microsoft.com/library/azure/dd179371.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43121-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="43121-372"><a name="subheading8"></a>以批次方式上傳資料</span><span class="sxs-lookup"><span data-stu-id="43121-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="43121-373">在某些應用程式案例中，您可以在本機彙總資料，然後以批次方式將它定期上傳，而非立即上傳每一份資料。</span><span class="sxs-lookup"><span data-stu-id="43121-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="43121-374">例如，web 應用程式可能會保留的活動記錄檔： hello 應用程式可能是上傳的每個活動的詳細資料發生視為資料表實體 （這需要許多儲存體作業），或其無法儲存活動詳細資料 tooa 本機記錄檔，然後按一下以分隔的檔案 tooa blob 定期上傳所有活動詳細資料。</span><span class="sxs-lookup"><span data-stu-id="43121-374">For example, a web application might keep a log file of activities: hello application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details tooa local log file, and then periodically upload all activity details as a delimited file tooa blob.</span></span> <span data-ttu-id="43121-375">如果每個記錄項目大小為 1 KB，您可以上傳千分位在單一的 「 Put Blob 」 交易 （您可以將 blob 上傳的總大小，在單一交易中 too64MB）。</span><span class="sxs-lookup"><span data-stu-id="43121-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up too64MB in size in a single transaction).</span></span> <span data-ttu-id="43121-376">當然，如果 hello 本機電腦當機前 toohello 上傳，您將可能遺失某些記錄檔資料： hello 應用程式開發人員必須設計為用戶端裝置 hello 可能性或上傳失敗。</span><span class="sxs-lookup"><span data-stu-id="43121-376">Of course, if hello local machine crashes prior toohello upload, you will potentially lose some log data: hello application developer must design for hello possibility of client device or upload failures.</span></span>  <span data-ttu-id="43121-377">如果 hello 活動資料需要 toobe 下載的時間範圍 （不是單一活動），blob 會建議資料表。</span><span class="sxs-lookup"><span data-stu-id="43121-377">If hello activity data needs toobe downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="43121-378">.NET 組態</span><span class="sxs-lookup"><span data-stu-id="43121-378">.NET Configuration</span></span>
<span data-ttu-id="43121-379">如果使用 hello.NET Framework，此區段會列出您可以使用 toomake 顯著的效能改善的數個快速的組態設定。</span><span class="sxs-lookup"><span data-stu-id="43121-379">If using hello .NET Framework, this section lists several quick configuration settings that you can use toomake significant performance improvements.</span></span>  <span data-ttu-id="43121-380">如果使用其他語言，請檢查 toosee 如果類似的概念適用於您所選擇的語言。</span><span class="sxs-lookup"><span data-stu-id="43121-380">If using other languages, check toosee if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="43121-381"><a name="subheading9"></a>提高預設的連線限制</span><span class="sxs-lookup"><span data-stu-id="43121-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="43121-382">在.NET 中，下列程式碼的 hello 增加 hello 預設連線限制 （這通常是 2 的用戶端環境中或在伺服器環境中的 10） too100。</span><span class="sxs-lookup"><span data-stu-id="43121-382">In .NET, hello following code increases hello default connection limit (which is usually 2 in a client environment or 10 in a server environment) too100.</span></span> <span data-ttu-id="43121-383">一般而言，您應該設定應用程式所使用的執行緒 hello 值 tooapproximately hello 的數目。</span><span class="sxs-lookup"><span data-stu-id="43121-383">Typically, you should set hello value tooapproximately hello number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="43121-384">您必須設定 hello 連線限制，才開啟任何連接。</span><span class="sxs-lookup"><span data-stu-id="43121-384">You must set hello connection limit before opening any connections.</span></span>  

<span data-ttu-id="43121-385">其他程式設計語言，請參閱該語言的文件 toodetermine tooset hello 連線的數量限制。</span><span class="sxs-lookup"><span data-stu-id="43121-385">For other programming languages, see that language's documentation toodetermine how tooset hello connection limit.</span></span>  

<span data-ttu-id="43121-386">如需詳細資訊，請參閱 hello 部落格文章[Web 服務： 並行連線](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43121-386">For additional information, see hello blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="43121-387"><a name="subheading10"></a>如果使用同步程式碼搭配 Async Task，則提高 ThreadPool 的執行緒數量下限</span><span class="sxs-lookup"><span data-stu-id="43121-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="43121-388">此程式碼將會增加 hello 執行緒集區最小值：</span><span class="sxs-lookup"><span data-stu-id="43121-388">This code will increase hello thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine hello right number for your application)  
```

<span data-ttu-id="43121-389">如需詳細資訊，請參閱 [ThreadPool.SetMinThreads 方法](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43121-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="43121-390"><a name="subheading11"></a>充分運用 .NET 4.5 記憶體回收</span><span class="sxs-lookup"><span data-stu-id="43121-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="43121-391">Hello 用戶端應用程式的伺服器記憶體回收中的效能改進的 tootake 優點適用於.NET 4.5 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="43121-391">Use .NET 4.5 or later for hello client application tootake advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="43121-392">如需詳細資訊，請參閱 hello 文章[概觀的效能改進中.NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43121-392">For more information, see hello article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="43121-393"><a name="subheading12"></a>無限制的平行處理原則</span><span class="sxs-lookup"><span data-stu-id="43121-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="43121-394">雖然平行處理原則可能很大的效能，請小心使用 unbounded 平行處理原則 （hello 執行緒及/或平行要求數目沒有限制） tooupload 或下載資料、 使用多個工作者 tooaccess 多個資料分割 (容器、 佇列，或資料表資料分割） 中請 hello 相同儲存體帳戶或 tooaccess hello 中的多個項目相同的資料分割。</span><span class="sxs-lookup"><span data-stu-id="43121-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on hello number of threads and/or parallel requests) tooupload or download data, using multiple workers tooaccess multiple partitions (containers, queues, or table partitions) in hello same storage account or tooaccess multiple items in hello same partition.</span></span> <span data-ttu-id="43121-395">Hello 平行處理原則未繫結，如果您的應用程式可以超過 hello 用戶端裝置的功能，或者 hello 導致較長的延遲和節流的儲存體帳戶的延展性目標。</span><span class="sxs-lookup"><span data-stu-id="43121-395">If hello parallelism is unbounded, your application can exceed hello client device's capabilities or hello storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="43121-396"><a name="subheading13"></a>儲存體用戶端程式庫和工具</span><span class="sxs-lookup"><span data-stu-id="43121-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="43121-397">一律使用最新版 Microsoft 提供的用戶端程式庫 hello 和工具。</span><span class="sxs-lookup"><span data-stu-id="43121-397">Always use hello latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="43121-398">在 hello 撰寫本文時，有適用於.NET、 Windows Phone、 Windows 執行階段、 Java 和 c + + 的用戶端程式庫，以及針對其他語言的預覽文件庫。</span><span class="sxs-lookup"><span data-stu-id="43121-398">At hello time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="43121-399">此外，Microsoft 也推出 PowerShell Cmdlet 和 Azure CLI 命令，可與 Azure 儲存體搭配使用。</span><span class="sxs-lookup"><span data-stu-id="43121-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="43121-400">Microsoft 主動開發這些工具與效能，請注意，保持 toodate hello 最新的服務版本，並確保這些 helper 能夠處理許多 hello 內部通過驗證的效能最佳。</span><span class="sxs-lookup"><span data-stu-id="43121-400">Microsoft actively develops these tools with performance in mind, keeps them up toodate with hello latest service versions, and ensures they handle many of hello proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="43121-401">重試</span><span class="sxs-lookup"><span data-stu-id="43121-401">Retries</span></span>
#### <span data-ttu-id="43121-402"><a name="subheading14"></a>節流/ServerBusy</span><span class="sxs-lookup"><span data-stu-id="43121-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="43121-403">在某些情況下，hello 儲存體服務會進行節流處理您的應用程式或可能只是無法 tooserve hello 要求，因為 toosome 暫時性狀況與傳回 「 500 逾時 」 或 「 503 伺服器忙碌中 」 訊息。</span><span class="sxs-lookup"><span data-stu-id="43121-403">In some cases, hello storage service may throttle your application or may simply be unable tooserve hello request due toosome transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="43121-404">如果您的應用程式即將任何 hello 延展性目標，或是 hello 系統會重新平衡您的資料分割的資料 tooallow 的較高的輸送量，也可能會發生。</span><span class="sxs-lookup"><span data-stu-id="43121-404">This can happen if your application is approaching any of hello scalability targets, or if hello system is rebalancing your partitioned data tooallow for higher throughput.</span></span>  <span data-ttu-id="43121-405">hello 用戶端應用程式通常應該重試 hello 作業會造成這類錯誤： 嘗試的 hello 相同要求稍後才會成功。</span><span class="sxs-lookup"><span data-stu-id="43121-405">hello client application should typically retry hello operation that causes such an error: attempting hello same request later can succeed.</span></span> <span data-ttu-id="43121-406">不過，如果 hello 儲存體服務節流處理您的應用程式，因為它超出延展性目標或即使 hello 服務因其他原因是無法 tooserve hello 提出要求時，積極重試通常會使 hello 問題更加複雜。</span><span class="sxs-lookup"><span data-stu-id="43121-406">However, if hello storage service is throttling your application because it is exceeding scalability targets, or even if hello service was unable tooserve hello request for some other reason, aggressive retries usually make hello problem worse.</span></span> <span data-ttu-id="43121-407">基於這個理由，您應該使用指數回關 （hello 用戶端程式庫預設 toothis 行為）。</span><span class="sxs-lookup"><span data-stu-id="43121-407">For this reason, you should use an exponential back off (hello client libraries default toothis behavior).</span></span> <span data-ttu-id="43121-408">例如，您的應用程式可能會在 2 秒後進行重試、然後 4 秒、然後 10 秒、然後 30 秒，最後會完全放棄。</span><span class="sxs-lookup"><span data-stu-id="43121-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="43121-409">這個行為會導致您的應用程式會大幅降低其 hello 服務上的負載，而非 exacerbating 任何問題。</span><span class="sxs-lookup"><span data-stu-id="43121-409">This behavior results in your application significantly reducing its load on hello service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="43121-410">請注意，連接錯誤可重試，因為它們不是節流的 hello 結果，而且會預期的 toobe 暫時性。</span><span class="sxs-lookup"><span data-stu-id="43121-410">Note that connectivity errors can be retried immediately, because they are not hello result of throttling and are expected toobe transient.</span></span>  

#### <span data-ttu-id="43121-411"><a name="subheading15"></a>無法重試的錯誤</span><span class="sxs-lookup"><span data-stu-id="43121-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="43121-412">hello 用戶端程式庫並知道哪些錯誤可重試，而且並不是。</span><span class="sxs-lookup"><span data-stu-id="43121-412">hello client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="43121-413">不過，如果您正在撰寫自己的程式碼對 hello 儲存體 REST API，請記住一些您應該不會重試的錯誤： 例如，400 （不正確的要求） 回應指出該 hello 用戶端應用程式傳送的要求，因為無法處理它未預期的格式。</span><span class="sxs-lookup"><span data-stu-id="43121-413">However, if you are writing your own code against hello storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that hello client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="43121-414">重新傳送此要求會導致 hello 相同的回應每次，因此沒有在重試該點。</span><span class="sxs-lookup"><span data-stu-id="43121-414">Resending this request will result hello same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="43121-415">如果您正在撰寫自己的程式碼對 hello 儲存體 REST API，請留意哪些 hello 錯誤碼平均值和 hello 的正確方式 tooretry （或停用） 針對每一項。</span><span class="sxs-lookup"><span data-stu-id="43121-415">If you are writing your own code against hello storage REST API, be aware of what hello error codes mean and hello proper way tooretry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="43121-416">有用資源</span><span class="sxs-lookup"><span data-stu-id="43121-416">Useful Resources</span></span>
<span data-ttu-id="43121-417">如需儲存體錯誤碼的詳細資訊，請參閱[狀態和錯誤碼](http://msdn.microsoft.com/library/azure/dd179382.aspx)hello Microsoft Azure 網站上。</span><span class="sxs-lookup"><span data-stu-id="43121-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on hello Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="43121-418">Blob</span><span class="sxs-lookup"><span data-stu-id="43121-418">Blobs</span></span>
<span data-ttu-id="43121-419">在加法 toohello 證實的作法[所有服務](#allservices)先前所述，證明作法 hello 下列套用特別 toohello blob 服務。</span><span class="sxs-lookup"><span data-stu-id="43121-419">In addition toohello proven practices for [All Services](#allservices) described previously, hello following proven practices apply specifically toohello blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="43121-420">Blob 特定的延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="43121-421"><a name="subheading46"></a>並行存取單一物件的多個用戶端</span><span class="sxs-lookup"><span data-stu-id="43121-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="43121-422">如果您有大量的並行存取單一物件的用戶端必須 tooconsider 每個物件和儲存體帳戶延展性目標。</span><span class="sxs-lookup"><span data-stu-id="43121-422">If you have a large number of clients accessing a single object concurrently you will need tooconsider per object and storage account scalability targets.</span></span> <span data-ttu-id="43121-423">hello 確切數目的用戶端可以存取的單一物件，將要求的用戶端 hello 物件同時 hello hello 物件大小的 hello 數目等因素而有所不同，網路狀況等。</span><span class="sxs-lookup"><span data-stu-id="43121-423">hello exact number of clients that can access a single object will vary depending on factors such as hello number of clients requesting hello object simultaneously, hello size of hello object, network conditions etc.</span></span>

<span data-ttu-id="43121-424">如果透過散發 hello 物件從網站的影像或視訊等 CDN 服務，則您應該使用 CDN。</span><span class="sxs-lookup"><span data-stu-id="43121-424">If hello object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="43121-425">請參閱 [這裡](#subheading5)。</span><span class="sxs-lookup"><span data-stu-id="43121-425">See [here](#subheading5).</span></span>

<span data-ttu-id="43121-426">在其他情況下，例如其中 hello 資料是機密的科學模擬您有兩個選項。</span><span class="sxs-lookup"><span data-stu-id="43121-426">In other scenarios such as scientific simulations where hello data is confidential you have two options.</span></span> <span data-ttu-id="43121-427">hello 第一個是的 toostagger 存取您的工作負載存取這類 hello 物件在一段時間與同步存取。</span><span class="sxs-lookup"><span data-stu-id="43121-427">hello first is toostagger your workload's access such that hello object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="43121-428">或者，您可以暫時複製因而增加 hello 每個物件，以及跨儲存體帳戶的 IOPS 總數的 hello 物件 toomultiple 儲存體帳戶。</span><span class="sxs-lookup"><span data-stu-id="43121-428">Alternatively, you can temporarily copy hello object toomultiple storage accounts thus increasing hello total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="43121-429">在有限的測試，我們發現，大約 25 Vm 無法同時下載由發佈 100 GB 的 blob，以平行方式 （每個 VM 的平行處理 hello 下載使用 32 個執行緒）。</span><span class="sxs-lookup"><span data-stu-id="43121-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing hello download using 32 threads).</span></span> <span data-ttu-id="43121-430">如果您有 100 個用戶端需要 tooaccess hello 物件時，先將它複製 tooa 第二個儲存體帳戶，擁有 hello 前 50 個 Vm 存取 hello 第一個 blob 然後 hello 50 第二個 Vm 存取 hello 第二個 blob。</span><span class="sxs-lookup"><span data-stu-id="43121-430">If you had 100 clients needing tooaccess hello object, first copy it tooa second storage account and then have hello first 50 VMs access hello first blob and hello second 50 VMs access hello second blob.</span></span> <span data-ttu-id="43121-431">結果將會視您的應用程式行為而有所不同，因此您應該在設計期間進行測試。</span><span class="sxs-lookup"><span data-stu-id="43121-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="43121-432"><a name="subheading16"></a>每個 Blob 的頻寬和作業</span><span class="sxs-lookup"><span data-stu-id="43121-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="43121-433">您可以讀取或寫入 tooa 單一 blob 在向上 tooa 最大值為 60 MB/秒 (這是大約 480 的 mbps 之間超過 hello 許多用戶端網路功能 (包括 hello hello 用戶端裝置上的實體 NIC)。</span><span class="sxs-lookup"><span data-stu-id="43121-433">You can read or write tooa single blob at up tooa maximum of 60 MB/second (this is approximately 480 Mbps which exceeds hello capabilities of many client side networks (including hello physical NIC on hello client device).</span></span> <span data-ttu-id="43121-434">此外，單一 blob 最多可支援 too500 每秒要求數。</span><span class="sxs-lookup"><span data-stu-id="43121-434">In addition, a single blob supports up too500 requests per second.</span></span> <span data-ttu-id="43121-435">如果您有多個用戶端需要 tooread hello 相同的 blob，並可能會超過這些限制，您應該考慮使用 CDN 發佈 hello blob。</span><span class="sxs-lookup"><span data-stu-id="43121-435">If you have multiple clients that need tooread hello same blob and you might exceed these limits, you should consider using a CDN for distributing hello blob.</span></span>  

<span data-ttu-id="43121-436">如需 Blob 的目標輸送量詳細資訊，請參閱 [Azure 儲存體延展性和效能目標](storage-scalability-targets.md)。</span><span class="sxs-lookup"><span data-stu-id="43121-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="43121-437">複製與移動 Blob</span><span class="sxs-lookup"><span data-stu-id="43121-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="43121-438"><a name="subheading17"></a>複製 Blob</span><span class="sxs-lookup"><span data-stu-id="43121-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="43121-439">跨帳戶 hello 儲存體 REST API 2012-02-12 版導入的 hello 有用能力 toocopy blob： 用戶端應用程式可以指示 hello 儲存體服務 toocopy 從 （可能位於不同的儲存體帳戶），另一個來源 blob，然後讓 hello服務會以非同步方式執行 hello 複製。</span><span class="sxs-lookup"><span data-stu-id="43121-439">hello storage REST API version 2012-02-12 introduced hello useful ability toocopy blobs across accounts: a client application can instruct hello storage service toocopy a blob from another source (possibly in a different storage account), and then let hello service perform hello copy asynchronously.</span></span> <span data-ttu-id="43121-440">這可以大幅降低 hello hello 應用程式時您是從其他儲存體帳戶將資料移轉，因為您不需要 toodownload 與 hello 資料上傳所需的頻寬。</span><span class="sxs-lookup"><span data-stu-id="43121-440">This can significantly reduce hello bandwidth needed for hello application when you are migrating data from other storage accounts because you do not need toodownload and upload hello data.</span></span>  

<span data-ttu-id="43121-441">一個考量，不過的不是，當儲存體帳戶之間進行複製，任何時間保證 hello 複製完成。</span><span class="sxs-lookup"><span data-stu-id="43121-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when hello copy will complete.</span></span> <span data-ttu-id="43121-442">如果您的應用程式需要的 toocomplete blob 快速複製您能夠控制，它可能更好的 toocopy hello blob 下載它 tooa VM，然後將它上傳 toohello 目的地。</span><span class="sxs-lookup"><span data-stu-id="43121-442">If your application needs toocomplete a blob copy quickly under your control, it may be better toocopy hello blob by downloading it tooa VM and then uploading it toohello destination.</span></span>  <span data-ttu-id="43121-443">在此情況下的完整可預測性，請確定 hello 複製在執行由 hello 中執行的 VM 相同的 Azure 區域，或其他網路狀況可能 （和可能會） 會影響您複製的效能。</span><span class="sxs-lookup"><span data-stu-id="43121-443">For full predictability in that situation, ensure that hello copy is performed by a VM running in hello same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="43121-444">此外，您可以透過程式設計方式監視 hello 進度的非同步複本。</span><span class="sxs-lookup"><span data-stu-id="43121-444">In addition, you can monitor hello progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="43121-445">請注意，相同的儲存體帳戶本身通常會迅速完成的 hello 內複製。</span><span class="sxs-lookup"><span data-stu-id="43121-445">Note that copies within hello same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="43121-446">如需詳細資訊，請參閱 [複製 Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43121-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="43121-447"><a name="subheading18"></a>使用 AzCopy</span><span class="sxs-lookup"><span data-stu-id="43121-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="43121-448">hello Azure 儲存體團隊發行了命令列工具 」 AzCopy"也就是它們的 toohelp 具有大量傳送至、 和儲存體帳戶間的許多 blob。</span><span class="sxs-lookup"><span data-stu-id="43121-448">hello Azure Storage team has released a command-line tool "AzCopy" that is meant toohelp with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="43121-449">此工具已針對此案例進行最佳化，且可達到高傳輸率。</span><span class="sxs-lookup"><span data-stu-id="43121-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="43121-450">建議在大量上傳、下載和複製案例中使用此工具。</span><span class="sxs-lookup"><span data-stu-id="43121-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="43121-451">詳細資訊，請參閱 toolearn 和下載，請參閱[hello AzCopy 命令列公用程式使用傳輸資料](storage-use-azcopy.md)。</span><span class="sxs-lookup"><span data-stu-id="43121-451">toolearn more about it and download it, see [Transfer data with hello AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="43121-452"><a name="subheading19"></a>Azure 匯入/匯出服務</span><span class="sxs-lookup"><span data-stu-id="43121-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="43121-453">Hello Azure 儲存體非常大量的資料 (超過 1 TB)，提供 hello 匯入/匯出服務，以便允許上傳和下載從 blob 儲存體傳送的硬碟機。</span><span class="sxs-lookup"><span data-stu-id="43121-453">For very large volumes of data (more than 1TB), hello Azure Storage offers hello Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="43121-454">您可以讓硬碟機上的資料並將它上傳，tooMicrosoft 或傳送空白的硬碟機 tooMicrosoft toodownload 資料。</span><span class="sxs-lookup"><span data-stu-id="43121-454">You can put your data on a hard drive and send it tooMicrosoft for upload, or send a blank hard drive tooMicrosoft toodownload data.</span></span>  <span data-ttu-id="43121-455">如需詳細資訊，請參閱[使用 hello Microsoft Azure 匯入/匯出服務 tooTransfer 資料 tooBlob 儲存體](storage-import-export-service.md)。</span><span class="sxs-lookup"><span data-stu-id="43121-455">For more information, see [Use hello Microsoft Azure Import/Export Service tooTransfer Data tooBlob Storage](storage-import-export-service.md).</span></span>  <span data-ttu-id="43121-456">這可以是比上傳/下載此磁碟區資料的 hello 網路上更有效率。</span><span class="sxs-lookup"><span data-stu-id="43121-456">This can be much more efficient than uploading/downloading this volume of data over hello network.</span></span>  

### <span data-ttu-id="43121-457"><a name="subheading20"></a>使用中繼資料</span><span class="sxs-lookup"><span data-stu-id="43121-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="43121-458">hello blob 服務支援標頭的要求，其中包含有關 hello blob 的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="43121-458">hello blob service supports head requests, which can include metadata about hello blob.</span></span> <span data-ttu-id="43121-459">例如，如果您的應用程式需要相片的 hello EXIF 資料，它無法擷取 hello 相片，並將它解壓縮。</span><span class="sxs-lookup"><span data-stu-id="43121-459">For example, if your application needed hello EXIF data out of a photo, it could retrieve hello photo and extract it.</span></span> <span data-ttu-id="43121-460">toosave 頻寬並提升效能，您的應用程式無法 hello EXIF 將資料儲存在 hello blob 的中繼資料時 hello 應用程式上傳相片 hello： 您可以再擷取 hello EXIF 資料使用只有 HEAD 要求的中繼資料中節省大量頻寬並且 hello 處理時間所需 tooextract hello EXIF 資料讀取每個時間 hello blob。</span><span class="sxs-lookup"><span data-stu-id="43121-460">toosave bandwidth and improve performance, your application could store hello EXIF data in hello blob's metadata when hello application uploaded hello photo: you can then retrieve hello EXIF data in metadata using only a HEAD request, saving significant bandwidth and hello processing time needed tooextract hello EXIF data each time hello blob is read.</span></span> <span data-ttu-id="43121-461">這會是適用於您只需要 hello 中繼資料，並不 hello 完整 blob 的內容的情況。</span><span class="sxs-lookup"><span data-stu-id="43121-461">This would be useful in scenarios where you only need hello metadata, and not hello full content of a blob.</span></span>  <span data-ttu-id="43121-462">請注意只有 8 KB 的中繼資料，可以儲存每個 blob （hello 服務不會接受要求 toostore 超過該值），所以如果該大小無法容納 hello 資料，您可能不是這種方法可以 toouse。</span><span class="sxs-lookup"><span data-stu-id="43121-462">Note that only 8 KB of metadata can be stored per blob (hello service will not accept a request toostore more than that), so if hello data does not fit in that size, you may not be able toouse this approach.</span></span>  

<span data-ttu-id="43121-463">如需如何 tooget blob 的中繼資料使用的.NET，請參閱[設定和擷取屬性和中繼資料](storage-properties-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="43121-463">For an example of how tooget a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="43121-464">快速上傳</span><span class="sxs-lookup"><span data-stu-id="43121-464">Uploading Fast</span></span>
<span data-ttu-id="43121-465">tooupload blobs 快速，第一個問題 tooanswer hello 是： 您上傳 blob 的一或多個？</span><span class="sxs-lookup"><span data-stu-id="43121-465">tooupload blobs fast, hello first question tooanswer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="43121-466">使用以下指南根據您的案例 toodetermine hello 正確方法 toouse hello。</span><span class="sxs-lookup"><span data-stu-id="43121-466">Use hello below guidance toodetermine hello correct method toouse depending on your scenario.</span></span>  

#### <span data-ttu-id="43121-467"><a name="subheading21"></a>快速上傳一個大型 Blob</span><span class="sxs-lookup"><span data-stu-id="43121-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="43121-468">單一大型 blob 快速 tooupload，用戶端應用程式應上傳的區塊或以平行方式 （要注意 hello 個別 blob 和整體 hello 儲存體帳戶的延展性目標） 的頁面。</span><span class="sxs-lookup"><span data-stu-id="43121-468">tooupload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of hello scalability targets for individual blobs and hello storage account as a whole).</span></span>  <span data-ttu-id="43121-469">請注意，hello 官方 Microsoft 薽俇 RTM 儲存體用戶端程式庫 （.NET、 Java） hello 能力 toodo 這。</span><span class="sxs-lookup"><span data-stu-id="43121-469">Note that hello official Microsoft-provided RTM Storage Client libraries (.NET, Java) have hello ability toodo this.</span></span>  <span data-ttu-id="43121-470">針對每個 hello 文件庫中，使用以下指定的物件屬性 tooset hello 並行存取層級的 hello:</span><span class="sxs-lookup"><span data-stu-id="43121-470">For each of hello libraries, use hello below specified object/property tooset hello level of concurrency:</span></span>  

* <span data-ttu-id="43121-471">.NET： 集 ParallelOperationThreadCount 用 BlobRequestOptions 物件 toobe 上。</span><span class="sxs-lookup"><span data-stu-id="43121-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object toobe used.</span></span>
* <span data-ttu-id="43121-472">Java/Android：使用 BlobRequestOptions.setConcurrentRequestCount()</span><span class="sxs-lookup"><span data-stu-id="43121-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="43121-473">Node.js： 使用 parallelOperationThreadCount 任一 hello 要求選項或 hello blob 服務上。</span><span class="sxs-lookup"><span data-stu-id="43121-473">Node.js: Use parallelOperationThreadCount on either hello request options or on hello blob service.</span></span>
* <span data-ttu-id="43121-474">C + +: 使用 hello blob_request_options:: set_parallelism_factor 方法。</span><span class="sxs-lookup"><span data-stu-id="43121-474">C++: Use hello blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="43121-475"><a name="subheading22"></a>快速上傳多個 Blob</span><span class="sxs-lookup"><span data-stu-id="43121-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="43121-476">tooupload 許多快速，blob 上傳 blob 以平行方式。</span><span class="sxs-lookup"><span data-stu-id="43121-476">tooupload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="43121-477">這是較快，單一 blob 一次使用上載平行區塊上傳因為它會將 hello 上載分散到多個資料分割的 hello 儲存體服務。</span><span class="sxs-lookup"><span data-stu-id="43121-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads hello upload across multiple partitions of hello storage service.</span></span> <span data-ttu-id="43121-478">單一 Blob 僅支援 60 MB/秒 (大約是 480 Mbps) 的輸送量。</span><span class="sxs-lookup"><span data-stu-id="43121-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="43121-479">Hello 撰寫本文時，美國 LRS 帳戶最多可支援 too20 Gbps 輸入，這可能會遠比 hello 輸送量受到個別的 blob。</span><span class="sxs-lookup"><span data-stu-id="43121-479">At hello time of writing, a US-based LRS account supports up too20 Gbps ingress which is far more than hello throughput supported by an individual blob.</span></span>  <span data-ttu-id="43121-480">[AzCopy](#subheading18) 依預設會執行平行上傳，在此案例中我們建議使用此方法。</span><span class="sxs-lookup"><span data-stu-id="43121-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="43121-481"><a name="subheading23"></a>選擇 blob 的 hello 正確的型別</span><span class="sxs-lookup"><span data-stu-id="43121-481"><a name="subheading23"></a>Choosing hello correct type of blob</span></span>
<span data-ttu-id="43121-482">Azure 儲存體支援兩種 Blob：分頁 Blob 和區塊 Blob。</span><span class="sxs-lookup"><span data-stu-id="43121-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="43121-483">針對特定的使用案例，hello 效能和延展性的方案，將會影響您選擇的 blob 類型。</span><span class="sxs-lookup"><span data-stu-id="43121-483">For a given usage scenario, your choice of blob type will affect hello performance and scalability of your solution.</span></span> <span data-ttu-id="43121-484">有效率地在 tooupload 大量資料時，區塊 blob 非常適當： 例如，用戶端應用程式可能需要 tooupload 相片或視訊 tooblob 儲存體。</span><span class="sxs-lookup"><span data-stu-id="43121-484">Block blobs are appropriate when you want tooupload large amounts of data efficiently: for example, a client application may need tooupload photos or video tooblob storage.</span></span> <span data-ttu-id="43121-485">分頁 blob 適合如果 hello 應用程式需要 tooperform 隨機寫入在 hello 資料： 例如，Azure Vhd 會儲存為分頁 blob。</span><span class="sxs-lookup"><span data-stu-id="43121-485">Page blobs are appropriate if hello application needs tooperform random writes on hello data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="43121-486">如需詳細資訊，請參閱 [了解區塊 Blob、附加 Blob 和分頁 Blob](http://msdn.microsoft.com/library/azure/ee691964.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43121-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="43121-487">資料表</span><span class="sxs-lookup"><span data-stu-id="43121-487">Tables</span></span>
<span data-ttu-id="43121-488">在加法 toohello 證實的作法[所有服務](#allservices)先前所述，證明作法 hello 下列套用特別 toohello 表格服務。</span><span class="sxs-lookup"><span data-stu-id="43121-488">In addition toohello proven practices for [All Services](#allservices) described previously, hello following proven practices apply specifically toohello table service.</span></span>  

### <span data-ttu-id="43121-489"><a name="subheading24"></a>資料表特定的延展性目標</span><span class="sxs-lookup"><span data-stu-id="43121-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="43121-490">中的整個儲存體帳戶的加法 toohello 頻寬限制，資料表具有下列特定的延展性限制的 hello。</span><span class="sxs-lookup"><span data-stu-id="43121-490">In addition toohello bandwidth limitations of an entire storage account, tables have hello following specific scalability limit.</span></span>  <span data-ttu-id="43121-491">請注意，hello 系統將負載平衡流量的增加，但如果您的流量具有量突然暴增，您可能不是 立即無法 tooget 此磁碟區的輸送量。</span><span class="sxs-lookup"><span data-stu-id="43121-491">Note that hello system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able tooget this volume of throughput immediately.</span></span>  <span data-ttu-id="43121-492">如果您的模式有暴增、 toosee 節流，您應該會和/或逾時期間 hello 高載 hello 儲存體服務作為自動負載平衡移出您的資料表。</span><span class="sxs-lookup"><span data-stu-id="43121-492">If your pattern has bursts, you should expect toosee throttling and/or timeouts during hello burst as hello storage service automatically load balances out your table.</span></span>  <span data-ttu-id="43121-493">緩時變通常根本上有更好的結果，適當地讓 hello 系統時間 tooload 餘額。</span><span class="sxs-lookup"><span data-stu-id="43121-493">Ramping up slowly generally has better results as it gives hello system time tooload balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="43121-494">每秒的實體數 (帳戶)</span><span class="sxs-lookup"><span data-stu-id="43121-494">Entities per Second (Account)</span></span>
<span data-ttu-id="43121-495">hello 延展性限制存取的資料表為向上 too20，000 實體 (每一個 1 KB) 每秒的帳戶。</span><span class="sxs-lookup"><span data-stu-id="43121-495">hello scalability limit for accessing tables is up too20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="43121-496">一般來說，已插入、更新、刪除或掃描的每個實體都會算在這個目標內。</span><span class="sxs-lookup"><span data-stu-id="43121-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="43121-497">因此包含 100 個實體的批次插入會算為 100 個實體。</span><span class="sxs-lookup"><span data-stu-id="43121-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="43121-498">掃描 1,000 個實體並傳回 5 的查詢會算為 1,000 個實體。</span><span class="sxs-lookup"><span data-stu-id="43121-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="43121-499">每秒的實體數 (資料分割)</span><span class="sxs-lookup"><span data-stu-id="43121-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="43121-500">在單一資料分割，hello 延展性目標為存取資料表為 2000 實體 (每一個 1 KB) 每秒，使用 hello 相同計數 hello 上一節中所述。</span><span class="sxs-lookup"><span data-stu-id="43121-500">Within a single partition, hello scalability target for accessing tables is 2,000 entities (1KB each) per second, using hello same counting as described in hello previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="43121-501">組態</span><span class="sxs-lookup"><span data-stu-id="43121-501">Configuration</span></span>
<span data-ttu-id="43121-502">此區段會列出您可以在 hello 表格服務中使用 toomake 顯著的效能改善的數個快速的組態設定：</span><span class="sxs-lookup"><span data-stu-id="43121-502">This section lists several quick configuration settings that you can use toomake significant performance improvements in hello table service:</span></span>  

#### <span data-ttu-id="43121-503"><a name="subheading25"></a>使用 JSON</span><span class="sxs-lookup"><span data-stu-id="43121-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="43121-504">開始儲存體服務版本 2013年-08-15，hello 表格服務支援使用 JSON 而不 hello 以 XML 為基礎的 AtomPub 格式，將資料表資料傳輸。</span><span class="sxs-lookup"><span data-stu-id="43121-504">Beginning with storage service version 2013-08-15, hello table service supports using JSON instead of hello XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="43121-505">這可以減少裝載大小最多可達 75%，並可大幅提升應用程式的 hello 效能。</span><span class="sxs-lookup"><span data-stu-id="43121-505">This can reduce payload sizes by as much as 75% and can significantly improve hello performance of your application.</span></span>

<span data-ttu-id="43121-506">如需詳細資訊，請參閱文章 hello [Microsoft Azure 資料表： JSON 簡介](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx)和[表格服務作業的裝載格式](http://msdn.microsoft.com/library/azure/dn535600.aspx)。</span><span class="sxs-lookup"><span data-stu-id="43121-506">For more information, see hello post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="43121-507"><a name="subheading26"></a>關閉 Nagle</span><span class="sxs-lookup"><span data-stu-id="43121-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="43121-508">跨 TCP/IP 網路表示 tooimprove 網路效能廣泛實作的 Nagle 演算法。</span><span class="sxs-lookup"><span data-stu-id="43121-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means tooimprove network performance.</span></span> <span data-ttu-id="43121-509">不過，它並非是所有情況下的最佳作法 (例如高互動式環境)。</span><span class="sxs-lookup"><span data-stu-id="43121-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="43121-510">Azure 儲存體而言的 Nagle 演算法 hello 要求 toohello 資料表和佇列服務，效能有負面影響，您應該停用的話。</span><span class="sxs-lookup"><span data-stu-id="43121-510">For Azure Storage, Nagle's algorithm has a negative impact on hello performance of requests toohello table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="43121-511">如需詳細資訊，請參閱我們的部落格文章[Nagle 的演算法是不好記往小要求](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx)，其中說明 Nagle 的演算法為何不良互動資料表和佇列的要求，並示範如何 toodisable 在您的用戶端應用程式。</span><span class="sxs-lookup"><span data-stu-id="43121-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how toodisable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="43121-512">結構描述</span><span class="sxs-lookup"><span data-stu-id="43121-512">Schema</span></span>
<span data-ttu-id="43121-513">代表及查詢資料的方式是 hello 最大單一因素會影響 hello hello 表格服務的效能。</span><span class="sxs-lookup"><span data-stu-id="43121-513">How you represent and query your data is hello biggest single factor that affects hello performance of hello table service.</span></span> <span data-ttu-id="43121-514">雖然每個應用程式都有所不同，本節將概述與下列項目相關的部分一般已經實證做法：</span><span class="sxs-lookup"><span data-stu-id="43121-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="43121-515">資料表設計</span><span class="sxs-lookup"><span data-stu-id="43121-515">Table design</span></span>
* <span data-ttu-id="43121-516">有效率的查詢</span><span class="sxs-lookup"><span data-stu-id="43121-516">Efficient queries</span></span>
* <span data-ttu-id="43121-517">有效率的資料更新</span><span class="sxs-lookup"><span data-stu-id="43121-517">Efficient data updates</span></span>  

#### <span data-ttu-id="43121-518"><a name="subheading27"></a>資料表和資料分割</span><span class="sxs-lookup"><span data-stu-id="43121-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="43121-519">資料表會被分為幾個資料分割。</span><span class="sxs-lookup"><span data-stu-id="43121-519">Tables are divided into partitions.</span></span> <span data-ttu-id="43121-520">儲存的每個實體資料分割中共用 hello 相同的資料分割索引鍵與具有唯一資料列的索引鍵 tooidentify 在該資料分割。</span><span class="sxs-lookup"><span data-stu-id="43121-520">Every entity stored in a partition shares hello same partition key and has a unique row key tooidentify it within that partition.</span></span> <span data-ttu-id="43121-521">資料分割提供了優點，但也同時引進延展性限制。</span><span class="sxs-lookup"><span data-stu-id="43121-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="43121-522">優點： 您可以更新相同資料分割，包含 too100 不同儲存體作業 （限制為 4 MB 的大小總計） 的單一、 不可部分完成的批次交易中的 hello 中的實體。</span><span class="sxs-lookup"><span data-stu-id="43121-522">Benefits: You can update entities in hello same partition in a single, atomic, batch transaction that contains up too100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="43121-523">假設 hello 相同數目的實體 toobe 擷取，您也可以查詢內的單一資料分割的資料比橫跨資料分割 （雖然閱讀，以取得進一步的查詢資料表資料的建議） 的資料，更有效率。</span><span class="sxs-lookup"><span data-stu-id="43121-523">Assuming hello same number of entities toobe retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="43121-524">延展性限制： 存取 tooentities 儲存在單一磁碟分割不能是負載平衡因為資料分割支援不可部分完成的批次交易。</span><span class="sxs-lookup"><span data-stu-id="43121-524">Scalability limit: Access tooentities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="43121-525">基於這個理由，hello 延展性目標為每個個別的資料表資料分割會低於 hello 表格服務的整體。</span><span class="sxs-lookup"><span data-stu-id="43121-525">For this reason, hello scalability target for an individual table partition is lower than for hello table service as a whole.</span></span>  

<span data-ttu-id="43121-526">因為這些特性的資料表和資料分割，您應該採用下列設計原則的 hello:</span><span class="sxs-lookup"><span data-stu-id="43121-526">Because of these characteristics of tables and partitions, you should adopt hello following design principles:</span></span>  

* <span data-ttu-id="43121-527">用戶端應用程式經常更新，或查詢的 hello 應該位於相同的邏輯單元的工作中的資料 hello 相同的資料分割。</span><span class="sxs-lookup"><span data-stu-id="43121-527">Data that your client application frequently updated or queried in hello same logical unit of work should be located in hello same partition.</span></span>  <span data-ttu-id="43121-528">這可能是因為您的應用程式正在彙總寫入，或您想要利用 tootake 不可部分完成的批次作業。</span><span class="sxs-lookup"><span data-stu-id="43121-528">This may be because your application is aggregating writes, or because you want tootake advantage of atomic batch operations.</span></span>  <span data-ttu-id="43121-529">另外，在單一查詢中，查詢單一資料分割中的資料會比查詢跨資料分割中的資料還要有效率。</span><span class="sxs-lookup"><span data-stu-id="43121-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="43121-530">用戶端應用程式不會插入/更新或查詢的 hello 應該位於相同的邏輯單元的工作 （單一查詢或批次更新） 中的資料的不同磁碟分割。</span><span class="sxs-lookup"><span data-stu-id="43121-530">Data that your client application does not insert/update or query in hello same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="43121-531">一個重要的原因是沒有 toohello 數目限制在單一資料表中，資料分割索引鍵以便有數百萬個資料分割索引鍵不是問題，並不會影響效能。</span><span class="sxs-lookup"><span data-stu-id="43121-531">One important note is that there is no limit toohello number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="43121-532">比方說，如果您的應用程式具有使用者登入受歡迎的網站，做為 hello 資料分割索引鍵使用 hello 使用者識別碼可能是不錯的選擇。</span><span class="sxs-lookup"><span data-stu-id="43121-532">For example, if your application is a popular website with user login, using hello User Id as hello partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="43121-533">常用資料分割</span><span class="sxs-lookup"><span data-stu-id="43121-533">Hot Partitions</span></span>
<span data-ttu-id="43121-534">熱資料分割是接收不當比例的百分比表示的 hello 流量 tooan 帳戶，且不能負載平衡因為它是單一磁碟分割。</span><span class="sxs-lookup"><span data-stu-id="43121-534">A hot partition is one that is receiving a disproportionate percentage of hello traffic tooan account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="43121-535">一般來說，可以用下列兩種方法其中之一來建立常用資料分割：</span><span class="sxs-lookup"><span data-stu-id="43121-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="43121-536"><a name="subheading28"></a>只開頭附加和只結尾附加模式</span><span class="sxs-lookup"><span data-stu-id="43121-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="43121-537">hello 「 僅附加 」 模式是其中所有 （或幾乎全部） 的 hello 流量 tooa 指定 PK 增加和減少相應 toohello 目前的時間。</span><span class="sxs-lookup"><span data-stu-id="43121-537">hello "Append Only" pattern is one where all (or nearly all) of hello traffic tooa given PK increases and decreases according toohello current time.</span></span>  <span data-ttu-id="43121-538">例如，如果您的應用程式使用 hello 目前日期做為記錄資料的資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="43121-538">An example is if your application used hello current date as a partition key for log data.</span></span>  <span data-ttu-id="43121-539">這會導致所有 hello 移 toohello 在資料表中，最後一個資料分割的插入和 hello 系統無法載入平衡，因為所有的 hello 寫入都是您的資料表進行 toohello 結尾。</span><span class="sxs-lookup"><span data-stu-id="43121-539">This results in all of hello inserts going toohello last partition in your table, and hello system cannot load balance because all of hello writes are going toohello end of your table.</span></span>  <span data-ttu-id="43121-540">如果 hello 流量 toothat 資料分割的磁碟區超過 hello 資料分割層級的延展性目標，然後它會導致節流。</span><span class="sxs-lookup"><span data-stu-id="43121-540">If hello volume of traffic toothat partition exceeds hello partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="43121-541">它是 toomultiple 資料分割，則會傳送流量的更佳 tooensure tooenable 負載平衡 hello 會透過您的資料表要求。</span><span class="sxs-lookup"><span data-stu-id="43121-541">It's better tooensure that traffic is sent toomultiple partitions, tooenable load balance hello requests across your table.</span></span>  

##### <span data-ttu-id="43121-542"><a name="subheading29"></a>高流量資料</span><span class="sxs-lookup"><span data-stu-id="43121-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="43121-543">如果您單一資料分割中的資料分割配置結果，只具有遠比其他分割區使用的資料，也可能會看到節流該資料分割接近 hello 的單一資料分割的延展性目標。</span><span class="sxs-lookup"><span data-stu-id="43121-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches hello scalability target for a single partition.</span></span>  <span data-ttu-id="43121-544">確定您沒有單一的資料分割配置結果分割區接近 hello 延展性目標的更佳 toomake 它。</span><span class="sxs-lookup"><span data-stu-id="43121-544">It's better toomake sure that your partition scheme results in no single partition approaching hello scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="43121-545">查詢</span><span class="sxs-lookup"><span data-stu-id="43121-545">Querying</span></span>
<span data-ttu-id="43121-546">本章節描述經過證實的作法，來查詢 hello 表格服務。</span><span class="sxs-lookup"><span data-stu-id="43121-546">This section describes proven practices for querying hello table service.</span></span>  

##### <span data-ttu-id="43121-547"><a name="subheading30"></a>查詢範圍</span><span class="sxs-lookup"><span data-stu-id="43121-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="43121-548">有數種方式 toospecify hello 實體 tooquery 的範圍。</span><span class="sxs-lookup"><span data-stu-id="43121-548">There are several ways toospecify hello range of entities tooquery.</span></span>  <span data-ttu-id="43121-549">hello 以下是每個 hello 使用的討論。</span><span class="sxs-lookup"><span data-stu-id="43121-549">hello following is a discussion of hello uses of each.</span></span>  

<span data-ttu-id="43121-550">一般情況下，以免掃描 （查詢大於單一實體），但如果必須掃描 tooorganize 您的資料，讓您掃描擷取 hello 資料，您需要不含掃描，或傳回大量不需要的實體。</span><span class="sxs-lookup"><span data-stu-id="43121-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try tooorganize your data so that your scans retrieve hello data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="43121-551">點查詢</span><span class="sxs-lookup"><span data-stu-id="43121-551">Point Queries</span></span>
<span data-ttu-id="43121-552">點查詢只會擷取一個實體。</span><span class="sxs-lookup"><span data-stu-id="43121-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="43121-553">它會藉由指定 hello 資料分割索引鍵和 hello 實體 tooretrieve 資料列索引鍵。</span><span class="sxs-lookup"><span data-stu-id="43121-553">It does this by specifying both hello partition key and row key of hello entity tooretrieve.</span></span> <span data-ttu-id="43121-554">這些查詢非常有效率，您應盡可能地加以使用。</span><span class="sxs-lookup"><span data-stu-id="43121-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="43121-555">資料分割查詢</span><span class="sxs-lookup"><span data-stu-id="43121-555">Partition Queries</span></span>
<span data-ttu-id="43121-556">資料分割查詢是指可擷取一組共用常見分割索引鍵之資料的查詢。</span><span class="sxs-lookup"><span data-stu-id="43121-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="43121-557">一般而言，hello 查詢加法 tooa 資料分割索引鍵中指定的資料列索引鍵值的範圍或某些實體屬性的值範圍。</span><span class="sxs-lookup"><span data-stu-id="43121-557">Typically, hello query specifies a range of row key values or a range of values for some entity property in addition tooa partition key.</span></span> <span data-ttu-id="43121-558">這些查詢會比點查詢沒有效率，且應謹慎使用。</span><span class="sxs-lookup"><span data-stu-id="43121-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="43121-559">資料表查詢</span><span class="sxs-lookup"><span data-stu-id="43121-559">Table Queries</span></span>
<span data-ttu-id="43121-560">資料表查詢是指可擷取一組不共用常見分割索引鍵之實體的查詢。</span><span class="sxs-lookup"><span data-stu-id="43121-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="43121-561">這些查詢非常沒有效率，您應盡量避免使用。</span><span class="sxs-lookup"><span data-stu-id="43121-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="43121-562"><a name="subheading31"></a>查詢密度</span><span class="sxs-lookup"><span data-stu-id="43121-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="43121-563">在查詢效率的另一個關鍵因素是 hello 數字，傳回做為比較的 toohello 數掃描的 toofind hello 傳回設定實體的實體。</span><span class="sxs-lookup"><span data-stu-id="43121-563">Another key factor in query efficiency is hello number of entities returned as compared toohello number of entities scanned toofind hello returned set.</span></span> <span data-ttu-id="43121-564">如果您的應用程式執行資料表查詢與屬性值的篩選，僅有 1%的 hello 資料共用，hello 查詢會掃描 100 個實體，它會傳回每一個實體。</span><span class="sxs-lookup"><span data-stu-id="43121-564">If your application performs a table query with a filter for a property value that only 1% of hello data shares, hello query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="43121-565">hello 資料表延展性目標討論先前所有 toohello 實體數目的掃描，和方面不 hello 傳回的實體數目： 低查詢密度，很容易造成 hello 資料表服務 toothrottle 您的應用程式因為必須掃描這麼多您所需實體 tooretrieve hello 實體。</span><span class="sxs-lookup"><span data-stu-id="43121-565">hello table scalability targets discussed previously all relate toohello number of entities scanned, and not hello number of entities returned: a low query density can easily cause hello table service toothrottle your application because it must scan so many entities tooretrieve hello entity you are looking for.</span></span>  <span data-ttu-id="43121-566">請參閱下一節 hello 上[非正規化](#subheading34)如需有關如何 tooavoid 這。</span><span class="sxs-lookup"><span data-stu-id="43121-566">See hello section below on [denormalization](#subheading34) for more information on how tooavoid this.</span></span>  

##### <a name="limiting-hello-amount-of-data-returned"></a><span data-ttu-id="43121-567">限制 hello 數量的傳回資料</span><span class="sxs-lookup"><span data-stu-id="43121-567">Limiting hello Amount of Data Returned</span></span>
###### <span data-ttu-id="43121-568"><a name="subheading32"></a>篩選</span><span class="sxs-lookup"><span data-stu-id="43121-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="43121-569">在您知道，查詢會傳回實體，您不需要 hello 用戶端應用程式中，請考慮使用篩選 tooreduce hello 大小為 hello 集傳回。</span><span class="sxs-lookup"><span data-stu-id="43121-569">Where you know that a query will return entities that you don't need in hello client application, consider using a filter tooreduce hello size of hello returned set.</span></span> <span data-ttu-id="43121-570">Hello 實體不會傳回 toohello 用戶端時仍算 hello 延展性限制，會因為 hello 降低網路承載大小改善應用程式效能，並將其 hello 的用戶端應用程式必須處理的實體數目減少.</span><span class="sxs-lookup"><span data-stu-id="43121-570">While hello entities not returned toohello client still count toward hello scalability limits, your application performance will improve because of hello reduced network payload size and hello reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="43121-571">請參閱上述附註上[查詢密度](#subheading31)，不過 – hello 延展性目標關聯 toohello 實體數目的掃描，以便篩選出許多實體的查詢可能仍然會導致節流，即使傳回幾個實體。</span><span class="sxs-lookup"><span data-stu-id="43121-571">See above note on [Query Density](#subheading31), however – hello scalability targets relate toohello number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="43121-572"><a name="subheading33"></a>投射</span><span class="sxs-lookup"><span data-stu-id="43121-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="43121-573">如果用戶端應用程式需要僅提供有限的屬性，從資料表中的 hello 實體，您可以使用傳回的資料集的 hello 投影 toolimit hello 大小。</span><span class="sxs-lookup"><span data-stu-id="43121-573">If your client application needs only a limited set of properties from hello entities in your table, you can use projection toolimit hello size of hello returned data set.</span></span> <span data-ttu-id="43121-574">使用篩選，這有助於 tooreduce 網路負載和用戶端處理。</span><span class="sxs-lookup"><span data-stu-id="43121-574">As with filtering, this helps tooreduce network load and client processing.</span></span>  

##### <span data-ttu-id="43121-575"><a name="subheading34"></a>反正規化</span><span class="sxs-lookup"><span data-stu-id="43121-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="43121-576">不同於使用關聯式資料庫，hello 經過證實的作法，有效率地查詢資料表的資料會導致 toodenormalizing 您的資料。</span><span class="sxs-lookup"><span data-stu-id="43121-576">Unlike working with relational databases, hello proven practices for efficiently querying table data lead toodenormalizing your data.</span></span> <span data-ttu-id="43121-577">也就是複製 hello 中多個實體有相同的資料 (其中每個索引鍵中，您可以使用 toofind hello 資料) 實體的查詢必須掃描 toofind hello 資料 hello 用戶端需求，而不是需要大量實體 toofind tooscan toominimize hello 數目您的應用程式必須 hello 資料。</span><span class="sxs-lookup"><span data-stu-id="43121-577">That is, duplicating hello same data in multiple entities (one for each key you may use toofind hello data) toominimize hello number of entities that a query must scan toofind hello data hello client needs, rather than having tooscan large numbers of entities toofind hello data your application needs.</span></span>  <span data-ttu-id="43121-578">例如，電子商務網站中，您可能想 toofind 依排序的這兩個 hello 客戶 ID （給我此客戶的訂單） 和依 hello 日期 （給我訂單日期）。</span><span class="sxs-lookup"><span data-stu-id="43121-578">For example, in an e-commerce website, you may want toofind an order both by hello customer ID (give me this customer's orders) and by hello date (give me orders on a date).</span></span>  <span data-ttu-id="43121-579">在資料表儲存體，它是最佳的 toostore hello 實體 （或參考 tooit） 兩次-一次使用客戶識別碼，一次 toofacilitate 尋找 hello 日期的資料表名稱、 PK 和 RK toofacilitate 尋找。</span><span class="sxs-lookup"><span data-stu-id="43121-579">In Table Storage, it is best toostore hello entity (or a reference tooit) twice – once with Table Name, PK, and RK toofacilitate finding by customer ID, once toofacilitate finding it by hello date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="43121-580">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="43121-580">Insert/Update/Delete</span></span>
<span data-ttu-id="43121-581">本章節描述經過證實的作法，修改儲存在 hello 表格服務中的實體。</span><span class="sxs-lookup"><span data-stu-id="43121-581">This section describes proven practices for modifying entities stored in hello table service.</span></span>  

##### <span data-ttu-id="43121-582"><a name="subheading35"></a>批次處理</span><span class="sxs-lookup"><span data-stu-id="43121-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="43121-583">批次交易已知為實體群組交易 (ETG) 在 Azure 儲存體。ETG 內的所有 hello 作業都必須在單一資料表中的單一資料分割上。</span><span class="sxs-lookup"><span data-stu-id="43121-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all hello operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="43121-584">請盡可能使用 ETGs tooperform 插入、 更新和刪除批次中。</span><span class="sxs-lookup"><span data-stu-id="43121-584">Where possible, use ETGs tooperform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="43121-585">這可以降低用戶端應用程式 toohello 伺服器 hello 的往返次數、 可減少 hello 數目的可計費的交易 （ETG 會計算為計費的單一交易，而且只能包含 too100 儲存體作業），以及啟用 不可部分完成更新 （所有作業成功或失敗 ETG 內所有）。</span><span class="sxs-lookup"><span data-stu-id="43121-585">This reduces hello number of round trips from your client application toohello server, reduces hello number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up too100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="43121-586">具有高延遲的環境 (例如行動裝置) 將會因為使用 ETG 而獲得極大的好處。</span><span class="sxs-lookup"><span data-stu-id="43121-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="43121-587"><a name="subheading36"></a>Upsert</span><span class="sxs-lookup"><span data-stu-id="43121-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="43121-588">您應盡可能地使用資料表 **Upsert** 作業。</span><span class="sxs-lookup"><span data-stu-id="43121-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="43121-589">**Upsert** 有兩種類型，這兩種類型都會比傳統的 **Insert** 和 **Update** 作業還要有效率：</span><span class="sxs-lookup"><span data-stu-id="43121-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="43121-590">**InsertOrMerge**： 當您想 tooupload hello 實體屬性的子集時，請使用此但不確定是否 hello 實體已經存在。</span><span class="sxs-lookup"><span data-stu-id="43121-590">**InsertOrMerge**: Use this when you want tooupload a subset of hello entity's properties, but aren't sure whether hello entity already exists.</span></span> <span data-ttu-id="43121-591">如果 hello 實體存在，此呼叫更新 hello 屬性包含在 hello **Upsert**作業，而且不會保留所有現有的屬性，如果 hello 實體不存在，它會插入 hello 新實體。</span><span class="sxs-lookup"><span data-stu-id="43121-591">If hello entity exists, this call updates hello properties included in hello **Upsert** operation, and leaves all existing properties as they are, if hello entity does not exist, it inserts hello new entity.</span></span> <span data-ttu-id="43121-592">這是在查詢中，類似 toousing 投影，您只需要 tooupload hello 屬性會變更的。</span><span class="sxs-lookup"><span data-stu-id="43121-592">This is similar toousing projection in a query, in that you only need tooupload hello properties that are changing.</span></span>
* <span data-ttu-id="43121-593">**InsertOrReplace**： 當您想要 tooupload 全新的實體，但您不確定是否已經存在時使用它。</span><span class="sxs-lookup"><span data-stu-id="43121-593">**InsertOrReplace**: Use this when you want tooupload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="43121-594">您應該只使用這在您知道該 hello 新上傳實體是完全正確，因為它完全覆寫 hello 舊實體。</span><span class="sxs-lookup"><span data-stu-id="43121-594">You should only use this when you know that hello newly uploaded entity is entirely correct because it completely overwrites hello old entity.</span></span> <span data-ttu-id="43121-595">例如，您想儲存使用者的目前位置，不論 hello 應用程式之前已儲存 hello 使用者; 位置資料的 tooupdate hello 實體hello 新位置的實體已完成，且您不需要從先前的任何實體的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="43121-595">For example, you want tooupdate hello entity that stores a user's current location regardless of whether or not hello application has previously stored location data for hello user; hello new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="43121-596"><a name="subheading37"></a>在單一實體中儲存資料序列</span><span class="sxs-lookup"><span data-stu-id="43121-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="43121-597">某些情況下，應用程式所儲存的它經常需要 tooretrieve 一次的資料數列： 例如，應用程式可能會追蹤 CPU 使用量一段時間順序 tooplot 輪流 hello 資料的圖表中從 hello 過去 24 小時。</span><span class="sxs-lookup"><span data-stu-id="43121-597">Sometimes, an application stores a series of data that it frequently needs tooretrieve all at once: for example, an application might track CPU usage over time in order tooplot a rolling chart of hello data from hello last 24 hours.</span></span> <span data-ttu-id="43121-598">其中一個方法是每小時，與每個實體代表特定的時間和儲存該小時內的 hello CPU 使用量的 toohave 一個資料表實體。</span><span class="sxs-lookup"><span data-stu-id="43121-598">One approach is toohave one table entity per hour, with each entity representing a specific hour and storing hello CPU usage for that hour.</span></span> <span data-ttu-id="43121-599">tooplot 這項資料，hello 應用程式必須保存從 hello hello 資料最新的 24 小時 tooretrieve hello 實體。</span><span class="sxs-lookup"><span data-stu-id="43121-599">tooplot this data, hello application needs tooretrieve hello entities holding hello data from hello 24 most recent hours.</span></span>  

<span data-ttu-id="43121-600">或者，您的應用程式時，可以為個別的單一實體屬性的每小時儲存 hello CPU 使用量： tooupdate 每小時依您的應用程式可以使用單一**InsertOrMerge Upsert** hello 呼叫 tooupdate hello 值最新的小時。</span><span class="sxs-lookup"><span data-stu-id="43121-600">Alternatively, your application could store hello CPU usage for each hour as a separate property of a single entity: tooupdate each hour, your application can use a single **InsertOrMerge Upsert** call tooupdate hello value for hello most recent hour.</span></span> <span data-ttu-id="43121-601">tooplot hello 資料，hello 應用程式只需要 tooretrieve 單一實體而不是 24，讓非常有效率的查詢 (請參閱上面討論的上[查詢範圍](#subheading30))。</span><span class="sxs-lookup"><span data-stu-id="43121-601">tooplot hello data, hello application only needs tooretrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="43121-602"><a name="subheading38"></a>在 Blob 中儲存結構化資料</span><span class="sxs-lookup"><span data-stu-id="43121-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="43121-603">有時候，結構化資料好像應該要以資料表方式呈現，但實體範圍總是會被一起擷取，並可批次插入。</span><span class="sxs-lookup"><span data-stu-id="43121-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="43121-604">記錄檔是這個狀況的良好範例。</span><span class="sxs-lookup"><span data-stu-id="43121-604">A good example of this is a log file.</span></span>  <span data-ttu-id="43121-605">在此案例中，您可以批次處理數分鐘的記錄，然後也總是一次擷取數分鐘的記錄。</span><span class="sxs-lookup"><span data-stu-id="43121-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="43121-606">在此情況下，效能，對於較佳的 toouse blob，而不是資料表，因為您可以大幅減少 hello 數目寫入/傳回物件，以及通常 hello 需要提出的要求數目。</span><span class="sxs-lookup"><span data-stu-id="43121-606">In this case, for performance, it's better toouse blobs instead of tables, since you can significantly reduce hello number of objects written/returned, as well as usually hello number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="43121-607">佇列</span><span class="sxs-lookup"><span data-stu-id="43121-607">Queues</span></span>
<span data-ttu-id="43121-608">在加法 toohello 證實的作法[所有服務](#allservices)先前所述，證明作法 hello 下列套用特別 toohello 佇列服務。</span><span class="sxs-lookup"><span data-stu-id="43121-608">In addition toohello proven practices for [All Services](#allservices) described previously, hello following proven practices apply specifically toohello queue service.</span></span>  

### <span data-ttu-id="43121-609"><a name="subheading39"></a>延展性限制</span><span class="sxs-lookup"><span data-stu-id="43121-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="43121-610">單一佇列每秒可以處理大約 2000 則訊息 (每則訊息 1 KB) (每個 AddMessage、GetMessage 和 DeleteMessage 在此算一則訊息)。</span><span class="sxs-lookup"><span data-stu-id="43121-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="43121-611">如果這是不足以執行您的應用程式，您應該使用多個佇列，並分散到它們的 hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="43121-611">If this is insufficient for your application, you should use multiple queues and spread hello messages across them.</span></span>  

<span data-ttu-id="43121-612">在 [Azure 儲存體延展性和效能目標](storage-scalability-targets.md)上檢視目前的延展性目標。</span><span class="sxs-lookup"><span data-stu-id="43121-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="43121-613"><a name="subheading40"></a>關閉 Nagle</span><span class="sxs-lookup"><span data-stu-id="43121-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="43121-614">請參閱 hello 一節討論 hello Nagle 演算法的資料表設定 — hello Nagle 演算法通常不正確的佇列要求 hello 效能，而且您應該停用。</span><span class="sxs-lookup"><span data-stu-id="43121-614">See hello section on table configuration that discusses hello Nagle algorithm — hello Nagle algorithm is generally bad for hello performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="43121-615"><a name="subheading41"></a>訊息大小</span><span class="sxs-lookup"><span data-stu-id="43121-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="43121-616">佇列效能和延展性會隨著訊息大小增加而減少。</span><span class="sxs-lookup"><span data-stu-id="43121-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="43121-617">您應該將只 hello 資訊 hello 收件者需要在訊息中。</span><span class="sxs-lookup"><span data-stu-id="43121-617">You should place only hello information hello receiver needs in a message.</span></span>  

### <span data-ttu-id="43121-618"><a name="subheading42"></a>批次擷取</span><span class="sxs-lookup"><span data-stu-id="43121-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="43121-619">您可以擷取 too32 從單一作業中佇列的訊息。</span><span class="sxs-lookup"><span data-stu-id="43121-619">You can retrieve up too32 messages from a queue in a single operation.</span></span> <span data-ttu-id="43121-620">這可以減少往返數目 hello hello 用戶端應用程式，這特別適用於環境中，行動裝置，例如從，含高延遲。</span><span class="sxs-lookup"><span data-stu-id="43121-620">This can reduce hello number of roundtrips from hello client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="43121-621"><a name="subheading43"></a>佇列輪詢間隔</span><span class="sxs-lookup"><span data-stu-id="43121-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="43121-622">大部分的應用程式輪詢訊息從佇列中，可以是其中一種 hello 交易，該應用程式的最大的來源。</span><span class="sxs-lookup"><span data-stu-id="43121-622">Most applications poll for messages from a queue, which can be one of hello largest sources of transactions for that application.</span></span> <span data-ttu-id="43121-623">請明智地選取輪詢間隔： 輪詢頻率太高可能會導致應用程式 tooapproach hello hello 佇列的延展性目標。</span><span class="sxs-lookup"><span data-stu-id="43121-623">Select your polling interval wisely: polling too frequently could cause your application tooapproach hello scalability targets for hello queue.</span></span> <span data-ttu-id="43121-624">不過，200,000 交易 $0.01 （在 hello 撰寫時），在單一處理器輪詢之後每個月份的第二個成本小於 15 分因此成本, 不通常會影響您所選擇的輪詢間隔的因素。</span><span class="sxs-lookup"><span data-stu-id="43121-624">However, at 200,000 transactions for $0.01 (at hello time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="43121-625">如需最新成本資訊，請參閱 [Azure 儲存體價格](https://azure.microsoft.com/pricing/details/storage/)。</span><span class="sxs-lookup"><span data-stu-id="43121-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="43121-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="43121-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="43121-627">您可以使用**UpdateMessage** tooincrease hello 過了隱藏逾時或 tooupdate 狀態資訊的訊息。</span><span class="sxs-lookup"><span data-stu-id="43121-627">You can use **UpdateMessage** tooincrease hello invisibility timeout or tooupdate state information of a message.</span></span> <span data-ttu-id="43121-628">雖然這是功能強大，請記住，每個**UpdateMessage**作業會計入 hello 延展性目標。</span><span class="sxs-lookup"><span data-stu-id="43121-628">While this is powerful, remember that each **UpdateMessage** operation counts towards hello scalability target.</span></span> <span data-ttu-id="43121-629">但是，這可能會更有效率的方式，比起作業中傳遞一個佇列 toohello 接下來，hello 工作的每個步驟完成時，工作流程。</span><span class="sxs-lookup"><span data-stu-id="43121-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue toohello next, as each step of hello job is completed.</span></span> <span data-ttu-id="43121-630">使用 hello **UpdateMessage**作業可讓您的應用程式 toosave hello 的作業狀態 toohello 訊息，然後繼續進行工作，而非重新佇列 hello 訊息，如 hello hello 作業每次在步驟完成下一個步驟。</span><span class="sxs-lookup"><span data-stu-id="43121-630">Using hello **UpdateMessage** operation allows your application toosave hello job state toohello message and then continue working, instead of re-queuing hello message for hello next step of hello job every time a step completes.</span></span>  

<span data-ttu-id="43121-631">如需詳細資訊，請參閱 hello 文章[如何： 變更佇列的訊息內容 hello](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message)。</span><span class="sxs-lookup"><span data-stu-id="43121-631">For more information, see hello article [How to: Change hello contents of a queued message](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="43121-632"><a name="subheading45"></a>應用程式架構</span><span class="sxs-lookup"><span data-stu-id="43121-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="43121-633">您應該使用佇列 toomake 可擴充您應用程式架構。</span><span class="sxs-lookup"><span data-stu-id="43121-633">You should use queues toomake your application architecture scalable.</span></span> <span data-ttu-id="43121-634">hello 下列列出一些您可以使用佇列 toomake 更具擴充性應用程式：</span><span class="sxs-lookup"><span data-stu-id="43121-634">hello following lists some ways you can use queues toomake your application more scalable:</span></span>  

* <span data-ttu-id="43121-635">您可以處理所使用的工作佇列 toocreate 待辦項目，且平滑應用程式中的工作負載。</span><span class="sxs-lookup"><span data-stu-id="43121-635">You can use queues toocreate backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="43121-636">例如，您無法排入佇列要求使用者 tooperform 處理器密集的工作例如調整大小上傳映像。</span><span class="sxs-lookup"><span data-stu-id="43121-636">For example, you could queue up requests from users tooperform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="43121-637">您可以使用應用程式的佇列 toodecouple 部分，讓您獨立擴充。</span><span class="sxs-lookup"><span data-stu-id="43121-637">You can use queues toodecouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="43121-638">例如，Web 前端可以將使用者的調查結果放到佇列中，以供日後分析與儲存。</span><span class="sxs-lookup"><span data-stu-id="43121-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="43121-639">您可以加入多個背景工作角色執行個體 tooprocess hello 佇列所需的資料。</span><span class="sxs-lookup"><span data-stu-id="43121-639">You could add more worker role instances tooprocess hello queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="43121-640">結論</span><span class="sxs-lookup"><span data-stu-id="43121-640">Conclusion</span></span>
<span data-ttu-id="43121-641">本文會討論一些最常見的 hello 證明最佳化效能，當使用 Azure 儲存體的作法。</span><span class="sxs-lookup"><span data-stu-id="43121-641">This article discussed some of hello most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="43121-642">我們鼓勵每個應用程式開發人員 tooassess 他們的應用程式，針對每個 hello 上述作法，請考慮在其應用程式使用 Azure 儲存體的 hello 建議 tooget 絕佳效能上運作。</span><span class="sxs-lookup"><span data-stu-id="43121-642">We encourage every application developer tooassess their application against each of hello above practices and consider acting on hello recommendations tooget great performance for their applications that use Azure Storage.</span></span>
