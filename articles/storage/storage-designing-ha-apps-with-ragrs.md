---
title: "aaaDesigning 高度可用的應用程式使用 Azure 讀取存取異地備援儲存體 (RA-GRS) |Microsoft 文件"
description: "如何 toouse Azure RA-GRS 儲存體 tooarchitect 彈性的高可用性應用程式足夠 toohandle 中斷。"
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: e4a9fe7ef33eecd894408b3c1ef59920a248d1bd
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="a3117-103">使用 RA-GRS 設計高可用性應用程式</span><span class="sxs-lookup"><span data-stu-id="a3117-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="a3117-104">雲端式基礎結構的常見功能是提供高可用性平台來裝載應用程式。</span><span class="sxs-lookup"><span data-stu-id="a3117-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="a3117-105">以雲端為基礎的應用程式的開發人員必須考慮如何仔細 tooleverage 這個平台 toodeliver 高可用性應用程式 tootheir 使用者。</span><span class="sxs-lookup"><span data-stu-id="a3117-105">Developers of cloud-based applications must consider carefully how tooleverage this platform toodeliver highly available applications tootheir users.</span></span> <span data-ttu-id="a3117-106">本文著重的特別開發人員如何使用 hello Azure 儲存體讀取權限地理備援儲存體 (RA-GRS) toomake 他們更多可用的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a3117-106">This article focuses specifically on how developers can use hello Azure Storage Read Access Geo Redundant Storage (RA-GRS) toomake their applications more available.</span></span>

<span data-ttu-id="a3117-107">有四種備援選項 - LRS (本地備援儲存體)、ZRS (區域備援儲存體)、GRS (異地備援儲存體) 和 RA-GRS (讀取權限異地備援儲存體)。</span><span class="sxs-lookup"><span data-stu-id="a3117-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="a3117-108">我們 toodiscuss GRS 和 RA-GRS 本文中。</span><span class="sxs-lookup"><span data-stu-id="a3117-108">We are going toodiscuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="a3117-109">使用 GRS 時，三份資料會保留在 hello 設定 hello 儲存體帳戶時，您選取的主要區域。</span><span class="sxs-lookup"><span data-stu-id="a3117-109">With GRS, three copies of your data are kept in hello primary region you selected when setting up hello storage account.</span></span> <span data-ttu-id="a3117-110">另外會以非同步方式在 Azure 所指定的次要區域中保留三個額外複本。</span><span class="sxs-lookup"><span data-stu-id="a3117-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="a3117-111">RA-GRS 是 hello GRS 相同的動作，差別在於您具有讀取權限 toohello 次要複本。</span><span class="sxs-lookup"><span data-stu-id="a3117-111">RA-GRS is hello same thing as GRS except that you have read access toohello secondary copy.</span></span> <span data-ttu-id="a3117-112">如需 hello 不同的 Azure 儲存體備援選項的詳細資訊，請參閱[Azure 儲存體複寫](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy)。</span><span class="sxs-lookup"><span data-stu-id="a3117-112">For more information about hello different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="a3117-113">hello 複寫發行項也會顯示 hello 配對的 hello 主要和次要區域。</span><span class="sxs-lookup"><span data-stu-id="a3117-113">hello replication article also shows hello pairings of hello primary and secondary regions.</span></span>

<span data-ttu-id="a3117-114">有包含在本文中和連結 tooa 完整的範例，您可以下載並執行 hello 端的程式碼片段。</span><span class="sxs-lookup"><span data-stu-id="a3117-114">There are code snippets included in this article, and a link tooa complete sample at hello end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="a3117-115">RA-GRS 的主要功能</span><span class="sxs-lookup"><span data-stu-id="a3117-115">Key features of RA-GRS</span></span>

<span data-ttu-id="a3117-116">我們會討論如何之前 toouse RA-GRS 存放裝置，我們來談談其屬性和行為。</span><span class="sxs-lookup"><span data-stu-id="a3117-116">Before we talk about how toouse RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="a3117-117">Azure 儲存體維護的唯讀副本儲存在次要區域; 主要區域中的 hello 資料如先前所述，hello 儲存體服務位置決定的 hello 的 hello 次要區域。</span><span class="sxs-lookup"><span data-stu-id="a3117-117">Azure Storage maintains a read-only copy of hello data you store in your primary region in a secondary region; as noted above, hello storage service determines hello location of hello secondary region.</span></span>

* <span data-ttu-id="a3117-118">hello 唯讀複本是[最終一致](https://en.wikipedia.org/wiki/Eventual_consistency)hello hello 主要區域中的資料。</span><span class="sxs-lookup"><span data-stu-id="a3117-118">hello read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with hello data in hello primary region.</span></span>

* <span data-ttu-id="a3117-119">Blob、 資料表和佇列，您可以查詢 hello 次要區域*上次同步處理時間*會告訴您發生 hello hello 主要 toohello 次要區域中的最後一個複寫的值。</span><span class="sxs-lookup"><span data-stu-id="a3117-119">For blobs, tables, and queues, you can query hello secondary region for a *Last Sync Time* value that tells you when hello last replication from hello primary toohello secondary region occurred.</span></span> <span data-ttu-id="a3117-120">(Azure 檔案儲存體不支援此動作，它目前沒有 RA-GRS 備援)。</span><span class="sxs-lookup"><span data-stu-id="a3117-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="a3117-121">您可以使用 hello 儲存體用戶端程式庫 toointeract hello 任一 hello 主要或次要區域中的資料。</span><span class="sxs-lookup"><span data-stu-id="a3117-121">You can use hello Storage Client Library toointeract with hello data in either hello primary or secondary region.</span></span> <span data-ttu-id="a3117-122">您也可以重新導向讀取要求自動 toohello 次要區域如果逾時，讀取的要求 toohello 主要區域。</span><span class="sxs-lookup"><span data-stu-id="a3117-122">You can also redirect read requests automatically toohello secondary region if a read request toohello primary region times out.</span></span>

* <span data-ttu-id="a3117-123">如果沒有主要的問題會影響 hello hello 主要區域中的 hello 資料存取範圍，hello Azure 團隊可能會觸發地理容錯移轉，此時 hello 指向 toohello 主要區域的 DNS 項目將會變更的 toopoint toohello 次要區域。</span><span class="sxs-lookup"><span data-stu-id="a3117-123">If there is a major issue affecting hello accessibility of hello data in hello primary region, hello Azure team may trigger a geo-failover, at which point hello DNS entries pointing toohello primary region will be changed toopoint toohello secondary region.</span></span>

* <span data-ttu-id="a3117-124">發生地理容錯移轉時，Azure 將會選取新的次要位置和複寫 toothat hello 資料的位置，然後指向次要 DNS 項目 tooit hello。</span><span class="sxs-lookup"><span data-stu-id="a3117-124">If a geo-failover occurs, Azure will select a new secondary location and replicate hello data toothat location, then point hello secondary DNS entries tooit.</span></span> <span data-ttu-id="a3117-125">hello 次要端點將無法使用，直到 hello 儲存體帳戶已完成複寫。</span><span class="sxs-lookup"><span data-stu-id="a3117-125">hello secondary endpoint will be unavailable until hello storage account has finished replicating.</span></span> <span data-ttu-id="a3117-126">如需詳細資訊，請參閱[如果 Azure 儲存體中斷，就會發生何種 toodo](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance)。</span><span class="sxs-lookup"><span data-stu-id="a3117-126">For more information, please see [What toodo if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="a3117-127">使用 RA-GRS 時的應用程式設計考量</span><span class="sxs-lookup"><span data-stu-id="a3117-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="a3117-128">這篇文章 hello 主要用途是 tooshow 您如何 toodesign 的應用程式，將會繼續 toofunction （雖然中容量有限） 即使在 hello 事件的重大的災害，在 hello 主要資料中心。</span><span class="sxs-lookup"><span data-stu-id="a3117-128">hello main purpose of this article is tooshow you how toodesign an application that will continue toofunction (albeit in a limited capacity) even in hello event of a major disaster at hello primary data center.</span></span> <span data-ttu-id="a3117-129">您可以切換 tooread hello 次要區域中，而有問題，並 hello 主要區域再次可用時，切換回具有您的應用程式 toohandle 暫時性或長時間執行的問題。</span><span class="sxs-lookup"><span data-stu-id="a3117-129">You do this by having your application toohandle transient or long-running issues by switching tooread from hello secondary region while there is a problem, and switching back when hello primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="a3117-130">使用最終一致的資料</span><span class="sxs-lookup"><span data-stu-id="a3117-130">Using eventually consistent data</span></span>

<span data-ttu-id="a3117-131">此建議的解決方案假設它是關係 tooreturn 可能過時資料 toohello 呼叫應用程式。</span><span class="sxs-lookup"><span data-stu-id="a3117-131">This proposed solution assumes that it is okay tooreturn what could be stale data toohello calling application.</span></span> <span data-ttu-id="a3117-132">Hello 次要資料是最終一致的所以 hello 資料已寫入 toohello 主要，但是 hello 更新 toohello 次要已完成複寫時 hello 主要區域變成無法存取。</span><span class="sxs-lookup"><span data-stu-id="a3117-132">Because hello secondary data is eventually consistent, it is possible that hello data was written toohello primary but hello update toohello secondary had not finished replicating when hello primary region became inaccessible.</span></span>

<span data-ttu-id="a3117-133">例如，客戶無法提交成功時，更新，然後 hello 主要可能會當機前 hello 更新傳播的 toohello 次要。</span><span class="sxs-lookup"><span data-stu-id="a3117-133">For example, your customer could submit an update that is successful, and then hello primary could go down before hello update is propagated toohello secondary.</span></span> <span data-ttu-id="a3117-134">在此情況下，如果 hello 客戶會接著詢問 tooread hello 資料後備，他會收到 hello 過時資料，而非 hello 更新資料。</span><span class="sxs-lookup"><span data-stu-id="a3117-134">In this case, if hello customer then asks tooread hello data back, he receives hello stale data instead of hello updated data.</span></span> <span data-ttu-id="a3117-135">您必須決定這是否可接受的而且如果是，您將訊息 hello 客戶的方式。</span><span class="sxs-lookup"><span data-stu-id="a3117-135">You must decide if this is acceptable, and if so, how you will message hello customer.</span></span> <span data-ttu-id="a3117-136">您會看到如何 toocheck hello 上次同步處理時間稍後在本文章 toosee 中的 hello 次要資料如果 hello 次要處於最新狀態。</span><span class="sxs-lookup"><span data-stu-id="a3117-136">You'll see how toocheck hello Last Sync Time on hello secondary data later in this article toosee if hello secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="a3117-137">個別處理服務或一併處理所有服務</span><span class="sxs-lookup"><span data-stu-id="a3117-137">Handling services separately or all together</span></span>

<span data-ttu-id="a3117-138">雖然不太可能，它可能會無法使用的一項服務 toobecome hello 其他服務仍然是完全正常運作時。</span><span class="sxs-lookup"><span data-stu-id="a3117-138">While not likely, it is possible for one service toobecome unavailable while hello other services are still fully functional.</span></span> <span data-ttu-id="a3117-139">您可以控制代碼 hello 重試次數和唯讀模式，每個服務分開 （blob、 佇列、 資料表），或您可以同時處理的所有 hello 儲存體服務以一般方式重試次數。</span><span class="sxs-lookup"><span data-stu-id="a3117-139">You can handle hello retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all hello storage services together.</span></span>

<span data-ttu-id="a3117-140">比方說，如果您在應用程式中使用佇列和 blob，您可能決定 tooput toohandle 可重試錯誤時，不同的程式碼中的每一種。</span><span class="sxs-lookup"><span data-stu-id="a3117-140">For example, if you use queues and blobs in your application, you may decide tooput in separate code toohandle retryable errors for each of these.</span></span> <span data-ttu-id="a3117-141">然後重試收到 hello blob 服務，但仍然正常 hello 佇列服務，如果只有 hello 部分處理 blob 的應用程式都會受到影響。</span><span class="sxs-lookup"><span data-stu-id="a3117-141">Then if you get a retry from hello blob service, but hello queue service is still working, only hello part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="a3117-142">如果您決定的 toohandle 所有儲存體服務會重試以一般方式並呼叫 toohello blob 服務傳回重試錯誤，然後要求 tooboth hello blob 服務和 hello 佇列服務將會受到影響。</span><span class="sxs-lookup"><span data-stu-id="a3117-142">If you decide toohandle all storage service retries generically and a call toohello blob service returns a retryable error, then requests tooboth hello blob service and hello queue service will be impacted.</span></span>

<span data-ttu-id="a3117-143">最後，這取決於您的應用程式的 hello 複雜性。</span><span class="sxs-lookup"><span data-stu-id="a3117-143">Ultimately, this depends on hello complexity of your application.</span></span> <span data-ttu-id="a3117-144">您可以決定 toohandle hello 失敗服務，但改為 tooredirect 讀取所有儲存體服務 toohello 次要區域的要求時您 hello 主要區域中偵測到任何儲存體服務的問題，請在唯讀模式中執行 hello 應用程式。</span><span class="sxs-lookup"><span data-stu-id="a3117-144">You may decide not toohandle hello failures by service, but instead tooredirect read requests for all storage services toohello secondary region and run hello application in read-only mode when you detect a problem with any storage service in hello primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="a3117-145">其他考量</span><span class="sxs-lookup"><span data-stu-id="a3117-145">Other considerations</span></span>

<span data-ttu-id="a3117-146">這些是 hello hello 本文其餘部分中，我們將討論其他考量。</span><span class="sxs-lookup"><span data-stu-id="a3117-146">These are hello other considerations we will discuss in hello rest of this article.</span></span>

*   <span data-ttu-id="a3117-147">處理重試讀取要求，使用 hello 斷路器模式</span><span class="sxs-lookup"><span data-stu-id="a3117-147">Handling retries of read requests using hello Circuit Breaker pattern</span></span>

*   <span data-ttu-id="a3117-148">最終一致的資料和 hello 上次同步處理時間</span><span class="sxs-lookup"><span data-stu-id="a3117-148">Eventually-consistent data and hello Last Sync Time</span></span>

*   <span data-ttu-id="a3117-149">測試</span><span class="sxs-lookup"><span data-stu-id="a3117-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="a3117-150">在唯讀模式中執行您的應用程式</span><span class="sxs-lookup"><span data-stu-id="a3117-150">Running your application in read-only mode</span></span>

<span data-ttu-id="a3117-151">toouse RA-GRS 儲存體，您必須是能夠 toohandle 這兩個無法讀取的要求，失敗更新要求 （在此情況下這表示插入、 更新和刪除的更新）。</span><span class="sxs-lookup"><span data-stu-id="a3117-151">toouse RA-GRS storage, you must be able toohandle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="a3117-152">如果 hello 主要資料中心失敗，讀取要求的可重新導向的 toohello 次要資料中心，但因為 hello 次要唯讀狀態，無法更新要求。</span><span class="sxs-lookup"><span data-stu-id="a3117-152">If hello primary data center fails, read requests can be redirected toohello secondary data center, but update requests cannot because hello secondary is read only.</span></span> <span data-ttu-id="a3117-153">基於這個理由，您需要某些方式 toorun 唯讀模式中的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a3117-153">For this reason, you need some way toorun your application in read-only mode.</span></span>

<span data-ttu-id="a3117-154">例如，您可以設定將送出的任何更新要求 toohello 儲存體服務之前檢查的旗標。</span><span class="sxs-lookup"><span data-stu-id="a3117-154">For example, you can set a flag that will be checked before submitting any update requests toohello storage service.</span></span> <span data-ttu-id="a3117-155">其中一個 hello 更新要求時，您可以略過它，並傳回適當的回應 toohello 客戶。</span><span class="sxs-lookup"><span data-stu-id="a3117-155">When one of hello update requests comes through, you can skip it and return an appropriate response toohello customer.</span></span> <span data-ttu-id="a3117-156">您甚至可能會想 toodisable 特定功能完全 hello 問題解決之前，並通知使用者這些功能會暫時無法使用。</span><span class="sxs-lookup"><span data-stu-id="a3117-156">You may even want toodisable certain features altogether until hello problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="a3117-157">如果您分別決定 toohandle 錯誤，以取得每個服務，您也必須 toohandle hello 能力 toorun 唯讀模式中的應用程式服務。</span><span class="sxs-lookup"><span data-stu-id="a3117-157">If you decide toohandle errors for each service separately, you will also need toohandle hello ability toorun your application in read-only mode by service.</span></span> <span data-ttu-id="a3117-158">您可能會有唯讀旗標，為每個服務可啟用和停用和控制代碼 hello hello 程式碼中的適當位置中的適當旗標。</span><span class="sxs-lookup"><span data-stu-id="a3117-158">You could have read-only flags for each service that can be enabled and disabled and handle hello appropriate flag in hello appropriate places in your code.</span></span>

<span data-ttu-id="a3117-159">正在 toorun 無法在唯讀模式下的應用程式具有另一個好處 – 可讓您在進行主要應用程式升級期間 hello 能力 tooensure 有限的功能。</span><span class="sxs-lookup"><span data-stu-id="a3117-159">Being able toorun your application in read-only mode has another side benefit – it gives you hello ability tooensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="a3117-160">您可以觸發唯讀模式和點 toohello 次要資料中心，您的應用程式 toorun 確保沒有人正在存取 hello hello 主要區域中的資料時要進行升級。</span><span class="sxs-lookup"><span data-stu-id="a3117-160">You can trigger your application toorun in read-only mode and point toohello secondary data center, ensuring nobody is accessing hello data in hello primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="a3117-161">在唯讀模式中執行時處理更新</span><span class="sxs-lookup"><span data-stu-id="a3117-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="a3117-162">有很多種 toohandle 更新要求時在唯讀模式下執行。</span><span class="sxs-lookup"><span data-stu-id="a3117-162">There are many ways toohandle update requests when running in read-only mode.</span></span> <span data-ttu-id="a3117-163">我們不會全面討論此問題，但一般來說，有一些模式是您需要考量的。</span><span class="sxs-lookup"><span data-stu-id="a3117-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="a3117-164">您可以回應 tooyour 使用者，告訴他們您目前沒有接收更新。</span><span class="sxs-lookup"><span data-stu-id="a3117-164">You can respond tooyour user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="a3117-165">例如，連絡人管理系統無法啟用客戶 tooaccess 連絡資訊，但無法進行更新。</span><span class="sxs-lookup"><span data-stu-id="a3117-165">For example, a contact management system could enable customers tooaccess contact information but not make updates.</span></span>

2.  <span data-ttu-id="a3117-166">您可以將更新加入其他區域中的佇列。</span><span class="sxs-lookup"><span data-stu-id="a3117-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="a3117-167">在此情況下，您會在不同區域中，撰寫您的待更新要求 tooa 佇列，然後的方式 tooprocess 這些要求，hello 主要資料中心再次上線之後。</span><span class="sxs-lookup"><span data-stu-id="a3117-167">In this case, you would write your pending update requests tooa queue in a different region, and then have a way tooprocess those requests after hello primary data center comes online again.</span></span> <span data-ttu-id="a3117-168">在此案例中，您應該讓 hello 客戶知道 hello 更新要求會排入佇列供稍後處理。</span><span class="sxs-lookup"><span data-stu-id="a3117-168">In this scenario, you should let hello customer know that hello update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="a3117-169">您可以撰寫您的更新 tooa 儲存體帳戶，另一個區域中。</span><span class="sxs-lookup"><span data-stu-id="a3117-169">You can write your updates tooa storage account in another region.</span></span> <span data-ttu-id="a3117-170">接著當 hello 主要資料中心再次上線，您可以讓方式 toomerge 為 hello 主要資料，根據 hello hello 資料結構的更新。</span><span class="sxs-lookup"><span data-stu-id="a3117-170">Then when hello primary data center comes back online, you can have a way toomerge those updates into hello primary data, depending on hello structure of hello data.</span></span> <span data-ttu-id="a3117-171">例如，如果您要建立個別的檔案與 hello 名稱中的日期/時間戳記，您可以複製這些檔案後 toohello 主要區域。</span><span class="sxs-lookup"><span data-stu-id="a3117-171">For example, if you are creating separate files with a date/time stamp in hello name, you can copy those files back toohello primary region.</span></span> <span data-ttu-id="a3117-172">這適用於某些工作負載，例如記錄和 iOT 資料。</span><span class="sxs-lookup"><span data-stu-id="a3117-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="a3117-173">處理重試</span><span class="sxs-lookup"><span data-stu-id="a3117-173">Handling retries</span></span>

<span data-ttu-id="a3117-174">您如何知道哪些錯誤是可重試的？</span><span class="sxs-lookup"><span data-stu-id="a3117-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="a3117-175">這取決於 hello 儲存體用戶端程式庫。</span><span class="sxs-lookup"><span data-stu-id="a3117-175">This is determined by hello storage client library.</span></span> <span data-ttu-id="a3117-176">例如，404 錯誤 （找不到資源） 不是可重試因為重試一次它不可能 tooresult 成功。</span><span class="sxs-lookup"><span data-stu-id="a3117-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely tooresult in success.</span></span> <span data-ttu-id="a3117-177">Hello 相反地，500 錯誤是發生可重試因為伺服器發生錯誤，而且也可能只是暫時性的問題。</span><span class="sxs-lookup"><span data-stu-id="a3117-177">On hello other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="a3117-178">如需詳細資訊，請參閱 hello[開啟 hello ExponentialRetry 類別原始程式碼](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs)hello.NET 儲存體用戶端程式庫。</span><span class="sxs-lookup"><span data-stu-id="a3117-178">For more details, check out hello [open source code for hello ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in hello .NET storage client library.</span></span> <span data-ttu-id="a3117-179">（尋找 hello ShouldRetry 方法）。</span><span class="sxs-lookup"><span data-stu-id="a3117-179">(Look for hello ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="a3117-180">讀取要求</span><span class="sxs-lookup"><span data-stu-id="a3117-180">Read requests</span></span>

<span data-ttu-id="a3117-181">如果沒有發生問題的主要儲存體讀取要求的可重新導向的 toosecondary 儲存體。</span><span class="sxs-lookup"><span data-stu-id="a3117-181">Read requests can be redirected toosecondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="a3117-182">如前面所述在[最終使用一致的資料](#using-eventually-consistent-data)，它必須是可接受應用程式 toopotentially 閱讀過時資料。</span><span class="sxs-lookup"><span data-stu-id="a3117-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application toopotentially read stale data.</span></span> <span data-ttu-id="a3117-183">如果您使用 hello 儲存體用戶端程式庫 tooaccess RA-GRS 資料，您可以設定 hello 的值來指定的讀取要求的 hello 重試行**LocationMode**屬性 tooone hello 以下的：</span><span class="sxs-lookup"><span data-stu-id="a3117-183">If you are using hello storage client library tooaccess RA-GRS data, you can specify hello retry behavior of a read request by setting a value for hello **LocationMode** property tooone of hello following:</span></span>

*   <span data-ttu-id="a3117-184">**Primaryonly 啟動**  (hello 預設值)</span><span class="sxs-lookup"><span data-stu-id="a3117-184">**PrimaryOnly** (hello default)</span></span>

*   <span data-ttu-id="a3117-185">**PrimaryThenSecondary**</span><span class="sxs-lookup"><span data-stu-id="a3117-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="a3117-186">**SecondaryOnly**</span><span class="sxs-lookup"><span data-stu-id="a3117-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="a3117-187">**SecondaryThenPrimary**</span><span class="sxs-lookup"><span data-stu-id="a3117-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="a3117-188">當您將 hello **LocationMode**太**PrimaryThenSecondary**，如果 hello 初始讀取要求 toohello 主要端點失敗，發生可重試的錯誤、 hello 用戶端會自動將另一次讀取要求 toohello 次要端點。</span><span class="sxs-lookup"><span data-stu-id="a3117-188">When you set hello **LocationMode** too**PrimaryThenSecondary**, if hello initial read request toohello primary endpoint fails with a retryable error, hello client automatically makes another read request toohello secondary endpoint.</span></span> <span data-ttu-id="a3117-189">如果伺服器逾時是 hello 錯誤，則 hello 用戶端將有 hello 逾時 tooexpire 的 toowait 才從 hello 服務收到可重試的錯誤。</span><span class="sxs-lookup"><span data-stu-id="a3117-189">If hello error is a server timeout, then hello client will have toowait for hello timeout tooexpire before it receives a retryable error from hello service.</span></span>

<span data-ttu-id="a3117-190">有兩個基本上案例 tooconsider 當您決定如何 toorespond tooa 重試錯誤：</span><span class="sxs-lookup"><span data-stu-id="a3117-190">There are basically two scenarios tooconsider when you are deciding how toorespond tooa retryable error:</span></span>

*   <span data-ttu-id="a3117-191">這是隔離的問題，而且 toohello 主要端點時，後續要求將不會傳回可重試的錯誤。</span><span class="sxs-lookup"><span data-stu-id="a3117-191">This is an isolated problem and subsequent requests toohello primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="a3117-192">舉例來說，這可能發生在有暫時性網路錯誤時。</span><span class="sxs-lookup"><span data-stu-id="a3117-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="a3117-193">在此案例中，沒有顯著的效能負面影響中沒有具有**LocationMode**設定得**PrimaryThenSecondary**因為這只會發生很少。</span><span class="sxs-lookup"><span data-stu-id="a3117-193">In this scenario, there is no significant performance penalty in having **LocationMode** set too**PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="a3117-194">這是與 hello hello 主要區域中的儲存體服務中至少一個問題，而且 hello 主要區域中的所有後續要求 toothat 服務可能 tooreturn 可重試錯誤，一段時間。</span><span class="sxs-lookup"><span data-stu-id="a3117-194">This is a problem with at least one of hello storage services in hello primary region and all subsequent requests toothat service in hello primary region are likely tooreturn retryable errors for a period of time.</span></span> <span data-ttu-id="a3117-195">舉例來說，這是 hello 主要區域是否完全無法存取。</span><span class="sxs-lookup"><span data-stu-id="a3117-195">An example of this is if hello primary region is completely inaccessible.</span></span>

    <span data-ttu-id="a3117-196">在此案例中，會對效能帶來負面影響因為您所有的讀取的要求會先嘗試 hello 主要端點，請等候 hello 逾時 tooexpire，然後切換 toohello 次要端點。</span><span class="sxs-lookup"><span data-stu-id="a3117-196">In this scenario, there is a performance penalty because all your read requests will try hello primary endpoint first, wait for hello timeout tooexpire, then switch toohello secondary endpoint.</span></span>

<span data-ttu-id="a3117-197">針對這些案例，您應該識別可那里 hello 主要端點進行中的問題，並傳送所有讀取要求直接 toohello 次要端點，藉由設定 hello **LocationMode**屬性太**SecondaryOnly**。</span><span class="sxs-lookup"><span data-stu-id="a3117-197">For these scenarios, you should identify that there is an ongoing issue with hello primary endpoint and send all read requests directly toohello secondary endpoint by setting hello **LocationMode** property too**SecondaryOnly**.</span></span> <span data-ttu-id="a3117-198">此時，您也應該變更 hello 應用程式 toorun 以唯讀模式。</span><span class="sxs-lookup"><span data-stu-id="a3117-198">At this time, you should also change hello application toorun in read-only mode.</span></span> <span data-ttu-id="a3117-199">這種方法稱為 hello[斷路器模式](https://msdn.microsoft.com/library/dn589784.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a3117-199">This approach is known as hello [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="a3117-200">更新要求</span><span class="sxs-lookup"><span data-stu-id="a3117-200">Update requests</span></span>

<span data-ttu-id="a3117-201">hello 斷路器模式也可以套用的 tooupdate 要求。</span><span class="sxs-lookup"><span data-stu-id="a3117-201">hello Circuit Breaker pattern can also be applied tooupdate requests.</span></span> <span data-ttu-id="a3117-202">不過，更新的要求不可重新導向的 toosecondary 儲存區，這是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="a3117-202">However, update requests cannot be redirected toosecondary storage, which is read-only.</span></span> <span data-ttu-id="a3117-203">這些要求，您應該保留 hello **LocationMode**屬性設定太**primaryonly 啟動**  (hello 預設值)。</span><span class="sxs-lookup"><span data-stu-id="a3117-203">For these requests, you should leave hello **LocationMode** property set too**PrimaryOnly** (hello default).</span></span> <span data-ttu-id="a3117-204">toohandle 這些錯誤，您可以套用度量 toothese 要求 – 例如在一個資料列 – 10 失敗，並符合您的閾值時，切換到唯讀模式的 hello 應用程式。</span><span class="sxs-lookup"><span data-stu-id="a3117-204">toohandle these errors, you can apply a metric toothese requests – such as 10 failures in a row – and when your threshold is met, switch hello application into read-only mode.</span></span> <span data-ttu-id="a3117-205">您可以使用 hello 相同方法來傳回 tooupdate 模式所需 hello 斷路器模式的 hello 下一節中，如下所述。</span><span class="sxs-lookup"><span data-stu-id="a3117-205">You can use hello same methods for returning tooupdate mode as those described below in hello next section about hello Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="a3117-206">斷路器模式</span><span class="sxs-lookup"><span data-stu-id="a3117-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="a3117-207">應用程式中使用 hello 斷路器模式可以防止它的作業可能 toofail 重複重試一次。</span><span class="sxs-lookup"><span data-stu-id="a3117-207">Using hello Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely toofail repeatedly.</span></span> <span data-ttu-id="a3117-208">它可讓 hello 應用程式 toocontinue toorun，而非佔用 hello 作業會以指數方式重試時的時間。</span><span class="sxs-lookup"><span data-stu-id="a3117-208">It allows hello application toocontinue toorun rather than taking up time while hello operation is retried exponentially.</span></span> <span data-ttu-id="a3117-209">它也會偵測 hello 錯誤已修正，此時時間 hello 應用程式可以 hello 再次嘗試操作。</span><span class="sxs-lookup"><span data-stu-id="a3117-209">It also detects when hello fault has been fixed, at which time hello application can try hello operation again.</span></span>

### <a name="how-tooimplement-hello-circuit-breaker-pattern"></a><span data-ttu-id="a3117-210">如何 tooimplement hello 斷路器模式</span><span class="sxs-lookup"><span data-stu-id="a3117-210">How tooimplement hello circuit breaker pattern</span></span>

<span data-ttu-id="a3117-211">tooidentify 持續性的問題與主要端點，您可以監視 hello 用戶端發生可重試錯誤的頻率。</span><span class="sxs-lookup"><span data-stu-id="a3117-211">tooidentify that there is an ongoing problem with a primary endpoint, you can monitor how frequently hello client encounters retryable errors.</span></span> <span data-ttu-id="a3117-212">由於每個案例有不同，您會有 toodecide hello 臨界值想 toouse hello 決策 tooswitch toohello 次要端點，並在唯讀模式下執行 hello 應用程式。</span><span class="sxs-lookup"><span data-stu-id="a3117-212">Because each case is different, you have toodecide on hello threshold you want toouse for hello decision tooswitch toohello secondary endpoint and run hello application in read-only mode.</span></span> <span data-ttu-id="a3117-213">比方說，您可以決定 tooperform hello 參數，如果不成功的資料列中有 10 個錯誤。</span><span class="sxs-lookup"><span data-stu-id="a3117-213">For example, you could decide tooperform hello switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="a3117-214">另一個例子是 tooswitch 如果 90 %2 分鐘內的 hello 要求失敗。</span><span class="sxs-lookup"><span data-stu-id="a3117-214">Another example is tooswitch if 90% of hello requests in a 2-minute period fail.</span></span>

<span data-ttu-id="a3117-215">Hello 第一個案例中，您可以只保留的 hello 失敗計數，如果沒有到達之前成功 hello toozero 後的最大值、 設定 hello 計數。</span><span class="sxs-lookup"><span data-stu-id="a3117-215">For hello first scenario, you can simply keep a count of hello failures, and if there is a success before reaching hello maximum, set hello count back toozero.</span></span> <span data-ttu-id="a3117-216">Hello 第二個案例中，它是 toouse 的其中一種方式 tooimplement hello MemoryCache 物件 （在.NET)。</span><span class="sxs-lookup"><span data-stu-id="a3117-216">For hello second scenario, one way tooimplement it is toouse hello MemoryCache object (in .NET).</span></span> <span data-ttu-id="a3117-217">每個要求都將加入 CacheItem toohello 快取、 設定 hello 值 toosuccess (1) 或失敗 (0)，並設定 hello 到期時間 too2 分鐘從現在 （或是指定任何時間限制）。</span><span class="sxs-lookup"><span data-stu-id="a3117-217">For each request, add a CacheItem toohello cache, set hello value toosuccess (1) or fail (0), and set hello expiration time too2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="a3117-218">當達到的項目到期時間時，會自動移除 hello 項目。</span><span class="sxs-lookup"><span data-stu-id="a3117-218">When an entry's expiration time is reached, hello entry is automatically removed.</span></span> <span data-ttu-id="a3117-219">這將會為您提供一個 2 分鐘循環的視窗。</span><span class="sxs-lookup"><span data-stu-id="a3117-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="a3117-220">請要求 toohello 對儲存體服務，每次您先使用 Linq 查詢跨 hello MemoryCache 物件 toocalculate hello 成功百分比方式加總 hello 值，並除以 hello 計數。</span><span class="sxs-lookup"><span data-stu-id="a3117-220">Each time you make a request toohello storage service, you first use a Linq query across hello MemoryCache object toocalculate hello percent success by summing hello values and dividing by hello count.</span></span> <span data-ttu-id="a3117-221">當 hello 成功百分比低於某個閾值 （如 10%) 時，設定 hello **LocationMode**屬性讀取要求太**SecondaryOnly**並切換到唯讀模式之前 hello 應用程式繼續進行。</span><span class="sxs-lookup"><span data-stu-id="a3117-221">When hello percent success drops below some threshold (such as 10%), set hello **LocationMode** property for read requests too**SecondaryOnly** and switch hello application into read-only mode before continuing.</span></span>

<span data-ttu-id="a3117-222">錯誤的 hello 臨界值時 toomake hello 參數可能因服務 tooservice 在您的應用程式，因此您應該考慮讓它們可設定參數，請使用 toodetermine。</span><span class="sxs-lookup"><span data-stu-id="a3117-222">hello threshold of errors used toodetermine when toomake hello switch may vary from service tooservice in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="a3117-223">這也是以在該處您分別決定每個服務 toohandle 可重試錯誤，或成為其中一員，如先前所討論。</span><span class="sxs-lookup"><span data-stu-id="a3117-223">This is also where you decide toohandle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="a3117-224">另一個考量是如何 toohandle 多個執行個體的應用程式，以及哪些 toodo，當您在每個執行個體中偵測可重試的錯誤。</span><span class="sxs-lookup"><span data-stu-id="a3117-224">Another consideration is how toohandle multiple instances of an application, and what toodo when you detect retryable errors in each instance.</span></span> <span data-ttu-id="a3117-225">例如，您可能有 20 的 Vm 執行以相同的應用程式載入的 hello。</span><span class="sxs-lookup"><span data-stu-id="a3117-225">For example, you may have 20 VMs running with hello same application loaded.</span></span> <span data-ttu-id="a3117-226">您要個別處理每個執行個體嗎？</span><span class="sxs-lookup"><span data-stu-id="a3117-226">Do you handle each instance separately?</span></span> <span data-ttu-id="a3117-227">如果一個執行個體啟動問題、 是否要 toolimit hello 回應 toojust 這個執行個體，或您想 tootry toohave 所有執行個體在回應 hello 相同一個執行個體發生問題時？</span><span class="sxs-lookup"><span data-stu-id="a3117-227">If one instance starts having problems, do you want toolimit hello response toojust that one instance, or do you want tootry toohave all instances respond in hello same way when one instance has a problem?</span></span> <span data-ttu-id="a3117-228">分別處理 hello 執行個體，會比嘗試 toocoordinate hello 回應跨，更簡單，但做法取決於您的應用程式架構。</span><span class="sxs-lookup"><span data-stu-id="a3117-228">Handling hello instances separately is much simpler than trying toocoordinate hello response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-hello-error-frequency"></a><span data-ttu-id="a3117-229">監視 hello 錯誤頻率的選項</span><span class="sxs-lookup"><span data-stu-id="a3117-229">Options for monitoring hello error frequency</span></span>

<span data-ttu-id="a3117-230">您有三個主要選項時透過 toohello 次要區域和變更 tooswitch hello 唯讀模式中的應用程式 toorun 監視的重試次數 hello toodetermine 順序中的主要區域中的 hello 頻率。</span><span class="sxs-lookup"><span data-stu-id="a3117-230">You have three main options for monitoring hello frequency of retries in hello primary region in order toodetermine when tooswitch over toohello secondary region and change hello application toorun in read-only mode.</span></span>

*   <span data-ttu-id="a3117-231">加入的處理常式 hello [**正在重試**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx)事件 hello [ **OperationContext** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx)物件傳遞 tooyour 儲存體要求 – 這是 hello方法會顯示在這份文件，而且 hello 隨附的範例中使用。</span><span class="sxs-lookup"><span data-stu-id="a3117-231">Add a handler for hello [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on hello [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass tooyour storage requests – this is hello method displayed in this article and used in hello accompanying sample.</span></span> <span data-ttu-id="a3117-232">每當 hello 用戶端重試要求時，會引發這些事件，讓您 tootrack 頻率 hello 用戶端發生可重試錯誤上主要端點。</span><span class="sxs-lookup"><span data-stu-id="a3117-232">These events fire whenever hello client retries a request, enabling you tootrack how often hello client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in hello primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="a3117-233">在 hello [**評估**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx)方法中的自訂重試原則，您可以執行自訂程式碼，每當重試會發生。</span><span class="sxs-lookup"><span data-stu-id="a3117-233">In hello [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="a3117-234">加法 toorecording 重試發生失敗時，這也可讓您 hello 機會 toomodify 重試行中。</span><span class="sxs-lookup"><span data-stu-id="a3117-234">In addition toorecording when a retry happens, this also gives you hello opportunity toomodify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in hello primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="a3117-235">hello 第三種方法是 tooimplement 持續偵測您的主要儲存體端點與虛擬應用程式中的自訂監視元件讀取要求 （例如讀取小型 blob） toodetermine 其健全狀況。</span><span class="sxs-lookup"><span data-stu-id="a3117-235">hello third approach is tooimplement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) toodetermine its health.</span></span> <span data-ttu-id="a3117-236">這會佔用某些資源，但時間不是很長。</span><span class="sxs-lookup"><span data-stu-id="a3117-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="a3117-237">當探索問題時，達到臨界值時，您會接著執行 hello 參數太**SecondaryOnly**和唯讀模式。</span><span class="sxs-lookup"><span data-stu-id="a3117-237">When a problem is discovered that reaches your threshold, you would then perform hello switch too**SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="a3117-238">在某些時候，您會想 tooswitch 後 toousing hello 主要端點，並允許更新。</span><span class="sxs-lookup"><span data-stu-id="a3117-238">At some point, you will want tooswitch back toousing hello primary endpoint and allowing updates.</span></span> <span data-ttu-id="a3117-239">如果使用其中一種 hello 上面所列的前兩個方法，只要無法切換後 toohello 主要端點，並執行可任意所選的時間內或作業的數目之後啟用更新模式。</span><span class="sxs-lookup"><span data-stu-id="a3117-239">If using one of hello first two methods listed above, you could simply switch back toohello primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="a3117-240">您可以讓它再次瀏覽 hello 重試邏輯。</span><span class="sxs-lookup"><span data-stu-id="a3117-240">You can then let it go through hello retry logic again.</span></span> <span data-ttu-id="a3117-241">如果已修正 hello 問題，它將繼續 toouse hello 主要端點，並允許更新。</span><span class="sxs-lookup"><span data-stu-id="a3117-241">If hello problem has been fixed, it will continue toouse hello primary endpoint and allow updates.</span></span> <span data-ttu-id="a3117-242">如果仍有問題，會一次後失敗的已設定的 hello 準則切換後 toohello 次要端點和唯讀模式。</span><span class="sxs-lookup"><span data-stu-id="a3117-242">If there is still a problem, it will once more switch back toohello secondary endpoint and read-only mode after failing hello criteria you've set.</span></span>

<span data-ttu-id="a3117-243">Hello 第三個案例中，當執行 ping hello 主要儲存體端點再次變為無法成功，您可以觸發 hello 切換回太**primaryonly 啟動** 並繼續允許更新。</span><span class="sxs-lookup"><span data-stu-id="a3117-243">For hello third scenario, when pinging hello primary storage endpoint becomes successful again, you can trigger hello switch back too**PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="a3117-244">處理最終一致的資料</span><span class="sxs-lookup"><span data-stu-id="a3117-244">Handling eventually consistent data</span></span>

<span data-ttu-id="a3117-245">RA-GRS 運作方式是從 hello 主要 toohello 次要區域複寫的交易。</span><span class="sxs-lookup"><span data-stu-id="a3117-245">RA-GRS works by replicating transactions from hello primary toohello secondary region.</span></span> <span data-ttu-id="a3117-246">此複寫程序可以確保 hello hello 次要區域中的資料將會*最終一致*。</span><span class="sxs-lookup"><span data-stu-id="a3117-246">This replication process guarantees that hello data in hello secondary region is *eventually consistent*.</span></span> <span data-ttu-id="a3117-247">這表示，所有 hello 主要區域中的 hello 交易最後會都出現在 hello 次要區域中，但可能會有延隔時間才會都出現，而且沒有任何的保證 hello 交易到達的 hello 相同順序中的 hello 次要區域可在其中它們當初套用 hello 主要區域中。</span><span class="sxs-lookup"><span data-stu-id="a3117-247">This means that all hello transactions in hello primary region will eventually appear in hello secondary region, but that there may be a lag before they appear, and that there is no guarantee hello transactions arrive in hello secondary region in hello same order as that in which they were originally applied in hello primary region.</span></span> <span data-ttu-id="a3117-248">如果您的交易到達 hello 次要區域不按順序，您*可能*hello 服務趕上之前，請考慮您的資料不一致的狀態中的 hello 次要區域 toobe。</span><span class="sxs-lookup"><span data-stu-id="a3117-248">If your transactions arrive in hello secondary region out of order, you *may* consider your data in hello secondary region toobe in an inconsistent state until hello service catches up.</span></span>

<span data-ttu-id="a3117-249">hello 下表顯示當您更新的員工 toomake hello 詳細資料時，可能會發生什麼情況的範例她的 hello 成員*管理員*角色。</span><span class="sxs-lookup"><span data-stu-id="a3117-249">hello following table shows an example of what might happen when you update hello details of an employee toomake her a member of hello *administrators* role.</span></span> <span data-ttu-id="a3117-250">對於此範例中的 hello 起見，這需要您更新 hello**員工**實體並更新**系統管理員角色**實體系統管理員的 hello 總數的計數。</span><span class="sxs-lookup"><span data-stu-id="a3117-250">For hello sake of this example, this requires you update hello **employee** entity and update an **administrator role** entity with a count of hello total number of administrators.</span></span> <span data-ttu-id="a3117-251">請注意 hello 套用更新的順序 hello 次要區域中。</span><span class="sxs-lookup"><span data-stu-id="a3117-251">Notice how hello updates are applied out of order in hello secondary region.</span></span>

| <bpt id="p1">**</bpt>Time<ept id="p1">**</ept> | <span data-ttu-id="a3117-253">**交易**</span><span class="sxs-lookup"><span data-stu-id="a3117-253">**Transaction**</span></span>                                            | <span data-ttu-id="a3117-254">**複寫**</span><span class="sxs-lookup"><span data-stu-id="a3117-254">**Replication**</span></span>                       | <span data-ttu-id="a3117-255">**上次同步處理時間**</span><span class="sxs-lookup"><span data-stu-id="a3117-255">**Last Sync Time**</span></span> | <span data-ttu-id="a3117-256">**結果**</span><span class="sxs-lookup"><span data-stu-id="a3117-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="a3117-257">T0</span><span class="sxs-lookup"><span data-stu-id="a3117-257">T0</span></span>       | <span data-ttu-id="a3117-258">交易 A：</span><span class="sxs-lookup"><span data-stu-id="a3117-258">Transaction A:</span></span> <br> <span data-ttu-id="a3117-259">會在主要區域中</span><span class="sxs-lookup"><span data-stu-id="a3117-259">Insert employee</span></span> <br> <span data-ttu-id="a3117-260">插入員工實體</span><span class="sxs-lookup"><span data-stu-id="a3117-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="a3117-261">交易 A 插入 tooprimary，</span><span class="sxs-lookup"><span data-stu-id="a3117-261">Transaction A inserted tooprimary,</span></span><br> <span data-ttu-id="a3117-262">但尚未複寫。</span><span class="sxs-lookup"><span data-stu-id="a3117-262">not replicated yet.</span></span> |
| <span data-ttu-id="a3117-263">T1</span><span class="sxs-lookup"><span data-stu-id="a3117-263">T1</span></span>       |                                                            | <span data-ttu-id="a3117-264">交易 A</span><span class="sxs-lookup"><span data-stu-id="a3117-264">Transaction A</span></span> <br> <span data-ttu-id="a3117-265">已複寫到</span><span class="sxs-lookup"><span data-stu-id="a3117-265">replicated to</span></span><br> <span data-ttu-id="a3117-266">次要區域</span><span class="sxs-lookup"><span data-stu-id="a3117-266">secondary</span></span> | <span data-ttu-id="a3117-267">T1</span><span class="sxs-lookup"><span data-stu-id="a3117-267">T1</span></span> | <span data-ttu-id="a3117-268">交易 A 複寫 toosecondary。</span><span class="sxs-lookup"><span data-stu-id="a3117-268">Transaction A replicated toosecondary.</span></span> <br><span data-ttu-id="a3117-269">已更新上次同步處理時間。</span><span class="sxs-lookup"><span data-stu-id="a3117-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="a3117-270">T2</span><span class="sxs-lookup"><span data-stu-id="a3117-270">T2</span></span>       | <span data-ttu-id="a3117-271">交易 B：</span><span class="sxs-lookup"><span data-stu-id="a3117-271">Transaction B:</span></span><br><span data-ttu-id="a3117-272">更新</span><span class="sxs-lookup"><span data-stu-id="a3117-272">Update</span></span><br> <span data-ttu-id="a3117-273">主要區域中的</span><span class="sxs-lookup"><span data-stu-id="a3117-273">employee entity</span></span><br> <span data-ttu-id="a3117-274">員工實體</span><span class="sxs-lookup"><span data-stu-id="a3117-274">in primary</span></span>  |                                | <span data-ttu-id="a3117-275">T1</span><span class="sxs-lookup"><span data-stu-id="a3117-275">T1</span></span>                 | <span data-ttu-id="a3117-276">交易 B 寫入 tooprimary，</span><span class="sxs-lookup"><span data-stu-id="a3117-276">Transaction B written tooprimary,</span></span><br> <span data-ttu-id="a3117-277">但尚未複寫。</span><span class="sxs-lookup"><span data-stu-id="a3117-277">not replicated yet.</span></span>  |
| <span data-ttu-id="a3117-278">T3</span><span class="sxs-lookup"><span data-stu-id="a3117-278">T3</span></span>       | <span data-ttu-id="a3117-279">交易 C：</span><span class="sxs-lookup"><span data-stu-id="a3117-279">Transaction C:</span></span><br> <span data-ttu-id="a3117-280">更新</span><span class="sxs-lookup"><span data-stu-id="a3117-280">Update</span></span> <br><span data-ttu-id="a3117-281">administrator</span><span class="sxs-lookup"><span data-stu-id="a3117-281">administrator</span></span><br><span data-ttu-id="a3117-282">角色實體，位於</span><span class="sxs-lookup"><span data-stu-id="a3117-282">role entity in</span></span><br><span data-ttu-id="a3117-283">primary</span><span class="sxs-lookup"><span data-stu-id="a3117-283">primary</span></span> |                    | <span data-ttu-id="a3117-284">T1</span><span class="sxs-lookup"><span data-stu-id="a3117-284">T1</span></span>                 | <span data-ttu-id="a3117-285">交易寫入 tooprimary C</span><span class="sxs-lookup"><span data-stu-id="a3117-285">Transaction C written tooprimary,</span></span><br> <span data-ttu-id="a3117-286">但尚未複寫。</span><span class="sxs-lookup"><span data-stu-id="a3117-286">not replicated yet.</span></span>  |
| <span data-ttu-id="a3117-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="a3117-287">*T4*</span></span>     |                                                       | <span data-ttu-id="a3117-288">交易 C</span><span class="sxs-lookup"><span data-stu-id="a3117-288">Transaction C</span></span> <br><span data-ttu-id="a3117-289">已複寫到</span><span class="sxs-lookup"><span data-stu-id="a3117-289">replicated to</span></span><br> <span data-ttu-id="a3117-290">次要區域</span><span class="sxs-lookup"><span data-stu-id="a3117-290">secondary</span></span> | <span data-ttu-id="a3117-291">T1</span><span class="sxs-lookup"><span data-stu-id="a3117-291">T1</span></span>         | <span data-ttu-id="a3117-292">C 的交易複寫 toosecondary。</span><span class="sxs-lookup"><span data-stu-id="a3117-292">Transaction C replicated toosecondary.</span></span><br><span data-ttu-id="a3117-293">無法更新 LastSyncTime，因為</span><span class="sxs-lookup"><span data-stu-id="a3117-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="a3117-294">尚未複寫交易 B。</span><span class="sxs-lookup"><span data-stu-id="a3117-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="a3117-295">*T5*</span><span class="sxs-lookup"><span data-stu-id="a3117-295">*T5*</span></span>     | <span data-ttu-id="a3117-296">從次要區域</span><span class="sxs-lookup"><span data-stu-id="a3117-296">Read entities</span></span> <br><span data-ttu-id="a3117-297">讀取實體</span><span class="sxs-lookup"><span data-stu-id="a3117-297">from secondary</span></span>                           |                                  | <span data-ttu-id="a3117-298">T1</span><span class="sxs-lookup"><span data-stu-id="a3117-298">T1</span></span>                 | <span data-ttu-id="a3117-299">取得 hello 員工過時的值</span><span class="sxs-lookup"><span data-stu-id="a3117-299">You get hello stale value for employee</span></span> <br> <span data-ttu-id="a3117-300">因為交易 B 尚未</span><span class="sxs-lookup"><span data-stu-id="a3117-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="a3117-301">複寫。</span><span class="sxs-lookup"><span data-stu-id="a3117-301">replicated yet.</span></span> <span data-ttu-id="a3117-302">取得 hello 新值</span><span class="sxs-lookup"><span data-stu-id="a3117-302">You get hello new value for</span></span><br> <span data-ttu-id="a3117-303">的新值，因為 C</span><span class="sxs-lookup"><span data-stu-id="a3117-303">administrator role entity because C has</span></span><br> <span data-ttu-id="a3117-304">已複寫。</span><span class="sxs-lookup"><span data-stu-id="a3117-304">replicated.</span></span> <span data-ttu-id="a3117-305">上次同步處理時間仍然尚未</span><span class="sxs-lookup"><span data-stu-id="a3117-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="a3117-306">更新，因為交易 B</span><span class="sxs-lookup"><span data-stu-id="a3117-306">been updated because transaction B</span></span><br> <span data-ttu-id="a3117-307">尚未複寫。</span><span class="sxs-lookup"><span data-stu-id="a3117-307">hasn't replicated.</span></span> <span data-ttu-id="a3117-308">您可以說</span><span class="sxs-lookup"><span data-stu-id="a3117-308">You can tell the</span></span><br><span data-ttu-id="a3117-309">系統管理員角色實體不一致，</span><span class="sxs-lookup"><span data-stu-id="a3117-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="a3117-310">因為 hello 實體日期/時間是之後</span><span class="sxs-lookup"><span data-stu-id="a3117-310">because hello entity date/time is after</span></span> <br><span data-ttu-id="a3117-311">hello 上次同步處理時間。</span><span class="sxs-lookup"><span data-stu-id="a3117-311">hello Last Sync Time.</span></span> |
| <span data-ttu-id="a3117-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="a3117-312">*T6*</span></span>     |                                                      | <span data-ttu-id="a3117-313">交易 B</span><span class="sxs-lookup"><span data-stu-id="a3117-313">Transaction B</span></span><br> <span data-ttu-id="a3117-314">已複寫到</span><span class="sxs-lookup"><span data-stu-id="a3117-314">replicated to</span></span><br> <span data-ttu-id="a3117-315">次要區域</span><span class="sxs-lookup"><span data-stu-id="a3117-315">secondary</span></span> | <span data-ttu-id="a3117-316">T6</span><span class="sxs-lookup"><span data-stu-id="a3117-316">T6</span></span>                 | <span data-ttu-id="a3117-317">*T6* - 透過 C 的所有交易都</span><span class="sxs-lookup"><span data-stu-id="a3117-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="a3117-318">已複寫，上次同步處理時間</span><span class="sxs-lookup"><span data-stu-id="a3117-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="a3117-319">已更新。</span><span class="sxs-lookup"><span data-stu-id="a3117-319">is updated.</span></span> |

<span data-ttu-id="a3117-320">在此範例中，假設 hello 用戶端參數 tooreading 從 T5 hello 次要區域。</span><span class="sxs-lookup"><span data-stu-id="a3117-320">In this example, assume hello client switches tooreading from hello secondary region at T5.</span></span> <span data-ttu-id="a3117-321">可順利讀取 hello**系統管理員角色**實體，在這個階段，但 hello 實體包含的系統管理員與 hello 數目不一致的 hello 計數的值**員工**實體此時標示為 hello 次要區域中的管理員。</span><span class="sxs-lookup"><span data-stu-id="a3117-321">It can successfully read hello **administrator role** entity at this time, but hello entity contains a value for hello count of administrators that is not consistent with hello number of **employee** entities that are marked as administrators in hello secondary region at this time.</span></span> <span data-ttu-id="a3117-322">您的用戶端可能只會顯示這個值，與 hello 風險，它是不一致的資訊。</span><span class="sxs-lookup"><span data-stu-id="a3117-322">Your client could simply display this value, with hello risk that it is inconsistent information.</span></span> <span data-ttu-id="a3117-323">或者，hello 用戶端無法嘗試 toodetermine 該 hello**系統管理員角色**處於可能不一致的狀態，因此 hello 更新是按順序，然後通知 hello 使用者，此事實。</span><span class="sxs-lookup"><span data-stu-id="a3117-323">Alternatively, hello client could attempt toodetermine that hello **administrator role** is in a potentially inconsistent state because hello updates have happened out of order, and then inform hello user of this fact.</span></span>

<span data-ttu-id="a3117-324">toorecognize 有潛在的不一致的資料，hello 用戶端可以使用 hello hello 值*上次同步處理時間*，就可以隨時藉由查詢儲存體服務。</span><span class="sxs-lookup"><span data-stu-id="a3117-324">toorecognize that it has potentially inconsistent data, hello client can use hello value of hello *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="a3117-325">這會告訴您 hello 次要區域中的 hello 資料上次 hello 時間一致和時套用 hello 服務所有 hello 交易先前 toothat 點的時間。</span><span class="sxs-lookup"><span data-stu-id="a3117-325">This tells you hello time when hello data in hello secondary region was last consistent and when hello service had applied all hello transactions prior toothat point in time.</span></span> <span data-ttu-id="a3117-326">在 hello 範例中，如上所示之後 hello 服務插入 hello,**員工**hello 次要區域中的實體，hello 上次同步處理時間設定太*T1*。</span><span class="sxs-lookup"><span data-stu-id="a3117-326">In hello example shown above, after hello service inserts hello **employee** entity in hello secondary region, hello last sync time is set too*T1*.</span></span> <span data-ttu-id="a3117-327">它會保持*T1*直到 hello 服務更新 hello**員工**時設定太 hello 次要區域中的實體*T6*。</span><span class="sxs-lookup"><span data-stu-id="a3117-327">It remains at *T1* until hello service updates hello **employee** entity in hello secondary region when it is set too*T6*.</span></span> <span data-ttu-id="a3117-328">如果 hello 用戶端會擷取 hello 上次同步處理時間，它會讀取位於 hello 實體*T5*，它可以比較它與 hello hello 實體上的時間戳記。</span><span class="sxs-lookup"><span data-stu-id="a3117-328">If hello client retrieves hello last sync time when it reads hello entity at *T5*, it can compare it with hello timestamp on hello entity.</span></span> <span data-ttu-id="a3117-329">Hello hello 實體上的時間戳記必須晚於 hello 上次同步處理時間，然後 hello 實體是潛在的不一致的狀態，且您可以採取任何是 hello 適當的動作，您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a3117-329">If hello timestamp on hello entity is later than hello last sync time, then hello entity is in a potentially inconsistent state, and you can take whatever is hello appropriate action for your application.</span></span> <span data-ttu-id="a3117-330">使用此欄位必須了解當 hello 上次更新 toohello 主要已完成。</span><span class="sxs-lookup"><span data-stu-id="a3117-330">Using this field requires that you know when hello last update toohello primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="a3117-331">測試</span><span class="sxs-lookup"><span data-stu-id="a3117-331">Testing</span></span>

<span data-ttu-id="a3117-332">應用程式的行為如預期般發生可重試的錯誤時的重要 tootest 它。</span><span class="sxs-lookup"><span data-stu-id="a3117-332">It's important tootest that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="a3117-333">例如，您需要 hello 應用程式切換 toohello 次要的 tootest 而且到唯讀模式時偵測到問題，並切換回 hello 主要區域何時可供使用一次。</span><span class="sxs-lookup"><span data-stu-id="a3117-333">For example, you need tootest that hello application switches toohello secondary and into read-only mode when it detects a problem, and switches back when hello primary region becomes available again.</span></span> <span data-ttu-id="a3117-334">toodo，您需要的方式 toosimulate 可重試錯誤，並控制在發生的頻率。</span><span class="sxs-lookup"><span data-stu-id="a3117-334">toodo this, you need a way toosimulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="a3117-335">您可以使用[Fiddler](http://www.telerik.com/fiddler) toointercept 和修改指令碼中的 HTTP 回應。</span><span class="sxs-lookup"><span data-stu-id="a3117-335">You can use [Fiddler](http://www.telerik.com/fiddler) toointercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="a3117-336">此指令碼可以識別來自主要端點的回應，並變更 hello HTTP 狀態碼 tooone 該 hello 儲存體用戶端程式庫會辨識為可重試的錯誤。</span><span class="sxs-lookup"><span data-stu-id="a3117-336">This script can identify responses that come from your primary endpoint and change hello HTTP status code tooone that hello Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="a3117-337">這個程式碼片段會示範會攔截對 hello 回應 tooread 要求 Fiddler 指令碼的簡單範例**employeedata**資料表 tooreturn 502 狀態：</span><span class="sxs-lookup"><span data-stu-id="a3117-337">This code snippet shows a simple example of a Fiddler script that intercepts responses tooread requests against hello **employeedata** table tooreturn a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="a3117-338">您無法擴充此範例 toointercept 廣泛的要求，而且只變更 hello **responseCode**上其中部分 toobetter 模擬真實世界的實例。</span><span class="sxs-lookup"><span data-stu-id="a3117-338">You could extend this example toointercept a wider range of requests and only change hello **responseCode** on some of them toobetter simulate a real-world scenario.</span></span> <span data-ttu-id="a3117-339">如需自訂 Fiddler 指令碼的詳細資訊，請參閱[修改要求或回應](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse)hello Fiddler 文件中。</span><span class="sxs-lookup"><span data-stu-id="a3117-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in hello Fiddler documentation.</span></span>

<span data-ttu-id="a3117-340">如果您做了 hello 切換您的應用程式僅限 tooread 模式可設定的臨界值，它將會更容易 tootest hello 行為與非實際執行的交易量。</span><span class="sxs-lookup"><span data-stu-id="a3117-340">If you have made hello thresholds for switching your application tooread-only mode configurable, it will be easier tootest hello behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="a3117-341">後續步驟</span><span class="sxs-lookup"><span data-stu-id="a3117-341">Next Steps</span></span>

* <span data-ttu-id="a3117-342">如需有關讀取存取異地備援，包括如何設定 hello LastSyncTime，另一個範例，請參閱[Windows Azure 儲存體備援選項和讀取權限地理備援儲存體](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/)。</span><span class="sxs-lookup"><span data-stu-id="a3117-342">For more information about Read Access Geo-Redundancy, including another example of how hello LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="a3117-343">如需完整範例，顯示如何 toomake hello hello 主要和次要端點之間來回切換，請參閱[Azure 範例-使用 RA-GRS 儲存體與 hello 斷路器模式](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs)。</span><span class="sxs-lookup"><span data-stu-id="a3117-343">For a complete sample showing how toomake hello switch back and forth between hello Primary and Secondary endpoints, please see [Azure Samples – Using hello Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
