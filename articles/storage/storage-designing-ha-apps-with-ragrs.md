---
title: "使用 Azure 讀取權限異地備援儲存體 (RA-GRS) 設計高可用性應用程式 | Microsoft Docs"
description: "如何使用 Azure RA-GRS 儲存體來設計高可用性應用程式的架構，使其有足夠的彈性來處理中斷。"
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: adc7e23d8c9f869f2951490020e3d0f1a2b2e81c
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/03/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="c58e1-103">使用 RA-GRS 設計高可用性應用程式</span><span class="sxs-lookup"><span data-stu-id="c58e1-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="c58e1-104">雲端式基礎結構的常見功能是提供高可用性平台來裝載應用程式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="c58e1-105">雲端式應用程式的開發人員必須仔細考慮如何運用此平台，來為使用者提供高可用性應用程式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-105">Developers of cloud-based applications must consider carefully how to leverage this platform to deliver highly available applications to their users.</span></span> <span data-ttu-id="c58e1-106">本文特別著重於開發人員如何利用 Azure 儲存體讀取權限異地備援儲存體 (RA-GRS)，來提高其應用程式的可用性。</span><span class="sxs-lookup"><span data-stu-id="c58e1-106">This article focuses specifically on how developers can use the Azure Storage Read Access Geo Redundant Storage (RA-GRS) to make their applications more available.</span></span>

<span data-ttu-id="c58e1-107">有四種備援選項 - LRS (本地備援儲存體)、ZRS (區域備援儲存體)、GRS (異地備援儲存體) 和 RA-GRS (讀取權限異地備援儲存體)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="c58e1-108">我們將在本文中討論 GRS 和 RA-GRS。</span><span class="sxs-lookup"><span data-stu-id="c58e1-108">We are going to discuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="c58e1-109">使用 GRS 時，會在您設定儲存體帳戶時選取的主要區域中保留三份您的資料。</span><span class="sxs-lookup"><span data-stu-id="c58e1-109">With GRS, three copies of your data are kept in the primary region you selected when setting up the storage account.</span></span> <span data-ttu-id="c58e1-110">另外會以非同步方式在 Azure 所指定的次要區域中保留三個額外複本。</span><span class="sxs-lookup"><span data-stu-id="c58e1-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="c58e1-111">除了您具備次要複本的讀取權限之外，RA-GRS 與 GRS 一樣。</span><span class="sxs-lookup"><span data-stu-id="c58e1-111">RA-GRS is the same thing as GRS except that you have read access to the secondary copy.</span></span> <span data-ttu-id="c58e1-112">如需各種 Azure 儲存體備援選項的詳細資訊，請參閱 [Azure 儲存體複寫](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-112">For more information about the different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="c58e1-113">該複寫文章也會示範主要和次要區域的配對。</span><span class="sxs-lookup"><span data-stu-id="c58e1-113">The replication article also shows the pairings of the primary and secondary regions.</span></span>

<span data-ttu-id="c58e1-114">本文提供一些程式碼片段，並在結尾處提供完整範例的連結，可供您下載並執行。</span><span class="sxs-lookup"><span data-stu-id="c58e1-114">There are code snippets included in this article, and a link to a complete sample at the end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="c58e1-115">RA-GRS 的主要功能</span><span class="sxs-lookup"><span data-stu-id="c58e1-115">Key features of RA-GRS</span></span>

<span data-ttu-id="c58e1-116">在討論如何使用 RA-GRS 儲存體之前，讓我們先談論它的屬性和行為。</span><span class="sxs-lookup"><span data-stu-id="c58e1-116">Before we talk about how to use RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="c58e1-117">Azure 儲存體會在次要區域中保留一份您儲存於主要區域之資料的唯讀複本；如前所述，儲存體服務會判斷次要區域的位置。</span><span class="sxs-lookup"><span data-stu-id="c58e1-117">Azure Storage maintains a read-only copy of the data you store in your primary region in a secondary region; as noted above, the storage service determines the location of the secondary region.</span></span>

* <span data-ttu-id="c58e1-118">唯讀複本與主要區域中的資料是[最終一致](https://en.wikipedia.org/wiki/Eventual_consistency)的。</span><span class="sxs-lookup"><span data-stu-id="c58e1-118">The read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with the data in the primary region.</span></span>

* <span data-ttu-id="c58e1-119">針對 Blob、資料表和佇列，您可以查詢次要區域來取得 [上次同步處理時間] 值，讓您知道上次從主要區域複寫到次要區域是在何時發生</span><span class="sxs-lookup"><span data-stu-id="c58e1-119">For blobs, tables, and queues, you can query the secondary region for a *Last Sync Time* value that tells you when the last replication from the primary to the secondary region occurred.</span></span> <span data-ttu-id="c58e1-120">(Azure 檔案儲存體不支援此動作，它目前沒有 RA-GRS 備援)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="c58e1-121">您可以使用儲存體用戶端程式庫，來與主要或次要區域中的資料進行互動。</span><span class="sxs-lookup"><span data-stu-id="c58e1-121">You can use the Storage Client Library to interact with the data in either the primary or secondary region.</span></span> <span data-ttu-id="c58e1-122">如果對主要區域的讀取要求逾時，您也可以將讀取要求自動重新導向到次要區域。</span><span class="sxs-lookup"><span data-stu-id="c58e1-122">You can also redirect read requests automatically to the secondary region if a read request to the primary region times out.</span></span>

* <span data-ttu-id="c58e1-123">如果產生會影響主要區域中資料可存取性的主要問題，Azure 團隊可能會觸發異地複寫容錯移轉，此時指向主要區域的 DNS 項目將會變更為指向次要區域。</span><span class="sxs-lookup"><span data-stu-id="c58e1-123">If there is a major issue affecting the accessibility of the data in the primary region, the Azure team may trigger a geo-failover, at which point the DNS entries pointing to the primary region will be changed to point to the secondary region.</span></span>

* <span data-ttu-id="c58e1-124">發生異地複寫容錯移轉時，Azure 將會選取新的次要位置並將資料複寫到該位置，然後將次要 DNS 項目指向它。</span><span class="sxs-lookup"><span data-stu-id="c58e1-124">If a geo-failover occurs, Azure will select a new secondary location and replicate the data to that location, then point the secondary DNS entries to it.</span></span> <span data-ttu-id="c58e1-125">次要端點要到儲存體帳戶複寫完成之後才能使用。</span><span class="sxs-lookup"><span data-stu-id="c58e1-125">The secondary endpoint will be unavailable until the storage account has finished replicating.</span></span> <span data-ttu-id="c58e1-126">如需詳細資訊，請參閱[如果 Azure 儲存體發生中斷怎麼辦](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-126">For more information, please see [What to do if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="c58e1-127">使用 RA-GRS 時的應用程式設計考量</span><span class="sxs-lookup"><span data-stu-id="c58e1-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="c58e1-128">本文的主要目的是示範如何設計即使主要資料中心發生重大災害，仍能繼續運作 (儘管容量有限) 的應用程式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-128">The main purpose of this article is to show you how to design an application that will continue to function (albeit in a limited capacity) even in the event of a major disaster at the primary data center.</span></span> <span data-ttu-id="c58e1-129">為了達成此目的，您可以讓應用程式在發生問題切換到從次要區域讀取，然後在主要區域再次可用時切換回來，藉以處理暫時性或長時間執行的問題。</span><span class="sxs-lookup"><span data-stu-id="c58e1-129">You do this by having your application to handle transient or long-running issues by switching to read from the secondary region while there is a problem, and switching back when the primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="c58e1-130">使用最終一致的資料</span><span class="sxs-lookup"><span data-stu-id="c58e1-130">Using eventually consistent data</span></span>

<span data-ttu-id="c58e1-131">這個建議的解決方案假設可以將可能過時的資料傳回呼叫的應用程式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-131">This proposed solution assumes that it is okay to return what could be stale data to the calling application.</span></span> <span data-ttu-id="c58e1-132">由於次要資料最終會維持一致，因此有可能已將資料寫入主要區域，但對次要區域的更新因為主要區域變成不可存取而無法完成複寫。</span><span class="sxs-lookup"><span data-stu-id="c58e1-132">Because the secondary data is eventually consistent, it is possible that the data was written to the primary but the update to the secondary had not finished replicating when the primary region became inaccessible.</span></span>

<span data-ttu-id="c58e1-133">例如，您的客戶成功提交更新，接著主要區域在將該更新傳播到次要區域時當機。</span><span class="sxs-lookup"><span data-stu-id="c58e1-133">For example, your customer could submit an update that is successful, and then the primary could go down before the update is propagated to the secondary.</span></span> <span data-ttu-id="c58e1-134">在此情況下，如果客戶接著要求讀回資料，則他會接收到過時的資料，而不是更新的資料。</span><span class="sxs-lookup"><span data-stu-id="c58e1-134">In this case, if the customer then asks to read the data back, he receives the stale data instead of the updated data.</span></span> <span data-ttu-id="c58e1-135">您必須決定是否可接受此情況，如果可以，您該如何傳達給為客戶。</span><span class="sxs-lookup"><span data-stu-id="c58e1-135">You must decide if this is acceptable, and if so, how you will message the customer.</span></span> <span data-ttu-id="c58e1-136">您將在本文後續內容中看到如何檢查次要資料的上次同步處理時間，以查看該次要資料是否為最新狀態。</span><span class="sxs-lookup"><span data-stu-id="c58e1-136">You'll see how to check the Last Sync Time on the secondary data later in this article to see if the secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="c58e1-137">個別處理服務或一併處理所有服務</span><span class="sxs-lookup"><span data-stu-id="c58e1-137">Handling services separately or all together</span></span>

<span data-ttu-id="c58e1-138">儘管不太可能，但某一個服務可能會在其他服務仍可完全運作時變成無法使用。</span><span class="sxs-lookup"><span data-stu-id="c58e1-138">While not likely, it is possible for one service to become unavailable while the other services are still fully functional.</span></span> <span data-ttu-id="c58e1-139">您可以針對每個服務 (Blob、佇列、資料表) 個別處理重試和唯讀模式，或者以一般方式一併處理所有儲存體服務的重試。</span><span class="sxs-lookup"><span data-stu-id="c58e1-139">You can handle the retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all the storage services together.</span></span>

<span data-ttu-id="c58e1-140">例如，如果您在應用程式中使用佇列和 Blob，您就能決定放入不同程式碼來處理這其中每一個項目的可重試錯誤。</span><span class="sxs-lookup"><span data-stu-id="c58e1-140">For example, if you use queues and blobs in your application, you may decide to put in separate code to handle retryable errors for each of these.</span></span> <span data-ttu-id="c58e1-141">接著，如果您從 Blob 服務進行重試，但佇列服務仍在運作，則只有處理 Blob 的應用程式組件會受到影響。</span><span class="sxs-lookup"><span data-stu-id="c58e1-141">Then if you get a retry from the blob service, but the queue service is still working, only the part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="c58e1-142">如果您決定要以一般方式處理所有儲存體服務重試，而且對 Blob 服務的呼叫會傳回可重試的錯誤，則對 Blob 服務和佇列服務的要求都將受到影響。</span><span class="sxs-lookup"><span data-stu-id="c58e1-142">If you decide to handle all storage service retries generically and a call to the blob service returns a retryable error, then requests to both the blob service and the queue service will be impacted.</span></span>

<span data-ttu-id="c58e1-143">這最終取決於應用程式的複雜性。</span><span class="sxs-lookup"><span data-stu-id="c58e1-143">Ultimately, this depends on the complexity of your application.</span></span> <span data-ttu-id="c58e1-144">在您偵測到主要區域中發生任何儲存體服務的問題時，您可能會決定不要處理服務所造成的失敗，而是改為將所有儲存體服務的讀取要求重新導向到次要區域，並在唯讀模式中執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-144">You may decide not to handle the failures by service, but instead to redirect read requests for all storage services to the secondary region and run the application in read-only mode when you detect a problem with any storage service in the primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="c58e1-145">其他考量</span><span class="sxs-lookup"><span data-stu-id="c58e1-145">Other considerations</span></span>

<span data-ttu-id="c58e1-146">以下是我們將在本文其餘內容中討論的其他考量。</span><span class="sxs-lookup"><span data-stu-id="c58e1-146">These are the other considerations we will discuss in the rest of this article.</span></span>

*   <span data-ttu-id="c58e1-147">使用斷路器模式處理讀取要求的重試</span><span class="sxs-lookup"><span data-stu-id="c58e1-147">Handling retries of read requests using the Circuit Breaker pattern</span></span>

*   <span data-ttu-id="c58e1-148">最終一致的資料和上次同步處理時間</span><span class="sxs-lookup"><span data-stu-id="c58e1-148">Eventually-consistent data and the Last Sync Time</span></span>

*   <span data-ttu-id="c58e1-149">測試</span><span class="sxs-lookup"><span data-stu-id="c58e1-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="c58e1-150">在唯讀模式中執行您的應用程式</span><span class="sxs-lookup"><span data-stu-id="c58e1-150">Running your application in read-only mode</span></span>

<span data-ttu-id="c58e1-151">若要使用 RA-GRS 儲存體，您必須能夠同時處理失敗的讀取要求和失敗的更新要求 (透過更新，在此案例中表示插入、更新和刪除)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-151">To use RA-GRS storage, you must be able to handle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="c58e1-152">如果主要資料中心失敗，可將讀取要求重新導向到次要資料中心，但由於次要資料中心是唯讀的，所以無法對更新要求執行此動作。</span><span class="sxs-lookup"><span data-stu-id="c58e1-152">If the primary data center fails, read requests can be redirected to the secondary data center, but update requests cannot because the secondary is read only.</span></span> <span data-ttu-id="c58e1-153">基於這個理由，您必須想辦法在唯讀模式中執行您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-153">For this reason, you need some way to run your application in read-only mode.</span></span>

<span data-ttu-id="c58e1-154">例如，您可以設定旗標，在將任何更新提交到儲存體服務之前先加以檢查。</span><span class="sxs-lookup"><span data-stu-id="c58e1-154">For example, you can set a flag that will be checked before submitting any update requests to the storage service.</span></span> <span data-ttu-id="c58e1-155">當其中一個更新要求傳入時，您可以略過它，並將適當的回應傳回給客戶。</span><span class="sxs-lookup"><span data-stu-id="c58e1-155">When one of the update requests comes through, you can skip it and return an appropriate response to the customer.</span></span> <span data-ttu-id="c58e1-156">您甚至可以在問題解決之前完全停用某些功能，並通知使用者，這些功能暫時無法使用。</span><span class="sxs-lookup"><span data-stu-id="c58e1-156">You may even want to disable certain features altogether until the problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="c58e1-157">如果您決定要個別處理每個服務的錯誤，也需要處理服務在唯讀模式中執行您應用程式的能力。</span><span class="sxs-lookup"><span data-stu-id="c58e1-157">If you decide to handle errors for each service separately, you will also need to handle the ability to run your application in read-only mode by service.</span></span> <span data-ttu-id="c58e1-158">您可以針對每個可啟用和停用的服務設定唯讀旗標，然後在程式碼的適當位置處理適當的旗標。</span><span class="sxs-lookup"><span data-stu-id="c58e1-158">You could have read-only flags for each service that can be enabled and disabled and handle the appropriate flag in the appropriate places in your code.</span></span>

<span data-ttu-id="c58e1-159">能夠在唯讀模式中執行您的應用程式有另一個好處 - 這讓您能夠在主要應用程式升級期間確保有限的功能。</span><span class="sxs-lookup"><span data-stu-id="c58e1-159">Being able to run your application in read-only mode has another side benefit – it gives you the ability to ensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="c58e1-160">您可以觸發應用程式在唯讀模式中執行並指向次要資料中心，確保當您進行升級時，不會有人正在存取主要區域中的資料。</span><span class="sxs-lookup"><span data-stu-id="c58e1-160">You can trigger your application to run in read-only mode and point to the secondary data center, ensuring nobody is accessing the data in the primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="c58e1-161">在唯讀模式中執行時處理更新</span><span class="sxs-lookup"><span data-stu-id="c58e1-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="c58e1-162">有許多方法可在唯讀模式中執行時處理更新要求。</span><span class="sxs-lookup"><span data-stu-id="c58e1-162">There are many ways to handle update requests when running in read-only mode.</span></span> <span data-ttu-id="c58e1-163">我們不會全面討論此問題，但一般來說，有一些模式是您需要考量的。</span><span class="sxs-lookup"><span data-stu-id="c58e1-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="c58e1-164">您可以回應您的使用者，並告訴他們，您目前不會接收更新。</span><span class="sxs-lookup"><span data-stu-id="c58e1-164">You can respond to your user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="c58e1-165">例如，連絡人管理系統能夠讓客戶存取連絡人資訊，但無法進行更新。</span><span class="sxs-lookup"><span data-stu-id="c58e1-165">For example, a contact management system could enable customers to access contact information but not make updates.</span></span>

2.  <span data-ttu-id="c58e1-166">您可以將更新加入其他區域中的佇列。</span><span class="sxs-lookup"><span data-stu-id="c58e1-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="c58e1-167">在此情況下，您會將擱置中的更新要求寫入不同區域中的佇列，然後想辦法在主要資料中心再次上線之後處理這些要求。</span><span class="sxs-lookup"><span data-stu-id="c58e1-167">In this case, you would write your pending update requests to a queue in a different region, and then have a way to process those requests after the primary data center comes online again.</span></span> <span data-ttu-id="c58e1-168">在此案例中，您應該讓客戶知道已將要求的更新排入佇列，以供稍後處理。</span><span class="sxs-lookup"><span data-stu-id="c58e1-168">In this scenario, you should let the customer know that the update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="c58e1-169">您可以將更新寫入其他區域中的儲存體帳戶。</span><span class="sxs-lookup"><span data-stu-id="c58e1-169">You can write your updates to a storage account in another region.</span></span> <span data-ttu-id="c58e1-170">然後在主要資料中心再度上線時，您就能根據資料結構，想辦法將這些更新合併到主要資料。</span><span class="sxs-lookup"><span data-stu-id="c58e1-170">Then when the primary data center comes back online, you can have a way to merge those updates into the primary data, depending on the structure of the data.</span></span> <span data-ttu-id="c58e1-171">例如，如果您建立了名稱中含有日期/時間戳記的不同檔案，就能將這些檔案複製回主要區域。</span><span class="sxs-lookup"><span data-stu-id="c58e1-171">For example, if you are creating separate files with a date/time stamp in the name, you can copy those files back to the primary region.</span></span> <span data-ttu-id="c58e1-172">這適用於某些工作負載，例如記錄和 iOT 資料。</span><span class="sxs-lookup"><span data-stu-id="c58e1-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="c58e1-173">處理重試</span><span class="sxs-lookup"><span data-stu-id="c58e1-173">Handling retries</span></span>

<span data-ttu-id="c58e1-174">您如何知道哪些錯誤是可重試的？</span><span class="sxs-lookup"><span data-stu-id="c58e1-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="c58e1-175">這取決於儲存體用戶端程式庫。</span><span class="sxs-lookup"><span data-stu-id="c58e1-175">This is determined by the storage client library.</span></span> <span data-ttu-id="c58e1-176">例如，404 錯誤 (找不到資源) 是不可重試的，因為重試很可能不會順利完成。</span><span class="sxs-lookup"><span data-stu-id="c58e1-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely to result in success.</span></span> <span data-ttu-id="c58e1-177">相反地，500 錯誤是可重試的，因為它是伺服器錯誤，而且可能只是暫時性問題。</span><span class="sxs-lookup"><span data-stu-id="c58e1-177">On the other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="c58e1-178">如需詳細資訊，請參閱 .NET 儲存體用戶端程式庫中的 [ExponentialRetry 類別的開放原始程式碼 (英文)](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs)</span><span class="sxs-lookup"><span data-stu-id="c58e1-178">For more details, check out the [open source code for the ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in the .NET storage client library.</span></span> <span data-ttu-id="c58e1-179">(尋找 ShouldRetry 方法)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-179">(Look for the ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="c58e1-180">讀取要求</span><span class="sxs-lookup"><span data-stu-id="c58e1-180">Read requests</span></span>

<span data-ttu-id="c58e1-181">如果主要儲存體發生問題，就可以將讀取要求重新導向到次要儲存體。</span><span class="sxs-lookup"><span data-stu-id="c58e1-181">Read requests can be redirected to secondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="c58e1-182">如前面[最終使用一致的資料](#using-eventually-consistent-data)中所述，您的應用程式必須可以接受可能讀取到過時的資料。</span><span class="sxs-lookup"><span data-stu-id="c58e1-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application to potentially read stale data.</span></span> <span data-ttu-id="c58e1-183">如果您使用儲存體用戶端程式庫來存取 RA-GRS 資料，就可以藉由將 **LocationMode** 屬性值設為下列其中一個值來指定讀取要求的重試行為：</span><span class="sxs-lookup"><span data-stu-id="c58e1-183">If you are using the storage client library to access RA-GRS data, you can specify the retry behavior of a read request by setting a value for the **LocationMode** property to one of the following:</span></span>

*   <span data-ttu-id="c58e1-184">**PrimaryOnly** (預設值)</span><span class="sxs-lookup"><span data-stu-id="c58e1-184">**PrimaryOnly** (the default)</span></span>

*   <span data-ttu-id="c58e1-185">**PrimaryThenSecondary**</span><span class="sxs-lookup"><span data-stu-id="c58e1-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="c58e1-186">**SecondaryOnly**</span><span class="sxs-lookup"><span data-stu-id="c58e1-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="c58e1-187">**SecondaryThenPrimary**</span><span class="sxs-lookup"><span data-stu-id="c58e1-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="c58e1-188">當您將 **LocationMode** 設為 **PrimaryThenSecondary** 時，如果對主要端點的最初讀取要求失敗且產生可重試的錯誤，則用戶端會自動對次要端點提出另一個讀取要求。</span><span class="sxs-lookup"><span data-stu-id="c58e1-188">When you set the **LocationMode** to **PrimaryThenSecondary**, if the initial read request to the primary endpoint fails with a retryable error, the client automatically makes another read request to the secondary endpoint.</span></span> <span data-ttu-id="c58e1-189">如果錯誤是伺服器逾時，則用戶端在接收到服務所提供的可重試錯誤之前，必須等候逾時到期。</span><span class="sxs-lookup"><span data-stu-id="c58e1-189">If the error is a server timeout, then the client will have to wait for the timeout to expire before it receives a retryable error from the service.</span></span>

<span data-ttu-id="c58e1-190">當您決定如何回應可重試的錯誤時，基本上有兩種情況需要考量：</span><span class="sxs-lookup"><span data-stu-id="c58e1-190">There are basically two scenarios to consider when you are deciding how to respond to a retryable error:</span></span>

*   <span data-ttu-id="c58e1-191">這是一個獨立的問題，而對主要端點的後續要求將不會傳回可重試的錯誤。</span><span class="sxs-lookup"><span data-stu-id="c58e1-191">This is an isolated problem and subsequent requests to the primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="c58e1-192">舉例來說，這可能發生在有暫時性網路錯誤時。</span><span class="sxs-lookup"><span data-stu-id="c58e1-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="c58e1-193">在此案例中，將 **LocationMode** 設為 **PrimaryThenSecondary** 並不會對效能產生顯著的負面影響，因為這很少發生。</span><span class="sxs-lookup"><span data-stu-id="c58e1-193">In this scenario, there is no significant performance penalty in having **LocationMode** set to **PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="c58e1-194">這是一個與主要區域中至少一個儲存體服務相關的問題，而對主要區域中該服務的所有後續要求很可能會在一段時間內傳回可重試的錯誤。</span><span class="sxs-lookup"><span data-stu-id="c58e1-194">This is a problem with at least one of the storage services in the primary region and all subsequent requests to that service in the primary region are likely to return retryable errors for a period of time.</span></span> <span data-ttu-id="c58e1-195">如果主要區域完全無法存取，即為一例。</span><span class="sxs-lookup"><span data-stu-id="c58e1-195">An example of this is if the primary region is completely inaccessible.</span></span>

    <span data-ttu-id="c58e1-196">在此案例中，會對效能產生負面影響，因為您的所有讀取要求都會先嘗試主要端點、等候逾時到期，然後切換到次要端點。</span><span class="sxs-lookup"><span data-stu-id="c58e1-196">In this scenario, there is a performance penalty because all your read requests will try the primary endpoint first, wait for the timeout to expire, then switch to the secondary endpoint.</span></span>

<span data-ttu-id="c58e1-197">針對這些情況，您應該確認主要端點會持續發生問題，並藉由將 **LocationMode** 屬性設為 **SecondaryOnly**，直接將所有讀取要求傳送到次要端點。</span><span class="sxs-lookup"><span data-stu-id="c58e1-197">For these scenarios, you should identify that there is an ongoing issue with the primary endpoint and send all read requests directly to the secondary endpoint by setting the **LocationMode** property to **SecondaryOnly**.</span></span> <span data-ttu-id="c58e1-198">此時，您也應該將應用程式變更為在唯讀模式中執行。</span><span class="sxs-lookup"><span data-stu-id="c58e1-198">At this time, you should also change the application to run in read-only mode.</span></span> <span data-ttu-id="c58e1-199">這種方法稱為[斷路器模式 (英文)](https://msdn.microsoft.com/library/dn589784.aspx)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-199">This approach is known as the [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="c58e1-200">更新要求</span><span class="sxs-lookup"><span data-stu-id="c58e1-200">Update requests</span></span>

<span data-ttu-id="c58e1-201">斷路器模式也適用於更新要求。</span><span class="sxs-lookup"><span data-stu-id="c58e1-201">The Circuit Breaker pattern can also be applied to update requests.</span></span> <span data-ttu-id="c58e1-202">不過，無法將更新要求重新導向到唯讀的次要儲存體。</span><span class="sxs-lookup"><span data-stu-id="c58e1-202">However, update requests cannot be redirected to secondary storage, which is read-only.</span></span> <span data-ttu-id="c58e1-203">針對這些要求，您應該讓 **LocationMode**屬性維持 **PrimaryOnly** (預設值) 的設定。</span><span class="sxs-lookup"><span data-stu-id="c58e1-203">For these requests, you should leave the **LocationMode** property set to **PrimaryOnly** (the default).</span></span> <span data-ttu-id="c58e1-204">若要處理這些錯誤，您可以將計量套用到這些要求 (例如，一列 10 個失敗)，並在到達臨界值時，將應用程式切換回唯讀模式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-204">To handle these errors, you can apply a metric to these requests – such as 10 failures in a row – and when your threshold is met, switch the application into read-only mode.</span></span> <span data-ttu-id="c58e1-205">您可以使用與下一個關於斷路器模式的小節中所述的相同方法來返回更新模式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-205">You can use the same methods for returning to update mode as those described below in the next section about the Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="c58e1-206">斷路器模式</span><span class="sxs-lookup"><span data-stu-id="c58e1-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="c58e1-207">在您的應用程式中使用斷路器模式，可防止重複重試很可能會失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="c58e1-207">Using the Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely to fail repeatedly.</span></span> <span data-ttu-id="c58e1-208">它可以讓應用程式繼續執行，而不會在以指數方式重試作業時佔用時間。</span><span class="sxs-lookup"><span data-stu-id="c58e1-208">It allows the application to continue to run rather than taking up time while the operation is retried exponentially.</span></span> <span data-ttu-id="c58e1-209">它也會偵測到已修正錯誤的時間，應用程式可於該時間點再次重試此作業。</span><span class="sxs-lookup"><span data-stu-id="c58e1-209">It also detects when the fault has been fixed, at which time the application can try the operation again.</span></span>

### <a name="how-to-implement-the-circuit-breaker-pattern"></a><span data-ttu-id="c58e1-210">如何實作斷路器模式</span><span class="sxs-lookup"><span data-stu-id="c58e1-210">How to implement the circuit breaker pattern</span></span>

<span data-ttu-id="c58e1-211">若要確認主要端點持續發生問題，您可以監視用戶端發生可重試錯誤的頻率。</span><span class="sxs-lookup"><span data-stu-id="c58e1-211">To identify that there is an ongoing problem with a primary endpoint, you can monitor how frequently the client encounters retryable errors.</span></span> <span data-ttu-id="c58e1-212">由於每個案例不同，因此，您必須決定要用於決定切換到次要端點，並在唯讀模式中執行應用程式的臨界值。</span><span class="sxs-lookup"><span data-stu-id="c58e1-212">Because each case is different, you have to decide on the threshold you want to use for the decision to switch to the secondary endpoint and run the application in read-only mode.</span></span> <span data-ttu-id="c58e1-213">例如，如果沒有成功的資料列中有 10 個錯誤，則您可能決定執行切換。</span><span class="sxs-lookup"><span data-stu-id="c58e1-213">For example, you could decide to perform the switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="c58e1-214">另一個範例是假設 2 分鐘內有 90 % 的要求失敗，就進行切換。</span><span class="sxs-lookup"><span data-stu-id="c58e1-214">Another example is to switch if 90% of the requests in a 2-minute period fail.</span></span>

<span data-ttu-id="c58e1-215">針對第一個案例，您只需保留失敗的計數，而且如果在到達最大值之前成功，則會將計數設定為零。</span><span class="sxs-lookup"><span data-stu-id="c58e1-215">For the first scenario, you can simply keep a count of the failures, and if there is a success before reaching the maximum, set the count back to zero.</span></span> <span data-ttu-id="c58e1-216">針對第二個案例，有一個實作它的方式是使用 MemoryCache 物件 (在 .NET 中)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-216">For the second scenario, one way to implement it is to use the MemoryCache object (in .NET).</span></span> <span data-ttu-id="c58e1-217">針對每個要求，將 CacheItem 新增到快取、將值設為成功 (1) 或失敗 (0)，然後將到期時間設定為從目前開始 2 分鐘 (或任何時間限制)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-217">For each request, add a CacheItem to the cache, set the value to success (1) or fail (0), and set the expiration time to 2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="c58e1-218">到達項目的到期時間時，即會自動移除項目。</span><span class="sxs-lookup"><span data-stu-id="c58e1-218">When an entry's expiration time is reached, the entry is automatically removed.</span></span> <span data-ttu-id="c58e1-219">這將會為您提供一個 2 分鐘循環的視窗。</span><span class="sxs-lookup"><span data-stu-id="c58e1-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="c58e1-220">每當您對儲存體服務提出要求時，您要先跨 MemoryCache 物件使用 Linq 查詢，藉由加總這些值並除以計數來計算成功百分比。</span><span class="sxs-lookup"><span data-stu-id="c58e1-220">Each time you make a request to the storage service, you first use a Linq query across the MemoryCache object to calculate the percent success by summing the values and dividing by the count.</span></span> <span data-ttu-id="c58e1-221">當成功百分比低於某個臨界值 (例如 10%) 時，將讀取要求的 **LocationMode** 屬性設為 **SecondaryOnly**，並將應用程式切換到唯讀模式，然後再繼續。</span><span class="sxs-lookup"><span data-stu-id="c58e1-221">When the percent success drops below some threshold (such as 10%), set the **LocationMode** property for read requests to **SecondaryOnly** and switch the application into read-only mode before continuing.</span></span>

<span data-ttu-id="c58e1-222">用來判斷何時要進行切換的錯誤臨界值可能會因應用程式中的服務不同而有所差異，因此您應該考慮讓它們成為可設定的參數。</span><span class="sxs-lookup"><span data-stu-id="c58e1-222">The threshold of errors used to determine when to make the switch may vary from service to service in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="c58e1-223">這也是您決定個別處理每個服務之可重試錯誤的地方 (或當成一個來處理)，如先前所述。</span><span class="sxs-lookup"><span data-stu-id="c58e1-223">This is also where you decide to handle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="c58e1-224">另一個考量是如何處理應用程式的多個執行個體，以及當您在每個執行個體中偵測到可重試的錯誤時該怎麼辦。</span><span class="sxs-lookup"><span data-stu-id="c58e1-224">Another consideration is how to handle multiple instances of an application, and what to do when you detect retryable errors in each instance.</span></span> <span data-ttu-id="c58e1-225">例如，您可能有 20 個 VM 正載入相同的應用程式來執行。</span><span class="sxs-lookup"><span data-stu-id="c58e1-225">For example, you may have 20 VMs running with the same application loaded.</span></span> <span data-ttu-id="c58e1-226">您要個別處理每個執行個體嗎？</span><span class="sxs-lookup"><span data-stu-id="c58e1-226">Do you handle each instance separately?</span></span> <span data-ttu-id="c58e1-227">如果有一個執行個體開始發生問題，您想要將回應只限制在該執行個體，或者您要在一個執行個體發生問題時，嘗試以相同方式回應所有執行個體？</span><span class="sxs-lookup"><span data-stu-id="c58e1-227">If one instance starts having problems, do you want to limit the response to just that one instance, or do you want to try to have all instances respond in the same way when one instance has a problem?</span></span> <span data-ttu-id="c58e1-228">個別處理執行個體會比嘗試在它們之間協調回應更簡單，但該如何做則取決於您的應用程式架構。</span><span class="sxs-lookup"><span data-stu-id="c58e1-228">Handling the instances separately is much simpler than trying to coordinate the response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-the-error-frequency"></a><span data-ttu-id="c58e1-229">監視錯誤頻率的選項</span><span class="sxs-lookup"><span data-stu-id="c58e1-229">Options for monitoring the error frequency</span></span>

<span data-ttu-id="c58e1-230">您有三個主要選項可用來監視主要區域中的重試頻率，以判斷何時要切換到次要區域，並將應用程式變更為在唯讀模式中執行。</span><span class="sxs-lookup"><span data-stu-id="c58e1-230">You have three main options for monitoring the frequency of retries in the primary region in order to determine when to switch over to the secondary region and change the application to run in read-only mode.</span></span>

*   <span data-ttu-id="c58e1-231">針對您傳遞到儲存體要求的 [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) 物件上的 [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) 事件新增處理常式 - 這是本文所示的方法，並會在隨附的範例中使用。</span><span class="sxs-lookup"><span data-stu-id="c58e1-231">Add a handler for the [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on the [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass to your storage requests – this is the method displayed in this article and used in the accompanying sample.</span></span> <span data-ttu-id="c58e1-232">每當用戶端重試要求時，這些事件即會觸發，讓您能夠追蹤用戶端在主要端點上發生可重試錯誤的頻率。</span><span class="sxs-lookup"><span data-stu-id="c58e1-232">These events fire whenever the client retries a request, enabling you to track how often the client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in the primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="c58e1-233">在自訂重試原則的 [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) 方法中，您可以在每次進行重試時執行自訂程式碼。</span><span class="sxs-lookup"><span data-stu-id="c58e1-233">In the [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="c58e1-234">除了記錄重試發生的時間，這也能讓您有機會修改重試行為。</span><span class="sxs-lookup"><span data-stu-id="c58e1-234">In addition to recording when a retry happens, this also gives you the opportunity to modify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in the primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="c58e1-235">第三個方法是在持續使用虛設的讀取要求 (例如讀取小型 blob) 來 ping 您主要儲存體端點的應用程式中，實作自訂的監視元件來判斷其健康狀態。</span><span class="sxs-lookup"><span data-stu-id="c58e1-235">The third approach is to implement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) to determine its health.</span></span> <span data-ttu-id="c58e1-236">這會佔用某些資源，但時間不是很長。</span><span class="sxs-lookup"><span data-stu-id="c58e1-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="c58e1-237">在探索到達到您臨界值的問題時，您接著可以執行切換到 **SecondaryOnly** 和唯讀模式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-237">When a problem is discovered that reaches your threshold, you would then perform the switch to **SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="c58e1-238">您會想要在某個時間點切換回來，以使用主要端點並允許更新。</span><span class="sxs-lookup"><span data-stu-id="c58e1-238">At some point, you will want to switch back to using the primary endpoint and allowing updates.</span></span> <span data-ttu-id="c58e1-239">如果使用上述前兩個方法的其中一個，您可能只需切換回主要端點，並在執行任意選取的時間量或作業數目之後啟用更新模式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-239">If using one of the first two methods listed above, you could simply switch back to the primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="c58e1-240">您接著可以讓它重新進行重試邏輯。</span><span class="sxs-lookup"><span data-stu-id="c58e1-240">You can then let it go through the retry logic again.</span></span> <span data-ttu-id="c58e1-241">如果已修正問題，它將會繼續使用主要端點，並允許更新。</span><span class="sxs-lookup"><span data-stu-id="c58e1-241">If the problem has been fixed, it will continue to use the primary endpoint and allow updates.</span></span> <span data-ttu-id="c58e1-242">如果仍有問題，它會在無法達到您所設定的準則時，再次切換回次要端點和唯讀模式。</span><span class="sxs-lookup"><span data-stu-id="c58e1-242">If there is still a problem, it will once more switch back to the secondary endpoint and read-only mode after failing the criteria you've set.</span></span>

<span data-ttu-id="c58e1-243">針對第三個案例，當 ping 主要儲存體端點再度變為成功時，您就能觸發切換回 **PrimaryOnly**，並繼續允許更新。</span><span class="sxs-lookup"><span data-stu-id="c58e1-243">For the third scenario, when pinging the primary storage endpoint becomes successful again, you can trigger the switch back to **PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="c58e1-244">處理最終一致的資料</span><span class="sxs-lookup"><span data-stu-id="c58e1-244">Handling eventually consistent data</span></span>

<span data-ttu-id="c58e1-245">RA-GRS 的運作方式是將交易從主要區域複寫到次要區域。</span><span class="sxs-lookup"><span data-stu-id="c58e1-245">RA-GRS works by replicating transactions from the primary to the secondary region.</span></span> <span data-ttu-id="c58e1-246">此複寫程序可保證次要區域中的資料是*最終一致*的。</span><span class="sxs-lookup"><span data-stu-id="c58e1-246">This replication process guarantees that the data in the secondary region is *eventually consistent*.</span></span> <span data-ttu-id="c58e1-247">這表示，主要區域中的所有交易最終都會出現在次要區域中，但有可能會延遲出現，而且不保證交易會以原本在主要區域中套用它們的相同順序到達次要區域。</span><span class="sxs-lookup"><span data-stu-id="c58e1-247">This means that all the transactions in the primary region will eventually appear in the secondary region, but that there may be a lag before they appear, and that there is no guarantee the transactions arrive in the secondary region in the same order as that in which they were originally applied in the primary region.</span></span> <span data-ttu-id="c58e1-248">如果您的交易不按順序到達次要區域，則您可能要考慮讓次要區域中的資料處於不一致狀態，直到服務更新為止。</span><span class="sxs-lookup"><span data-stu-id="c58e1-248">If your transactions arrive in the secondary region out of order, you *may* consider your data in the secondary region to be in an inconsistent state until the service catches up.</span></span>

<span data-ttu-id="c58e1-249">下表所示的範例是，當您更新員工的詳細資料，使她成為「系統管理員」角色的成員時，可能會發生什麼情況。</span><span class="sxs-lookup"><span data-stu-id="c58e1-249">The following table shows an example of what might happen when you update the details of an employee to make her a member of the *administrators* role.</span></span> <span data-ttu-id="c58e1-250">基於此範例，這會要求您更新**員工**實體，並利用系統管理員總數的計數來更新**系統管理員角色**實體。</span><span class="sxs-lookup"><span data-stu-id="c58e1-250">For the sake of this example, this requires you update the **employee** entity and update an **administrator role** entity with a count of the total number of administrators.</span></span> <span data-ttu-id="c58e1-251">請注意，如何在次要區域中不按順序套用更新。</span><span class="sxs-lookup"><span data-stu-id="c58e1-251">Notice how the updates are applied out of order in the secondary region.</span></span>

| <bpt id="p1">**</bpt>Time<ept id="p1">**</ept> | <span data-ttu-id="c58e1-253">**交易**</span><span class="sxs-lookup"><span data-stu-id="c58e1-253">**Transaction**</span></span>                                            | <span data-ttu-id="c58e1-254">**複寫**</span><span class="sxs-lookup"><span data-stu-id="c58e1-254">**Replication**</span></span>                       | <span data-ttu-id="c58e1-255">**上次同步處理時間**</span><span class="sxs-lookup"><span data-stu-id="c58e1-255">**Last Sync Time**</span></span> | <span data-ttu-id="c58e1-256">**結果**</span><span class="sxs-lookup"><span data-stu-id="c58e1-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="c58e1-257">T0</span><span class="sxs-lookup"><span data-stu-id="c58e1-257">T0</span></span>       | <span data-ttu-id="c58e1-258">交易 A：</span><span class="sxs-lookup"><span data-stu-id="c58e1-258">Transaction A:</span></span> <br> <span data-ttu-id="c58e1-259">會在主要區域中</span><span class="sxs-lookup"><span data-stu-id="c58e1-259">Insert employee</span></span> <br> <span data-ttu-id="c58e1-260">插入員工實體</span><span class="sxs-lookup"><span data-stu-id="c58e1-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="c58e1-261">交易 A 已插入至主要區域，</span><span class="sxs-lookup"><span data-stu-id="c58e1-261">Transaction A inserted to primary,</span></span><br> <span data-ttu-id="c58e1-262">但尚未複寫。</span><span class="sxs-lookup"><span data-stu-id="c58e1-262">not replicated yet.</span></span> |
| <span data-ttu-id="c58e1-263">T1</span><span class="sxs-lookup"><span data-stu-id="c58e1-263">T1</span></span>       |                                                            | <span data-ttu-id="c58e1-264">交易 A</span><span class="sxs-lookup"><span data-stu-id="c58e1-264">Transaction A</span></span> <br> <span data-ttu-id="c58e1-265">已複寫到</span><span class="sxs-lookup"><span data-stu-id="c58e1-265">replicated to</span></span><br> <span data-ttu-id="c58e1-266">次要區域</span><span class="sxs-lookup"><span data-stu-id="c58e1-266">secondary</span></span> | <span data-ttu-id="c58e1-267">T1</span><span class="sxs-lookup"><span data-stu-id="c58e1-267">T1</span></span> | <span data-ttu-id="c58e1-268">交易 A 已複寫到次要區域。</span><span class="sxs-lookup"><span data-stu-id="c58e1-268">Transaction A replicated to secondary.</span></span> <br><span data-ttu-id="c58e1-269">已更新上次同步處理時間。</span><span class="sxs-lookup"><span data-stu-id="c58e1-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="c58e1-270">T2</span><span class="sxs-lookup"><span data-stu-id="c58e1-270">T2</span></span>       | <span data-ttu-id="c58e1-271">交易 B：</span><span class="sxs-lookup"><span data-stu-id="c58e1-271">Transaction B:</span></span><br><span data-ttu-id="c58e1-272">更新</span><span class="sxs-lookup"><span data-stu-id="c58e1-272">Update</span></span><br> <span data-ttu-id="c58e1-273">主要區域中的</span><span class="sxs-lookup"><span data-stu-id="c58e1-273">employee entity</span></span><br> <span data-ttu-id="c58e1-274">員工實體</span><span class="sxs-lookup"><span data-stu-id="c58e1-274">in primary</span></span>  |                                | <span data-ttu-id="c58e1-275">T1</span><span class="sxs-lookup"><span data-stu-id="c58e1-275">T1</span></span>                 | <span data-ttu-id="c58e1-276">交易 B 已寫入主要區域，</span><span class="sxs-lookup"><span data-stu-id="c58e1-276">Transaction B written to primary,</span></span><br> <span data-ttu-id="c58e1-277">但尚未複寫。</span><span class="sxs-lookup"><span data-stu-id="c58e1-277">not replicated yet.</span></span>  |
| <span data-ttu-id="c58e1-278">T3</span><span class="sxs-lookup"><span data-stu-id="c58e1-278">T3</span></span>       | <span data-ttu-id="c58e1-279">交易 C：</span><span class="sxs-lookup"><span data-stu-id="c58e1-279">Transaction C:</span></span><br> <span data-ttu-id="c58e1-280">更新</span><span class="sxs-lookup"><span data-stu-id="c58e1-280">Update</span></span> <br><span data-ttu-id="c58e1-281">administrator</span><span class="sxs-lookup"><span data-stu-id="c58e1-281">administrator</span></span><br><span data-ttu-id="c58e1-282">角色實體，位於</span><span class="sxs-lookup"><span data-stu-id="c58e1-282">role entity in</span></span><br><span data-ttu-id="c58e1-283">primary</span><span class="sxs-lookup"><span data-stu-id="c58e1-283">primary</span></span> |                    | <span data-ttu-id="c58e1-284">T1</span><span class="sxs-lookup"><span data-stu-id="c58e1-284">T1</span></span>                 | <span data-ttu-id="c58e1-285">交易 C 已寫入主要區域，</span><span class="sxs-lookup"><span data-stu-id="c58e1-285">Transaction C written to primary,</span></span><br> <span data-ttu-id="c58e1-286">但尚未複寫。</span><span class="sxs-lookup"><span data-stu-id="c58e1-286">not replicated yet.</span></span>  |
| <span data-ttu-id="c58e1-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="c58e1-287">*T4*</span></span>     |                                                       | <span data-ttu-id="c58e1-288">交易 C</span><span class="sxs-lookup"><span data-stu-id="c58e1-288">Transaction C</span></span> <br><span data-ttu-id="c58e1-289">已複寫到</span><span class="sxs-lookup"><span data-stu-id="c58e1-289">replicated to</span></span><br> <span data-ttu-id="c58e1-290">次要區域</span><span class="sxs-lookup"><span data-stu-id="c58e1-290">secondary</span></span> | <span data-ttu-id="c58e1-291">T1</span><span class="sxs-lookup"><span data-stu-id="c58e1-291">T1</span></span>         | <span data-ttu-id="c58e1-292">交易 C 已複寫到次要區域。</span><span class="sxs-lookup"><span data-stu-id="c58e1-292">Transaction C replicated to secondary.</span></span><br><span data-ttu-id="c58e1-293">無法更新 LastSyncTime，因為</span><span class="sxs-lookup"><span data-stu-id="c58e1-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="c58e1-294">尚未複寫交易 B。</span><span class="sxs-lookup"><span data-stu-id="c58e1-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="c58e1-295">*T5*</span><span class="sxs-lookup"><span data-stu-id="c58e1-295">*T5*</span></span>     | <span data-ttu-id="c58e1-296">從次要區域</span><span class="sxs-lookup"><span data-stu-id="c58e1-296">Read entities</span></span> <br><span data-ttu-id="c58e1-297">讀取實體</span><span class="sxs-lookup"><span data-stu-id="c58e1-297">from secondary</span></span>                           |                                  | <span data-ttu-id="c58e1-298">T1</span><span class="sxs-lookup"><span data-stu-id="c58e1-298">T1</span></span>                 | <span data-ttu-id="c58e1-299">您取得員工實體的過時值，</span><span class="sxs-lookup"><span data-stu-id="c58e1-299">You get the stale value for employee</span></span> <br> <span data-ttu-id="c58e1-300">因為交易 B 尚未</span><span class="sxs-lookup"><span data-stu-id="c58e1-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="c58e1-301">複寫。</span><span class="sxs-lookup"><span data-stu-id="c58e1-301">replicated yet.</span></span> <span data-ttu-id="c58e1-302">您取得系統管理員角色實體</span><span class="sxs-lookup"><span data-stu-id="c58e1-302">You get the new value for</span></span><br> <span data-ttu-id="c58e1-303">的新值，因為 C</span><span class="sxs-lookup"><span data-stu-id="c58e1-303">administrator role entity because C has</span></span><br> <span data-ttu-id="c58e1-304">已複寫。</span><span class="sxs-lookup"><span data-stu-id="c58e1-304">replicated.</span></span> <span data-ttu-id="c58e1-305">上次同步處理時間仍然尚未</span><span class="sxs-lookup"><span data-stu-id="c58e1-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="c58e1-306">更新，因為交易 B</span><span class="sxs-lookup"><span data-stu-id="c58e1-306">been updated because transaction B</span></span><br> <span data-ttu-id="c58e1-307">尚未複寫。</span><span class="sxs-lookup"><span data-stu-id="c58e1-307">hasn't replicated.</span></span> <span data-ttu-id="c58e1-308">您可以說</span><span class="sxs-lookup"><span data-stu-id="c58e1-308">You can tell the</span></span><br><span data-ttu-id="c58e1-309">系統管理員角色實體不一致，</span><span class="sxs-lookup"><span data-stu-id="c58e1-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="c58e1-310">因為實體日期/時間是在</span><span class="sxs-lookup"><span data-stu-id="c58e1-310">because the entity date/time is after</span></span> <br><span data-ttu-id="c58e1-311">上次同步處理時間之後。</span><span class="sxs-lookup"><span data-stu-id="c58e1-311">the Last Sync Time.</span></span> |
| <span data-ttu-id="c58e1-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="c58e1-312">*T6*</span></span>     |                                                      | <span data-ttu-id="c58e1-313">交易 B</span><span class="sxs-lookup"><span data-stu-id="c58e1-313">Transaction B</span></span><br> <span data-ttu-id="c58e1-314">已複寫到</span><span class="sxs-lookup"><span data-stu-id="c58e1-314">replicated to</span></span><br> <span data-ttu-id="c58e1-315">次要區域</span><span class="sxs-lookup"><span data-stu-id="c58e1-315">secondary</span></span> | <span data-ttu-id="c58e1-316">T6</span><span class="sxs-lookup"><span data-stu-id="c58e1-316">T6</span></span>                 | <span data-ttu-id="c58e1-317">*T6* - 透過 C 的所有交易都</span><span class="sxs-lookup"><span data-stu-id="c58e1-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="c58e1-318">已複寫，上次同步處理時間</span><span class="sxs-lookup"><span data-stu-id="c58e1-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="c58e1-319">已更新。</span><span class="sxs-lookup"><span data-stu-id="c58e1-319">is updated.</span></span> |

<span data-ttu-id="c58e1-320">在此範例中，假設用戶端會在 T5 從次要區域切換到讀取。</span><span class="sxs-lookup"><span data-stu-id="c58e1-320">In this example, assume the client switches to reading from the secondary region at T5.</span></span> <span data-ttu-id="c58e1-321">它可以在此時順利讀取**系統管理員角色**實體，但實體包含的系統管理員計數值與**員工**實體數目不一致，後者在此時標示為次要區域中的系統管理員。</span><span class="sxs-lookup"><span data-stu-id="c58e1-321">It can successfully read the **administrator role** entity at this time, but the entity contains a value for the count of administrators that is not consistent with the number of **employee** entities that are marked as administrators in the secondary region at this time.</span></span> <span data-ttu-id="c58e1-322">您的用戶端可能只會顯示此值，存有資訊不一致的風險。</span><span class="sxs-lookup"><span data-stu-id="c58e1-322">Your client could simply display this value, with the risk that it is inconsistent information.</span></span> <span data-ttu-id="c58e1-323">或者，用戶端可能嘗試判斷**系統管理員角色**處於可能不一致的狀態，因為更新並未按順序進行，然後通知使用者此一事實。</span><span class="sxs-lookup"><span data-stu-id="c58e1-323">Alternatively, the client could attempt to determine that the **administrator role** is in a potentially inconsistent state because the updates have happened out of order, and then inform the user of this fact.</span></span>

<span data-ttu-id="c58e1-324">若要辨識其中可能含有不一致的資料，用戶端可以使用「上次同步處理時間」的值，你可以隨時查詢儲存體服務來取得此值。</span><span class="sxs-lookup"><span data-stu-id="c58e1-324">To recognize that it has potentially inconsistent data, the client can use the value of the *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="c58e1-325">這會告訴您次要區域中的資料上次保持一致的時間，以及在此時間點之前服務套用所有交易的時間。</span><span class="sxs-lookup"><span data-stu-id="c58e1-325">This tells you the time when the data in the secondary region was last consistent and when the service had applied all the transactions prior to that point in time.</span></span> <span data-ttu-id="c58e1-326">在上述範例中，當服務在次要區域中插入**員工**實體之後，就會將上次同步處理時間設為 *T1*。</span><span class="sxs-lookup"><span data-stu-id="c58e1-326">In the example shown above, after the service inserts the **employee** entity in the secondary region, the last sync time is set to *T1*.</span></span> <span data-ttu-id="c58e1-327">它會保持在 *T1*，直到將其設為 *T6* 之後，服務更新次要區域中的**員工**實體為止。</span><span class="sxs-lookup"><span data-stu-id="c58e1-327">It remains at *T1* until the service updates the **employee** entity in the secondary region when it is set to *T6*.</span></span> <span data-ttu-id="c58e1-328">如果用戶端會在其讀取 *T5* 上的實體時擷取上次同步處理時間，就能與實體上的時間戳記進行比較。</span><span class="sxs-lookup"><span data-stu-id="c58e1-328">If the client retrieves the last sync time when it reads the entity at *T5*, it can compare it with the timestamp on the entity.</span></span> <span data-ttu-id="c58e1-329">如果實體上的時間戳記晚於上次同步處理時間，則該實體可能會處於不一致狀態，而您就能針對應用程式採取適當的動作。</span><span class="sxs-lookup"><span data-stu-id="c58e1-329">If the timestamp on the entity is later than the last sync time, then the entity is in a potentially inconsistent state, and you can take whatever is the appropriate action for your application.</span></span> <span data-ttu-id="c58e1-330">您必須知道上次對主要區域完成更新的時間，才能使用此欄位。</span><span class="sxs-lookup"><span data-stu-id="c58e1-330">Using this field requires that you know when the last update to the primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="c58e1-331">測試</span><span class="sxs-lookup"><span data-stu-id="c58e1-331">Testing</span></span>

<span data-ttu-id="c58e1-332">請務必測試應用程式在發生可重試的錯誤時會如預期般運作。</span><span class="sxs-lookup"><span data-stu-id="c58e1-332">It's important to test that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="c58e1-333">例如，您需要測試應用程式會在偵測到問題時切換到次要區域並進入唯讀模式，然後在主要區域再度變成可供使用時切換回來。</span><span class="sxs-lookup"><span data-stu-id="c58e1-333">For example, you need to test that the application switches to the secondary and into read-only mode when it detects a problem, and switches back when the primary region becomes available again.</span></span> <span data-ttu-id="c58e1-334">若要這樣做，您需要想辦法模擬可重試的錯誤，並控制其發生頻率。</span><span class="sxs-lookup"><span data-stu-id="c58e1-334">To do this, you need a way to simulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="c58e1-335">您可以使用 [Fiddler (英文)](http://www.telerik.com/fiddler)，來攔截與修改指令碼中的 HTTP 回應。</span><span class="sxs-lookup"><span data-stu-id="c58e1-335">You can use [Fiddler](http://www.telerik.com/fiddler) to intercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="c58e1-336">此指令碼可以識別來自您主要端點的回應，並將 HTTP 狀態碼變更為儲存體用戶端程式庫可辨識為可重試錯誤的狀態碼。</span><span class="sxs-lookup"><span data-stu-id="c58e1-336">This script can identify responses that come from your primary endpoint and change the HTTP status code to one that the Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="c58e1-337">此程式碼片段示範一個簡單的 Fiddler 指令碼範例，來攔截對 **employeedata** 資料表之讀取要求的回應，以傳回 502 狀態：</span><span class="sxs-lookup"><span data-stu-id="c58e1-337">This code snippet shows a simple example of a Fiddler script that intercepts responses to read requests against the **employeedata** table to return a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="c58e1-338">您可以擴充此範例，以攔截範圍較大的要求，而且只需變更其中的 **responseCode**，就能進一步模擬真實世界的案例。</span><span class="sxs-lookup"><span data-stu-id="c58e1-338">You could extend this example to intercept a wider range of requests and only change the **responseCode** on some of them to better simulate a real-world scenario.</span></span> <span data-ttu-id="c58e1-339">如需自訂 Fiddler 指令碼的詳細資訊，請參閱 Fiddler 文件中的[修改要求或回應 (英文)](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in the Fiddler documentation.</span></span>

<span data-ttu-id="c58e1-340">如果您已讓可用來將應用程式切換到唯讀模式的臨界值變成可設定的，就能更輕易地使用非實際執行的交易量來測試此行為。</span><span class="sxs-lookup"><span data-stu-id="c58e1-340">If you have made the thresholds for switching your application to read-only mode configurable, it will be easier to test the behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="c58e1-341">後續步驟</span><span class="sxs-lookup"><span data-stu-id="c58e1-341">Next Steps</span></span>

* <span data-ttu-id="c58e1-342">如需讀取存取異地備援的詳細資訊 (包括另一個如何設定 LastSyncTime 的範例)，請參閱 [Microsoft Azure 儲存體備援選項與讀取權限異地備援儲存體 (英文)](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-342">For more information about Read Access Geo-Redundancy, including another example of how the LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="c58e1-343">如需示範如何在主要和次要端點之間來回切換的完整範例，請參閱 [Azure 範例 - 搭配 RA-GRS 儲存體使用斷路器模式 (英文)](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs)。</span><span class="sxs-lookup"><span data-stu-id="c58e1-343">For a complete sample showing how to make the switch back and forth between the Primary and Secondary endpoints, please see [Azure Samples – Using the Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
