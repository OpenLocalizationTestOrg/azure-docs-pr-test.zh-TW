---
title: "aaaManaging Microsoft Azure 儲存體中的並行存取"
description: "Toomanage 的並行存取如何 hello Blob、 佇列、 表格和檔案服務"
services: storage
documentationcenter: 
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 5b8efbe0a9ebc881ded8f3abef5f138e0385f7c6
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/06/2017
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a><span data-ttu-id="38eaa-103">管理 Microsoft Azure 儲存體中的並行存取</span><span class="sxs-lookup"><span data-stu-id="38eaa-103">Managing Concurrency in Microsoft Azure Storage</span></span>
## <a name="overview"></a><span data-ttu-id="38eaa-104">概觀</span><span class="sxs-lookup"><span data-stu-id="38eaa-104">Overview</span></span>
<span data-ttu-id="38eaa-105">現代以網際網路為基礎的應用程式通常會有多個使用者同時檢視及更新資料。</span><span class="sxs-lookup"><span data-stu-id="38eaa-105">Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</span></span> <span data-ttu-id="38eaa-106">這需要仔細的相關說明的可預測的 tooprovide 遇到 tootheir 一般使用者、 應用程式開發人員 toothink，特別是針對案例多位使用者可以更新其中 hello 相同資料。</span><span class="sxs-lookup"><span data-stu-id="38eaa-106">This requires application developers toothink carefully about how tooprovide a predictable experience tootheir end users, particularly for scenarios where multiple users can update hello same data.</span></span> <span data-ttu-id="38eaa-107">開發人員通常會考量三個主要的資料並行存取策略：</span><span class="sxs-lookup"><span data-stu-id="38eaa-107">There are three main data concurrency strategies that developers typically consider:</span></span>  

1. <span data-ttu-id="38eaa-108">開放式並行存取 – 應用程式執行更新會做為其更新的一部分確認如果 hello 之後資料已經變更 hello 應用程式上次讀取資料。</span><span class="sxs-lookup"><span data-stu-id="38eaa-108">Optimistic concurrency – An application performing an update will as part of its update verify if hello data has changed since hello application last read that data.</span></span> <span data-ttu-id="38eaa-109">例如，如果兩個檢視的 wiki 頁面的使用者進行更新 toohello 相同頁面上則 hello wiki 平台必須確定該 hello 第二個更新不會覆寫第一個更新 hello – 和兩個使用者了解它們的更新是否已成功。</span><span class="sxs-lookup"><span data-stu-id="38eaa-109">For example, if two users viewing a wiki page make an update toohello same page then hello wiki platform must ensure that hello second update does not overwrite hello first update – and that both users understand whether their update was successful or not.</span></span> <span data-ttu-id="38eaa-110">此策略最常用在 Web 應用程式中。</span><span class="sxs-lookup"><span data-stu-id="38eaa-110">This strategy is most often used in web applications.</span></span>
2. <span data-ttu-id="38eaa-111">封閉式並行存取 – 尋找 tooperform 更新應用程式將會鎖定 hello 鎖定釋放，直到更新 hello 資料時，防止其他使用者的物件。</span><span class="sxs-lookup"><span data-stu-id="38eaa-111">Pessimistic concurrency – An application looking tooperform an update will take a lock on an object preventing other users from updating hello data until hello lock is released.</span></span> <span data-ttu-id="38eaa-112">例如，在只有 hello 主要將在何處執行更新的主/從資料複寫案例 hello 主要會通常保存的獨佔鎖定一段時間 hello 資料 tooensure 任何人都可以更新它。</span><span class="sxs-lookup"><span data-stu-id="38eaa-112">For example, in a master/slave data replication scenario where only hello master will perform updates hello master will typically hold an exclusive lock for an extended period of time on hello data tooensure no one else can update it.</span></span>
3. <span data-ttu-id="38eaa-113">最後一個的寫入者獲勝 – 可讓任何 update 作業 tooproceed，而不驗證 hello 應用程式第一次讀取 hello 資料，因此是否其他應用程式已更新 hello 資料的方法。</span><span class="sxs-lookup"><span data-stu-id="38eaa-113">Last writer wins – An approach that allows any update operations tooproceed without verifying if any other application has updated hello data since hello application first read hello data.</span></span> <span data-ttu-id="38eaa-114">此策略 （或缺乏型式策略） 通常用於資料分割的方式會有多個使用者會存取 hello 沒有可能性的位置相同的資料。</span><span class="sxs-lookup"><span data-stu-id="38eaa-114">This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access hello same data.</span></span> <span data-ttu-id="38eaa-115">在處理暫時性資料串流的情況中，也可以利用此策略。</span><span class="sxs-lookup"><span data-stu-id="38eaa-115">It can also be useful where short-lived data streams are being processed.</span></span>  

<span data-ttu-id="38eaa-116">本文章提供如何 hello Azure 儲存體的平台開發提供簡化第一級支援所有三個這些並行策略的概觀。</span><span class="sxs-lookup"><span data-stu-id="38eaa-116">This article provides an overview of how hello Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</span></span>  

## <a name="azure-storage--simplifies-cloud-development"></a><span data-ttu-id="38eaa-117">Azure 儲存體 – 簡化雲端開發</span><span class="sxs-lookup"><span data-stu-id="38eaa-117">Azure Storage – Simplifies Cloud Development</span></span>
<span data-ttu-id="38eaa-118">hello Azure 儲存體服務支援所有的三種策略，雖然它是特殊中其能力 tooprovide 的完整支援開放式和封閉式並行存取，因為它是設計的 tooembrace 強式一致性模型以確保，當hello 儲存體服務認可資料插入或更新的作業的所有進一步存取 toothat 資料會看到最新版本更新的 hello。</span><span class="sxs-lookup"><span data-stu-id="38eaa-118">hello Azure storage service supports all three strategies, although it is distinctive in its ability tooprovide full support for optimistic and pessimistic concurrency because it was designed tooembrace a strong consistency model which guarantees that when hello Storage service commits a data insert or update operation all further accesses toothat data will see hello latest update.</span></span> <span data-ttu-id="38eaa-119">使用最終一致性模型的儲存體平台都有之間由一位使用者執行寫入時的延遲和其他使用者，因此複雜順序 tooprevent 不一致，從用戶端應用程式的開發 hello 更新時可以看到資料使用者的影響。</span><span class="sxs-lookup"><span data-stu-id="38eaa-119">Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when hello updated data can be seen by other users thus complicating development of client applications in order tooprevent inconsistencies from affecting end users.</span></span>  

<span data-ttu-id="38eaa-120">此外 tooselecting 適當的並行策略開發人員也應該知道的儲存體的平台會變更 – 特別變更 toohello 相同的物件不同的交易之間的隔離。</span><span class="sxs-lookup"><span data-stu-id="38eaa-120">In addition tooselecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes toohello same object across transactions.</span></span> <span data-ttu-id="38eaa-121">hello Azure 儲存體服務會使用快照集隔離 tooallow 讀取與寫入作業的單一資料分割內同時作業 toohappen。</span><span class="sxs-lookup"><span data-stu-id="38eaa-121">hello Azure storage service uses snapshot isolation tooallow read operations toohappen concurrently with write operations within a single partition.</span></span> <span data-ttu-id="38eaa-122">不同於其他隔離等級，快照集隔離保證所有讀取都看到 hello 資料的一致快照集，即使在進行更新 – 基本上藉由更新交易在處理時，傳回 hello 最後認可的值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-122">Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of hello data even while updates are occurring – essentially by returning hello last committed values while an update transaction is being processed.</span></span>  

## <a name="managing-concurrency-in-blob-storage"></a><span data-ttu-id="38eaa-123">管理 Blob 儲存體中的並行存取</span><span class="sxs-lookup"><span data-stu-id="38eaa-123">Managing Concurrency in Blob storage</span></span>
<span data-ttu-id="38eaa-124">您可以選擇 toouse 是開放式或封閉式並行存取模型 toomanage 存取 tooblobs 和中的容器 hello blob 服務。</span><span class="sxs-lookup"><span data-stu-id="38eaa-124">You can opt toouse either optimistic or pessimistic concurrency models toomanage access tooblobs and containers in hello blob service.</span></span> <span data-ttu-id="38eaa-125">如果您未明確指定策略上次寫入 wins 是 hello 預設值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-125">If you do not explicitly specify a strategy last writes wins is hello default.</span></span>  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a><span data-ttu-id="38eaa-126">Blob 和容器的開放式並行存取</span><span class="sxs-lookup"><span data-stu-id="38eaa-126">Optimistic concurrency for blobs and containers</span></span>
<span data-ttu-id="38eaa-127">hello 儲存體服務會指派儲存的識別項 tooevery 物件。</span><span class="sxs-lookup"><span data-stu-id="38eaa-127">hello Storage service assigns an identifier tooevery object stored.</span></span> <span data-ttu-id="38eaa-128">此識別碼會在每次對物件執行更新作業時更新。</span><span class="sxs-lookup"><span data-stu-id="38eaa-128">This identifier is updated every time an update operation is performed on an object.</span></span> <span data-ttu-id="38eaa-129">toohello 用戶端，使用 hello HTTP 通訊協定中定義的 hello （實體標記） 的 ETag 標頭的 HTTP GET 回應的一部分時，會傳回 hello 識別項。</span><span class="sxs-lookup"><span data-stu-id="38eaa-129">hello identifier is returned toohello client as part of an HTTP GET response using hello ETag (entity tag) header that is defined within hello HTTP protocol.</span></span> <span data-ttu-id="38eaa-130">使用者執行這類物件上的更新可以傳送 hello 以及更新才會在符合特定條件-在此情況下 hello 條件是 「 If-match"標頭，這需要 hello 存放裝置的條件式標頭 tooensure 原始的 ETag服務 tooensure hello hello hello 更新要求中指定的 ETag 為 hello 與 hello 儲存體服務中儲存相同的值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-130">A user performing an update on such an object can send in hello original ETag along with a conditional header tooensure that an update will only occur if a certain condition has been met – in this case hello condition is an "If-Match" header, which requires hello Storage Service tooensure hello value of hello ETag specified in hello update request is hello same as that stored in hello Storage Service.</span></span>  

<span data-ttu-id="38eaa-131">hello 這個程序概述如下所示：</span><span class="sxs-lookup"><span data-stu-id="38eaa-131">hello outline of this process is as follows:</span></span>  

1. <span data-ttu-id="38eaa-132">擷取 hello 儲存體服務中的 blob，hello 回應包含 HTTP ETag 標頭的值，識別 hello hello 儲存體服務中的 hello 物件的目前版本。</span><span class="sxs-lookup"><span data-stu-id="38eaa-132">Retrieve a blob from hello storage service, hello response includes an HTTP ETag Header value that identifies hello current version of hello object in hello storage service.</span></span>
2. <span data-ttu-id="38eaa-133">當您更新 hello blob 時，包括您在步驟 1 中 hello 中收到 hello ETag 值**If-match** hello 要求您傳送 toohello 服務的條件式標頭。</span><span class="sxs-lookup"><span data-stu-id="38eaa-133">When you update hello blob, include hello ETag value you received in step 1 in hello **If-Match** conditional header of hello request you send toohello service.</span></span>
3. <span data-ttu-id="38eaa-134">hello 服務會比較 hello 要求中的 hello 目前的 ETag 值 hello blob 的 hello ETag 值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-134">hello service compares hello ETag value in hello request with hello current ETag value of hello blob.</span></span>
4. <span data-ttu-id="38eaa-135">如果 hello 目前的 ETag 值 hello blob 是不同的版本，比在 hello hello ETag **If-match** hello 要求，hello 服務中的條件式標頭會傳回 412 錯誤 toohello 用戶端。</span><span class="sxs-lookup"><span data-stu-id="38eaa-135">If hello current ETag value of hello blob is a different version than hello ETag in hello **If-Match** conditional header in hello request, hello service returns a 412 error toohello client.</span></span> <span data-ttu-id="38eaa-136">這表示 toohello 用戶端 hello 用戶端擷取它之後，另一個處理序已更新 hello blob。</span><span class="sxs-lookup"><span data-stu-id="38eaa-136">This indicates toohello client that another process has updated hello blob since hello client retrieved it.</span></span>
5. <span data-ttu-id="38eaa-137">如果 hello 目前的 ETag 值 hello blob 是 hello 與相同的版本 hello ETag 在 hello **If-match** hello 要求，hello 服務中的條件式標頭執行 hello 要求的作業和更新 hello 目前 hello blob 的 ETag 值tooshow 一旦建立新的版本。</span><span class="sxs-lookup"><span data-stu-id="38eaa-137">If hello current ETag value of hello blob is hello same version as hello ETag in hello **If-Match** conditional header in hello request, hello service performs hello requested operation and updates hello current ETag value of hello blob tooshow that it has created a new version.</span></span>  

<span data-ttu-id="38eaa-138">hello 下列 C# 程式碼片段 （使用用戶端儲存庫 4.2.0 hello） 示範如何的簡單範例 tooconstruct **If-match AccessCondition** hello 存取 hello 之屬性的已將 blob 的 ETag 值為基礎先前擷取或插入。</span><span class="sxs-lookup"><span data-stu-id="38eaa-138">hello following C# snippet (using hello Client Storage Library 4.2.0) shows a simple example of how tooconstruct an **If-Match AccessCondition** based on hello ETag value that is accessed from hello properties of a blob that was previously either retrieved or inserted.</span></span> <span data-ttu-id="38eaa-139">然後它會使用 hello **AccessCondition**物件時便會更新 hello blob: hello **AccessCondition**物件加入 hello **If-match**標頭 toohello 要求。</span><span class="sxs-lookup"><span data-stu-id="38eaa-139">It then uses hello **AccessCondition** object when it updates hello blob: hello **AccessCondition** object adds hello **If-Match** header toohello request.</span></span> <span data-ttu-id="38eaa-140">如果另一個處理序已更新 hello blob，hello blob 服務會傳回 HTTP 412 （先決條件失敗） 的狀態訊息。</span><span class="sxs-lookup"><span data-stu-id="38eaa-140">If another process has updated hello blob, hello blob service returns an HTTP 412 (Precondition Failed) status message.</span></span> <span data-ttu-id="38eaa-141">您可以在此處下載 hello 完整的範例：[使用 Azure 儲存體管理並行](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)。</span><span class="sxs-lookup"><span data-stu-id="38eaa-141">You can download hello full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>  

```csharp
// Retrieve hello ETag from hello newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// toostorage blob service which returns hello etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try tooupdate hello blob using hello orignal ETag provided when hello blob was created
try
{
    Console.WriteLine("Trying tooupdate blob using orignal etag toogenerate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants toohandle hello 3rd party updated content.
    }
    else
        throw;
}  
```

<span data-ttu-id="38eaa-142">hello 儲存體服務也支援其他的條件式標頭例如**如果修改自**，**如果不想修改自**和**如果 If-none-Match**以及組合類別。</span><span class="sxs-lookup"><span data-stu-id="38eaa-142">hello Storage Service also includes support for additional conditional headers such as **If-Modified-Since**, **If-Unmodified-Since** and **If-None-Match** as well as combinations thereof.</span></span> <span data-ttu-id="38eaa-143">如需詳細資訊，請參閱 MSDN 上的 [為 Blob 服務作業指定條件式標頭](http://msdn.microsoft.com/library/azure/dd179371.aspx) 。</span><span class="sxs-lookup"><span data-stu-id="38eaa-143">For more information, see [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) on MSDN.</span></span>  

<span data-ttu-id="38eaa-144">hello 下表摘要說明接受下列條件式標頭的 hello 容器作業**If-match** hello 要求，而且傳回以 hello 回應的 ETag 值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-144">hello following table summarizes hello container operations that accept conditional headers such as **If-Match** in hello request and that return an ETag value in hello response.</span></span>  

| <span data-ttu-id="38eaa-145">作業</span><span class="sxs-lookup"><span data-stu-id="38eaa-145">Operation</span></span> | <span data-ttu-id="38eaa-146">傳回容器 ETag 值</span><span class="sxs-lookup"><span data-stu-id="38eaa-146">Returns Container ETag value</span></span> | <span data-ttu-id="38eaa-147">接受條件式標頭</span><span class="sxs-lookup"><span data-stu-id="38eaa-147">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="38eaa-148">建立容器</span><span class="sxs-lookup"><span data-stu-id="38eaa-148">Create Container</span></span> |<span data-ttu-id="38eaa-149">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-149">Yes</span></span> |<span data-ttu-id="38eaa-150">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-150">No</span></span> |
| <span data-ttu-id="38eaa-151">取得容器屬性</span><span class="sxs-lookup"><span data-stu-id="38eaa-151">Get Container Properties</span></span> |<span data-ttu-id="38eaa-152">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-152">Yes</span></span> |<span data-ttu-id="38eaa-153">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-153">No</span></span> |
| <span data-ttu-id="38eaa-154">取得容器中繼資料</span><span class="sxs-lookup"><span data-stu-id="38eaa-154">Get Container Metadata</span></span> |<span data-ttu-id="38eaa-155">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-155">Yes</span></span> |<span data-ttu-id="38eaa-156">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-156">No</span></span> |
| <span data-ttu-id="38eaa-157">設定容器中繼資料</span><span class="sxs-lookup"><span data-stu-id="38eaa-157">Set Container Metadata</span></span> |<span data-ttu-id="38eaa-158">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-158">Yes</span></span> |<span data-ttu-id="38eaa-159">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-159">Yes</span></span> |
| <span data-ttu-id="38eaa-160">取得容器 ACL</span><span class="sxs-lookup"><span data-stu-id="38eaa-160">Get Container ACL</span></span> |<span data-ttu-id="38eaa-161">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-161">Yes</span></span> |<span data-ttu-id="38eaa-162">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-162">No</span></span> |
| <span data-ttu-id="38eaa-163">設定容器 ACL</span><span class="sxs-lookup"><span data-stu-id="38eaa-163">Set Container ACL</span></span> |<span data-ttu-id="38eaa-164">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-164">Yes</span></span> |<span data-ttu-id="38eaa-165">是 (*)</span><span class="sxs-lookup"><span data-stu-id="38eaa-165">Yes (*)</span></span> |
| <span data-ttu-id="38eaa-166">刪除容器</span><span class="sxs-lookup"><span data-stu-id="38eaa-166">Delete Container</span></span> |<span data-ttu-id="38eaa-167">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-167">No</span></span> |<span data-ttu-id="38eaa-168">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-168">Yes</span></span> |
| <span data-ttu-id="38eaa-169">租用容器</span><span class="sxs-lookup"><span data-stu-id="38eaa-169">Lease Container</span></span> |<span data-ttu-id="38eaa-170">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-170">Yes</span></span> |<span data-ttu-id="38eaa-171">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-171">Yes</span></span> |
| <span data-ttu-id="38eaa-172">列出 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-172">List Blobs</span></span> |<span data-ttu-id="38eaa-173">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-173">No</span></span> |<span data-ttu-id="38eaa-174">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-174">No</span></span> |

<span data-ttu-id="38eaa-175">（*） hello 定義的權限 SetContainerACL 快取中，更新 toothese 權限會一致的 toopropagate 哪些期間更新便無法保證 toobe 30 秒。</span><span class="sxs-lookup"><span data-stu-id="38eaa-175">(*) hello permissions defined by SetContainerACL are cached and updates toothese permissions take 30 seconds toopropagate during which period updates are not guaranteed toobe consistent.</span></span>  

<span data-ttu-id="38eaa-176">hello 下表摘要說明接受下列條件式標頭的 hello blob 作業**If-match** hello 要求，而且傳回以 hello 回應的 ETag 值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-176">hello following table summarizes hello blob operations that accept conditional headers such as **If-Match** in hello request and that return an ETag value in hello response.</span></span>

| <span data-ttu-id="38eaa-177">作業</span><span class="sxs-lookup"><span data-stu-id="38eaa-177">Operation</span></span> | <span data-ttu-id="38eaa-178">傳回 ETag 值</span><span class="sxs-lookup"><span data-stu-id="38eaa-178">Returns ETag value</span></span> | <span data-ttu-id="38eaa-179">接受條件式標頭</span><span class="sxs-lookup"><span data-stu-id="38eaa-179">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="38eaa-180">放置 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-180">Put Blob</span></span> |<span data-ttu-id="38eaa-181">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-181">Yes</span></span> |<span data-ttu-id="38eaa-182">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-182">Yes</span></span> |
| <span data-ttu-id="38eaa-183">取得 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-183">Get Blob</span></span> |<span data-ttu-id="38eaa-184">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-184">Yes</span></span> |<span data-ttu-id="38eaa-185">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-185">Yes</span></span> |
| <span data-ttu-id="38eaa-186">取得 Blob 屬性</span><span class="sxs-lookup"><span data-stu-id="38eaa-186">Get Blob Properties</span></span> |<span data-ttu-id="38eaa-187">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-187">Yes</span></span> |<span data-ttu-id="38eaa-188">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-188">Yes</span></span> |
| <span data-ttu-id="38eaa-189">設定 Blob 屬性</span><span class="sxs-lookup"><span data-stu-id="38eaa-189">Set Blob Properties</span></span> |<span data-ttu-id="38eaa-190">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-190">Yes</span></span> |<span data-ttu-id="38eaa-191">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-191">Yes</span></span> |
| <span data-ttu-id="38eaa-192">取得 Blob 中繼資料</span><span class="sxs-lookup"><span data-stu-id="38eaa-192">Get Blob Metadata</span></span> |<span data-ttu-id="38eaa-193">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-193">Yes</span></span> |<span data-ttu-id="38eaa-194">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-194">Yes</span></span> |
| <span data-ttu-id="38eaa-195">設定 Blob 中繼資料</span><span class="sxs-lookup"><span data-stu-id="38eaa-195">Set Blob Metadata</span></span> |<span data-ttu-id="38eaa-196">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-196">Yes</span></span> |<span data-ttu-id="38eaa-197">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-197">Yes</span></span> |
| <span data-ttu-id="38eaa-198">租用 Blob (*)</span><span class="sxs-lookup"><span data-stu-id="38eaa-198">Lease Blob (*)</span></span> |<span data-ttu-id="38eaa-199">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-199">Yes</span></span> |<span data-ttu-id="38eaa-200">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-200">Yes</span></span> |
| <span data-ttu-id="38eaa-201">快照 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-201">Snapshot Blob</span></span> |<span data-ttu-id="38eaa-202">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-202">Yes</span></span> |<span data-ttu-id="38eaa-203">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-203">Yes</span></span> |
| <span data-ttu-id="38eaa-204">複製 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-204">Copy Blob</span></span> |<span data-ttu-id="38eaa-205">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-205">Yes</span></span> |<span data-ttu-id="38eaa-206">是 (針對來源及目的地 Blob)</span><span class="sxs-lookup"><span data-stu-id="38eaa-206">Yes (for source and destination blob)</span></span> |
| <span data-ttu-id="38eaa-207">中止複製 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-207">Abort Copy Blob</span></span> |<span data-ttu-id="38eaa-208">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-208">No</span></span> |<span data-ttu-id="38eaa-209">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-209">No</span></span> |
| <span data-ttu-id="38eaa-210">刪除 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-210">Delete Blob</span></span> |<span data-ttu-id="38eaa-211">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-211">No</span></span> |<span data-ttu-id="38eaa-212">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-212">Yes</span></span> |
| <span data-ttu-id="38eaa-213">放置區塊</span><span class="sxs-lookup"><span data-stu-id="38eaa-213">Put Block</span></span> |<span data-ttu-id="38eaa-214">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-214">No</span></span> |<span data-ttu-id="38eaa-215">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-215">No</span></span> |
| <span data-ttu-id="38eaa-216">放置區塊清單</span><span class="sxs-lookup"><span data-stu-id="38eaa-216">Put Block List</span></span> |<span data-ttu-id="38eaa-217">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-217">Yes</span></span> |<span data-ttu-id="38eaa-218">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-218">Yes</span></span> |
| <span data-ttu-id="38eaa-219">取得區塊清單</span><span class="sxs-lookup"><span data-stu-id="38eaa-219">Get Block List</span></span> |<span data-ttu-id="38eaa-220">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-220">Yes</span></span> |<span data-ttu-id="38eaa-221">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-221">No</span></span> |
| <span data-ttu-id="38eaa-222">放置頁面</span><span class="sxs-lookup"><span data-stu-id="38eaa-222">Put Page</span></span> |<span data-ttu-id="38eaa-223">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-223">Yes</span></span> |<span data-ttu-id="38eaa-224">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-224">Yes</span></span> |
| <span data-ttu-id="38eaa-225">取得頁面範圍</span><span class="sxs-lookup"><span data-stu-id="38eaa-225">Get Page Ranges</span></span> |<span data-ttu-id="38eaa-226">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-226">Yes</span></span> |<span data-ttu-id="38eaa-227">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-227">Yes</span></span> |

<span data-ttu-id="38eaa-228">(*)租用 Blob 不會變更 blob 上的 hello ETag。</span><span class="sxs-lookup"><span data-stu-id="38eaa-228">(*) Lease Blob does not change hello ETag on a blob.</span></span>  

### <a name="pessimistic-concurrency-for-blobs"></a><span data-ttu-id="38eaa-229">Blob 的封閉式並行存取</span><span class="sxs-lookup"><span data-stu-id="38eaa-229">Pessimistic concurrency for blobs</span></span>
<span data-ttu-id="38eaa-230">toolock 專供 blob，您可以取得[租用](http://msdn.microsoft.com/library/azure/ee691972.aspx)在其上。</span><span class="sxs-lookup"><span data-stu-id="38eaa-230">toolock a blob for exclusive use, you can acquire a [lease](http://msdn.microsoft.com/library/azure/ee691972.aspx) on it.</span></span> <span data-ttu-id="38eaa-231">當您取得租用時，指定您需要多久 hello 租用： 這可以是 15 too60 秒的時間或無限的其數量 tooan 獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="38eaa-231">When you acquire a lease, you specify for how long you need hello lease: this can be for between 15 too60 seconds or infinite, which amounts tooan exclusive lock.</span></span> <span data-ttu-id="38eaa-232">您可以更新，以及您可以釋放任何租用完與其有限租用 tooextend。</span><span class="sxs-lookup"><span data-stu-id="38eaa-232">You can renew a finite lease tooextend it, and you can release any lease when you are finished with it.</span></span> <span data-ttu-id="38eaa-233">hello blob 服務會在到期時，會自動釋放有限的租用。</span><span class="sxs-lookup"><span data-stu-id="38eaa-233">hello blob service automatically releases finite leases when they expire.</span></span>  

<span data-ttu-id="38eaa-234">/ 共用讀取、 獨佔寫入啟用不同的同步處理策略 toobe 支援，包括獨佔寫入租用獨佔讀取和寫入的共用 / 獨佔讀取。</span><span class="sxs-lookup"><span data-stu-id="38eaa-234">Leases enable different synchronization strategies toobe supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</span></span> <span data-ttu-id="38eaa-235">其中存在租用 hello 儲存體服務會強制執行獨佔寫入 （put、 設定和刪除作業） 但是確保讀取作業的專用性需要所有的用戶端應用程式一次租用識別碼和該只有一部用戶端使用的 hello 開發人員 tooensure具有有效的租用識別碼。</span><span class="sxs-lookup"><span data-stu-id="38eaa-235">Where a lease exists hello storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires hello developer tooensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</span></span> <span data-ttu-id="38eaa-236">未包含租用識別碼的讀取作業將會導致共用讀取。</span><span class="sxs-lookup"><span data-stu-id="38eaa-236">Read operations that do not include a lease ID result in shared reads.</span></span>  

<span data-ttu-id="38eaa-237">hello 下列 C# 程式碼片段顯示 30 秒的 blob 上取得獨佔租用及更新 hello blob 的內容 hello，再放開 hello 租用的範例。</span><span class="sxs-lookup"><span data-stu-id="38eaa-237">hello following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating hello content of hello blob, and then releasing hello lease.</span></span> <span data-ttu-id="38eaa-238">如果已經有有效的租用 hello blob 上嘗試 tooacquire 新租用時，hello blob 服務會傳回 「 HTTP (409) 衝突 」 的狀態結果。</span><span class="sxs-lookup"><span data-stu-id="38eaa-238">If there is already a valid lease on hello blob when you try tooacquire a new lease, hello blob service returns an "HTTP (409) Conflict" status result.</span></span> <span data-ttu-id="38eaa-239">hello 下列程式碼片段會使用**AccessCondition** hello 儲存體服務要求 tooupdate hello blob 時，物件 tooencapsulate hello 租用資訊。</span><span class="sxs-lookup"><span data-stu-id="38eaa-239">hello following snippet uses an **AccessCondition** object tooencapsulate hello lease information when it makes a request tooupdate hello blob in hello storage service.</span></span>  <span data-ttu-id="38eaa-240">您可以在此處下載 hello 完整的範例：[使用 Azure 儲存體管理並行](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)。</span><span class="sxs-lookup"><span data-stu-id="38eaa-240">You can download hello full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update tooblob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying tooupdate blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

<span data-ttu-id="38eaa-241">如果您嘗試在租用的 blob 上的寫入作業而不需傳遞 hello 租用識別碼，hello 要求 412 錯誤而失敗。</span><span class="sxs-lookup"><span data-stu-id="38eaa-241">If you attempt a write operation on a leased blob without passing hello lease ID, hello request fails with a 412 error.</span></span> <span data-ttu-id="38eaa-242">請注意，如果 hello 租用到期之前呼叫 hello **UploadText**方法，但仍會傳遞 hello 租用識別碼，hello 要求也會因**412**錯誤。</span><span class="sxs-lookup"><span data-stu-id="38eaa-242">Note that if hello lease expires before calling hello **UploadText** method but you still pass hello lease ID, hello request also fails with a **412** error.</span></span> <span data-ttu-id="38eaa-243">如需管理的租用到期時間和租用識別碼的詳細資訊，請參閱 hello[租用 Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST 文件。</span><span class="sxs-lookup"><span data-stu-id="38eaa-243">For more information about managing lease expiry times and lease IDs, see hello [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST documentation.</span></span>  

<span data-ttu-id="38eaa-244">hello 下列 blob 作業可以使用租用 toomanage 封閉式並行存取：</span><span class="sxs-lookup"><span data-stu-id="38eaa-244">hello following blob operations can use leases toomanage pessimistic concurrency:</span></span>  

* <span data-ttu-id="38eaa-245">放置 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-245">Put Blob</span></span>
* <span data-ttu-id="38eaa-246">取得 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-246">Get Blob</span></span>
* <span data-ttu-id="38eaa-247">取得 Blob 屬性</span><span class="sxs-lookup"><span data-stu-id="38eaa-247">Get Blob Properties</span></span>
* <span data-ttu-id="38eaa-248">設定 Blob 屬性</span><span class="sxs-lookup"><span data-stu-id="38eaa-248">Set Blob Properties</span></span>
* <span data-ttu-id="38eaa-249">取得 Blob 中繼資料</span><span class="sxs-lookup"><span data-stu-id="38eaa-249">Get Blob Metadata</span></span>
* <span data-ttu-id="38eaa-250">設定 Blob 中繼資料</span><span class="sxs-lookup"><span data-stu-id="38eaa-250">Set Blob Metadata</span></span>
* <span data-ttu-id="38eaa-251">刪除 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-251">Delete Blob</span></span>
* <span data-ttu-id="38eaa-252">放置區塊</span><span class="sxs-lookup"><span data-stu-id="38eaa-252">Put Block</span></span>
* <span data-ttu-id="38eaa-253">放置區塊清單</span><span class="sxs-lookup"><span data-stu-id="38eaa-253">Put Block List</span></span>
* <span data-ttu-id="38eaa-254">取得區塊清單</span><span class="sxs-lookup"><span data-stu-id="38eaa-254">Get Block List</span></span>
* <span data-ttu-id="38eaa-255">放置頁面</span><span class="sxs-lookup"><span data-stu-id="38eaa-255">Put Page</span></span>
* <span data-ttu-id="38eaa-256">取得頁面範圍</span><span class="sxs-lookup"><span data-stu-id="38eaa-256">Get Page Ranges</span></span>
* <span data-ttu-id="38eaa-257">快照 Blob - 若有租用存在，租用識別碼則是選用的</span><span class="sxs-lookup"><span data-stu-id="38eaa-257">Snapshot Blob - lease ID optional if a lease exists</span></span>
* <span data-ttu-id="38eaa-258">複製 Blob-hello 目的地 blob 上是否有租用需要租用識別碼</span><span class="sxs-lookup"><span data-stu-id="38eaa-258">Copy Blob - lease ID required if a lease exists on hello destination blob</span></span>
* <span data-ttu-id="38eaa-259">中止複製 Blob-hello 目的地 blob 上是否有無限期租用需要租用識別碼</span><span class="sxs-lookup"><span data-stu-id="38eaa-259">Abort Copy Blob - lease ID required if an infinite lease exists on hello destination blob</span></span>
* <span data-ttu-id="38eaa-260">租用 Blob</span><span class="sxs-lookup"><span data-stu-id="38eaa-260">Lease Blob</span></span>  

### <a name="pessimistic-concurrency-for-containers"></a><span data-ttu-id="38eaa-261">容器的封閉式並行存取</span><span class="sxs-lookup"><span data-stu-id="38eaa-261">Pessimistic concurrency for containers</span></span>
<span data-ttu-id="38eaa-262">租用容器上的啟用相同的同步處理策略 toobe 支援在 blob 的 hello (獨佔寫入 / 共用讀取、 獨佔寫入 / 獨佔讀取和寫入的共用 / 獨佔唯讀) 但是不同於 blob hello 儲存體服務只會強制專用性在刪除作業。</span><span class="sxs-lookup"><span data-stu-id="38eaa-262">Leases on containers enable hello same synchronization strategies toobe supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs hello storage service only enforces exclusivity on delete operations.</span></span> <span data-ttu-id="38eaa-263">toodelete 具有作用中租用的容器，用戶端必須包含 hello 與 hello 刪除要求的作用中租用識別碼。</span><span class="sxs-lookup"><span data-stu-id="38eaa-263">toodelete a container with an active lease, a client must include hello active lease ID with hello delete request.</span></span> <span data-ttu-id="38eaa-264">所有其他容器作業在租用的容器上成功但不包括 hello 租用識別碼在此情況下它們共用作業。</span><span class="sxs-lookup"><span data-stu-id="38eaa-264">All other container operations succeed on a leased container without including hello lease ID in which case they are shared operations.</span></span> <span data-ttu-id="38eaa-265">如果更新 (放置或設定) 或讀取作業需要獨佔性，則開發人員應確定所有的用戶端都使用同一個租用識別碼，並確定同一時間只有一個用戶端具有有效的租用識別碼。</span><span class="sxs-lookup"><span data-stu-id="38eaa-265">If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</span></span>  

<span data-ttu-id="38eaa-266">hello 下列容器作業可以使用租用 toomanage 封閉式並行存取：</span><span class="sxs-lookup"><span data-stu-id="38eaa-266">hello following container operations can use leases toomanage pessimistic concurrency:</span></span>  

* <span data-ttu-id="38eaa-267">刪除容器</span><span class="sxs-lookup"><span data-stu-id="38eaa-267">Delete Container</span></span>
* <span data-ttu-id="38eaa-268">取得容器屬性</span><span class="sxs-lookup"><span data-stu-id="38eaa-268">Get Container Properties</span></span>
* <span data-ttu-id="38eaa-269">取得容器中繼資料</span><span class="sxs-lookup"><span data-stu-id="38eaa-269">Get Container Metadata</span></span>
* <span data-ttu-id="38eaa-270">設定容器中繼資料</span><span class="sxs-lookup"><span data-stu-id="38eaa-270">Set Container Metadata</span></span>
* <span data-ttu-id="38eaa-271">取得容器 ACL</span><span class="sxs-lookup"><span data-stu-id="38eaa-271">Get Container ACL</span></span>
* <span data-ttu-id="38eaa-272">設定容器 ACL</span><span class="sxs-lookup"><span data-stu-id="38eaa-272">Set Container ACL</span></span>
* <span data-ttu-id="38eaa-273">租用容器</span><span class="sxs-lookup"><span data-stu-id="38eaa-273">Lease Container</span></span>  

<span data-ttu-id="38eaa-274">如需詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="38eaa-274">For more information, see:</span></span>  

* [<span data-ttu-id="38eaa-275">指定 Blob 服務作業的條件式標頭</span><span class="sxs-lookup"><span data-stu-id="38eaa-275">Specifying Conditional Headers for Blob Service Operations</span></span>](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [<span data-ttu-id="38eaa-276">租用容器</span><span class="sxs-lookup"><span data-stu-id="38eaa-276">Lease Container</span></span>](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [<span data-ttu-id="38eaa-277">租用 Blob </span><span class="sxs-lookup"><span data-stu-id="38eaa-277">Lease Blob </span></span>](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-hello-table-service"></a><span data-ttu-id="38eaa-278">Hello 表格服務中的 < 管理並行存取</span><span class="sxs-lookup"><span data-stu-id="38eaa-278">Managing Concurrency in hello Table Service</span></span>
<span data-ttu-id="38eaa-279">hello 表格服務會使用開放式並行存取檢查作為 hello 預設行為，當您使用與 hello blob 服務，必須明確選擇 tooperform 開放式並行存取檢查不同的實體。</span><span class="sxs-lookup"><span data-stu-id="38eaa-279">hello table service uses optimistic concurrency checks as hello default behavior when you are working with entities, unlike hello blob service where you must explicitly choose tooperform optimistic concurrency checks.</span></span> <span data-ttu-id="38eaa-280">hello 其他 hello 資料表和 blob 服務之間的差異是，您可以只管理的實體 hello 並行行為而與 hello blob 服務中，您可以管理的容器和 blob 的 hello 並行。</span><span class="sxs-lookup"><span data-stu-id="38eaa-280">hello other difference between hello table and blob services is that you can only manage hello concurrency behavior of entities whereas with hello blob service you can manage hello concurrency of both containers and blobs.</span></span>  

<span data-ttu-id="38eaa-281">toouse 開放式並行存取以及 toocheck 如果另一個處理序修改實體，因為從 hello 資料表儲存體服務中擷取，您可以使用 hello 表格服務會傳回實體時，您會收到 hello ETag 值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-281">toouse optimistic concurrency and toocheck if another process modified an entity since you retrieved it from hello table storage service, you can use hello ETag value you receive when hello table service returns an entity.</span></span> <span data-ttu-id="38eaa-282">hello 這個程序概述如下所示：</span><span class="sxs-lookup"><span data-stu-id="38eaa-282">hello outline of this process is as follows:</span></span>  

1. <span data-ttu-id="38eaa-283">擷取從 hello 資料表儲存體服務的實體，hello 回應包含 ETag 值，識別 hello 與 hello 儲存體服務中該實體相關聯的目前識別項。</span><span class="sxs-lookup"><span data-stu-id="38eaa-283">Retrieve an entity from hello table storage service, hello response includes an ETag value that identifies hello current identifier associated with that entity in hello storage service.</span></span>
2. <span data-ttu-id="38eaa-284">當您更新 hello 實體時，包括您在步驟 1 中強制 hello 中收到 hello ETag 值**If-match** hello 傳送 toohello 服務的要求標頭。</span><span class="sxs-lookup"><span data-stu-id="38eaa-284">When you update hello entity, include hello ETag value you received in step 1 in hello mandatory **If-Match** header of hello request you send toohello service.</span></span>
3. <span data-ttu-id="38eaa-285">hello 服務會比較 hello 要求中的 hello 目前的 ETag 值 hello 實體的 hello ETag 值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-285">hello service compares hello ETag value in hello request with hello current ETag value of hello entity.</span></span>
4. <span data-ttu-id="38eaa-286">如果 hello 目前的 ETag 值 hello 實體中強制 hello hello ETag 不同**If-match** hello 要求，hello 服務中的標頭會傳回 412 錯誤 toohello 用戶端。</span><span class="sxs-lookup"><span data-stu-id="38eaa-286">If hello current ETag value of hello entity is different than hello ETag in hello mandatory **If-Match** header in hello request, hello service returns a 412 error toohello client.</span></span> <span data-ttu-id="38eaa-287">這表示 toohello 用戶端 hello 用戶端擷取它之後，另一個處理序已更新 hello 實體。</span><span class="sxs-lookup"><span data-stu-id="38eaa-287">This indicates toohello client that another process has updated hello entity since hello client retrieved it.</span></span>
5. <span data-ttu-id="38eaa-288">如果 hello 目前的 ETag 值 hello 實體是 hello 相同 hello 強制在 hello ETag **If-match**標頭中的 hello 要求或 hello **If-match**標頭包含 hello 的萬用字元 （*） hello 服務執行 hello 要求的作業和更新 hello hello 實體 tooshow 已更新過的目前的 ETag 值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-288">If hello current ETag value of hello entity is hello same as hello ETag in hello mandatory **If-Match** header in hello request or hello **If-Match** header contains hello wildcard character (*), hello service performs hello requested operation and updates hello current ETag value of hello entity tooshow that it has been updated.</span></span>  

<span data-ttu-id="38eaa-289">請注意，不同於 hello blob 服務，hello 表格服務需要 hello 用戶端 tooinclude **If-match**更新要求中的標頭。</span><span class="sxs-lookup"><span data-stu-id="38eaa-289">Note that unlike hello blob service, hello table service requires hello client tooinclude an **If-Match** header in update requests.</span></span> <span data-ttu-id="38eaa-290">不過，很可能 tooforce 無條件更新 （最後一個寫入器 wins 策略），並略過的並行存取檢查，如果 hello 用戶端設定 hello **If-match**標頭 toohello 萬用字元 （*） hello 要求中的。</span><span class="sxs-lookup"><span data-stu-id="38eaa-290">However, it is possible tooforce an unconditional update (last writer wins strategy) and bypass concurrency checks if hello client sets hello **If-Match** header toohello wildcard character (*) in hello request.</span></span>  

<span data-ttu-id="38eaa-291">下列 C# 程式碼片段的 hello 顯示 customer 實體可能是先前建立或擷取需要更新的電子郵件地址。</span><span class="sxs-lookup"><span data-stu-id="38eaa-291">hello following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</span></span> <span data-ttu-id="38eaa-292">hello 初始插入或擷取作業存放區 hello ETag 值以 hello 客戶物件、 且由於 hello 範例使用 hello 相同物件執行個體時，它會執行 hello 取代作業時，會自動傳送 hello ETag 值後 toohello 表格服務，啟用 hello 服務 toocheck 並行違規。</span><span class="sxs-lookup"><span data-stu-id="38eaa-292">hello initial insert or retrieve operation stores hello ETag value in hello customer object, and because hello sample uses hello same object instance when it executes hello replace operation, it automatically sends hello ETag value back toohello table service, enabling hello service toocheck for concurrency violations.</span></span> <span data-ttu-id="38eaa-293">如果另一個處理序已更新資料表儲存體中的 hello 實體，hello 服務會傳回 HTTP 412 （先決條件失敗） 的狀態訊息。</span><span class="sxs-lookup"><span data-stu-id="38eaa-293">If another process has updated hello entity in table storage, hello service returns an HTTP 412 (Precondition Failed) status message.</span></span>  <span data-ttu-id="38eaa-294">您可以在此處下載 hello 完整的範例：[使用 Azure 儲存體管理並行](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)。</span><span class="sxs-lookup"><span data-stu-id="38eaa-294">You can download hello full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

<span data-ttu-id="38eaa-295">tooexplicitly 停用 hello 並行存取檢查，您應該設定的 hello **ETag** hello 屬性**員工**物件太"*"之前執行 hello 取代作業。</span><span class="sxs-lookup"><span data-stu-id="38eaa-295">tooexplicitly disable hello concurrency check, you should set hello **ETag** property of hello **employee** object too"*" before you execute hello replace operation.</span></span>  

```csharp
customer.ETag = "*";  
```

<span data-ttu-id="38eaa-296">hello 下表摘要說明如何 hello 資料表實體作業會使用 ETag 值：</span><span class="sxs-lookup"><span data-stu-id="38eaa-296">hello following table summarizes how hello table entity operations use ETag values:</span></span>

| <span data-ttu-id="38eaa-297">作業</span><span class="sxs-lookup"><span data-stu-id="38eaa-297">Operation</span></span> | <span data-ttu-id="38eaa-298">傳回 ETag 值</span><span class="sxs-lookup"><span data-stu-id="38eaa-298">Returns ETag value</span></span> | <span data-ttu-id="38eaa-299">需要 If-Match 要求標頭</span><span class="sxs-lookup"><span data-stu-id="38eaa-299">Requires If-Match request header</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="38eaa-300">查詢實體</span><span class="sxs-lookup"><span data-stu-id="38eaa-300">Query Entities</span></span> |<span data-ttu-id="38eaa-301">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-301">Yes</span></span> |<span data-ttu-id="38eaa-302">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-302">No</span></span> |
| <span data-ttu-id="38eaa-303">插入實體</span><span class="sxs-lookup"><span data-stu-id="38eaa-303">Insert Entity</span></span> |<span data-ttu-id="38eaa-304">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-304">Yes</span></span> |<span data-ttu-id="38eaa-305">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-305">No</span></span> |
| <span data-ttu-id="38eaa-306">更新實體</span><span class="sxs-lookup"><span data-stu-id="38eaa-306">Update Entity</span></span> |<span data-ttu-id="38eaa-307">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-307">Yes</span></span> |<span data-ttu-id="38eaa-308">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-308">Yes</span></span> |
| <span data-ttu-id="38eaa-309">合併實體</span><span class="sxs-lookup"><span data-stu-id="38eaa-309">Merge Entity</span></span> |<span data-ttu-id="38eaa-310">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-310">Yes</span></span> |<span data-ttu-id="38eaa-311">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-311">Yes</span></span> |
| <span data-ttu-id="38eaa-312">刪除實體</span><span class="sxs-lookup"><span data-stu-id="38eaa-312">Delete Entity</span></span> |<span data-ttu-id="38eaa-313">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-313">No</span></span> |<span data-ttu-id="38eaa-314">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-314">Yes</span></span> |
| <span data-ttu-id="38eaa-315">插入或取代實體</span><span class="sxs-lookup"><span data-stu-id="38eaa-315">Insert or Replace Entity</span></span> |<span data-ttu-id="38eaa-316">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-316">Yes</span></span> |<span data-ttu-id="38eaa-317">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-317">No</span></span> |
| <span data-ttu-id="38eaa-318">插入或合併實體</span><span class="sxs-lookup"><span data-stu-id="38eaa-318">Insert or Merge Entity</span></span> |<span data-ttu-id="38eaa-319">是</span><span class="sxs-lookup"><span data-stu-id="38eaa-319">Yes</span></span> |<span data-ttu-id="38eaa-320">否</span><span class="sxs-lookup"><span data-stu-id="38eaa-320">No</span></span> |

<span data-ttu-id="38eaa-321">請注意該 hello**插入或取代實體**和**插入或合併實體**operations*不*執行任何並行存取檢查，因為其不會傳送的 ETag 值 toohello表格服務。</span><span class="sxs-lookup"><span data-stu-id="38eaa-321">Note that hello **Insert or Replace Entity** and **Insert or Merge Entity** operations do *not* perform any concurrency checks because they do not send an ETag value toohello table service.</span></span>  

<span data-ttu-id="38eaa-322">一般而言，使用資料表的開發人員在開發可擴充的應用程式時，應該會採用開放式並行存取。</span><span class="sxs-lookup"><span data-stu-id="38eaa-322">In general developers using tables should rely on optimistic concurrency when developing scalable applications.</span></span> <span data-ttu-id="38eaa-323">如果封閉式鎖定所需的其中一個方法的開發人員可以採取時存取資料表的每個資料表的指定之 blob tooassign 試 tootake hello blob 上的租用之前 hello 資料表上運作。</span><span class="sxs-lookup"><span data-stu-id="38eaa-323">If pessimistic locking is needed, one approach developers can take when accessing Tables is tooassign a designated blob for each table and try tootake a lease on hello blob before operating on hello table.</span></span> <span data-ttu-id="38eaa-324">這種方法需要具備 hello 應用程式 tooensure 所有資料存取權的路徑取得 hello 租用先前 toooperating hello 資料表上的。</span><span class="sxs-lookup"><span data-stu-id="38eaa-324">This approach does require hello application tooensure all data access paths obtain hello lease prior toooperating on hello table.</span></span> <span data-ttu-id="38eaa-325">您也應注意 hello 最小的租用時間是 15 秒，需要仔細考慮延展性。</span><span class="sxs-lookup"><span data-stu-id="38eaa-325">You should also note that hello minimum lease time is 15 seconds which requires careful consideration for scalability.</span></span>  

<span data-ttu-id="38eaa-326">如需詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="38eaa-326">For more information, see:</span></span>  

* [<span data-ttu-id="38eaa-327">實體上的作業</span><span class="sxs-lookup"><span data-stu-id="38eaa-327">Operations on Entities</span></span>](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-hello-queue-service"></a><span data-ttu-id="38eaa-328">Hello 佇列服務中的 < 管理並行存取</span><span class="sxs-lookup"><span data-stu-id="38eaa-328">Managing Concurrency in hello Queue Service</span></span>
<span data-ttu-id="38eaa-329">其中一個案例是以並行 hello 佇列服務的考量是其中多個用戶端時，會從佇列擷取訊息。</span><span class="sxs-lookup"><span data-stu-id="38eaa-329">One scenario in which concurrency is a concern in hello queueing service is where multiple clients are retrieving messages from a queue.</span></span> <span data-ttu-id="38eaa-330">從 hello 佇列擷取訊息時，hello 回應包括 hello 訊息和 pop receipt 值，也就是必要的 toodelete hello 訊息。</span><span class="sxs-lookup"><span data-stu-id="38eaa-330">When a message is retrieved from hello queue, hello response includes hello message and a pop receipt value, which is required toodelete hello message.</span></span> <span data-ttu-id="38eaa-331">hello 訊息不會自動刪除從 hello 佇列，但已擷取之後，就不可見的 tooother 用戶端 hello hello visibilitytimeout 參數所指定的時間間隔。</span><span class="sxs-lookup"><span data-stu-id="38eaa-331">hello message is not automatically deleted from hello queue, but after it has been retrieved, it is not visible tooother clients for hello time interval specified by hello visibilitytimeout parameter.</span></span> <span data-ttu-id="38eaa-332">擷取 hello 訊息的 hello 用戶端預期的 toodelete hello 訊息之後便已被處理，而之前 hello 時間所指定 hello TimeNextVisible 的 hello 回應，計算出 hello visibilitytimeout hello 值為基礎的項目參數。</span><span class="sxs-lookup"><span data-stu-id="38eaa-332">hello client that retrieves hello message is expected toodelete hello message after it has been processed, and before hello time specified by hello TimeNextVisible element of hello response, which is calculated based on hello value of hello visibilitytimeout parameter.</span></span> <span data-ttu-id="38eaa-333">visibilitytimeout hello 值會加入 toohello 時間的 hello 訊息擷取 TimeNextVisible toodetermine hello 值。</span><span class="sxs-lookup"><span data-stu-id="38eaa-333">hello value of visibilitytimeout is added toohello time at which hello message is retrieved toodetermine hello value of TimeNextVisible.</span></span>  

<span data-ttu-id="38eaa-334">hello 佇列服務沒有支援開放式或封閉式並行存取，這個處理從佇列擷取訊息的原因用戶端應該確定等冪的方式處理訊息。</span><span class="sxs-lookup"><span data-stu-id="38eaa-334">hello queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</span></span> <span data-ttu-id="38eaa-335">「最後寫入為準」策略可用於更新作業，例如 SetQueueServiceProperties、SetQueueMetaData、SetQueueACL 和 UpdateMessage。</span><span class="sxs-lookup"><span data-stu-id="38eaa-335">A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</span></span>  

<span data-ttu-id="38eaa-336">如需詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="38eaa-336">For more information, see:</span></span>  

* [<span data-ttu-id="38eaa-337">佇列服務 REST API</span><span class="sxs-lookup"><span data-stu-id="38eaa-337">Queue Service REST API</span></span>](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [<span data-ttu-id="38eaa-338">取得訊息</span><span class="sxs-lookup"><span data-stu-id="38eaa-338">Get Messages</span></span>](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-hello-file-service"></a><span data-ttu-id="38eaa-339">Hello 檔案服務中的 < 管理並行存取</span><span class="sxs-lookup"><span data-stu-id="38eaa-339">Managing Concurrency in hello File Service</span></span>
<span data-ttu-id="38eaa-340">hello 檔案服務可以使用兩個不同的通訊協定端點 – SMB 和 REST 來存取。</span><span class="sxs-lookup"><span data-stu-id="38eaa-340">hello file service can be accessed using two different protocol endpoints – SMB and REST.</span></span> <span data-ttu-id="38eaa-341">hello REST 服務沒有設定鎖定的開放式或封閉式鎖定的支援，所有更新都會都依循的最後一個寫入器 wins 策略。</span><span class="sxs-lookup"><span data-stu-id="38eaa-341">hello REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</span></span> <span data-ttu-id="38eaa-342">掛接檔案共用的 SMB 用戶端可以利用檔案系統鎖定機制 toomanage 存取 tooshared 檔案 – 包括 hello 能力 tooperform 封閉式鎖定。</span><span class="sxs-lookup"><span data-stu-id="38eaa-342">SMB clients that mount file shares can leverage file system locking mechanisms toomanage access tooshared files – including hello ability tooperform pessimistic locking.</span></span> <span data-ttu-id="38eaa-343">當 SMB 用戶端開啟檔案時，它會指定 hello 檔案存取和共用模式。</span><span class="sxs-lookup"><span data-stu-id="38eaa-343">When an SMB client opens a file, it specifies both hello file access and share mode.</span></span> <span data-ttu-id="38eaa-344">設定檔案存取選項的 「 寫入 」 或 「 讀取/寫入 」 以及 「 無 」 的檔案共用模式，會導致鎖定由 SMB 用戶端 hello 檔案會在關閉之前的 hello 檔案。</span><span class="sxs-lookup"><span data-stu-id="38eaa-344">Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in hello file being locked by an SMB client until hello file is closed.</span></span> <span data-ttu-id="38eaa-345">如果 SMB 用戶端之 hello 檔案鎖定的檔案會執行 REST 作業 hello REST 服務會傳回狀態碼 409 （衝突） 和錯誤碼 SharingViolation。</span><span class="sxs-lookup"><span data-stu-id="38eaa-345">If REST operation is attempted on a file where an SMB client has hello file locked hello REST service will return status code 409 (Conflict) with error code SharingViolation.</span></span>  

<span data-ttu-id="38eaa-346">當 SMB 用戶端開啟檔案以進行刪除時，會將標示 hello 檔案為暫止刪除，直到所有其他 SMB 用戶端上該檔案的開啟控制代碼已關閉。</span><span class="sxs-lookup"><span data-stu-id="38eaa-346">When an SMB client opens a file for delete, it marks hello file as pending delete until all other SMB client open handles on that file are closed.</span></span> <span data-ttu-id="38eaa-347">在檔案標示為「擱置刪除」時，任何對該檔案的 REST 作業都將傳回狀態碼 409 (衝突) 和錯誤碼 SMBDeletePending。</span><span class="sxs-lookup"><span data-stu-id="38eaa-347">While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</span></span> <span data-ttu-id="38eaa-348">因為可能的 hello SMB 用戶端 tooremove hello 暫止刪除旗標先前 tooclosing hello 檔案，不會傳回狀態碼 404 （找不到）。</span><span class="sxs-lookup"><span data-stu-id="38eaa-348">Status code 404 (Not Found) is not returned since it is possible for hello SMB client tooremove hello pending deletion flag prior tooclosing hello file.</span></span> <span data-ttu-id="38eaa-349">換句話說，狀態碼 404 （找不到） 只應該已經移除 hello 檔案時。</span><span class="sxs-lookup"><span data-stu-id="38eaa-349">In other words, status code 404 (Not Found) is only expected when hello file has been removed.</span></span> <span data-ttu-id="38eaa-350">請注意，當檔案處於 SMB 暫止刪除狀態，它將不會包含在結果清單檔案的 hello。</span><span class="sxs-lookup"><span data-stu-id="38eaa-350">Note that while a file is in an SMB pending delete state, it will not be included in hello List Files results.</span></span> <span data-ttu-id="38eaa-351">另外請注意 hello REST 刪除的檔案和 REST 刪除目錄作業會以不可分割方式認可，而不會處於暫止刪除狀態。</span><span class="sxs-lookup"><span data-stu-id="38eaa-351">Also, note that hello REST Delete File and REST Delete Directory operations are committed atomically and do not result in a pending delete state.</span></span>  

<span data-ttu-id="38eaa-352">如需詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="38eaa-352">For more information, see:</span></span>  

* [<span data-ttu-id="38eaa-353">管理檔案鎖定</span><span class="sxs-lookup"><span data-stu-id="38eaa-353">Managing File Locks</span></span>](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a><span data-ttu-id="38eaa-354">摘要和後續步驟</span><span class="sxs-lookup"><span data-stu-id="38eaa-354">Summary and Next Steps</span></span>
<span data-ttu-id="38eaa-355">hello Microsoft Azure 儲存體服務已設計 toomeet hello hello 最複雜的線上應用程式需求而不未強制開發人員 toocompromise 或思考關鍵的設計假設例如並行存取，以及資料的一致性，它們都是 tootake針對授與。</span><span class="sxs-lookup"><span data-stu-id="38eaa-355">hello Microsoft Azure Storage service has been designed toomeet hello needs of hello most complex online applications without forcing developers toocompromise or rethink key design assumptions such as concurrency and data consistency that they have come tootake for granted.</span></span>  

<span data-ttu-id="38eaa-356">對於 hello 完成範例應用程式中這篇部落格參考：</span><span class="sxs-lookup"><span data-stu-id="38eaa-356">For hello complete sample application referenced in this blog:</span></span>  

* [<span data-ttu-id="38eaa-357">使用 Azure 儲存體管理並行存取 - 範例應用程式</span><span class="sxs-lookup"><span data-stu-id="38eaa-357">Managing Concurrency using Azure Storage - Sample Application</span></span>](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

<span data-ttu-id="38eaa-358">如需 Azure 儲存體的詳細資訊，請參閱：</span><span class="sxs-lookup"><span data-stu-id="38eaa-358">For more information on Azure Storage see:</span></span>  

* [<span data-ttu-id="38eaa-359">Microsoft Azure 儲存體首頁</span><span class="sxs-lookup"><span data-stu-id="38eaa-359">Microsoft Azure Storage Home Page</span></span>](https://azure.microsoft.com/services/storage/)
* [<span data-ttu-id="38eaa-360">簡介 tooAzure 儲存體</span><span class="sxs-lookup"><span data-stu-id="38eaa-360">Introduction tooAzure Storage</span></span>](storage-introduction.md)
* <span data-ttu-id="38eaa-361">[Blob](../blobs/storage-dotnet-how-to-use-blobs.md)、[資料表](../../cosmos-db/table-storage-how-to-use-dotnet.md)、[佇列](../storage-dotnet-how-to-use-queues.md)及[檔案](../storage-dotnet-how-to-use-files.md)的儲存體入門</span><span class="sxs-lookup"><span data-stu-id="38eaa-361">Storage Getting Started for [Blob](../blobs/storage-dotnet-how-to-use-blobs.md), [Table](../../cosmos-db/table-storage-how-to-use-dotnet.md),  [Queues](../storage-dotnet-how-to-use-queues.md), and [Files](../storage-dotnet-how-to-use-files.md)</span></span>
* <span data-ttu-id="38eaa-362">儲存體架構 – [Azure 儲存體：具有高度一致性的高可用性雲端儲存體服務](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span><span class="sxs-lookup"><span data-stu-id="38eaa-362">Storage Architecture – [Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span></span>

