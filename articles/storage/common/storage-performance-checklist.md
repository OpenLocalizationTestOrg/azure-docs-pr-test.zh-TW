---
title: "Azure 儲存體效能與延展性檢查清單 | Microsoft Docs"
description: "在開發具效能的應用程式中使用 Azure 儲存體的實證做法檢查清單。"
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: d2683bf9a2833485467bf2b4edff527876102f7d
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/29/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="704ec-103">Microsoft Azure 儲存體效能與延展性檢查清單</span><span class="sxs-lookup"><span data-stu-id="704ec-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="704ec-104">Overview</span><span class="sxs-lookup"><span data-stu-id="704ec-104">Overview</span></span>
<span data-ttu-id="704ec-105">在推出 Microsoft Azure 儲存體服務後，Microsoft 針對以具效能方式使用這些服務方面，開發許多經實證的做法，本文的目的在於將最重要的做法整合成檢查清單樣式的清單。</span><span class="sxs-lookup"><span data-stu-id="704ec-105">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</span></span> <span data-ttu-id="704ec-106">本文旨在協助應用程式開發人員驗證他們在 Azure 儲存體上使用的做法是否已經實證，並協助他們識別應該考慮採用的其他已經實證做法。</span><span class="sxs-lookup"><span data-stu-id="704ec-106">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="704ec-107">本文並不嘗試包含每個可能的效能與延展性最佳化做法 — 它會將影響不大或無法廣泛適用的做法排除。</span><span class="sxs-lookup"><span data-stu-id="704ec-107">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="704ec-108">對於設計過程中可預測的應用程式行為，一開始便謹記這些行為將可避免設計遇到效能問題。</span><span class="sxs-lookup"><span data-stu-id="704ec-108">To the extent that the application's behavior can be predicted during design, it's useful to keep these in mind early on to avoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="704ec-109">每位使用 Azure 儲存體的應用程式開發人員都應該花一點時間閱讀本文，並檢查他或她的應用程式是否遵循以下所列的每個已經實證做法。</span><span class="sxs-lookup"><span data-stu-id="704ec-109">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="704ec-110">檢查清單</span><span class="sxs-lookup"><span data-stu-id="704ec-110">Checklist</span></span>
<span data-ttu-id="704ec-111">本文將已經實證做法分成下列幾類。</span><span class="sxs-lookup"><span data-stu-id="704ec-111">This article organizes the proven practices into the following groups.</span></span> <span data-ttu-id="704ec-112">已經實證做法的適用對象：</span><span class="sxs-lookup"><span data-stu-id="704ec-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="704ec-113">所有 Azure 儲存體服務 (Blob、資料表、佇列和檔案)</span><span class="sxs-lookup"><span data-stu-id="704ec-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="704ec-114">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-114">Blobs</span></span>
* <span data-ttu-id="704ec-115">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-115">Tables</span></span>
* <span data-ttu-id="704ec-116">佇列</span><span class="sxs-lookup"><span data-stu-id="704ec-116">Queues</span></span>  

| <span data-ttu-id="704ec-117">完成</span><span class="sxs-lookup"><span data-stu-id="704ec-117">Done</span></span> | <span data-ttu-id="704ec-118">領域</span><span class="sxs-lookup"><span data-stu-id="704ec-118">Area</span></span> | <span data-ttu-id="704ec-119">類別</span><span class="sxs-lookup"><span data-stu-id="704ec-119">Category</span></span> | <span data-ttu-id="704ec-120">問題</span><span class="sxs-lookup"><span data-stu-id="704ec-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="704ec-121">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-121">All Services</span></span> |<span data-ttu-id="704ec-122">延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-122">Scalability Targets</span></span> |[<span data-ttu-id="704ec-123">您的應用程式是否旨在避免達到延展性目標？</span><span class="sxs-lookup"><span data-stu-id="704ec-123">Is your application designed to avoid approaching the scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="704ec-124">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-124">All Services</span></span> |<span data-ttu-id="704ec-125">延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-125">Scalability Targets</span></span> |[<span data-ttu-id="704ec-126">您的命名慣例設計能因應更好的負載平衡嗎？</span><span class="sxs-lookup"><span data-stu-id="704ec-126">Is your naming convention designed to enable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="704ec-127">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-127">All Services</span></span> |<span data-ttu-id="704ec-128">網路</span><span class="sxs-lookup"><span data-stu-id="704ec-128">Networking</span></span> |[<span data-ttu-id="704ec-129">用戶端裝置是否有足夠高的頻寬和足夠低的延遲，以達到所需的效能？</span><span class="sxs-lookup"><span data-stu-id="704ec-129">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="704ec-130">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-130">All Services</span></span> |<span data-ttu-id="704ec-131">網路</span><span class="sxs-lookup"><span data-stu-id="704ec-131">Networking</span></span> |[<span data-ttu-id="704ec-132">用戶端裝置是否有足夠高的品質連結？</span><span class="sxs-lookup"><span data-stu-id="704ec-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="704ec-133">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-133">All Services</span></span> |<span data-ttu-id="704ec-134">網路</span><span class="sxs-lookup"><span data-stu-id="704ec-134">Networking</span></span> |[<span data-ttu-id="704ec-135">用戶端應用程式的位置是否靠近儲存體帳戶？</span><span class="sxs-lookup"><span data-stu-id="704ec-135">Is the client application located "near" the storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="704ec-136">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-136">All Services</span></span> |<span data-ttu-id="704ec-137">內容發佈</span><span class="sxs-lookup"><span data-stu-id="704ec-137">Content Distribution</span></span> |[<span data-ttu-id="704ec-138">您是否會使用 CDN 進行內容發佈？</span><span class="sxs-lookup"><span data-stu-id="704ec-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="704ec-139">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-139">All Services</span></span> |<span data-ttu-id="704ec-140">直接用戶端存取</span><span class="sxs-lookup"><span data-stu-id="704ec-140">Direct Client Access</span></span> |[<span data-ttu-id="704ec-141">您是否會使用 SAS 和 CORS (而不是 Proxy) 來允許儲存體的直接存取？</span><span class="sxs-lookup"><span data-stu-id="704ec-141">Are you using SAS and CORS to allow direct access to storage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="704ec-142">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-142">All Services</span></span> |<span data-ttu-id="704ec-143">快取</span><span class="sxs-lookup"><span data-stu-id="704ec-143">Caching</span></span> |[<span data-ttu-id="704ec-144">您的應用程式是否會針對重複使用和極少變更的資料進行快取？</span><span class="sxs-lookup"><span data-stu-id="704ec-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="704ec-145">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-145">All Services</span></span> |<span data-ttu-id="704ec-146">快取</span><span class="sxs-lookup"><span data-stu-id="704ec-146">Caching</span></span> |[<span data-ttu-id="704ec-147">您的應用程式是否會批次執行更新 (在用戶端快取更新，然後以大型集合的方式上傳)？</span><span class="sxs-lookup"><span data-stu-id="704ec-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="704ec-148">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-148">All Services</span></span> |<span data-ttu-id="704ec-149">.NET 組態</span><span class="sxs-lookup"><span data-stu-id="704ec-149">.NET Configuration</span></span> |[<span data-ttu-id="704ec-150">您是否已設定用戶端使用足夠數量的並行連線？</span><span class="sxs-lookup"><span data-stu-id="704ec-150">Have you configured your client to use a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="704ec-151">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-151">All Services</span></span> |<span data-ttu-id="704ec-152">.NET 組態</span><span class="sxs-lookup"><span data-stu-id="704ec-152">.NET Configuration</span></span> |[<span data-ttu-id="704ec-153">您是否已設定 .NET 使用足夠數量的執行緒？</span><span class="sxs-lookup"><span data-stu-id="704ec-153">Have you configured .NET to use a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="704ec-154">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-154">All Services</span></span> |<span data-ttu-id="704ec-155">.NET 組態</span><span class="sxs-lookup"><span data-stu-id="704ec-155">.NET Configuration</span></span> |[<span data-ttu-id="704ec-156">您使用的是已改善記憶體回收的 .NET 4.5 或更新版本嗎？</span><span class="sxs-lookup"><span data-stu-id="704ec-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="704ec-157">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-157">All Services</span></span> |<span data-ttu-id="704ec-158">平行處理原則</span><span class="sxs-lookup"><span data-stu-id="704ec-158">Parallelism</span></span> |[<span data-ttu-id="704ec-159">您是否已確保平行處理原則已適當地受到限制，因此您的用戶端功能或延展性目標不會超載？</span><span class="sxs-lookup"><span data-stu-id="704ec-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or the scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="704ec-160">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-160">All Services</span></span> |<span data-ttu-id="704ec-161">工具</span><span class="sxs-lookup"><span data-stu-id="704ec-161">Tools</span></span> |[<span data-ttu-id="704ec-162">您是否使用 Microsoft 所提供的最新用戶端程式庫和工具版本？</span><span class="sxs-lookup"><span data-stu-id="704ec-162">Are you using the latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="704ec-163">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-163">All Services</span></span> |<span data-ttu-id="704ec-164">重試</span><span class="sxs-lookup"><span data-stu-id="704ec-164">Retries</span></span> |[<span data-ttu-id="704ec-165">您是否針對節流錯誤和逾時使用指數輪詢重試原則？</span><span class="sxs-lookup"><span data-stu-id="704ec-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="704ec-166">所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-166">All Services</span></span> |<span data-ttu-id="704ec-167">重試</span><span class="sxs-lookup"><span data-stu-id="704ec-167">Retries</span></span> |[<span data-ttu-id="704ec-168">您的應用程式是否避免重試不能再嘗試的錯誤？</span><span class="sxs-lookup"><span data-stu-id="704ec-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="704ec-169">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-169">Blobs</span></span> |<span data-ttu-id="704ec-170">延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-170">Scalability Targets</span></span> |[<span data-ttu-id="704ec-171">您是嘔有大量的用戶端並行存取單一物件？</span><span class="sxs-lookup"><span data-stu-id="704ec-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="704ec-172">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-172">Blobs</span></span> |<span data-ttu-id="704ec-173">延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-173">Scalability Targets</span></span> |[<span data-ttu-id="704ec-174">您的應用程式是否不超過單一 Blob 的頻寬或操作延展性目標？</span><span class="sxs-lookup"><span data-stu-id="704ec-174">Is your application staying within the bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="704ec-175">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-175">Blobs</span></span> |<span data-ttu-id="704ec-176">複製 Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-176">Copying Blobs</span></span> |[<span data-ttu-id="704ec-177">您是否以有效的方式複製 Blob？</span><span class="sxs-lookup"><span data-stu-id="704ec-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="704ec-178">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-178">Blobs</span></span> |<span data-ttu-id="704ec-179">複製 Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-179">Copying Blobs</span></span> |[<span data-ttu-id="704ec-180">您是否使用 AzCopy 進行 Blob 的大量複製？</span><span class="sxs-lookup"><span data-stu-id="704ec-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="704ec-181">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-181">Blobs</span></span> |<span data-ttu-id="704ec-182">複製 Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-182">Copying Blobs</span></span> |[<span data-ttu-id="704ec-183">您是否使用 Azure 匯入/匯出來轉換超大量的資料？</span><span class="sxs-lookup"><span data-stu-id="704ec-183">Are you using Azure Import/Export to transfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="704ec-184">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-184">Blobs</span></span> |<span data-ttu-id="704ec-185">使用中繼資料</span><span class="sxs-lookup"><span data-stu-id="704ec-185">Use Metadata</span></span> |[<span data-ttu-id="704ec-186">您是否將 Blob 相關的常用中繼資料儲存在它的中繼資料內？</span><span class="sxs-lookup"><span data-stu-id="704ec-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="704ec-187">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-187">Blobs</span></span> |<span data-ttu-id="704ec-188">快速上傳</span><span class="sxs-lookup"><span data-stu-id="704ec-188">Uploading Fast</span></span> |[<span data-ttu-id="704ec-189">嘗試快速上傳一個 Blob 時，您是否平行上傳區塊？</span><span class="sxs-lookup"><span data-stu-id="704ec-189">When trying to upload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="704ec-190">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-190">Blobs</span></span> |<span data-ttu-id="704ec-191">快速上傳</span><span class="sxs-lookup"><span data-stu-id="704ec-191">Uploading Fast</span></span> |[<span data-ttu-id="704ec-192">嘗試快速上傳多個 Blob 時，您是否平行上傳 Blob？</span><span class="sxs-lookup"><span data-stu-id="704ec-192">When trying to upload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="704ec-193">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-193">Blobs</span></span> |<span data-ttu-id="704ec-194">正確的 Blob 類型</span><span class="sxs-lookup"><span data-stu-id="704ec-194">Correct Blob Type</span></span> |[<span data-ttu-id="704ec-195">您是否在適當的時機使用分頁 Blob 或區塊 Blob？</span><span class="sxs-lookup"><span data-stu-id="704ec-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="704ec-196">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-196">Tables</span></span> |<span data-ttu-id="704ec-197">延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-197">Scalability Targets</span></span> |[<span data-ttu-id="704ec-198">您的每秒實體數是否逐漸達到延展性目標？</span><span class="sxs-lookup"><span data-stu-id="704ec-198">Are you approaching the scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="704ec-199">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-199">Tables</span></span> |<span data-ttu-id="704ec-200">組態</span><span class="sxs-lookup"><span data-stu-id="704ec-200">Configuration</span></span> |[<span data-ttu-id="704ec-201">您是否使用 JSON 來處理資料表要求？</span><span class="sxs-lookup"><span data-stu-id="704ec-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="704ec-202">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-202">Tables</span></span> |<span data-ttu-id="704ec-203">組態</span><span class="sxs-lookup"><span data-stu-id="704ec-203">Configuration</span></span> |[<span data-ttu-id="704ec-204">您是否已關閉 Nagle 以提高小型要求的效能？</span><span class="sxs-lookup"><span data-stu-id="704ec-204">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="704ec-205">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-205">Tables</span></span> |<span data-ttu-id="704ec-206">資料表和資料分割</span><span class="sxs-lookup"><span data-stu-id="704ec-206">Tables and Partitions</span></span> |[<span data-ttu-id="704ec-207">您是否已正確分割您的資料？</span><span class="sxs-lookup"><span data-stu-id="704ec-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="704ec-208">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-208">Tables</span></span> |<span data-ttu-id="704ec-209">常用資料分割</span><span class="sxs-lookup"><span data-stu-id="704ec-209">Hot Partitions</span></span> |[<span data-ttu-id="704ec-210">您是否避免只開頭附加和只結尾附加模式？</span><span class="sxs-lookup"><span data-stu-id="704ec-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="704ec-211">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-211">Tables</span></span> |<span data-ttu-id="704ec-212">常用資料分割</span><span class="sxs-lookup"><span data-stu-id="704ec-212">Hot Partitions</span></span> |[<span data-ttu-id="704ec-213">您的插入/更新是否散佈到許多資料分割中？</span><span class="sxs-lookup"><span data-stu-id="704ec-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="704ec-214">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-214">Tables</span></span> |<span data-ttu-id="704ec-215">查詢範圍</span><span class="sxs-lookup"><span data-stu-id="704ec-215">Query Scope</span></span> |[<span data-ttu-id="704ec-216">您是否設計結構描述以允許在大部分情況下使用點查詢，並盡量少用資料表查詢？</span><span class="sxs-lookup"><span data-stu-id="704ec-216">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="704ec-217">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-217">Tables</span></span> |<span data-ttu-id="704ec-218">查詢密度</span><span class="sxs-lookup"><span data-stu-id="704ec-218">Query Density</span></span> |[<span data-ttu-id="704ec-219">您的查詢是否通常只掃描並傳回應用程式將使用的列？</span><span class="sxs-lookup"><span data-stu-id="704ec-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="704ec-220">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-220">Tables</span></span> |<span data-ttu-id="704ec-221">限制傳回資料</span><span class="sxs-lookup"><span data-stu-id="704ec-221">Limiting Returned Data</span></span> |[<span data-ttu-id="704ec-222">您是否使用篩選來避免傳回不需要的實體？</span><span class="sxs-lookup"><span data-stu-id="704ec-222">Are you using filtering to avoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="704ec-223">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-223">Tables</span></span> |<span data-ttu-id="704ec-224">限制傳回資料</span><span class="sxs-lookup"><span data-stu-id="704ec-224">Limiting Returned Data</span></span> |[<span data-ttu-id="704ec-225">您是否使用投射來避免傳回不需要的屬性？</span><span class="sxs-lookup"><span data-stu-id="704ec-225">Are you using projection to avoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="704ec-226">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-226">Tables</span></span> |<span data-ttu-id="704ec-227">反正規化</span><span class="sxs-lookup"><span data-stu-id="704ec-227">Denormalization</span></span> |[<span data-ttu-id="704ec-228">您是否將資料反正規化，以便您在嘗試取得資料時，避免不敷使用的查詢或多個讀取要求？</span><span class="sxs-lookup"><span data-stu-id="704ec-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="704ec-229">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-229">Tables</span></span> |<span data-ttu-id="704ec-230">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="704ec-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="704ec-231">您是否批次執行必須是交易式，或可同時完成以減少反覆存取的要求？</span><span class="sxs-lookup"><span data-stu-id="704ec-231">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="704ec-232">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-232">Tables</span></span> |<span data-ttu-id="704ec-233">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="704ec-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="704ec-234">您是否避免擷取實體，以避免判斷是要呼叫插入或更新？</span><span class="sxs-lookup"><span data-stu-id="704ec-234">Are you avoiding retrieving an entity just to determine whether to call insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="704ec-235">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-235">Tables</span></span> |<span data-ttu-id="704ec-236">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="704ec-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="704ec-237">您是否考慮將經常會被一起擷取的一系列資料，以屬性的方式儲存在單一實體中 (而非儲存在多個實體中)？</span><span class="sxs-lookup"><span data-stu-id="704ec-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="704ec-238">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-238">Tables</span></span> |<span data-ttu-id="704ec-239">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="704ec-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="704ec-240">針對總是會被一起擷取並可以批次執行方式寫入的實體 (例如時間序列資料)，您是否考慮使用 Blob (而非資料表)？</span><span class="sxs-lookup"><span data-stu-id="704ec-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="704ec-241">佇列</span><span class="sxs-lookup"><span data-stu-id="704ec-241">Queues</span></span> |<span data-ttu-id="704ec-242">延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-242">Scalability Targets</span></span> |[<span data-ttu-id="704ec-243">您的每秒訊息數是否逐漸達到延展性目標？</span><span class="sxs-lookup"><span data-stu-id="704ec-243">Are you approaching the scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="704ec-244">佇列</span><span class="sxs-lookup"><span data-stu-id="704ec-244">Queues</span></span> |<span data-ttu-id="704ec-245">組態</span><span class="sxs-lookup"><span data-stu-id="704ec-245">Configuration</span></span> |[<span data-ttu-id="704ec-246">您是否已關閉 Nagle 以提高小型要求的效能？</span><span class="sxs-lookup"><span data-stu-id="704ec-246">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="704ec-247">佇列</span><span class="sxs-lookup"><span data-stu-id="704ec-247">Queues</span></span> |<span data-ttu-id="704ec-248">訊息大小</span><span class="sxs-lookup"><span data-stu-id="704ec-248">Message Size</span></span> |[<span data-ttu-id="704ec-249">您的訊息是否精簡以提高佇列效能？</span><span class="sxs-lookup"><span data-stu-id="704ec-249">Are your messages compact to improve the performance of the queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="704ec-250">佇列</span><span class="sxs-lookup"><span data-stu-id="704ec-250">Queues</span></span> |<span data-ttu-id="704ec-251">大量擷取</span><span class="sxs-lookup"><span data-stu-id="704ec-251">Bulk Retrieve</span></span> |[<span data-ttu-id="704ec-252">您是否在單一 "Get" 操作中擷取多則訊息？</span><span class="sxs-lookup"><span data-stu-id="704ec-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="704ec-253">佇列</span><span class="sxs-lookup"><span data-stu-id="704ec-253">Queues</span></span> |<span data-ttu-id="704ec-254">輪詢頻率</span><span class="sxs-lookup"><span data-stu-id="704ec-254">Polling Frequency</span></span> |[<span data-ttu-id="704ec-255">您是否夠常輪詢以降低可察覺的應用程式延遲？</span><span class="sxs-lookup"><span data-stu-id="704ec-255">Are you polling frequently enough to reduce the perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="704ec-256">佇列</span><span class="sxs-lookup"><span data-stu-id="704ec-256">Queues</span></span> |<span data-ttu-id="704ec-257">更新訊息</span><span class="sxs-lookup"><span data-stu-id="704ec-257">Update Message</span></span> |[<span data-ttu-id="704ec-258">您是否使用 UpdateMessage 來儲存處理訊息時的進度，避免在出現錯誤時需要重新處理整個訊息？</span><span class="sxs-lookup"><span data-stu-id="704ec-258">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="704ec-259">佇列</span><span class="sxs-lookup"><span data-stu-id="704ec-259">Queues</span></span> |<span data-ttu-id="704ec-260">架構</span><span class="sxs-lookup"><span data-stu-id="704ec-260">Architecture</span></span> |[<span data-ttu-id="704ec-261">您是否透過將長時間執行的工作負載排除在重要路徑外，然後再個別進行調整的方式，使用佇列來讓您的整個應用程式更有彈性？</span><span class="sxs-lookup"><span data-stu-id="704ec-261">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="704ec-262"><a name="allservices"></a>所有服務</span><span class="sxs-lookup"><span data-stu-id="704ec-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="704ec-263">本節列出適用於使用任何 Azure 儲存體服務 (Blob、資料表、佇列或檔案) 的已經實證做法。</span><span class="sxs-lookup"><span data-stu-id="704ec-263">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="704ec-264"><a name="subheading1"></a>延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="704ec-265">每個 Azure 儲存體服務都有容量 (GB)、交易費率和頻寬的延展性目標。</span><span class="sxs-lookup"><span data-stu-id="704ec-265">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="704ec-266">如果您的應用程式達到或超過任何延展性目標，它可能會遇到增加的交易延遲或節流。</span><span class="sxs-lookup"><span data-stu-id="704ec-266">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="704ec-267">當儲存體服務對您的應用程式進行節流時，該服務會開始針對某些儲存體交易傳回「503 伺服器忙碌」或「500 作業逾時」錯誤碼。</span><span class="sxs-lookup"><span data-stu-id="704ec-267">When a Storage service throttles your application, the service begins to return "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="704ec-268">本節將討論特別是處理延展性目標和頻寬延展性目標的常見方法。</span><span class="sxs-lookup"><span data-stu-id="704ec-268">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="704ec-269">後續處理個別儲存體服務的小節將討論在該特定服務內容中的延展性目標：</span><span class="sxs-lookup"><span data-stu-id="704ec-269">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</span></span>  

* [<span data-ttu-id="704ec-270">Blob 頻寬和每秒要求數</span><span class="sxs-lookup"><span data-stu-id="704ec-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="704ec-271">每秒的資料表實體</span><span class="sxs-lookup"><span data-stu-id="704ec-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="704ec-272">每秒佇列訊息</span><span class="sxs-lookup"><span data-stu-id="704ec-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="704ec-273"><a name="sub1bandwidth"></a>所有服務的頻寬延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="704ec-274">本文撰寫期間，美國地理區域備援儲存體 (GRS) 帳戶的輸入 (傳送至儲存體帳戶的資料) 頻寬目標是每秒 10 GB (Gbps)，輸出 (從儲存體帳戶傳送出去的資料) 頻寬目標是 20 Gbps。</span><span class="sxs-lookup"><span data-stu-id="704ec-274">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</span></span> <span data-ttu-id="704ec-275">若是本機備援儲存體 (LRS) 帳戶，則會有較高的限制 – 輸入是 20 Gbps，輸出是 30 Gbps。</span><span class="sxs-lookup"><span data-stu-id="704ec-275">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="704ec-276">國際頻寬可能有較低的限制，您可以在我們的 [延展性目標頁面](http://msdn.microsoft.com/library/azure/dn249410.aspx)上找到此資訊。</span><span class="sxs-lookup"><span data-stu-id="704ec-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="704ec-277">如需有關儲存體備援選項的詳細資訊，請參閱下方的 [有用資源](#sub1useful) 連結。</span><span class="sxs-lookup"><span data-stu-id="704ec-277">For more information on the storage redundancy options, see the links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a><span data-ttu-id="704ec-278">達到延展性目標時該採取哪些作業</span><span class="sxs-lookup"><span data-stu-id="704ec-278">What to do when approaching a scalability target</span></span>
<span data-ttu-id="704ec-279">如果您的應用程式即將達到單一儲存體帳戶的延展性目標，您可以考慮採用下列其中一個方法：</span><span class="sxs-lookup"><span data-stu-id="704ec-279">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</span></span>  

* <span data-ttu-id="704ec-280">重新思考會造成您的應用程式達到或超出延展性目標的工作負載。</span><span class="sxs-lookup"><span data-stu-id="704ec-280">Reconsider the workload that causes your application to approach or exceed the scalability target.</span></span> <span data-ttu-id="704ec-281">您是否能夠以不同的方式設計工作負載，以使用較少的頻寬或容量或使用較少的交易？</span><span class="sxs-lookup"><span data-stu-id="704ec-281">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="704ec-282">如果應用程式必須超出其中一個延展性目標，您應建立多個儲存體帳戶，並將您的應用程式資料在這幾個儲存體帳戶中進行分割。</span><span class="sxs-lookup"><span data-stu-id="704ec-282">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="704ec-283">如果您要使用此模式，那麼請確定設計您的應用程式，以便日後可以增加更多儲存體帳戶以取得負載平衡。</span><span class="sxs-lookup"><span data-stu-id="704ec-283">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</span></span> <span data-ttu-id="704ec-284">本文撰寫期間，每個 Azure 訂閱可以擁有高達 100 個儲存體帳戶。</span><span class="sxs-lookup"><span data-stu-id="704ec-284">At time of writing, each Azure subscription can have up to 100 storage accounts.</span></span>  <span data-ttu-id="704ec-285">除了儲存資料、進行交易或傳輸資料等使用方式外，儲存體帳戶也不會有其他費用。</span><span class="sxs-lookup"><span data-stu-id="704ec-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="704ec-286">如果您的應用程式達到頻寬目標，請考慮在用戶端壓縮資料，以便降低將資料傳送至儲存體服務所需的頻寬。</span><span class="sxs-lookup"><span data-stu-id="704ec-286">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</span></span>  <span data-ttu-id="704ec-287">請注意，在節省頻寬並提高網路效能的同時，這也可能出現某些負面影響。</span><span class="sxs-lookup"><span data-stu-id="704ec-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="704ec-288">您應針對在用戶端壓縮和解壓縮資料的額外處理需求所造成的效能影響進行評估。</span><span class="sxs-lookup"><span data-stu-id="704ec-288">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</span></span> <span data-ttu-id="704ec-289">此外，儲存壓縮的資料可能會使得疑難排解問題變得更加困難，因為這會提高使用標準工具檢視已儲存資料的難度。</span><span class="sxs-lookup"><span data-stu-id="704ec-289">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</span></span>
* <span data-ttu-id="704ec-290">如果您的應用程式達到延展性目標，那麼請確定使用指數輪詢進行重試 (請參閱 [重試](#subheading14))。</span><span class="sxs-lookup"><span data-stu-id="704ec-290">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="704ec-291">最好的方式是確保您一定不會達到延展性目標 (方法是使用上述其中一個方法)，但這可確保您的應用程式不會持續快速重試，而降低節流的效能。</span><span class="sxs-lookup"><span data-stu-id="704ec-291">It's better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won't just keep retrying rapidly, making the throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="704ec-292">有用資源</span><span class="sxs-lookup"><span data-stu-id="704ec-292">Useful Resources</span></span>
<span data-ttu-id="704ec-293">下列連結提供有關延展性目標的其他詳細資料：</span><span class="sxs-lookup"><span data-stu-id="704ec-293">The following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="704ec-294">如需延展性目標的資訊，請參閱 [Azure 儲存體延展性和效能目標](storage-scalability-targets.md) 。</span><span class="sxs-lookup"><span data-stu-id="704ec-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="704ec-295">如需儲存體備援選項的資訊，請參閱 [Azure 儲存體複寫](storage-redundancy.md)以及部落格文章 [Azure 儲存體備援選項和讀取權限異地備援儲存體](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx)。</span><span class="sxs-lookup"><span data-stu-id="704ec-295">See [Azure Storage replication](storage-redundancy.md) and the blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="704ec-296">如需 Azure 服務定價的最新資訊，請參閱 [Azure 定價](https://azure.microsoft.com/pricing/overview/)。</span><span class="sxs-lookup"><span data-stu-id="704ec-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="704ec-297"><a name="subheading47"></a>分割區命名慣例</span><span class="sxs-lookup"><span data-stu-id="704ec-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="704ec-298">Azure 儲存體使用範圍型的資料分割配置，調整和負載平衡系統。</span><span class="sxs-lookup"><span data-stu-id="704ec-298">Azure Storage uses a range-based partitioning scheme to scale and load balance the system.</span></span> <span data-ttu-id="704ec-299">分割區索引鍵是用來將資料分割成數個範圍，這些範圍在整個系統都是負載平衡的。</span><span class="sxs-lookup"><span data-stu-id="704ec-299">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="704ec-300">這表示命名慣例，如語彙順序 (例如 msftpayroll、msftperformance、msftemployees 等等) 或使用時間戳記 (log20160101、log20160102、log20160102 等等) 會將本身出借給可能共置於相同分割區伺服器的分割區，直到負載平衡作業將它們分割成較小的範圍。</span><span class="sxs-lookup"><span data-stu-id="704ec-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself to the partitions being potentially co-located on the same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="704ec-301">例如，容器內的所有 Bob 接受單一伺服器的服務，直到這些 Blob 的負載需要進一步重新平衡分割區範圍。</span><span class="sxs-lookup"><span data-stu-id="704ec-301">For example, all blobs within a container can be served by a single server until the load on these blobs requires further rebalancing of the partition ranges.</span></span> <span data-ttu-id="704ec-302">同樣地，一群名稱依語彙順序排列的少量負載帳戶可能接受單一伺服器的服務，直到其中一個或所有帳戶的負載要求它們分割到多個分割區伺服器。</span><span class="sxs-lookup"><span data-stu-id="704ec-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until the load on one or all of these accounts require them to be split across multiple partitions servers.</span></span> <span data-ttu-id="704ec-303">每個負載平衡作業都可能在作業期間影響儲存體呼叫的延遲。</span><span class="sxs-lookup"><span data-stu-id="704ec-303">Each load balancing operation may impact the latency of storage calls during the operation.</span></span> <span data-ttu-id="704ec-304">系統處理某個分割區流量突然暴增的能力，會受到單一分割區伺服器延展性的限制，直到負載平衡作業著手重新平衡分割區索引鍵範圍。</span><span class="sxs-lookup"><span data-stu-id="704ec-304">The system's ability to handle a sudden burst of traffic to a partition is limited by the scalability of a single partition server until the load balancing operation kicks-in and rebalances the partition key range.</span></span>  

<span data-ttu-id="704ec-305">您可以遵循一些最佳做法來降低這類作業的頻率。</span><span class="sxs-lookup"><span data-stu-id="704ec-305">You can follow some best practices to reduce the frequency of such operations.</span></span>  

* <span data-ttu-id="704ec-306">詳細檢查帳戶、容器、Blob、資料表和佇列所使用的命名慣例。</span><span class="sxs-lookup"><span data-stu-id="704ec-306">Examine the naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="704ec-307">請考慮使用最符合您需求的雜湊函數，在帳戶名稱前加上 3 位數的雜湊。</span><span class="sxs-lookup"><span data-stu-id="704ec-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="704ec-308">如果使用時間戳記或數字識別碼組織資料，您必須確定您使用的不是僅附加在後 (或僅在前面加上) 的流量模式。</span><span class="sxs-lookup"><span data-stu-id="704ec-308">If you organize your data using timestamps or numerical identifiers, you have to ensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="704ec-309">這些模式並不適合範圍型的分割區系統，而且可能導致所有流量進入單一分割區並限制系統進行有效的負載平衡。</span><span class="sxs-lookup"><span data-stu-id="704ec-309">These patterns are not suitable for a range -based partitioning system, and could lead to all the traffic going to a single partition and limiting the system from effectively load balancing.</span></span> <span data-ttu-id="704ec-310">例如，如果日常作業使用有時間戳記的 Blob 物件，如 yyyymmdd，則該日常作業的所有流量都會導向至由單一分割區伺服器服務的單一物件。</span><span class="sxs-lookup"><span data-stu-id="704ec-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all the traffic for that daily operation is directed to a single object which is served by a single partition server.</span></span> <span data-ttu-id="704ec-311">請查看每個 Blob 的限制和每個分割區的限制是否符合您的需求，考慮是否需要將這項作業拆分成多個 Blob。</span><span class="sxs-lookup"><span data-stu-id="704ec-311">Look at whether the per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="704ec-312">同樣地，如果在資料表中儲存時間序列資料，則所有流量都可能導向到索引鍵命名空間的最後部分。</span><span class="sxs-lookup"><span data-stu-id="704ec-312">Similarly, if you store time series data in your tables, all the traffic could be directed to the last part of the key namespace.</span></span> <span data-ttu-id="704ec-313">如果必須使用時間戳記或數字識別碼，識別碼前面請加上 3 位數雜湊，或在時間戳記前加上時間的秒數部分，如 ssyyyymmdd。</span><span class="sxs-lookup"><span data-stu-id="704ec-313">If you must use timestamps or numerical IDs, prefix the id with a 3-digit hash, or in the case of timestamps prefix the seconds part of the time such as ssyyyymmdd.</span></span> <span data-ttu-id="704ec-314">如果定期執行列出和查詢作業，請選擇會限制查詢次數的雜湊函數。</span><span class="sxs-lookup"><span data-stu-id="704ec-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="704ec-315">其他情況，隨機的前置詞即足以應付。</span><span class="sxs-lookup"><span data-stu-id="704ec-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="704ec-316">如需 Azure 儲存體所用之分割區配置的其他資訊，請參閱 [這裡](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf)的 SOSP 文件。</span><span class="sxs-lookup"><span data-stu-id="704ec-316">For additional information on the partitioning scheme used in Azure Storage, read the SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="704ec-317">網路</span><span class="sxs-lookup"><span data-stu-id="704ec-317">Networking</span></span>
<span data-ttu-id="704ec-318">雖然 API 呼叫非常重要，但應用程式的實體網路限制經常會對效能產生重大影響。</span><span class="sxs-lookup"><span data-stu-id="704ec-318">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</span></span> <span data-ttu-id="704ec-319">下列說明了使用者可能會遇到的部分限制。</span><span class="sxs-lookup"><span data-stu-id="704ec-319">The following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="704ec-320">用戶端網路功能</span><span class="sxs-lookup"><span data-stu-id="704ec-320">Client Network Capability</span></span>
##### <span data-ttu-id="704ec-321"><a name="subheading2"></a>輸送量</span><span class="sxs-lookup"><span data-stu-id="704ec-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="704ec-322">頻寬的問題經常是用戶端的功能。</span><span class="sxs-lookup"><span data-stu-id="704ec-322">For bandwidth, the problem is often the capabilities of the client.</span></span> <span data-ttu-id="704ec-323">例如，當單一儲存體帳戶可處理 10 Gbps 或以上的輸入 (請參閱 [頻寬延展性目標](#sub1bandwidth)) 時，「小型」 Azure 背景工作角色執行個體只能達到 100 Mbps 左右的網路速度。</span><span class="sxs-lookup"><span data-stu-id="704ec-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), the network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="704ec-324">較大型的 Azure 執行個體擁有較大容量的 NIC，因此，如果您需要單一機器的較高網路限制，您應考慮使用較大型的執行個體或更多的 VM。</span><span class="sxs-lookup"><span data-stu-id="704ec-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="704ec-325">如果您從內部部署應用程式存取儲存體服務，則適用相同的規則：了解用戶端裝置的網路功能和與 Azure 儲存體位置的網路連線能力，以及視需要進行改善或設計您的應用程式以便使用其功能。</span><span class="sxs-lookup"><span data-stu-id="704ec-325">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</span></span>  

##### <span data-ttu-id="704ec-326"><a name="subheading3"></a>連結品質</span><span class="sxs-lookup"><span data-stu-id="704ec-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="704ec-327">與任何網路使用方式一樣，請留意導致錯誤和封包遺失的網路狀況將會減慢有效的輸送量。</span><span class="sxs-lookup"><span data-stu-id="704ec-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="704ec-328">使用 WireShark 或 NetMon 可能有助於診斷此問題。</span><span class="sxs-lookup"><span data-stu-id="704ec-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="704ec-329">有用資源</span><span class="sxs-lookup"><span data-stu-id="704ec-329">Useful Resources</span></span>
<span data-ttu-id="704ec-330">如需虛擬機器大小與所配置頻寬的詳細資訊，請參閱 [Windows VM 大小](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)或 [Linux VM 大小](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)。</span><span class="sxs-lookup"><span data-stu-id="704ec-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="704ec-331"><a name="subheading4"></a>位置</span><span class="sxs-lookup"><span data-stu-id="704ec-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="704ec-332">在任何分散式環境中，將用戶端放置於伺服器附近可提供最佳的效能。</span><span class="sxs-lookup"><span data-stu-id="704ec-332">In any distributed environment, placing the client near to the server delivers in the best performance.</span></span> <span data-ttu-id="704ec-333">若要以最低的延遲時間存取 Azure 儲存體，對用戶端而言的最佳位置是在同一個 Azure 區域內。</span><span class="sxs-lookup"><span data-stu-id="704ec-333">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</span></span> <span data-ttu-id="704ec-334">例如，如果您擁有使用 Azure 儲存體的 Azure 網站，您應將這兩者置於單一區域內 (例如，美國西部或東南亞)。</span><span class="sxs-lookup"><span data-stu-id="704ec-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="704ec-335">這可降低延遲和成本 — 本文撰寫期間，在單一區域內的頻寬使用量是免費的。</span><span class="sxs-lookup"><span data-stu-id="704ec-335">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="704ec-336">如果不在 Azure 中託管 (例如行動裝置應用程式或內部部署企業服務) 您的用戶端應用程式，則將儲存體帳戶再次置於用來存取帳戶之裝置附近的區域內，這通常可以降低延遲。</span><span class="sxs-lookup"><span data-stu-id="704ec-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="704ec-337">如果您的用戶端分散的十分廣泛 (例如，有些用戶端在北美，有些在歐洲)，則您應考慮使用多個儲存體帳戶：一個位於北美地區，一個位於歐洲地區。</span><span class="sxs-lookup"><span data-stu-id="704ec-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="704ec-338">這可協助這兩個區域內的使用者降低延遲。</span><span class="sxs-lookup"><span data-stu-id="704ec-338">This will help to reduce latency for users in both regions.</span></span> <span data-ttu-id="704ec-339">如果應用程式儲存的資料特定用於個別使用者，且不需要複寫儲存體帳戶之間的資料，則此方法通常較容易實作。</span><span class="sxs-lookup"><span data-stu-id="704ec-339">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="704ec-340">如需廣泛的內容發佈，我們建議 CDN – 如需詳細資料，請參閱下一節。</span><span class="sxs-lookup"><span data-stu-id="704ec-340">For broad content distribution, a CDN is recommended – see the next section for more details.</span></span>  

### <span data-ttu-id="704ec-341"><a name="subheading5"></a>內容發佈</span><span class="sxs-lookup"><span data-stu-id="704ec-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="704ec-342">有時，應用程式需要提供相同的內容給位於相同或多個區域中的多位使用者，例如，網站首頁上所用的產品示範影片。</span><span class="sxs-lookup"><span data-stu-id="704ec-342">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</span></span> <span data-ttu-id="704ec-343">在本案例中，您應使用如 Azure CDN 的內容傳遞網路 (CDN)，且 CDN 會將 Azure 儲存體作為資料的原始來源使用。</span><span class="sxs-lookup"><span data-stu-id="704ec-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</span></span> <span data-ttu-id="704ec-344">不同於在單一區域內存在，且無法以低延遲方式傳遞內容到其他區域的 Azure 儲存體帳戶，Azure CDN 會使用在全球多個資料中心內的伺服器。</span><span class="sxs-lookup"><span data-stu-id="704ec-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</span></span> <span data-ttu-id="704ec-345">此外，CDN 通常可以支援比單一儲存體帳戶高很多的輸出限制。</span><span class="sxs-lookup"><span data-stu-id="704ec-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="704ec-346">如需 Azure CDN 的詳細資訊，請參閱 [Azure CDN](https://azure.microsoft.com/services/cdn/)。</span><span class="sxs-lookup"><span data-stu-id="704ec-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="704ec-347"><a name="subheading6"></a>使用 SAS 和 CORS</span><span class="sxs-lookup"><span data-stu-id="704ec-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="704ec-348">當您必須在使用者的網頁瀏覽器或行動電話應用程式中授權程式碼 (例如 JavaScript) 以存取 Azure 儲存體中的資料時，一個方法是將 Web 角色中的應用程式作為 Proxy 使用：使用者的裝置會向 Web 角色進行驗證，Web 服務轉而向儲存體服務進行驗證。</span><span class="sxs-lookup"><span data-stu-id="704ec-348">When you need to authorize code such as JavaScript in a user's web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user's device authenticates with the web role, which in turn authenticates with the storage service.</span></span> <span data-ttu-id="704ec-349">如此一來，您可以避免在未受到保護的裝置上公開您的儲存體帳戶金鑰。</span><span class="sxs-lookup"><span data-stu-id="704ec-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="704ec-350">不過，因為在使用者裝置和儲存體服務之間傳輸的所有資料都必須通過 Web 角色，所以這會在 Web 角色上加上大量負荷。</span><span class="sxs-lookup"><span data-stu-id="704ec-350">However, this places a big overhead on the web role because all the data transferred between the user's device and the storage service must pass through the web role.</span></span> <span data-ttu-id="704ec-351">您可以透過使用共用存取簽章 (SAS)，有時與跨原始來源資源分享 (CORS) 標頭搭配使用，來避免將 Web 角色作為儲存體服務的 Proxy 使用。</span><span class="sxs-lookup"><span data-stu-id="704ec-351">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="704ec-352">使用 SAS，您可以透過有限的存取權杖，允許使用者裝置直接對儲存體服務提出要求。</span><span class="sxs-lookup"><span data-stu-id="704ec-352">Using SAS, you can allow your user's device to make requests directly to a storage service by means of a limited access token.</span></span> <span data-ttu-id="704ec-353">例如，如果使用者想要將相片上傳到您的應用程式，您的 Web 角色可產生 SAS 權杖，可授與接下來 30 分鐘內寫入特定 Blob 或容器的權限 (時間過後 SAS 權杖便會過期)，並將它傳送到使用者裝置。</span><span class="sxs-lookup"><span data-stu-id="704ec-353">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user's device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</span></span>

<span data-ttu-id="704ec-354">通常，在某個網域上由網站託管的頁面中，瀏覽器不允許 JavaScript 對另一個網域執行特定作業 (例如 "PUT")。</span><span class="sxs-lookup"><span data-stu-id="704ec-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a "PUT" to another domain.</span></span> <span data-ttu-id="704ec-355">例如，如果您在 "contosomarketing.cloudapp.net" 上主控 Web 角色，並想要使用用戶端 JavaScript 來將 Blob 上傳至您在 "contosoproducts.blob.core.windows.net" 的儲存體帳戶，則瀏覽器的「相同原始原則」將會禁止此作業。</span><span class="sxs-lookup"><span data-stu-id="704ec-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want to use client side JavaScript to upload a blob to your storage account at "contosoproducts.blob.core.windows.net," the browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="704ec-356">CORS 是個瀏覽器功能，可允許目標網域 (在此案例中是儲存體帳戶) 與信任源自來源網域 (在此案例中是 Web 角色) 要求的瀏覽器進行通訊。</span><span class="sxs-lookup"><span data-stu-id="704ec-356">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</span></span>  

<span data-ttu-id="704ec-357">這些技術可協助您避免 Web 應用程式上的不必要負荷 (和瓶頸)。</span><span class="sxs-lookup"><span data-stu-id="704ec-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="704ec-358">有用資源</span><span class="sxs-lookup"><span data-stu-id="704ec-358">Useful Resources</span></span>
<span data-ttu-id="704ec-359">如需 SAS 的詳細資訊，請參閱 [共用存取簽章：第 1 部分：了解 SAS 模型](../storage-dotnet-shared-access-signature-part-1.md)。</span><span class="sxs-lookup"><span data-stu-id="704ec-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding the SAS Model](../storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="704ec-360">如需 CORS 的詳細資訊，請參閱 [Azure 儲存體服務的跨原始資源共用 (CORS) 支援](http://msdn.microsoft.com/library/azure/dn535601.aspx)。</span><span class="sxs-lookup"><span data-stu-id="704ec-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="704ec-361">快取</span><span class="sxs-lookup"><span data-stu-id="704ec-361">Caching</span></span>
#### <span data-ttu-id="704ec-362"><a name="subheading7"></a>取得資料</span><span class="sxs-lookup"><span data-stu-id="704ec-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="704ec-363">一般來說，從服務中一次取得資料勝過分兩次取得資料。</span><span class="sxs-lookup"><span data-stu-id="704ec-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="704ec-364">以 Web 角色身分執行的 MVC Web 應用程式為例，該應用程式已從儲存體服務中擷取 50MB Blob 作為使用者的內容。</span><span class="sxs-lookup"><span data-stu-id="704ec-364">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</span></span> <span data-ttu-id="704ec-365">然後，應用程式可以在每次使用者要求內容時擷取相同的 Blob，或在本機中將內容快取至磁碟，並在後續的使用者要求中重複使用此快取版本。</span><span class="sxs-lookup"><span data-stu-id="704ec-365">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</span></span> <span data-ttu-id="704ec-366">此外，每當使用者要求資料時，此應用程式可以使用修改時間的條件式標頭發出 GET，這可避免在未修改 Blob 的情況下取得整個 Blob。</span><span class="sxs-lookup"><span data-stu-id="704ec-366">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn't been modified.</span></span> <span data-ttu-id="704ec-367">您可以將這個相同模式套用到使用資料表實體上。</span><span class="sxs-lookup"><span data-stu-id="704ec-367">You can apply this same pattern to working with table entities.</span></span>  

<span data-ttu-id="704ec-368">在某些情況下，您會決定應用程式可假定 Blob 在被擷取之後的短時間內仍然有效，並且應用程式無需在此期間內檢查 Blob 是否遭到修改。</span><span class="sxs-lookup"><span data-stu-id="704ec-368">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</span></span>

<span data-ttu-id="704ec-369">組態、查詢和其他持續被應用程式使用的資料是進行快取的最佳候選對象。</span><span class="sxs-lookup"><span data-stu-id="704ec-369">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</span></span>  

<span data-ttu-id="704ec-370">如需如何使用 .NET 來取得 Blob 屬性，以找出最後修改日期的範例，請參閱 [設定和擷取屬性及中繼資料](../blobs/storage-properties-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="704ec-370">For an example of how to get a blob's properties to discover the last modified date using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span> <span data-ttu-id="704ec-371">如需條件式下載的詳細資訊，請參閱 [有條件地重新整理 Blob 的本機複本](http://msdn.microsoft.com/library/azure/dd179371.aspx)。</span><span class="sxs-lookup"><span data-stu-id="704ec-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="704ec-372"><a name="subheading8"></a>以批次方式上傳資料</span><span class="sxs-lookup"><span data-stu-id="704ec-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="704ec-373">在某些應用程式案例中，您可以在本機彙總資料，然後以批次方式將它定期上傳，而非立即上傳每一份資料。</span><span class="sxs-lookup"><span data-stu-id="704ec-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="704ec-374">例如，Web 應用程式可保留活動記錄檔︰應用程式可以在每次活動發生時，以資料表實體的格式 (這需要許多儲存體作業) 將每個活動的詳細資料上傳到 Blob，或可以將活動詳細資料儲存到本機記錄檔，然後以使用分隔符號的檔案格式將所有活動詳細資料定期上傳到 Blob。</span><span class="sxs-lookup"><span data-stu-id="704ec-374">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</span></span> <span data-ttu-id="704ec-375">如果每筆記錄項目的大小是 1KB，您可以在單一 "Put Blob" 交易中上傳上千筆記錄項目 (您可以在單一交易中上傳的 Blob 大小上限為 64MB)。</span><span class="sxs-lookup"><span data-stu-id="704ec-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up to 64MB in size in a single transaction).</span></span> <span data-ttu-id="704ec-376">當然，如果本機電腦在上傳前當機，您可能會失去一些記錄資料：應用程式開發人員必須針對用戶端裝置的可能性進行設計，或上傳失敗。</span><span class="sxs-lookup"><span data-stu-id="704ec-376">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</span></span>  <span data-ttu-id="704ec-377">如果必須上傳活動資料以取得 Timespan (而不是只是單一活動)，則我們建議選擇 Blob 勝過資料表。</span><span class="sxs-lookup"><span data-stu-id="704ec-377">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="704ec-378">.NET 組態</span><span class="sxs-lookup"><span data-stu-id="704ec-378">.NET Configuration</span></span>
<span data-ttu-id="704ec-379">如果使用 .NET Framework，本節會列出數個可用來大幅改善效能的快速組態設定。</span><span class="sxs-lookup"><span data-stu-id="704ec-379">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</span></span>  <span data-ttu-id="704ec-380">如果使用其他語言，請查看類似的概念是否適用於您所選擇的語言。</span><span class="sxs-lookup"><span data-stu-id="704ec-380">If using other languages, check to see if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="704ec-381"><a name="subheading9"></a>提高預設的連線限制</span><span class="sxs-lookup"><span data-stu-id="704ec-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="704ec-382">在 .NET 中，下列程式碼可將預設的連線限制 (此值在用戶端環境中通常為 2，或在伺服器環境中通常為 10) 提高到 100。</span><span class="sxs-lookup"><span data-stu-id="704ec-382">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</span></span> <span data-ttu-id="704ec-383">一般而言，您應將此值大約設為應用程式所使用的執行緒數量。</span><span class="sxs-lookup"><span data-stu-id="704ec-383">Typically, you should set the value to approximately the number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="704ec-384">您必須在開啟任何連線之前設定連線限制。</span><span class="sxs-lookup"><span data-stu-id="704ec-384">You must set the connection limit before opening any connections.</span></span>  

<span data-ttu-id="704ec-385">若是其他程式設計語言，請參閱該語言的文件以確定如何設定連線限制。</span><span class="sxs-lookup"><span data-stu-id="704ec-385">For other programming languages, see that language's documentation to determine how to set the connection limit.</span></span>  

<span data-ttu-id="704ec-386">如需詳細資訊，請參閱 [Web 服務：並行連線](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx)(Web Services: Concurrent Connections) 部落格文章。</span><span class="sxs-lookup"><span data-stu-id="704ec-386">For additional information, see the blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="704ec-387"><a name="subheading10"></a>如果使用同步程式碼搭配 Async Task，則提高 ThreadPool 的執行緒數量下限</span><span class="sxs-lookup"><span data-stu-id="704ec-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="704ec-388">此程式碼將提高執行緒集合的執行緒數量下限：</span><span class="sxs-lookup"><span data-stu-id="704ec-388">This code will increase the thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

<span data-ttu-id="704ec-389">如需詳細資訊，請參閱 [ThreadPool.SetMinThreads 方法](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx)。</span><span class="sxs-lookup"><span data-stu-id="704ec-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="704ec-390"><a name="subheading11"></a>充分運用 .NET 4.5 記憶體回收</span><span class="sxs-lookup"><span data-stu-id="704ec-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="704ec-391">在用戶端應用程式中使用 .NET 4.5 或更新版本，以便在伺服器記憶體回收中充分運用效能改善。</span><span class="sxs-lookup"><span data-stu-id="704ec-391">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="704ec-392">如需詳細資訊，請參閱 [.NET 4.5 中的效能改進概觀](http://msdn.microsoft.com/magazine/hh882452.aspx)文章。</span><span class="sxs-lookup"><span data-stu-id="704ec-392">For more information, see the article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="704ec-393"><a name="subheading12"></a>無限制的平行處理原則</span><span class="sxs-lookup"><span data-stu-id="704ec-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="704ec-394">雖然平行處理原則對效能而言是一大利器，但在使用無限制的平行處理原則 (沒有執行緒數量和/或平行要求的限制) 來上傳或下載資料、使用多個背景工作來存取相同儲存體帳戶內的多個資料分割 (容器、佇列或資料表分割)，或存取相同資料分割中的多個項目時，請小心處理。</span><span class="sxs-lookup"><span data-stu-id="704ec-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</span></span> <span data-ttu-id="704ec-395">如果平行處理原則沒有限制，則您的應用程式可超出用戶端裝置的功能或儲存體帳戶的延展性目標，因而產生較長的延遲與節流作業。</span><span class="sxs-lookup"><span data-stu-id="704ec-395">If the parallelism is unbounded, your application can exceed the client device's capabilities or the storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="704ec-396"><a name="subheading13"></a>儲存體用戶端程式庫和工具</span><span class="sxs-lookup"><span data-stu-id="704ec-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="704ec-397">一律使用 Microsoft 所提供的最新版用戶端程式庫和工具。</span><span class="sxs-lookup"><span data-stu-id="704ec-397">Always use the latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="704ec-398">本文撰寫期間，有適用於 .NET、Windows Phone、Windows Runtime、Java 和 C++ 的用戶端程式庫，以及其他語言的預覽程式庫。</span><span class="sxs-lookup"><span data-stu-id="704ec-398">At the time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="704ec-399">此外，Microsoft 也推出 PowerShell Cmdlet 和 Azure CLI 命令，可與 Azure 儲存體搭配使用。</span><span class="sxs-lookup"><span data-stu-id="704ec-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="704ec-400">Microsoft 主動開發根據效能考量的這些工具，透過最新的服務版本將他們保持在最新的狀態，並確保這些工具會在內部處理許多已經實證的效能做法。</span><span class="sxs-lookup"><span data-stu-id="704ec-400">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="704ec-401">重試</span><span class="sxs-lookup"><span data-stu-id="704ec-401">Retries</span></span>
#### <span data-ttu-id="704ec-402"><a name="subheading14"></a>節流/ServerBusy</span><span class="sxs-lookup"><span data-stu-id="704ec-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="704ec-403">在某些情況下，儲存體服務可節流應用程式，或因某些暫時性狀況而無法服務要求，並傳回「503 伺服器忙碌」訊息或「500 逾時」。</span><span class="sxs-lookup"><span data-stu-id="704ec-403">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="704ec-404">如果您的應用程式即將達到其中任何一個延展性目標，或如果系統重新平衡分割資料以允許較高輸送量，則有可能會發生這個問題。</span><span class="sxs-lookup"><span data-stu-id="704ec-404">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</span></span>  <span data-ttu-id="704ec-405">用戶端應用程式通常應重試會造成這類錯誤的作業：稍後嘗試相同的要求即可成功。</span><span class="sxs-lookup"><span data-stu-id="704ec-405">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</span></span> <span data-ttu-id="704ec-406">不過，如果儲存體服務因為您的應用程式超出延展性目標而進行節流，或即使服務因為一些其他原因而無法服務要求，則積極重試的結果通常會使問題雪上加霜。</span><span class="sxs-lookup"><span data-stu-id="704ec-406">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</span></span> <span data-ttu-id="704ec-407">基於這個原因，您應使用指數輪詢 (用戶端程式庫預設為此行為)。</span><span class="sxs-lookup"><span data-stu-id="704ec-407">For this reason, you should use an exponential back off (the client libraries default to this behavior).</span></span> <span data-ttu-id="704ec-408">例如，您的應用程式可能會在 2 秒後進行重試、然後 4 秒、然後 10 秒、然後 30 秒，最後會完全放棄。</span><span class="sxs-lookup"><span data-stu-id="704ec-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="704ec-409">此行為會大幅降低您的應用程式在服務上的負荷，而不會使任何問題惡化。</span><span class="sxs-lookup"><span data-stu-id="704ec-409">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="704ec-410">請注意，因為連線能力錯誤不是節流的結果，且被認為是暫時性的，因此可以立即重試連線能力錯誤。</span><span class="sxs-lookup"><span data-stu-id="704ec-410">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</span></span>  

#### <span data-ttu-id="704ec-411"><a name="subheading15"></a>無法重試的錯誤</span><span class="sxs-lookup"><span data-stu-id="704ec-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="704ec-412">用戶端程式庫會留意哪些錯誤可以重試哪些無法重試。</span><span class="sxs-lookup"><span data-stu-id="704ec-412">The client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="704ec-413">不過，如果您打算根據儲存體 REST API 撰寫自己的程式碼，請記得有一些您不該重試的錯誤：例如，400 (不正確的要求) 回應指出用戶端應用程式傳送的要求因為不是預期的形式而無法處理。</span><span class="sxs-lookup"><span data-stu-id="704ec-413">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="704ec-414">每次重新傳送此要求都將產生相同回應，所以重試並沒有用。</span><span class="sxs-lookup"><span data-stu-id="704ec-414">Resending this request will result the same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="704ec-415">如果您打算根據儲存體 REST API 撰寫自己的程式碼，請留意錯誤碼所代表的意思，以及重試 (或不重試) 每個錯誤碼的正確方式。</span><span class="sxs-lookup"><span data-stu-id="704ec-415">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="704ec-416">有用資源</span><span class="sxs-lookup"><span data-stu-id="704ec-416">Useful Resources</span></span>
<span data-ttu-id="704ec-417">如需儲存體錯誤碼的詳細資訊，請參閱 Microsoft Azure 網站上的 [狀態和錯誤碼](http://msdn.microsoft.com/library/azure/dd179382.aspx) 。</span><span class="sxs-lookup"><span data-stu-id="704ec-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on the Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="704ec-418">Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-418">Blobs</span></span>
<span data-ttu-id="704ec-419">除了上述 [所有服務](#allservices) 的已經實證做法以外，下列已經實證的做法尤其適用於 Blob 服務。</span><span class="sxs-lookup"><span data-stu-id="704ec-419">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="704ec-420">Blob 特定的延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="704ec-421"><a name="subheading46"></a>並行存取單一物件的多個用戶端</span><span class="sxs-lookup"><span data-stu-id="704ec-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="704ec-422">如果您有大量的用戶端並行存取單一物件，您必須考慮每個物件和儲存體帳戶延展性目標。</span><span class="sxs-lookup"><span data-stu-id="704ec-422">If you have a large number of clients accessing a single object concurrently you will need to consider per object and storage account scalability targets.</span></span> <span data-ttu-id="704ec-423">可以存取單一物件的用戶端確切數目將視各種因素而有所不同，例如，同時要求物件的用戶端數目、物件的大小、網路狀況等等。</span><span class="sxs-lookup"><span data-stu-id="704ec-423">The exact number of clients that can access a single object will vary depending on factors such as the number of clients requesting the object simultaneously, the size of the object, network conditions etc.</span></span>

<span data-ttu-id="704ec-424">如果可以透過 CDN 散佈物件 (例如從網站提供的影像或視訊)，則您應該使用 CDN。</span><span class="sxs-lookup"><span data-stu-id="704ec-424">If the object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="704ec-425">請參閱 [這裡](#subheading5)。</span><span class="sxs-lookup"><span data-stu-id="704ec-425">See [here](#subheading5).</span></span>

<span data-ttu-id="704ec-426">在其他情況下 (例如機密資料的科學模擬)，您有兩個選擇。</span><span class="sxs-lookup"><span data-stu-id="704ec-426">In other scenarios such as scientific simulations where the data is confidential you have two options.</span></span> <span data-ttu-id="704ec-427">第一個選擇是以錯開您工作負載的存取，比較經過一段時間後存取物件以及同時存取物件的不同。</span><span class="sxs-lookup"><span data-stu-id="704ec-427">The first is to stagger your workload's access such that the object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="704ec-428">或者，您可以將物件暫時複製到多個儲存體帳戶，因而增加每個物件以及所有儲存體帳戶上的 IOPS 總數。</span><span class="sxs-lookup"><span data-stu-id="704ec-428">Alternatively, you can temporarily copy the object to multiple storage accounts thus increasing the total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="704ec-429">在有限的測試中，我們發現大約有 25 個 VM 可以同時平行下載 100GB 的 Blob (每個 VM 都是使用 32 個執行緒平行處理下載)。</span><span class="sxs-lookup"><span data-stu-id="704ec-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing the download using 32 threads).</span></span> <span data-ttu-id="704ec-430">如果您有 100 個用戶端需要存取物件，首先請將該物件複製到另一個儲存體帳戶，然後讓前 50 個 VM 存取第一個 Blob，並讓後 50 個 VM 存取第二個 Blob。</span><span class="sxs-lookup"><span data-stu-id="704ec-430">If you had 100 clients needing to access the object, first copy it to a second storage account and then have the first 50 VMs access the first blob and the second 50 VMs access the second blob.</span></span> <span data-ttu-id="704ec-431">結果將會視您的應用程式行為而有所不同，因此您應該在設計期間進行測試。</span><span class="sxs-lookup"><span data-stu-id="704ec-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="704ec-432"><a name="subheading16"></a>每個 Blob 的頻寬和作業</span><span class="sxs-lookup"><span data-stu-id="704ec-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="704ec-433">您能夠以高達上限 60 MB/秒 (這大約是 480 Mbps，已超出許多用戶端網路的功能，包括用戶端裝置上的實體 NIC) 的速度來讀取或寫入單一 Blob。</span><span class="sxs-lookup"><span data-stu-id="704ec-433">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</span></span> <span data-ttu-id="704ec-434">此外，單一 Blob 每秒支援高達 500 個要求。</span><span class="sxs-lookup"><span data-stu-id="704ec-434">In addition, a single blob supports up to 500 requests per second.</span></span> <span data-ttu-id="704ec-435">如果您有多個需要讀取相同 Blob 的用戶端，您可能超出這些限制，您應考慮使用 CDN 來分散 Blob。</span><span class="sxs-lookup"><span data-stu-id="704ec-435">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</span></span>  

<span data-ttu-id="704ec-436">如需 Blob 的目標輸送量詳細資訊，請參閱 [Azure 儲存體延展性和效能目標](storage-scalability-targets.md)。</span><span class="sxs-lookup"><span data-stu-id="704ec-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="704ec-437">複製與移動 Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="704ec-438"><a name="subheading17"></a>複製 Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="704ec-439">儲存體 REST API 2012-02-12 版引進了跨帳戶複製 Blob 的實用功能： 用戶端應用程式可指示儲存體服務從另一個來源 (可能是不同的儲存體帳戶) 複製 Blob，然後讓服務非同步執行複製作業。</span><span class="sxs-lookup"><span data-stu-id="704ec-439">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</span></span> <span data-ttu-id="704ec-440">當您從其他儲存體帳戶移轉資料時，這可大幅降低應用程式所需的頻寬，因為您無需下載及上傳資料。</span><span class="sxs-lookup"><span data-stu-id="704ec-440">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</span></span>  

<span data-ttu-id="704ec-441">不過，一個考量是在儲存體帳戶之間進行複製時，不會保證完成複製的時間。</span><span class="sxs-lookup"><span data-stu-id="704ec-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</span></span> <span data-ttu-id="704ec-442">如果您的應用程式需要在您的掌控下快速完成 Blob 複製，則複製 Blob 的最佳方式可能是將它下載到 VM，然後再將它上傳至目的地。</span><span class="sxs-lookup"><span data-stu-id="704ec-442">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</span></span>  <span data-ttu-id="704ec-443">如需該情況下的完全可預測性，請確保該複製作業是由執行於相同 Azure 區域的 VM 所執行，否則網路狀況可以 (且很可能會) 影響您的複製效能。</span><span class="sxs-lookup"><span data-stu-id="704ec-443">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="704ec-444">此外，您能夠以程式設計方式監控非同步複製作業的進度。</span><span class="sxs-lookup"><span data-stu-id="704ec-444">In addition, you can monitor the progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="704ec-445">請注意，在相同儲存體帳戶本身內進行複製通常可快速完成。</span><span class="sxs-lookup"><span data-stu-id="704ec-445">Note that copies within the same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="704ec-446">如需詳細資訊，請參閱 [複製 Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx)。</span><span class="sxs-lookup"><span data-stu-id="704ec-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="704ec-447"><a name="subheading18"></a>使用 AzCopy</span><span class="sxs-lookup"><span data-stu-id="704ec-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="704ec-448">Azure 儲存體團隊推出一個命令列工具 "AzCopy"，旨在協助將多個 Blob 大量傳輸至儲存體帳戶、從儲存體帳戶複製，及跨儲存體帳戶進行複製。</span><span class="sxs-lookup"><span data-stu-id="704ec-448">The Azure Storage team has released a command-line tool "AzCopy" that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="704ec-449">此工具已針對此案例進行最佳化，且可達到高傳輸率。</span><span class="sxs-lookup"><span data-stu-id="704ec-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="704ec-450">建議在大量上傳、下載和複製案例中使用此工具。</span><span class="sxs-lookup"><span data-stu-id="704ec-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="704ec-451">如需詳細資訊並加以下載，請參閱 [使用 AzCopy 命令列公用程式傳輸資料](storage-use-azcopy.md)。</span><span class="sxs-lookup"><span data-stu-id="704ec-451">To learn more about it and download it, see [Transfer data with the AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="704ec-452"><a name="subheading19"></a>Azure 匯入/匯出服務</span><span class="sxs-lookup"><span data-stu-id="704ec-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="704ec-453">Azure 儲存體針對超大量的資料 (大於 1TB) 提供匯入/匯出服務，這允許透過寄送硬碟的方式，從 Blob 儲存體進行上傳和下載。</span><span class="sxs-lookup"><span data-stu-id="704ec-453">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="704ec-454">您可以將資料放在硬碟上，並將它寄送到 Microsoft 進行上傳，或寄送空白硬碟到 Microsoft 以下載資料。</span><span class="sxs-lookup"><span data-stu-id="704ec-454">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</span></span>  <span data-ttu-id="704ec-455">如需詳細資訊，請參閱「 [使用 Microsoft Azure 匯入/匯出服務將資料移轉至 Blob 儲存體](../storage-import-export-service.md)」。</span><span class="sxs-lookup"><span data-stu-id="704ec-455">For more information, see [Use the Microsoft Azure Import/Export Service to Transfer Data to Blob Storage](../storage-import-export-service.md).</span></span>  <span data-ttu-id="704ec-456">這會比透過網路來上傳/下載此大量資料還要有效率。</span><span class="sxs-lookup"><span data-stu-id="704ec-456">This can be much more efficient than uploading/downloading this volume of data over the network.</span></span>  

### <span data-ttu-id="704ec-457"><a name="subheading20"></a>使用中繼資料</span><span class="sxs-lookup"><span data-stu-id="704ec-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="704ec-458">Blob 服務支援包含 Blob 中繼資料的標頭要求。</span><span class="sxs-lookup"><span data-stu-id="704ec-458">The blob service supports head requests, which can include metadata about the blob.</span></span> <span data-ttu-id="704ec-459">例如，如果您的應用程式需要相片的 EXIF 資料，它可以擷取相片並擷取該資料。</span><span class="sxs-lookup"><span data-stu-id="704ec-459">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</span></span> <span data-ttu-id="704ec-460">若要節省頻寬並改善效能，當應用程式上傳相片時，您的應用程式可以在 Blob 的中繼資料中儲存 EXIF 資料：您即可僅使用一個 HEAD 要求來擷取中繼資料中的 EXIF 資料，並節省大量頻寬以及每次讀取 Blob 時擷取 EXIF 資料所需的處理時間。</span><span class="sxs-lookup"><span data-stu-id="704ec-460">To save bandwidth and improve performance, your application could store the EXIF data in the blob's metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</span></span> <span data-ttu-id="704ec-461">這在您僅需要中繼資料而非 Blob 完整內容的案例中，此操作會很有幫助。</span><span class="sxs-lookup"><span data-stu-id="704ec-461">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</span></span>  <span data-ttu-id="704ec-462">請注意，每個 Blob 僅可儲存 8 KB 的中繼資料 (此服務不接受超過此值的儲存要求)，因此如果資料不符合該大小，您就可能無法使用此方法。</span><span class="sxs-lookup"><span data-stu-id="704ec-462">Note that only 8 KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</span></span>  

<span data-ttu-id="704ec-463">如需如何使用 .NET 來取得 Blob 中繼資料的範例，請參閱[設定和擷取屬性及中繼資料](../blobs/storage-properties-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="704ec-463">For an example of how to get a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](../blobs/storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="704ec-464">快速上傳</span><span class="sxs-lookup"><span data-stu-id="704ec-464">Uploading Fast</span></span>
<span data-ttu-id="704ec-465">若要快速上傳 Blob，請先回答一個問題：您會上傳一或多個 Blob？</span><span class="sxs-lookup"><span data-stu-id="704ec-465">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="704ec-466">使用下列指引，根據您的案例來判斷所要使用的正確方法。</span><span class="sxs-lookup"><span data-stu-id="704ec-466">Use the below guidance to determine the correct method to use depending on your scenario.</span></span>  

#### <span data-ttu-id="704ec-467"><a name="subheading21"></a>快速上傳一個大型 Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="704ec-468">若要快速上傳單一大型 Blob，您的用戶端應用程式應平行上傳其區塊或分頁 (請留意個別 Blob 和儲存體帳戶整體的延展性目標)。</span><span class="sxs-lookup"><span data-stu-id="704ec-468">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</span></span>  <span data-ttu-id="704ec-469">請注意，Microsoft-提供的正式 RTM 儲存體用戶端程式庫 (.NET、Java) 能夠執行此作業。</span><span class="sxs-lookup"><span data-stu-id="704ec-469">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</span></span>  <span data-ttu-id="704ec-470">在每個程式庫中，使用下列特定的物件/屬性來設定並行層級：</span><span class="sxs-lookup"><span data-stu-id="704ec-470">For each of the libraries, use the below specified object/property to set the level of concurrency:</span></span>  

* <span data-ttu-id="704ec-471">.NET：在要使用的 BlobRequestOptions 物件上設定 ParallelOperationThreadCount。</span><span class="sxs-lookup"><span data-stu-id="704ec-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</span></span>
* <span data-ttu-id="704ec-472">Java/Android：使用 BlobRequestOptions.setConcurrentRequestCount()</span><span class="sxs-lookup"><span data-stu-id="704ec-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="704ec-473">Node.js：在要求選項或在 Blob 服務上使用 parallelOperationThreadCount。</span><span class="sxs-lookup"><span data-stu-id="704ec-473">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</span></span>
* <span data-ttu-id="704ec-474">C++：使用 blob_request_options::set_parallelism_factor 方法。</span><span class="sxs-lookup"><span data-stu-id="704ec-474">C++: Use the blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="704ec-475"><a name="subheading22"></a>快速上傳多個 Blob</span><span class="sxs-lookup"><span data-stu-id="704ec-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="704ec-476">若要快速上傳多個 Blob，請平行上傳 Blob。</span><span class="sxs-lookup"><span data-stu-id="704ec-476">To upload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="704ec-477">因為這個方法會將上傳散佈到儲存體服務的多個資料分割，因此會比搭配平行區塊上傳一次上傳單一 Blob 的方法要快。</span><span class="sxs-lookup"><span data-stu-id="704ec-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</span></span> <span data-ttu-id="704ec-478">單一 Blob 僅支援 60 MB/秒 (大約是 480 Mbps) 的輸送量。</span><span class="sxs-lookup"><span data-stu-id="704ec-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="704ec-479">本文撰寫期間，位於美國的 LRS 帳戶支援高達 20 Gbps 輸入，這比個別 Blob 所支援的輸送量要大的多。</span><span class="sxs-lookup"><span data-stu-id="704ec-479">At the time of writing, a US-based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</span></span>  <span data-ttu-id="704ec-480">[AzCopy](#subheading18) 依預設會執行平行上傳，在此案例中我們建議使用此方法。</span><span class="sxs-lookup"><span data-stu-id="704ec-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="704ec-481"><a name="subheading23"></a>選擇 Blob 的正確類型</span><span class="sxs-lookup"><span data-stu-id="704ec-481"><a name="subheading23"></a>Choosing the correct type of blob</span></span>
<span data-ttu-id="704ec-482">Azure 儲存體支援兩種 Blob：分頁 Blob 和區塊 Blob。</span><span class="sxs-lookup"><span data-stu-id="704ec-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="704ec-483">在指定使用的案例中，您的 Blob 類型選擇將會影響解決方案的效能和延展性。</span><span class="sxs-lookup"><span data-stu-id="704ec-483">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</span></span> <span data-ttu-id="704ec-484">區塊 Blob 適用於您想要有效地上傳大量資料時：例如，用戶端應用程式可能需要將相片或視訊上傳至 Blob 儲存體。</span><span class="sxs-lookup"><span data-stu-id="704ec-484">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</span></span> <span data-ttu-id="704ec-485">分頁 Blob 則適用於應用程式需要執行隨機寫入資料時：例如，將 Azure VHD 儲存為分頁 Blob。</span><span class="sxs-lookup"><span data-stu-id="704ec-485">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="704ec-486">如需詳細資訊，請參閱 [了解區塊 Blob、附加 Blob 和分頁 Blob](http://msdn.microsoft.com/library/azure/ee691964.aspx)。</span><span class="sxs-lookup"><span data-stu-id="704ec-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="704ec-487">資料表</span><span class="sxs-lookup"><span data-stu-id="704ec-487">Tables</span></span>
<span data-ttu-id="704ec-488">除了上述 [所有服務](#allservices) 的已經實證做法以外，下列已經實證的做法尤其適用於資料表服務。</span><span class="sxs-lookup"><span data-stu-id="704ec-488">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the table service.</span></span>  

### <span data-ttu-id="704ec-489"><a name="subheading24"></a>資料表特定的延展性目標</span><span class="sxs-lookup"><span data-stu-id="704ec-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="704ec-490">除了整個儲存體帳戶的頻寬限制外，資料表還有下列特定的延展性限制。</span><span class="sxs-lookup"><span data-stu-id="704ec-490">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</span></span>  <span data-ttu-id="704ec-491">請注意，系統會在您的流量增加時進行負載平衡，但是如果您的流量突然暴增，您可以無法立即取得此輸送量。</span><span class="sxs-lookup"><span data-stu-id="704ec-491">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</span></span>  <span data-ttu-id="704ec-492">如果您的模式暴增，當儲存體服務自動負載平衡資料表時，您應預期會在暴增期間看到節流和/或逾時。</span><span class="sxs-lookup"><span data-stu-id="704ec-492">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</span></span>  <span data-ttu-id="704ec-493">緩慢增加通常會有較好的結果，因為它讓系統有時間適當地負載平衡。</span><span class="sxs-lookup"><span data-stu-id="704ec-493">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="704ec-494">每秒的實體數 (帳戶)</span><span class="sxs-lookup"><span data-stu-id="704ec-494">Entities per Second (Account)</span></span>
<span data-ttu-id="704ec-495">存取資料表的延展性限制為一個帳戶每秒最高 20,000 個實體 (每個 1KB)。</span><span class="sxs-lookup"><span data-stu-id="704ec-495">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="704ec-496">一般來說，已插入、更新、刪除或掃描的每個實體都會算在這個目標內。</span><span class="sxs-lookup"><span data-stu-id="704ec-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="704ec-497">因此包含 100 個實體的批次插入會算為 100 個實體。</span><span class="sxs-lookup"><span data-stu-id="704ec-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="704ec-498">掃描 1,000 個實體並傳回 5 的查詢會算為 1,000 個實體。</span><span class="sxs-lookup"><span data-stu-id="704ec-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="704ec-499">每秒的實體數 (資料分割)</span><span class="sxs-lookup"><span data-stu-id="704ec-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="704ec-500">在單一資料分割內，存取資料表的延展性目標為每秒 2,000 個實體 (每個 1KB)，使用上一節所述的相同計算方法。</span><span class="sxs-lookup"><span data-stu-id="704ec-500">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="704ec-501">組態</span><span class="sxs-lookup"><span data-stu-id="704ec-501">Configuration</span></span>
<span data-ttu-id="704ec-502">本節將列出數個快速組態設定，可用來在資料表服務中大幅改善效能：</span><span class="sxs-lookup"><span data-stu-id="704ec-502">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</span></span>  

#### <span data-ttu-id="704ec-503"><a name="subheading25"></a>使用 JSON</span><span class="sxs-lookup"><span data-stu-id="704ec-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="704ec-504">自儲存體服務版本 2013-08-15 開始，資料表服務支援使用 JSON (而非以 XML 為基礎的 AtomPub 格式) 來轉換資料表資料。</span><span class="sxs-lookup"><span data-stu-id="704ec-504">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="704ec-505">這可降低約 75% 的裝載大小，並可大幅提高您的應用程式效能。</span><span class="sxs-lookup"><span data-stu-id="704ec-505">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</span></span>

<span data-ttu-id="704ec-506">如需詳細資訊，請參閱 [Microsoft Azure 資料表：JSON 簡介](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx)和[表格服務作業的裝載格式](http://msdn.microsoft.com/library/azure/dn535600.aspx)。</span><span class="sxs-lookup"><span data-stu-id="704ec-506">For more information, see the post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="704ec-507"><a name="subheading26"></a>關閉 Nagle</span><span class="sxs-lookup"><span data-stu-id="704ec-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="704ec-508">在不同的 TCP/IP 網路中已廣泛採用 Nagle 的演算法，來作為提高網路效能的方法。</span><span class="sxs-lookup"><span data-stu-id="704ec-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</span></span> <span data-ttu-id="704ec-509">不過，它並非是所有情況下的最佳作法 (例如高互動式環境)。</span><span class="sxs-lookup"><span data-stu-id="704ec-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="704ec-510">在 Azure 儲存體中，Nagle 的演算法對於資料表和佇列服務要求的效能有負面的影響，可以的話您應將它停用。</span><span class="sxs-lookup"><span data-stu-id="704ec-510">For Azure Storage, Nagle's algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="704ec-511">如需詳細資訊，請參閱我們的部落格文章 [Nagle 的演算法並不適用於小型要求](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx)(英文)，其中說明 Nagle 的演算法與資料表和佇列要求互動不佳的原因，以及說明如何將它在您的用戶端應用程式中停用。</span><span class="sxs-lookup"><span data-stu-id="704ec-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="704ec-512">結構描述</span><span class="sxs-lookup"><span data-stu-id="704ec-512">Schema</span></span>
<span data-ttu-id="704ec-513">如何呈現與查詢您的資料是影響資料表服務效能的單一最大因素。</span><span class="sxs-lookup"><span data-stu-id="704ec-513">How you represent and query your data is the biggest single factor that affects the performance of the table service.</span></span> <span data-ttu-id="704ec-514">雖然每個應用程式都有所不同，本節將概述與下列項目相關的部分一般已經實證做法：</span><span class="sxs-lookup"><span data-stu-id="704ec-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="704ec-515">資料表設計</span><span class="sxs-lookup"><span data-stu-id="704ec-515">Table design</span></span>
* <span data-ttu-id="704ec-516">有效率的查詢</span><span class="sxs-lookup"><span data-stu-id="704ec-516">Efficient queries</span></span>
* <span data-ttu-id="704ec-517">有效率的資料更新</span><span class="sxs-lookup"><span data-stu-id="704ec-517">Efficient data updates</span></span>  

#### <span data-ttu-id="704ec-518"><a name="subheading27"></a>資料表和資料分割</span><span class="sxs-lookup"><span data-stu-id="704ec-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="704ec-519">資料表會被分為幾個資料分割。</span><span class="sxs-lookup"><span data-stu-id="704ec-519">Tables are divided into partitions.</span></span> <span data-ttu-id="704ec-520">儲存在資料分割中的每個實體會共用相同的資料分割索引鍵，並會有可在資料分割中識別該實體的唯一資料列索引鍵。</span><span class="sxs-lookup"><span data-stu-id="704ec-520">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</span></span> <span data-ttu-id="704ec-521">資料分割提供了優點，但也同時引進延展性限制。</span><span class="sxs-lookup"><span data-stu-id="704ec-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="704ec-522">優點：在包含高達 100 個不同儲存體作業 (總大小限制為 4 MB) 的單一、不可部分完成的批次交易中，您可以在相同資料分割中更新實體。</span><span class="sxs-lookup"><span data-stu-id="704ec-522">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="704ec-523">假設要擷取相同的實體數，則查詢單一資料分割中的資料會比查詢跨越資料分割的資料還要更有效率 (請繼續閱讀，以取得有關查詢資料表資料的進一步建議)。</span><span class="sxs-lookup"><span data-stu-id="704ec-523">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="704ec-524">延展性限制：因為資料分割支援不可部分完成的批次交易，因此無法針對儲存在單一資料分割中的實體存取進行負載平衡。</span><span class="sxs-lookup"><span data-stu-id="704ec-524">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="704ec-525">基於這個原因，個別資料表分割的延展性目標會低於資料表服務整體。</span><span class="sxs-lookup"><span data-stu-id="704ec-525">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</span></span>  

<span data-ttu-id="704ec-526">由於資料表和資料分割的這些特性，您應採用下列設計原則：</span><span class="sxs-lookup"><span data-stu-id="704ec-526">Because of these characteristics of tables and partitions, you should adopt the following design principles:</span></span>  

* <span data-ttu-id="704ec-527">用戶端應用程式在相同工作邏輯單位中經常更新或查詢的資料應位於相同的資料分割中。</span><span class="sxs-lookup"><span data-stu-id="704ec-527">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</span></span>  <span data-ttu-id="704ec-528">這有可能是因為應用程式正在聚總寫入，或因為您想要充分運用不可部分完成的批次作業。</span><span class="sxs-lookup"><span data-stu-id="704ec-528">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</span></span>  <span data-ttu-id="704ec-529">另外，在單一查詢中，查詢單一資料分割中的資料會比查詢跨資料分割中的資料還要有效率。</span><span class="sxs-lookup"><span data-stu-id="704ec-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="704ec-530">用戶端應用程式在相同工作邏輯單位 (單一查詢或批次更新) 中無法插入/更新或查詢的資料應位於不同的資料分割中。</span><span class="sxs-lookup"><span data-stu-id="704ec-530">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="704ec-531">一個重要事項是單一資料表中的資料分割索引鍵數目沒有限制，因此擁有數百萬個資料分割索引鍵也不是問題，而且還不會影響效能。</span><span class="sxs-lookup"><span data-stu-id="704ec-531">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="704ec-532">例如，如果您的應用程式是具備使用者登入的常用網站，則使用使用者識別碼作為資料分割索引鍵可能是個不錯的選擇。</span><span class="sxs-lookup"><span data-stu-id="704ec-532">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="704ec-533">常用資料分割</span><span class="sxs-lookup"><span data-stu-id="704ec-533">Hot Partitions</span></span>
<span data-ttu-id="704ec-534">常用資料分割是指收到某個帳戶的不相稱百分比流量，但因為它是單一資料分割，所以無法進行負載平衡的資料分割。</span><span class="sxs-lookup"><span data-stu-id="704ec-534">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="704ec-535">一般來說，可以用下列兩種方法其中之一來建立常用資料分割：</span><span class="sxs-lookup"><span data-stu-id="704ec-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="704ec-536"><a name="subheading28"></a>只開頭附加和只結尾附加模式</span><span class="sxs-lookup"><span data-stu-id="704ec-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="704ec-537">所謂的「只開頭附加」模式，是指在此模式下，對指定 PK 的全部 (或幾乎全部) 流量會根據目前時間增加和減少。</span><span class="sxs-lookup"><span data-stu-id="704ec-537">The "Append Only" pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</span></span>  <span data-ttu-id="704ec-538">一個範例是如果您的應用程式使用目前日期作為記錄資料的資料分割索引鍵。</span><span class="sxs-lookup"><span data-stu-id="704ec-538">An example is if your application used the current date as a partition key for log data.</span></span>  <span data-ttu-id="704ec-539">這會造成所有插入都會跑到資料表的最後一個資料分割，且因為所有寫入都會跑到資料表的結尾處，所以系統無法負載平衡。</span><span class="sxs-lookup"><span data-stu-id="704ec-539">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</span></span>  <span data-ttu-id="704ec-540">如果進入該資料分割的流量超出資料分割層級的延展性目標，則會造成節流。</span><span class="sxs-lookup"><span data-stu-id="704ec-540">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="704ec-541">最好的方法是確保流量會傳送到多個資料分割，以在資料表中啟用負載平衡要求。</span><span class="sxs-lookup"><span data-stu-id="704ec-541">It's better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</span></span>  

##### <span data-ttu-id="704ec-542"><a name="subheading29"></a>高流量資料</span><span class="sxs-lookup"><span data-stu-id="704ec-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="704ec-543">如果您的資料分割結構描述導致使用單一資料分割的資料比使用其他資料分割的資料高出甚多，當該資料分割達到單一資料分割的延展性目標時，您也可能會看到節流。</span><span class="sxs-lookup"><span data-stu-id="704ec-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</span></span>  <span data-ttu-id="704ec-544">最好的方式是確定您的資料分割結構描述不會造成任何單一資料分割達到延展性目標。</span><span class="sxs-lookup"><span data-stu-id="704ec-544">It's better to make sure that your partition scheme results in no single partition approaching the scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="704ec-545">查詢</span><span class="sxs-lookup"><span data-stu-id="704ec-545">Querying</span></span>
<span data-ttu-id="704ec-546">本節說明可查詢資料表服務的已經實證做法。</span><span class="sxs-lookup"><span data-stu-id="704ec-546">This section describes proven practices for querying the table service.</span></span>  

##### <span data-ttu-id="704ec-547"><a name="subheading30"></a>查詢範圍</span><span class="sxs-lookup"><span data-stu-id="704ec-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="704ec-548">您可以透過數種方式來指定查詢的實體範圍。</span><span class="sxs-lookup"><span data-stu-id="704ec-548">There are several ways to specify the range of entities to query.</span></span>  <span data-ttu-id="704ec-549">下列是使用每個方式的討論。</span><span class="sxs-lookup"><span data-stu-id="704ec-549">The following is a discussion of the uses of each.</span></span>  

<span data-ttu-id="704ec-550">一般來說，請避免掃描 (大於單一實體的查詢)，但如果您必須掃描，請嘗試組織您的資料，以方便掃描可以擷取所需資料，而無需掃描或傳回您不需要的大量實體數。</span><span class="sxs-lookup"><span data-stu-id="704ec-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="704ec-551">點查詢</span><span class="sxs-lookup"><span data-stu-id="704ec-551">Point Queries</span></span>
<span data-ttu-id="704ec-552">點查詢只會擷取一個實體。</span><span class="sxs-lookup"><span data-stu-id="704ec-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="704ec-553">做法是指定要擷取的實體分割索引鍵和資料列索引鍵。</span><span class="sxs-lookup"><span data-stu-id="704ec-553">It does this by specifying both the partition key and row key of the entity to retrieve.</span></span> <span data-ttu-id="704ec-554">這些查詢非常有效率，您應盡可能地加以使用。</span><span class="sxs-lookup"><span data-stu-id="704ec-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="704ec-555">資料分割查詢</span><span class="sxs-lookup"><span data-stu-id="704ec-555">Partition Queries</span></span>
<span data-ttu-id="704ec-556">資料分割查詢是指可擷取一組共用常見分割索引鍵之資料的查詢。</span><span class="sxs-lookup"><span data-stu-id="704ec-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="704ec-557">通常，除了分割索引鍵，查詢還會指定資料列索引鍵值的範圍或某些實體屬性值的範圍。</span><span class="sxs-lookup"><span data-stu-id="704ec-557">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</span></span> <span data-ttu-id="704ec-558">這些查詢會比點查詢沒有效率，且應謹慎使用。</span><span class="sxs-lookup"><span data-stu-id="704ec-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="704ec-559">資料表查詢</span><span class="sxs-lookup"><span data-stu-id="704ec-559">Table Queries</span></span>
<span data-ttu-id="704ec-560">資料表查詢是指可擷取一組不共用常見分割索引鍵之實體的查詢。</span><span class="sxs-lookup"><span data-stu-id="704ec-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="704ec-561">這些查詢非常沒有效率，您應盡量避免使用。</span><span class="sxs-lookup"><span data-stu-id="704ec-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="704ec-562"><a name="subheading31"></a>查詢密度</span><span class="sxs-lookup"><span data-stu-id="704ec-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="704ec-563">與為了尋找傳回的集合所掃描的實體數相較之下，查詢效率的另一個主要因素是傳回的實體數。</span><span class="sxs-lookup"><span data-stu-id="704ec-563">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</span></span> <span data-ttu-id="704ec-564">如果您的應用程式使用屬性值只有 1% 資料共用的篩選來執行資料表查詢，則查詢會為所傳回的每一個實體掃描 100 個實體。</span><span class="sxs-lookup"><span data-stu-id="704ec-564">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="704ec-565">先前討論的資料表延展性目標與掃描的實體數目相關，而與傳回的實體數目無關：低查詢密度會輕易導致資料表服務將您的應用程式節流，因為它必須掃描這麼多的實體，才可擷取您要尋找的實體。</span><span class="sxs-lookup"><span data-stu-id="704ec-565">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</span></span>  <span data-ttu-id="704ec-566">請參閱下面的 [反正規化](#subheading34) 一節，以取得如何避免此問題的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="704ec-566">See the section below on [denormalization](#subheading34) for more information on how to avoid this.</span></span>  

##### <a name="limiting-the-amount-of-data-returned"></a><span data-ttu-id="704ec-567">限制傳回的資料量</span><span class="sxs-lookup"><span data-stu-id="704ec-567">Limiting the Amount of Data Returned</span></span>
###### <span data-ttu-id="704ec-568"><a name="subheading32"></a>篩選</span><span class="sxs-lookup"><span data-stu-id="704ec-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="704ec-569">在您知道查詢將傳回用戶端應用程式不需要之實體的情況下，請考慮使用篩選來減少傳回集合的大小。</span><span class="sxs-lookup"><span data-stu-id="704ec-569">Where you know that a query will return entities that you don't need in the client application, consider using a filter to reduce the size of the returned set.</span></span> <span data-ttu-id="704ec-570">雖然未傳回至用戶端的實體仍然算在延展性目標內，但您的應用程式效能將會因為網路裝載大小減輕以及用戶端應用程式必須處理的實體數減少而提升。</span><span class="sxs-lookup"><span data-stu-id="704ec-570">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="704ec-571">請參閱 [查詢密度](#subheading31)上面的注意事項，不過，延展性目標會與掃描的實體數有關，因此即使只傳回幾個實體，篩選出許多實體的查詢仍然可能會導致節流。</span><span class="sxs-lookup"><span data-stu-id="704ec-571">See above note on [Query Density](#subheading31), however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="704ec-572"><a name="subheading33"></a>投射</span><span class="sxs-lookup"><span data-stu-id="704ec-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="704ec-573">如果您的用戶端應用程式只需要資料表中一組有限的實體屬性，則您可以使用投射來限制傳回資料集的大小。</span><span class="sxs-lookup"><span data-stu-id="704ec-573">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</span></span> <span data-ttu-id="704ec-574">與篩選一樣，此功能可協助降低網路負荷及用戶端處理。</span><span class="sxs-lookup"><span data-stu-id="704ec-574">As with filtering, this helps to reduce network load and client processing.</span></span>  

##### <span data-ttu-id="704ec-575"><a name="subheading34"></a>反正規化</span><span class="sxs-lookup"><span data-stu-id="704ec-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="704ec-576">與使用關聯式資料庫不同的是，為求有效率地查詢資料表資料的已經實證做法會導致將您的資料反正規化。</span><span class="sxs-lookup"><span data-stu-id="704ec-576">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</span></span> <span data-ttu-id="704ec-577">也就是說，為了尋找用戶端所需的資料，在多個實體 (每個您可能用來尋找資料的索引鍵一個實體) 中複製相同的資料，可將查詢所必須掃描的實體數降到最低。</span><span class="sxs-lookup"><span data-stu-id="704ec-577">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</span></span>  <span data-ttu-id="704ec-578">例如，在電子商務網站中，您可能想要根據客戶識別碼 (向我提供此客戶的訂單) 和根據日期 (向我提供某個日期的訂單) 來尋找一筆訂單。</span><span class="sxs-lookup"><span data-stu-id="704ec-578">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer's orders) and by the date (give me orders on a date).</span></span>  <span data-ttu-id="704ec-579">在資料表儲存體中，最好是儲存實體 (或它的參照) 兩次 – 一次包括資料表名稱、PK 和 RK，可根據客戶識別碼加快尋找的速度，一次可根據日期加快尋找的速度。</span><span class="sxs-lookup"><span data-stu-id="704ec-579">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="704ec-580">插入/更新/刪除</span><span class="sxs-lookup"><span data-stu-id="704ec-580">Insert/Update/Delete</span></span>
<span data-ttu-id="704ec-581">本節說明可修改儲存在資料表服務中實體的已經實證做法。</span><span class="sxs-lookup"><span data-stu-id="704ec-581">This section describes proven practices for modifying entities stored in the table service.</span></span>  

##### <span data-ttu-id="704ec-582"><a name="subheading35"></a>批次處理</span><span class="sxs-lookup"><span data-stu-id="704ec-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="704ec-583">在 Azure 儲存體中，批次交易又稱為實體群組交易 (ETG)；ETG 內的所有作業都必須位於單一資料表的單一資料分割上。</span><span class="sxs-lookup"><span data-stu-id="704ec-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="704ec-584">可能的話，請使用 ETG 以批次的方式執行插入、更新及刪除。</span><span class="sxs-lookup"><span data-stu-id="704ec-584">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="704ec-585">這會減少從用戶端應用程式到伺服器的反覆存取次數、減少計費交易數目 (為方便計費，ETG 會被視為單一交易，並可包含最多 100 個儲存體作業)，以及啟用不可部分完成的更新 (在 ETG 內的所有作業已成功或已失敗)。</span><span class="sxs-lookup"><span data-stu-id="704ec-585">This reduces the number of round trips from your client application to the server, reduces the number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="704ec-586">具有高延遲的環境 (例如行動裝置) 將會因為使用 ETG 而獲得極大的好處。</span><span class="sxs-lookup"><span data-stu-id="704ec-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="704ec-587"><a name="subheading36"></a>Upsert</span><span class="sxs-lookup"><span data-stu-id="704ec-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="704ec-588">您應盡可能地使用資料表 **Upsert** 作業。</span><span class="sxs-lookup"><span data-stu-id="704ec-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="704ec-589">**Upsert** 有兩種類型，這兩種類型都會比傳統的 **Insert** 和 **Update** 作業還要有效率：</span><span class="sxs-lookup"><span data-stu-id="704ec-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="704ec-590">**InsertOrMerge**：當您想要上傳實體屬性的子集，但不確定此實體是否已存在時，請使用此選項。</span><span class="sxs-lookup"><span data-stu-id="704ec-590">**InsertOrMerge**: Use this when you want to upload a subset of the entity's properties, but aren't sure whether the entity already exists.</span></span> <span data-ttu-id="704ec-591">如果實體已存在，則此呼叫會更新包含在 **Upsert** 作業的屬性，並將所有現有的屬性保留不變，如果實體不存在，則此呼叫會插入新的實體。</span><span class="sxs-lookup"><span data-stu-id="704ec-591">If the entity exists, this call updates the properties included in the **Upsert** operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</span></span> <span data-ttu-id="704ec-592">這類似於在查詢中使用投射，在此情況下，您只需要上傳正在變更的屬性。</span><span class="sxs-lookup"><span data-stu-id="704ec-592">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</span></span>
* <span data-ttu-id="704ec-593">**InsertOrReplace**：當您想要上傳全新的實體，但不確定此實體是否已存在時，請使用此選項。</span><span class="sxs-lookup"><span data-stu-id="704ec-593">**InsertOrReplace**: Use this when you want to upload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="704ec-594">您應該只在知道此全新上傳的實體完全正確時才使用此選項，因為它會完全覆寫舊的實體。</span><span class="sxs-lookup"><span data-stu-id="704ec-594">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</span></span> <span data-ttu-id="704ec-595">例如，您想要更新儲存使用者目前位置的實體，而不管應用程式先前是否已儲存使用者的位置資料；新的位置實體已完成，而且您無需任何先前實體的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="704ec-595">For example, you want to update the entity that stores a user's current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="704ec-596"><a name="subheading37"></a>在單一實體中儲存資料序列</span><span class="sxs-lookup"><span data-stu-id="704ec-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="704ec-597">有時候，應用程式會儲存它經常需要一次擷取的一系列資料：例如，應用程式可能會隨著時間追蹤 CPU 使用量，以便繪製資料在過去 24 小時的機動圖表。</span><span class="sxs-lookup"><span data-stu-id="704ec-597">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</span></span> <span data-ttu-id="704ec-598">一個方法是每個小時有一個資料表實體，且每個實體會代表特定的小時數，並儲存該小時的 CPU 使用量。</span><span class="sxs-lookup"><span data-stu-id="704ec-598">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</span></span> <span data-ttu-id="704ec-599">若要繪製此資料，應用程式必須擷取保存過去 24 小時資料的實體。</span><span class="sxs-lookup"><span data-stu-id="704ec-599">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</span></span>  

<span data-ttu-id="704ec-600">或者，您的應用程式可以儲存每小時 CPU 使用量做為單一實體的個別屬性：若要每小時更新，您的應用程式可以使用單一 **InsertOrMerge Upsert** 呼叫來更新最近一小時的值。</span><span class="sxs-lookup"><span data-stu-id="704ec-600">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single **InsertOrMerge Upsert** call to update the value for the most recent hour.</span></span> <span data-ttu-id="704ec-601">若要繪製此資料，應用程式只需擷取單一實體 (而不是 24 個實體)，提供極有效率的查詢 (請參閱上面 [查詢範圍](#subheading30)的討論)。</span><span class="sxs-lookup"><span data-stu-id="704ec-601">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="704ec-602"><a name="subheading38"></a>在 Blob 中儲存結構化資料</span><span class="sxs-lookup"><span data-stu-id="704ec-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="704ec-603">有時候，結構化資料好像應該要以資料表方式呈現，但實體範圍總是會被一起擷取，並可批次插入。</span><span class="sxs-lookup"><span data-stu-id="704ec-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="704ec-604">記錄檔是這個狀況的良好範例。</span><span class="sxs-lookup"><span data-stu-id="704ec-604">A good example of this is a log file.</span></span>  <span data-ttu-id="704ec-605">在此案例中，您可以批次處理數分鐘的記錄，然後也總是一次擷取數分鐘的記錄。</span><span class="sxs-lookup"><span data-stu-id="704ec-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="704ec-606">在此案例中，為了達到最佳化效能，最好是使用 Blob (而不是資料表)，因為您可以大幅降低寫入/傳回的物件數，以及通常需要提出的要求數。</span><span class="sxs-lookup"><span data-stu-id="704ec-606">In this case, for performance, it's better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="704ec-607">佇列</span><span class="sxs-lookup"><span data-stu-id="704ec-607">Queues</span></span>
<span data-ttu-id="704ec-608">除了上述[所有服務](#allservices)的已經實證做法以外，下列已經實證的做法尤其適用於佇列服務。</span><span class="sxs-lookup"><span data-stu-id="704ec-608">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the queue service.</span></span>  

### <span data-ttu-id="704ec-609"><a name="subheading39"></a>延展性限制</span><span class="sxs-lookup"><span data-stu-id="704ec-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="704ec-610">單一佇列每秒可以處理大約 2000 則訊息 (每則訊息 1 KB) (每個 AddMessage、GetMessage 和 DeleteMessage 在此算一則訊息)。</span><span class="sxs-lookup"><span data-stu-id="704ec-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="704ec-611">如果這對於您的應用程式而言還不足夠，您應該使用多個佇列並將訊息分散於這些佇列。</span><span class="sxs-lookup"><span data-stu-id="704ec-611">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</span></span>  

<span data-ttu-id="704ec-612">在 [Azure 儲存體延展性和效能目標](storage-scalability-targets.md)上檢視目前的延展性目標。</span><span class="sxs-lookup"><span data-stu-id="704ec-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="704ec-613"><a name="subheading40"></a>關閉 Nagle</span><span class="sxs-lookup"><span data-stu-id="704ec-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="704ec-614">請參閱討論 Nagle 演算法的資料表組態一節 — Nagle 演算法通常對佇列要求的效能有負面影響，您應將它停用。</span><span class="sxs-lookup"><span data-stu-id="704ec-614">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="704ec-615"><a name="subheading41"></a>訊息大小</span><span class="sxs-lookup"><span data-stu-id="704ec-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="704ec-616">佇列效能和延展性會隨著訊息大小增加而減少。</span><span class="sxs-lookup"><span data-stu-id="704ec-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="704ec-617">您應該只將接收端所需的資訊放在訊息中。</span><span class="sxs-lookup"><span data-stu-id="704ec-617">You should place only the information the receiver needs in a message.</span></span>  

### <span data-ttu-id="704ec-618"><a name="subheading42"></a>批次擷取</span><span class="sxs-lookup"><span data-stu-id="704ec-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="704ec-619">您可以在單一作業中，從佇列擷取高達 32 則的訊息。</span><span class="sxs-lookup"><span data-stu-id="704ec-619">You can retrieve up to 32 messages from a queue in a single operation.</span></span> <span data-ttu-id="704ec-620">這可降低與用戶端應用程式之間反覆存取的次數，這在具有高延遲的環境 (例如行動裝置) 中特別有用。</span><span class="sxs-lookup"><span data-stu-id="704ec-620">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="704ec-621"><a name="subheading43"></a>佇列輪詢間隔</span><span class="sxs-lookup"><span data-stu-id="704ec-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="704ec-622">大部分的應用程式會輪詢佇列中的訊息，而佇列可以是該應用程式的最大交易來源之一。</span><span class="sxs-lookup"><span data-stu-id="704ec-622">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</span></span> <span data-ttu-id="704ec-623">明智地選取輪詢間隔：輪詢太過頻繁可能會導致您的應用程式接近佇列的延展性目標。</span><span class="sxs-lookup"><span data-stu-id="704ec-623">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</span></span> <span data-ttu-id="704ec-624">不過，如果以 200,000 筆交易 0.01 美元計算 (寫入時)，則單一處理器每秒輪詢一次的一個月成本不到 15 分，所以成本通常不是影響您選擇輪詢間隔的因素。</span><span class="sxs-lookup"><span data-stu-id="704ec-624">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="704ec-625">如需最新成本資訊，請參閱 [Azure 儲存體價格](https://azure.microsoft.com/pricing/details/storage/)。</span><span class="sxs-lookup"><span data-stu-id="704ec-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="704ec-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="704ec-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="704ec-627">您可以使用 **UpdateMessage** 來增加隱藏逾時，或更新訊息的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="704ec-627">You can use **UpdateMessage** to increase the invisibility timeout or to update state information of a message.</span></span> <span data-ttu-id="704ec-628">雖然這是個強大的功能，請記住，每個 **UpdateMessage** 作業都會算在延展性目標內。</span><span class="sxs-lookup"><span data-stu-id="704ec-628">While this is powerful, remember that each **UpdateMessage** operation counts towards the scalability target.</span></span> <span data-ttu-id="704ec-629">不過，相較於在工作的每個階段完成時，將工作從一個佇列傳遞到下一個佇列的工作流程，這會更有效率。</span><span class="sxs-lookup"><span data-stu-id="704ec-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</span></span> <span data-ttu-id="704ec-630">使用 **UpdateMessage** 作業可讓應用程式將工作狀態儲存到訊息，然後繼續工作，而不是每次步驟完成時，便重新佇列訊息以進行下個工作步驟。</span><span class="sxs-lookup"><span data-stu-id="704ec-630">Using the **UpdateMessage** operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</span></span>  

<span data-ttu-id="704ec-631">如需詳細資訊，請參閱文章 [如何：變更佇列訊息的內容](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message)。</span><span class="sxs-lookup"><span data-stu-id="704ec-631">For more information, see the article [How to: Change the contents of a queued message](../queues/storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="704ec-632"><a name="subheading45"></a>應用程式架構</span><span class="sxs-lookup"><span data-stu-id="704ec-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="704ec-633">您應使用佇列，讓應用程式變得具擴充性。</span><span class="sxs-lookup"><span data-stu-id="704ec-633">You should use queues to make your application architecture scalable.</span></span> <span data-ttu-id="704ec-634">下列將列出您可以使用佇列，讓應用程式變得較具擴充性的幾個方式：</span><span class="sxs-lookup"><span data-stu-id="704ec-634">The following lists some ways you can use queues to make your application more scalable:</span></span>  

* <span data-ttu-id="704ec-635">您可以使用佇列來建立工作的待處理項目，以便在您的應用程式中處理及穩住工作負載。</span><span class="sxs-lookup"><span data-stu-id="704ec-635">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="704ec-636">例如，您可以佇列使用者的要求，以執行需密集使用處理器的工作 (例如重新調整上傳的影像)。</span><span class="sxs-lookup"><span data-stu-id="704ec-636">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="704ec-637">您可以使用佇列來脫離應用程式的零件，以便您可以個別進行調整。</span><span class="sxs-lookup"><span data-stu-id="704ec-637">You can use queues to decouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="704ec-638">例如，Web 前端可以將使用者的調查結果放到佇列中，以供日後分析與儲存。</span><span class="sxs-lookup"><span data-stu-id="704ec-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="704ec-639">您可以加入更多的背景工作角色執行個體，以視需要處理佇列資料。</span><span class="sxs-lookup"><span data-stu-id="704ec-639">You could add more worker role instances to process the queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="704ec-640">結論</span><span class="sxs-lookup"><span data-stu-id="704ec-640">Conclusion</span></span>
<span data-ttu-id="704ec-641">本文討論一些最常見的已經實證做法，以便在使用 Azure 儲存體時將效能最佳化。</span><span class="sxs-lookup"><span data-stu-id="704ec-641">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="704ec-642">我們鼓勵每位應用程式開發人員根據上述的每個做法來評估他們的應用程式，並考慮照著建議去做，為其使用 Azure 儲存體的應用程式取得最佳效能。</span><span class="sxs-lookup"><span data-stu-id="704ec-642">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</span></span>